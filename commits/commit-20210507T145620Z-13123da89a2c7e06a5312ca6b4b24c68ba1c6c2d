{
  "sha": "13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTMxMjNkYTg5YTJjN2UwNmE1MzEyY2E2YjRiMjRjNjhiYTFjNmMyZA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-07T14:56:20Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-07T14:56:20Z"
    },
    "message": "gdb: re-format Python files using black 21.4b0\n\nRe-format all Python files using black [1] version 21.4b0.  The goal is\nthat from now on, we keep all Python files formatted using black.  And\nthat we never have to discuss formatting during review (for these files\nat least) ever again.\n\nOne change is needed in gdb.python/py-prettyprint.exp, because it\nmatches the string representation of an exception, which shows source\ncode.  So the change in formatting must be replicated in the expected\nregexp.\n\nTo document our usage of black I plan on adding this to the \"GDB Python\nCoding Standards\" wiki page [2]:\n\n--8<--\n\nAll Python source files under the `gdb/` directory must be formatted\nusing black version 21.4b0.\n\nThis specific version can be installed using:\n\n    $ pip3 install 'black == 21.4b0'\n\nAll you need to do to re-format files is run `black <file/directory>`,\nand black will re-format any Python file it finds in there.  It runs\nquite fast, so the simplest is to do:\n\n    $ black gdb/\n\nfrom the top-level.\n\nIf you notice that black produces changes unrelated to your patch, it's\nprobably because someone forgot to run it before you.  In this case,\ndon't include unrelated hunks in your patch.  Push an obvious patch\nfixing the formatting and rebase your work on top of that.\n\n-->8--\n\nOnce this is merged, I plan on setting a up an `ignoreRevsFile`\nconfig so that git-blame ignores this commit, as described here:\n\n  https://github.com/psf/black#migrating-your-code-style-without-ruining-git-blame\n\nI also plan on working on a git commit hook (checked in the repo) to\nautomatically check the formatting of the Python files on commit.\n\n[1] https://pypi.org/project/black/\n[2] https://sourceware.org/gdb/wiki/Internals%20GDB-Python-Coding-Standards\n\ngdb/ChangeLog:\n\n\t* Re-format all Python files using black.\n\ngdb/testsuite/ChangeLog:\n\n\t* Re-format all Python files using black.\n\t* gdb.python/py-prettyprint.exp (run_lang_tests): Adjust.\n\nChange-Id: I28588a22c2406afd6bc2703774ddfff47cd61919",
    "tree": {
      "sha": "ec33a85ccb58f44445608d0cab68020fa588cb74",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ec33a85ccb58f44445608d0cab68020fa588cb74"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a9b49cbcd5935a713da5715799ea3b24e0a52851",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a9b49cbcd5935a713da5715799ea3b24e0a52851",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a9b49cbcd5935a713da5715799ea3b24e0a52851"
    }
  ],
  "stats": {
    "total": 4183,
    "additions": 2348,
    "deletions": 1835
  },
  "files": [
    {
      "sha": "45b048da4f53542ac7b0c13eb39c54db97f8b153",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -1,3 +1,7 @@\n+2021-05-07  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* Re-format all Python files using black.\n+\n 2021-05-07  Tom de Vries  <tdevries@suse.de>\n \n \tPR symtab/26327"
    },
    {
      "sha": "cc767a2cf107e87ddfec66e7a7833a355d1981ca",
      "filename": "gdb/contrib/test_pubnames_and_indexes.py",
      "status": "modified",
      "additions": 160,
      "deletions": 143,
      "changes": 303,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/contrib/test_pubnames_and_indexes.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/contrib/test_pubnames_and_indexes.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/contrib/test_pubnames_and_indexes.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -39,7 +39,7 @@\n Finally, check that all strings are canonicalized identically.\n \"\"\"\n \n-__author__ = 'saugustine@google.com (Sterling Augustine)'\n+__author__ = \"saugustine@google.com (Sterling Augustine)\"\n \n import os\n import subprocess\n@@ -49,159 +49,176 @@\n READELF = None\n GDB = None\n \n+\n def get_pub_info(filename, readelf_option):\n-  \"\"\"Parse and return all the pubnames or pubtypes produced by readelf with the\n-  given option.\n-  \"\"\"\n-  readelf = subprocess.Popen([READELF, '--debug-dump=' + readelf_option,\n-                                       filename], stdout=subprocess.PIPE)\n-  pubnames = []\n-\n-  in_list = False;\n-  for line in readelf.stdout:\n-    fields = line.split(None, 1)\n-    if (len(fields) == 2 and fields[0] == 'Offset'\n-        and fields[1].strip() == 'Name'):\n-      in_list = True\n-    # Either a blank-line or a new Length field terminates the current section.\n-    elif (len(fields) == 0 or fields[0] == 'Length:'):\n-      in_list = False;\n-    elif (in_list):\n-      pubnames.append(fields[1].strip())\n-\n-  readelf.wait()\n-  return pubnames\n+    \"\"\"Parse and return all the pubnames or pubtypes produced by readelf with the\n+    given option.\n+    \"\"\"\n+    readelf = subprocess.Popen(\n+        [READELF, \"--debug-dump=\" + readelf_option, filename], stdout=subprocess.PIPE\n+    )\n+    pubnames = []\n+\n+    in_list = False\n+    for line in readelf.stdout:\n+        fields = line.split(None, 1)\n+        if len(fields) == 2 and fields[0] == \"Offset\" and fields[1].strip() == \"Name\":\n+            in_list = True\n+        # Either a blank-line or a new Length field terminates the current section.\n+        elif len(fields) == 0 or fields[0] == \"Length:\":\n+            in_list = False\n+        elif in_list:\n+            pubnames.append(fields[1].strip())\n+\n+    readelf.wait()\n+    return pubnames\n \n \n def get_gdb_index(filename):\n-  \"\"\"Use readelf to dump the gdb index and collect the types and names\"\"\"\n-  readelf = subprocess.Popen([READELF, '--debug-dump=gdb_index',\n-                              filename], stdout=subprocess.PIPE)\n-  index_symbols = []\n-  symbol_table_started = False\n-  for line in readelf.stdout:\n-    if (line == 'Symbol table:\\n'):\n-      symbol_table_started = True;\n-    elif (symbol_table_started):\n-      # Readelf prints gdb-index lines formatted like so:\n-      # [  4] two::c2<double>::c2: 0\n-      # So take the string between the first close bracket and the last colon.\n-      index_symbols.append(line[line.find(']') + 2: line.rfind(':')])\n-\n-  readelf.wait()\n-  return index_symbols\n+    \"\"\"Use readelf to dump the gdb index and collect the types and names\"\"\"\n+    readelf = subprocess.Popen(\n+        [READELF, \"--debug-dump=gdb_index\", filename], stdout=subprocess.PIPE\n+    )\n+    index_symbols = []\n+    symbol_table_started = False\n+    for line in readelf.stdout:\n+        if line == \"Symbol table:\\n\":\n+            symbol_table_started = True\n+        elif symbol_table_started:\n+            # Readelf prints gdb-index lines formatted like so:\n+            # [  4] two::c2<double>::c2: 0\n+            # So take the string between the first close bracket and the last colon.\n+            index_symbols.append(line[line.find(\"]\") + 2 : line.rfind(\":\")])\n+\n+    readelf.wait()\n+    return index_symbols\n \n \n def CheckSets(list0, list1, name0, name1):\n-  \"\"\"Report any setwise differences between the two lists\"\"\"\n-\n-  if len(list0) == 0 or len(list1) == 0:\n+    \"\"\"Report any setwise differences between the two lists\"\"\"\n+\n+    if len(list0) == 0 or len(list1) == 0:\n+        return False\n+\n+    difference0 = set(list0) - set(list1)\n+    if len(difference0) != 0:\n+        print \"Elements in \" + name0 + \" but not \" + name1 + \": (\",\n+        print len(difference0),\n+        print \")\"\n+        for element in difference0:\n+            print \"  \" + element\n+\n+    difference1 = set(list1) - set(list0)\n+    if len(difference1) != 0:\n+        print \"Elements in \" + name1 + \" but not \" + name0 + \": (\",\n+        print len(difference1),\n+        print \")\"\n+        for element in difference1:\n+            print \"  \" + element\n+\n+    if len(difference0) != 0 or len(difference1) != 0:\n+        return True\n+\n+    print name0 + \" and \" + name1 + \" are identical.\"\n     return False\n \n-  difference0 = set(list0) - set(list1)\n-  if len(difference0) != 0:\n-    print \"Elements in \" + name0 + \" but not \" + name1 + \": (\",\n-    print len(difference0),\n-    print \")\"\n-    for element in difference0:\n-      print \"  \" + element\n-\n-  difference1 = set(list1) - set(list0)\n-  if len(difference1) != 0:\n-    print \"Elements in \" + name1 + \" but not \" + name0 + \": (\",\n-    print len(difference1),\n-    print \")\"\n-    for element in difference1:\n-      print \"  \" + element\n-\n-  if (len(difference0) != 0 or len(difference1) != 0):\n-    return True\n-\n-  print name0 + \" and \" + name1 + \" are identical.\"\n-  return False\n-\n \n def find_executables():\n-  \"\"\"Find the copies of readelf, objcopy and gdb to use.\"\"\"\n-  # Executable finding logic follows cc-with-index.sh\n-  global READELF\n-  READELF = os.getenv('READELF')\n-  if READELF is None:\n-    READELF = 'readelf'\n-  global OBJCOPY\n-  OBJCOPY = os.getenv('OBJCOPY')\n-  if OBJCOPY is None:\n-    OBJCOPY = 'objcopy'\n-\n-  global GDB\n-  GDB = os.getenv('GDB')\n-  if (GDB is None):\n-    if os.path.isfile('./gdb') and os.access('./gdb', os.X_OK):\n-      GDB = './gdb'\n-    elif os.path.isfile('../gdb') and os.access('../gdb', os.X_OK):\n-      GDB = '../gdb'\n-    elif os.path.isfile('../../gdb') and os.access('../../gdb', os.X_OK):\n-      GDB = '../../gdb'\n-    else:\n-      # Punt and use the gdb in the path.\n-      GDB = 'gdb'\n+    \"\"\"Find the copies of readelf, objcopy and gdb to use.\"\"\"\n+    # Executable finding logic follows cc-with-index.sh\n+    global READELF\n+    READELF = os.getenv(\"READELF\")\n+    if READELF is None:\n+        READELF = \"readelf\"\n+    global OBJCOPY\n+    OBJCOPY = os.getenv(\"OBJCOPY\")\n+    if OBJCOPY is None:\n+        OBJCOPY = \"objcopy\"\n+\n+    global GDB\n+    GDB = os.getenv(\"GDB\")\n+    if GDB is None:\n+        if os.path.isfile(\"./gdb\") and os.access(\"./gdb\", os.X_OK):\n+            GDB = \"./gdb\"\n+        elif os.path.isfile(\"../gdb\") and os.access(\"../gdb\", os.X_OK):\n+            GDB = \"../gdb\"\n+        elif os.path.isfile(\"../../gdb\") and os.access(\"../../gdb\", os.X_OK):\n+            GDB = \"../../gdb\"\n+        else:\n+            # Punt and use the gdb in the path.\n+            GDB = \"gdb\"\n \n \n def main(argv):\n-  \"\"\"The main subprogram.\"\"\"\n-  if len(argv) != 2:\n-    print \"Usage: test_pubnames_and_indexes.py <filename>\"\n-    sys.exit(2)\n-\n-  find_executables();\n-\n-  # Get the index produced by Gold--It should have been built into the binary.\n-  gold_index = get_gdb_index(argv[1])\n-\n-  # Collect the pubnames and types list\n-  pubs_list = get_pub_info(argv[1], \"pubnames\")\n-  pubs_list = pubs_list + get_pub_info(argv[1], \"pubtypes\")\n-\n-  # Generate a .gdb_index with gdb\n-  gdb_index_file = argv[1] + '.gdb-generated-index'\n-  subprocess.check_call([OBJCOPY, '--remove-section', '.gdb_index',\n-                         argv[1], gdb_index_file])\n-  subprocess.check_call([GDB, '-batch', '-nx', gdb_index_file,\n-                         '-ex', 'save gdb-index ' + os.path.dirname(argv[1]),\n-                         '-ex', 'quit'])\n-  subprocess.check_call([OBJCOPY, '--add-section',\n-                         '.gdb_index=' + gdb_index_file + '.gdb-index',\n-                         gdb_index_file])\n-  gdb_index = get_gdb_index(gdb_index_file)\n-  os.remove(gdb_index_file)\n-  os.remove(gdb_index_file + '.gdb-index')\n-\n-  failed = False\n-  gdb_index.sort()\n-  gold_index.sort()\n-  pubs_list.sort()\n-\n-  # Find the differences between the various indices.\n-  if len(gold_index) == 0:\n-    print \"Gold index is empty\"\n-    failed |= True\n-\n-  if len(gdb_index) == 0:\n-    print \"Gdb index is empty\"\n-    failed |= True\n-\n-  if len(pubs_list) == 0:\n-    print \"Pubs list is empty\"\n-    failed |= True\n-\n-  failed |= CheckSets(gdb_index, gold_index, \"gdb index\", \"gold index\")\n-  failed |= CheckSets(pubs_list, gold_index, \"pubs list\", \"gold index\")\n-  failed |= CheckSets(pubs_list, gdb_index, \"pubs list\", \"gdb index\")\n-\n-  if failed:\n-    print \"Test failed\"\n-    sys.exit(1)\n-\n-\n-if __name__ == '__main__':\n-  main(sys.argv)\n+    \"\"\"The main subprogram.\"\"\"\n+    if len(argv) != 2:\n+        print \"Usage: test_pubnames_and_indexes.py <filename>\"\n+        sys.exit(2)\n+\n+    find_executables()\n+\n+    # Get the index produced by Gold--It should have been built into the binary.\n+    gold_index = get_gdb_index(argv[1])\n+\n+    # Collect the pubnames and types list\n+    pubs_list = get_pub_info(argv[1], \"pubnames\")\n+    pubs_list = pubs_list + get_pub_info(argv[1], \"pubtypes\")\n+\n+    # Generate a .gdb_index with gdb\n+    gdb_index_file = argv[1] + \".gdb-generated-index\"\n+    subprocess.check_call(\n+        [OBJCOPY, \"--remove-section\", \".gdb_index\", argv[1], gdb_index_file]\n+    )\n+    subprocess.check_call(\n+        [\n+            GDB,\n+            \"-batch\",\n+            \"-nx\",\n+            gdb_index_file,\n+            \"-ex\",\n+            \"save gdb-index \" + os.path.dirname(argv[1]),\n+            \"-ex\",\n+            \"quit\",\n+        ]\n+    )\n+    subprocess.check_call(\n+        [\n+            OBJCOPY,\n+            \"--add-section\",\n+            \".gdb_index=\" + gdb_index_file + \".gdb-index\",\n+            gdb_index_file,\n+        ]\n+    )\n+    gdb_index = get_gdb_index(gdb_index_file)\n+    os.remove(gdb_index_file)\n+    os.remove(gdb_index_file + \".gdb-index\")\n+\n+    failed = False\n+    gdb_index.sort()\n+    gold_index.sort()\n+    pubs_list.sort()\n+\n+    # Find the differences between the various indices.\n+    if len(gold_index) == 0:\n+        print \"Gold index is empty\"\n+        failed |= True\n+\n+    if len(gdb_index) == 0:\n+        print \"Gdb index is empty\"\n+        failed |= True\n+\n+    if len(pubs_list) == 0:\n+        print \"Pubs list is empty\"\n+        failed |= True\n+\n+    failed |= CheckSets(gdb_index, gold_index, \"gdb index\", \"gold index\")\n+    failed |= CheckSets(pubs_list, gold_index, \"pubs list\", \"gold index\")\n+    failed |= CheckSets(pubs_list, gdb_index, \"pubs list\", \"gdb index\")\n+\n+    if failed:\n+        print \"Test failed\"\n+        sys.exit(1)\n+\n+\n+if __name__ == \"__main__\":\n+    main(sys.argv)"
    },
    {
      "sha": "e501e2533c2e3a439dbe049bf617a424f4e37771",
      "filename": "gdb/copyright.py",
      "status": "modified",
      "additions": 206,
      "deletions": 83,
      "changes": 289,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/copyright.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/copyright.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/copyright.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -47,23 +47,32 @@ def get_update_list():\n     \"\"\"\n     result = []\n     for gdb_dir in (\n-        'gdb', 'gdbserver', 'gdbsupport', 'gnulib', 'sim', 'include/gdb',\n+        \"gdb\",\n+        \"gdbserver\",\n+        \"gdbsupport\",\n+        \"gnulib\",\n+        \"sim\",\n+        \"include/gdb\",\n     ):\n         for root, dirs, files in os.walk(gdb_dir, topdown=True):\n             for dirname in dirs:\n                 reldirname = \"%s/%s\" % (root, dirname)\n-                if (dirname in EXCLUDE_ALL_LIST\n+                if (\n+                    dirname in EXCLUDE_ALL_LIST\n                     or reldirname in EXCLUDE_LIST\n                     or reldirname in NOT_FSF_LIST\n-                    or reldirname in BY_HAND):\n+                    or reldirname in BY_HAND\n+                ):\n                     # Prune this directory from our search list.\n                     dirs.remove(dirname)\n             for filename in files:\n                 relpath = \"%s/%s\" % (root, filename)\n-                if (filename in EXCLUDE_ALL_LIST\n+                if (\n+                    filename in EXCLUDE_ALL_LIST\n                     or relpath in EXCLUDE_LIST\n                     or relpath in NOT_FSF_LIST\n-                    or relpath in BY_HAND):\n+                    or relpath in BY_HAND\n+                ):\n                     # Ignore this file.\n                     pass\n                 else:\n@@ -80,15 +89,18 @@ def update_files(update_list):\n     # all years should be collapsed to one single year interval,\n     # even if there are \"holes\" in the list of years found in the\n     # original copyright notice (OK'ed by the FSF, case [gnu.org #719834]).\n-    os.environ['UPDATE_COPYRIGHT_USE_INTERVALS'] = '2'\n+    os.environ[\"UPDATE_COPYRIGHT_USE_INTERVALS\"] = \"2\"\n \n     # Perform the update, and save the output in a string.\n-    update_cmd = ['bash', 'gnulib/import/extra/update-copyright']\n+    update_cmd = [\"bash\", \"gnulib/import/extra/update-copyright\"]\n     update_cmd += update_list\n \n-    p = subprocess.Popen(update_cmd, stdout=subprocess.PIPE,\n-                         stderr=subprocess.STDOUT,\n-                         encoding=locale.getpreferredencoding())\n+    p = subprocess.Popen(\n+        update_cmd,\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.STDOUT,\n+        encoding=locale.getpreferredencoding(),\n+    )\n     update_out = p.communicate()[0]\n \n     # Process the output.  Typically, a lot of files do not have\n@@ -100,7 +112,7 @@ def update_files(update_list):\n     # short of looking at each file and seeing which notice is appropriate.\n     # Too much work! (~4,000 files listed as of 2012-01-03).\n     update_out = update_out.splitlines(keepends=False)\n-    warning_string = ': warning: copyright statement not found'\n+    warning_string = \": warning: copyright statement not found\"\n     warning_len = len(warning_string)\n \n     for line in update_out:\n@@ -134,48 +146,53 @@ def may_have_copyright_notice(filename):\n     # so just open the file as a byte stream. We only need to search\n     # for a pattern that should be the same regardless of encoding,\n     # so that should be good enough.\n-    fd = open(filename, 'rb')\n+    fd = open(filename, \"rb\")\n \n     lineno = 1\n     for line in fd:\n-        if b'Copyright' in line:\n+        if b\"Copyright\" in line:\n             return True\n         lineno += 1\n         if lineno > 50:\n             return False\n     return False\n \n \n-def main ():\n+def main():\n     \"\"\"The main subprogram.\"\"\"\n     root_dir = os.path.dirname(os.getcwd())\n     os.chdir(root_dir)\n \n-    if not (os.path.isdir('gdb') and\n-            os.path.isfile(\"gnulib/import/extra/update-copyright\")):\n+    if not (\n+        os.path.isdir(\"gdb\") and os.path.isfile(\"gnulib/import/extra/update-copyright\")\n+    ):\n         print(\"Error: This script must be called from the gdb directory.\")\n         sys.exit(1)\n \n     update_list = get_update_list()\n-    update_files (update_list)\n+    update_files(update_list)\n \n     # Remind the user that some files need to be updated by HAND...\n \n     if MULTIPLE_COPYRIGHT_HEADERS:\n         print()\n-        print(\"\\033[31m\"\n-              \"REMINDER: Multiple copyright headers must be updated by hand:\"\n-              \"\\033[0m\")\n+        print(\n+            \"\\033[31m\"\n+            \"REMINDER: Multiple copyright headers must be updated by hand:\"\n+            \"\\033[0m\"\n+        )\n         for filename in MULTIPLE_COPYRIGHT_HEADERS:\n             print(\"  \", filename)\n \n     if BY_HAND:\n         print()\n-        print(\"\\033[31mREMINDER: The following files must be updated by hand.\" \\\n-              \"\\033[0m\")\n+        print(\n+            \"\\033[31mREMINDER: The following files must be updated by hand.\" \"\\033[0m\"\n+        )\n         for filename in BY_HAND:\n             print(\"  \", filename)\n \n+\n ############################################################################\n #\n # Some constants, placed at the end because they take up a lot of room.\n@@ -190,11 +207,11 @@ def main ():\n #\n # Filenames are relative to the root directory.\n EXCLUDE_LIST = (\n-    'gdb/nat/glibc_thread_db.h',\n-    'gdb/CONTRIBUTE',\n-    'gnulib/import',\n-    'gnulib/config.in',\n-    'gnulib/Makefile.in',\n+    \"gdb/nat/glibc_thread_db.h\",\n+    \"gdb/CONTRIBUTE\",\n+    \"gnulib/import\",\n+    \"gnulib/config.in\",\n+    \"gnulib/Makefile.in\",\n )\n \n # Files which should not be modified, either because they are\n@@ -206,8 +223,14 @@ def main ():\n # Eg: We want all files named COPYING to be left untouched.\n \n EXCLUDE_ALL_LIST = (\n-    \"COPYING\", \"COPYING.LIB\", \"CVS\", \"configure\", \"copying.c\",\n-    \"fdl.texi\", \"gpl.texi\", \"aclocal.m4\",\n+    \"COPYING\",\n+    \"COPYING.LIB\",\n+    \"CVS\",\n+    \"configure\",\n+    \"copying.c\",\n+    \"fdl.texi\",\n+    \"gpl.texi\",\n+    \"aclocal.m4\",\n )\n \n # The list of files to update by hand.\n@@ -230,66 +253,166 @@ def main ():\n     \"gdb/exc_request.defs\",\n     \"gdb/gdbtk\",\n     \"gdb/testsuite/gdb.gdbtk/\",\n-    \"sim/arm/armemu.h\", \"sim/arm/armos.c\", \"sim/arm/gdbhost.c\",\n-    \"sim/arm/dbg_hif.h\", \"sim/arm/dbg_conf.h\", \"sim/arm/communicate.h\",\n-    \"sim/arm/armos.h\", \"sim/arm/armcopro.c\", \"sim/arm/armemu.c\",\n-    \"sim/arm/kid.c\", \"sim/arm/thumbemu.c\", \"sim/arm/armdefs.h\",\n-    \"sim/arm/armopts.h\", \"sim/arm/dbg_cp.h\", \"sim/arm/dbg_rdi.h\",\n-    \"sim/arm/parent.c\", \"sim/arm/armsupp.c\", \"sim/arm/armrdi.c\",\n-    \"sim/arm/bag.c\", \"sim/arm/armvirt.c\", \"sim/arm/main.c\", \"sim/arm/bag.h\",\n-    \"sim/arm/communicate.c\", \"sim/arm/gdbhost.h\", \"sim/arm/armfpe.h\",\n+    \"sim/arm/armemu.h\",\n+    \"sim/arm/armos.c\",\n+    \"sim/arm/gdbhost.c\",\n+    \"sim/arm/dbg_hif.h\",\n+    \"sim/arm/dbg_conf.h\",\n+    \"sim/arm/communicate.h\",\n+    \"sim/arm/armos.h\",\n+    \"sim/arm/armcopro.c\",\n+    \"sim/arm/armemu.c\",\n+    \"sim/arm/kid.c\",\n+    \"sim/arm/thumbemu.c\",\n+    \"sim/arm/armdefs.h\",\n+    \"sim/arm/armopts.h\",\n+    \"sim/arm/dbg_cp.h\",\n+    \"sim/arm/dbg_rdi.h\",\n+    \"sim/arm/parent.c\",\n+    \"sim/arm/armsupp.c\",\n+    \"sim/arm/armrdi.c\",\n+    \"sim/arm/bag.c\",\n+    \"sim/arm/armvirt.c\",\n+    \"sim/arm/main.c\",\n+    \"sim/arm/bag.h\",\n+    \"sim/arm/communicate.c\",\n+    \"sim/arm/gdbhost.h\",\n+    \"sim/arm/armfpe.h\",\n     \"sim/arm/arminit.c\",\n-    \"sim/common/cgen-fpu.c\", \"sim/common/cgen-fpu.h\",\n+    \"sim/common/cgen-fpu.c\",\n+    \"sim/common/cgen-fpu.h\",\n     \"sim/common/cgen-accfp.c\",\n-    \"sim/mips/m16run.c\", \"sim/mips/sim-main.c\",\n+    \"sim/mips/m16run.c\",\n+    \"sim/mips/sim-main.c\",\n     \"sim/moxie/moxie-gdb.dts\",\n     # Not a single file in sim/ppc/ appears to be copyright FSF :-(.\n-    \"sim/ppc/filter.h\", \"sim/ppc/gen-support.h\", \"sim/ppc/ld-insn.h\",\n-    \"sim/ppc/hw_sem.c\", \"sim/ppc/hw_disk.c\", \"sim/ppc/idecode_branch.h\",\n-    \"sim/ppc/sim-endian.h\", \"sim/ppc/table.c\", \"sim/ppc/hw_core.c\",\n-    \"sim/ppc/gen-support.c\", \"sim/ppc/gen-semantics.h\", \"sim/ppc/cpu.h\",\n-    \"sim/ppc/sim_callbacks.h\", \"sim/ppc/RUN\", \"sim/ppc/Makefile.in\",\n-    \"sim/ppc/emul_chirp.c\", \"sim/ppc/hw_nvram.c\", \"sim/ppc/dc-test.01\",\n-    \"sim/ppc/hw_phb.c\", \"sim/ppc/hw_eeprom.c\", \"sim/ppc/bits.h\",\n-    \"sim/ppc/hw_vm.c\", \"sim/ppc/cap.h\", \"sim/ppc/os_emul.h\",\n-    \"sim/ppc/options.h\", \"sim/ppc/gen-idecode.c\", \"sim/ppc/filter.c\",\n-    \"sim/ppc/corefile-n.h\", \"sim/ppc/std-config.h\", \"sim/ppc/ld-decode.h\",\n-    \"sim/ppc/filter_filename.h\", \"sim/ppc/hw_shm.c\",\n-    \"sim/ppc/pk_disklabel.c\", \"sim/ppc/dc-simple\", \"sim/ppc/misc.h\",\n-    \"sim/ppc/device_table.h\", \"sim/ppc/ld-insn.c\", \"sim/ppc/inline.c\",\n-    \"sim/ppc/emul_bugapi.h\", \"sim/ppc/hw_cpu.h\", \"sim/ppc/debug.h\",\n-    \"sim/ppc/hw_ide.c\", \"sim/ppc/debug.c\", \"sim/ppc/gen-itable.h\",\n-    \"sim/ppc/interrupts.c\", \"sim/ppc/hw_glue.c\", \"sim/ppc/emul_unix.c\",\n-    \"sim/ppc/sim_calls.c\", \"sim/ppc/dc-complex\", \"sim/ppc/ld-cache.c\",\n-    \"sim/ppc/registers.h\", \"sim/ppc/dc-test.02\", \"sim/ppc/options.c\",\n-    \"sim/ppc/igen.h\", \"sim/ppc/registers.c\", \"sim/ppc/device.h\",\n-    \"sim/ppc/emul_chirp.h\", \"sim/ppc/hw_register.c\", \"sim/ppc/hw_init.c\",\n-    \"sim/ppc/sim-endian-n.h\", \"sim/ppc/filter_filename.c\",\n-    \"sim/ppc/bits.c\", \"sim/ppc/idecode_fields.h\", \"sim/ppc/hw_memory.c\",\n-    \"sim/ppc/misc.c\", \"sim/ppc/double.c\", \"sim/ppc/psim.h\",\n-    \"sim/ppc/hw_trace.c\", \"sim/ppc/emul_netbsd.h\", \"sim/ppc/psim.c\",\n-    \"sim/ppc/ppc-instructions\", \"sim/ppc/tree.h\", \"sim/ppc/README\",\n-    \"sim/ppc/gen-icache.h\", \"sim/ppc/gen-model.h\", \"sim/ppc/ld-cache.h\",\n-    \"sim/ppc/mon.c\", \"sim/ppc/corefile.h\", \"sim/ppc/vm.c\",\n-    \"sim/ppc/INSTALL\", \"sim/ppc/gen-model.c\", \"sim/ppc/hw_cpu.c\",\n-    \"sim/ppc/corefile.c\", \"sim/ppc/hw_opic.c\", \"sim/ppc/gen-icache.c\",\n-    \"sim/ppc/events.h\", \"sim/ppc/os_emul.c\", \"sim/ppc/emul_generic.c\",\n-    \"sim/ppc/main.c\", \"sim/ppc/hw_com.c\", \"sim/ppc/gen-semantics.c\",\n-    \"sim/ppc/emul_bugapi.c\", \"sim/ppc/device.c\", \"sim/ppc/emul_generic.h\",\n-    \"sim/ppc/tree.c\", \"sim/ppc/mon.h\", \"sim/ppc/interrupts.h\",\n-    \"sim/ppc/cap.c\", \"sim/ppc/cpu.c\", \"sim/ppc/hw_phb.h\",\n-    \"sim/ppc/device_table.c\", \"sim/ppc/lf.c\", \"sim/ppc/lf.c\",\n-    \"sim/ppc/dc-stupid\", \"sim/ppc/hw_pal.c\", \"sim/ppc/ppc-spr-table\",\n-    \"sim/ppc/emul_unix.h\", \"sim/ppc/words.h\", \"sim/ppc/basics.h\",\n-    \"sim/ppc/hw_htab.c\", \"sim/ppc/lf.h\", \"sim/ppc/ld-decode.c\",\n-    \"sim/ppc/sim-endian.c\", \"sim/ppc/gen-itable.c\",\n-    \"sim/ppc/idecode_expression.h\", \"sim/ppc/table.h\", \"sim/ppc/dgen.c\",\n-    \"sim/ppc/events.c\", \"sim/ppc/gen-idecode.h\", \"sim/ppc/emul_netbsd.c\",\n-    \"sim/ppc/igen.c\", \"sim/ppc/vm_n.h\", \"sim/ppc/vm.h\",\n-    \"sim/ppc/hw_iobus.c\", \"sim/ppc/inline.h\",\n+    \"sim/ppc/filter.h\",\n+    \"sim/ppc/gen-support.h\",\n+    \"sim/ppc/ld-insn.h\",\n+    \"sim/ppc/hw_sem.c\",\n+    \"sim/ppc/hw_disk.c\",\n+    \"sim/ppc/idecode_branch.h\",\n+    \"sim/ppc/sim-endian.h\",\n+    \"sim/ppc/table.c\",\n+    \"sim/ppc/hw_core.c\",\n+    \"sim/ppc/gen-support.c\",\n+    \"sim/ppc/gen-semantics.h\",\n+    \"sim/ppc/cpu.h\",\n+    \"sim/ppc/sim_callbacks.h\",\n+    \"sim/ppc/RUN\",\n+    \"sim/ppc/Makefile.in\",\n+    \"sim/ppc/emul_chirp.c\",\n+    \"sim/ppc/hw_nvram.c\",\n+    \"sim/ppc/dc-test.01\",\n+    \"sim/ppc/hw_phb.c\",\n+    \"sim/ppc/hw_eeprom.c\",\n+    \"sim/ppc/bits.h\",\n+    \"sim/ppc/hw_vm.c\",\n+    \"sim/ppc/cap.h\",\n+    \"sim/ppc/os_emul.h\",\n+    \"sim/ppc/options.h\",\n+    \"sim/ppc/gen-idecode.c\",\n+    \"sim/ppc/filter.c\",\n+    \"sim/ppc/corefile-n.h\",\n+    \"sim/ppc/std-config.h\",\n+    \"sim/ppc/ld-decode.h\",\n+    \"sim/ppc/filter_filename.h\",\n+    \"sim/ppc/hw_shm.c\",\n+    \"sim/ppc/pk_disklabel.c\",\n+    \"sim/ppc/dc-simple\",\n+    \"sim/ppc/misc.h\",\n+    \"sim/ppc/device_table.h\",\n+    \"sim/ppc/ld-insn.c\",\n+    \"sim/ppc/inline.c\",\n+    \"sim/ppc/emul_bugapi.h\",\n+    \"sim/ppc/hw_cpu.h\",\n+    \"sim/ppc/debug.h\",\n+    \"sim/ppc/hw_ide.c\",\n+    \"sim/ppc/debug.c\",\n+    \"sim/ppc/gen-itable.h\",\n+    \"sim/ppc/interrupts.c\",\n+    \"sim/ppc/hw_glue.c\",\n+    \"sim/ppc/emul_unix.c\",\n+    \"sim/ppc/sim_calls.c\",\n+    \"sim/ppc/dc-complex\",\n+    \"sim/ppc/ld-cache.c\",\n+    \"sim/ppc/registers.h\",\n+    \"sim/ppc/dc-test.02\",\n+    \"sim/ppc/options.c\",\n+    \"sim/ppc/igen.h\",\n+    \"sim/ppc/registers.c\",\n+    \"sim/ppc/device.h\",\n+    \"sim/ppc/emul_chirp.h\",\n+    \"sim/ppc/hw_register.c\",\n+    \"sim/ppc/hw_init.c\",\n+    \"sim/ppc/sim-endian-n.h\",\n+    \"sim/ppc/filter_filename.c\",\n+    \"sim/ppc/bits.c\",\n+    \"sim/ppc/idecode_fields.h\",\n+    \"sim/ppc/hw_memory.c\",\n+    \"sim/ppc/misc.c\",\n+    \"sim/ppc/double.c\",\n+    \"sim/ppc/psim.h\",\n+    \"sim/ppc/hw_trace.c\",\n+    \"sim/ppc/emul_netbsd.h\",\n+    \"sim/ppc/psim.c\",\n+    \"sim/ppc/ppc-instructions\",\n+    \"sim/ppc/tree.h\",\n+    \"sim/ppc/README\",\n+    \"sim/ppc/gen-icache.h\",\n+    \"sim/ppc/gen-model.h\",\n+    \"sim/ppc/ld-cache.h\",\n+    \"sim/ppc/mon.c\",\n+    \"sim/ppc/corefile.h\",\n+    \"sim/ppc/vm.c\",\n+    \"sim/ppc/INSTALL\",\n+    \"sim/ppc/gen-model.c\",\n+    \"sim/ppc/hw_cpu.c\",\n+    \"sim/ppc/corefile.c\",\n+    \"sim/ppc/hw_opic.c\",\n+    \"sim/ppc/gen-icache.c\",\n+    \"sim/ppc/events.h\",\n+    \"sim/ppc/os_emul.c\",\n+    \"sim/ppc/emul_generic.c\",\n+    \"sim/ppc/main.c\",\n+    \"sim/ppc/hw_com.c\",\n+    \"sim/ppc/gen-semantics.c\",\n+    \"sim/ppc/emul_bugapi.c\",\n+    \"sim/ppc/device.c\",\n+    \"sim/ppc/emul_generic.h\",\n+    \"sim/ppc/tree.c\",\n+    \"sim/ppc/mon.h\",\n+    \"sim/ppc/interrupts.h\",\n+    \"sim/ppc/cap.c\",\n+    \"sim/ppc/cpu.c\",\n+    \"sim/ppc/hw_phb.h\",\n+    \"sim/ppc/device_table.c\",\n+    \"sim/ppc/lf.c\",\n+    \"sim/ppc/lf.c\",\n+    \"sim/ppc/dc-stupid\",\n+    \"sim/ppc/hw_pal.c\",\n+    \"sim/ppc/ppc-spr-table\",\n+    \"sim/ppc/emul_unix.h\",\n+    \"sim/ppc/words.h\",\n+    \"sim/ppc/basics.h\",\n+    \"sim/ppc/hw_htab.c\",\n+    \"sim/ppc/lf.h\",\n+    \"sim/ppc/ld-decode.c\",\n+    \"sim/ppc/sim-endian.c\",\n+    \"sim/ppc/gen-itable.c\",\n+    \"sim/ppc/idecode_expression.h\",\n+    \"sim/ppc/table.h\",\n+    \"sim/ppc/dgen.c\",\n+    \"sim/ppc/events.c\",\n+    \"sim/ppc/gen-idecode.h\",\n+    \"sim/ppc/emul_netbsd.c\",\n+    \"sim/ppc/igen.c\",\n+    \"sim/ppc/vm_n.h\",\n+    \"sim/ppc/vm.h\",\n+    \"sim/ppc/hw_iobus.c\",\n+    \"sim/ppc/inline.h\",\n     \"sim/testsuite/sim/mips/mips32-dsp2.s\",\n )\n \n if __name__ == \"__main__\":\n     main()\n-"
    },
    {
      "sha": "1f4b2cab6eccac80433d77924c2545b34b467303",
      "filename": "gdb/python/lib/gdb/FrameDecorator.py",
      "status": "modified",
      "additions": 25,
      "deletions": 18,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/FrameDecorator.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/FrameDecorator.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/FrameDecorator.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -24,6 +24,7 @@\n except NameError:\n     basestring = str\n \n+\n class FrameDecorator(object):\n     \"\"\"Basic implementation of a Frame Decorator\"\"\"\n \n@@ -66,9 +67,12 @@ def _is_limited_frame(frame):\n         limited.\"\"\"\n         sal = frame.find_sal()\n \n-        if (not sal.symtab or not sal.symtab.filename\n+        if (\n+            not sal.symtab\n+            or not sal.symtab.filename\n             or frame.type() == gdb.DUMMY_FRAME\n-            or frame.type() == gdb.SIGTRAMP_FRAME):\n+            or frame.type() == gdb.SIGTRAMP_FRAME\n+        ):\n \n             return True\n \n@@ -83,7 +87,7 @@ def elided(self):\n         return None\n \n     def function(self):\n-        \"\"\" Return the name of the frame's function or an address of\n+        \"\"\"Return the name of the frame's function or an address of\n         the function of the frame.  First determine if this is a\n         special frame.  If not, try to determine filename from GDB's\n         frame internal function API.  Finally, if a name cannot be\n@@ -120,7 +124,7 @@ def function(self):\n         return str(func)\n \n     def address(self):\n-        \"\"\" Return the address of the frame's pc\"\"\"\n+        \"\"\"Return the address of the frame's pc\"\"\"\n \n         if hasattr(self._base, \"address\"):\n             return self._base.address()\n@@ -129,7 +133,7 @@ def address(self):\n         return frame.pc()\n \n     def filename(self):\n-        \"\"\" Return the filename associated with this frame, detecting\n+        \"\"\"Return the filename associated with this frame, detecting\n         and returning the appropriate library name is this is a shared\n         library.\"\"\"\n \n@@ -145,7 +149,7 @@ def filename(self):\n             return sal.symtab.filename\n \n     def frame_args(self):\n-        \"\"\" Return an iterable of frame arguments for this frame, if\n+        \"\"\"Return an iterable of frame arguments for this frame, if\n         any.  The iterable object contains objects conforming with the\n         Symbol/Value interface.  If there are no frame arguments, or\n         if this frame is deemed to be a special case, return None.\"\"\"\n@@ -161,7 +165,7 @@ def frame_args(self):\n         return args.fetch_frame_args()\n \n     def frame_locals(self):\n-        \"\"\" Return an iterable of local variables for this frame, if\n+        \"\"\"Return an iterable of local variables for this frame, if\n         any.  The iterable object contains objects conforming with the\n         Symbol/Value interface.  If there are no frame locals, or if\n         this frame is deemed to be a special case, return None.\"\"\"\n@@ -177,7 +181,7 @@ def frame_locals(self):\n         return args.fetch_frame_locals()\n \n     def line(self):\n-        \"\"\" Return line number information associated with the frame's\n+        \"\"\"Return line number information associated with the frame's\n         pc.  If symbol table/line information does not exist, or if\n         this frame is deemed to be a special case, return None\"\"\"\n \n@@ -189,36 +193,39 @@ def line(self):\n             return None\n \n         sal = frame.find_sal()\n-        if (sal):\n+        if sal:\n             return sal.line\n         else:\n             return None\n \n     def inferior_frame(self):\n-        \"\"\" Return the gdb.Frame underpinning this frame decorator.\"\"\"\n+        \"\"\"Return the gdb.Frame underpinning this frame decorator.\"\"\"\n \n         # If 'base' is a frame decorator, we want to call its inferior\n         # frame method.  If '_base' is a gdb.Frame, just return that.\n         if hasattr(self._base, \"inferior_frame\"):\n             return self._base.inferior_frame()\n         return self._base\n \n+\n class SymValueWrapper(object):\n     \"\"\"A container class conforming to the Symbol/Value interface\n     which holds frame locals or frame arguments.\"\"\"\n+\n     def __init__(self, symbol, value):\n         self.sym = symbol\n         self.val = value\n \n     def value(self):\n-        \"\"\" Return the value associated with this symbol, or None\"\"\"\n+        \"\"\"Return the value associated with this symbol, or None\"\"\"\n         return self.val\n \n     def symbol(self):\n-        \"\"\" Return the symbol, or Python text, associated with this\n+        \"\"\"Return the symbol, or Python text, associated with this\n         symbol, or None\"\"\"\n         return self.sym\n \n+\n class FrameVars(object):\n \n     \"\"\"Utility class to fetch and store frame local variables, or\n@@ -232,12 +239,12 @@ def __init__(self, frame):\n             gdb.SYMBOL_LOC_ARG: True,\n             gdb.SYMBOL_LOC_REF_ARG: True,\n             gdb.SYMBOL_LOC_LOCAL: True,\n-\t    gdb.SYMBOL_LOC_REGPARM_ADDR: True,\n-\t    gdb.SYMBOL_LOC_COMPUTED: True\n-            }\n+            gdb.SYMBOL_LOC_REGPARM_ADDR: True,\n+            gdb.SYMBOL_LOC_COMPUTED: True,\n+        }\n \n     def fetch_b(self, sym):\n-        \"\"\" Local utility method to determine if according to Symbol\n+        \"\"\"Local utility method to determine if according to Symbol\n         type whether it should be included in the iterator.  Not all\n         symbols are fetched, and only symbols that return\n         True from this method should be fetched.\"\"\"\n@@ -268,7 +275,7 @@ def fetch_frame_locals(self):\n                 break\n             for sym in block:\n                 if sym.is_argument:\n-                    continue;\n+                    continue\n                 if self.fetch_b(sym):\n                     lvars.append(SymValueWrapper(sym, None))\n \n@@ -296,7 +303,7 @@ def fetch_frame_args(self):\n         if block != None:\n             for sym in block:\n                 if not sym.is_argument:\n-                    continue;\n+                    continue\n                 args.append(SymValueWrapper(sym, None))\n \n         return args"
    },
    {
      "sha": "fccb5886d1aa9c3fa37010f197e96e3d0c54e70e",
      "filename": "gdb/python/lib/gdb/FrameIterator.py",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/FrameIterator.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/FrameIterator.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/FrameIterator.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -16,6 +16,7 @@\n import gdb\n import itertools\n \n+\n class FrameIterator(object):\n     \"\"\"A gdb.Frame iterator.  Iterates over gdb.Frames or objects that\n     conform to that interface.\"\"\""
    },
    {
      "sha": "d748b3a5827e7842e970afe6c730c781b633a76e",
      "filename": "gdb/python/lib/gdb/__init__.py",
      "status": "modified",
      "additions": 38,
      "deletions": 22,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/__init__.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/__init__.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/__init__.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -26,7 +26,8 @@\n \n from _gdb import *\n \n-class _GdbFile (object):\n+\n+class _GdbFile(object):\n     # These two are needed in Python 3\n     encoding = \"UTF-8\"\n     errors = \"strict\"\n@@ -45,24 +46,28 @@ def writelines(self, iterable):\n     def flush(self):\n         flush()\n \n-class _GdbOutputFile (_GdbFile):\n+\n+class _GdbOutputFile(_GdbFile):\n     def write(self, s):\n         write(s, stream=STDOUT)\n \n+\n sys.stdout = _GdbOutputFile()\n \n-class _GdbOutputErrorFile (_GdbFile):\n+\n+class _GdbOutputErrorFile(_GdbFile):\n     def write(self, s):\n         write(s, stream=STDERR)\n \n+\n sys.stderr = _GdbOutputErrorFile()\n \n # Default prompt hook does nothing.\n prompt_hook = None\n \n # Ensure that sys.argv is set to something.\n # We do not use PySys_SetArgvEx because it did not appear until 2.6.6.\n-sys.argv = ['']\n+sys.argv = [\"\"]\n \n # Initial pretty printers.\n pretty_printers = []\n@@ -76,6 +81,7 @@ def write(self, s):\n # Initial frame unwinders.\n frame_unwinders = []\n \n+\n def _execute_unwinders(pending_frame):\n     \"\"\"Internal function called from GDB to execute all unwinders.\n \n@@ -108,6 +114,7 @@ def _execute_unwinders(pending_frame):\n \n     return None\n \n+\n def _execute_file(filepath):\n     \"\"\"This function is used to replace Python 2's PyRun_SimpleFile.\n \n@@ -117,22 +124,22 @@ def _execute_file(filepath):\n     \"Furthermore, any functions and classes defined by the executed code are\n     not guaranteed to work correctly after a runpy function has returned.\"\n     \"\"\"\n-    globals = sys.modules['__main__'].__dict__\n+    globals = sys.modules[\"__main__\"].__dict__\n     set_file = False\n     # Set file (if not set) so that the imported file can use it (e.g. to\n     # access file-relative paths). This matches what PyRun_SimpleFile does.\n-    if not hasattr(globals, '__file__'):\n-        globals['__file__'] = filepath\n+    if not hasattr(globals, \"__file__\"):\n+        globals[\"__file__\"] = filepath\n         set_file = True\n     try:\n-        with open(filepath, 'rb') as file:\n+        with open(filepath, \"rb\") as file:\n             # We pass globals also as locals to match what Python does\n             # in PyRun_SimpleFile.\n-            compiled = compile(file.read(), filepath, 'exec')\n+            compiled = compile(file.read(), filepath, \"exec\")\n             exec(compiled, globals, globals)\n     finally:\n         if set_file:\n-            del globals['__file__']\n+            del globals[\"__file__\"]\n \n \n # Convenience variable to GDB's python directory\n@@ -142,38 +149,37 @@ def _execute_file(filepath):\n \n # Packages to auto-load.\n \n-packages = [\n-    'function',\n-    'command',\n-    'printer'\n-]\n+packages = [\"function\", \"command\", \"printer\"]\n \n # pkgutil.iter_modules is not available prior to Python 2.6.  Instead,\n # manually iterate the list, collating the Python files in each module\n # path.  Construct the module name, and import.\n \n+\n def _auto_load_packages():\n     for package in packages:\n         location = os.path.join(os.path.dirname(__file__), package)\n         if os.path.exists(location):\n-            py_files = filter(lambda x: x.endswith('.py')\n-                                        and x != '__init__.py',\n-                              os.listdir(location))\n+            py_files = filter(\n+                lambda x: x.endswith(\".py\") and x != \"__init__.py\", os.listdir(location)\n+            )\n \n             for py_file in py_files:\n                 # Construct from foo.py, gdb.module.foo\n-                modname = \"%s.%s.%s\" % ( __name__, package, py_file[:-3] )\n+                modname = \"%s.%s.%s\" % (__name__, package, py_file[:-3])\n                 try:\n                     if modname in sys.modules:\n                         # reload modules with duplicate names\n                         reload(__import__(modname))\n                     else:\n                         __import__(modname)\n                 except:\n-                    sys.stderr.write (traceback.format_exc() + \"\\n\")\n+                    sys.stderr.write(traceback.format_exc() + \"\\n\")\n+\n \n _auto_load_packages()\n \n+\n def GdbSetPythonDirectory(dir):\n     \"\"\"Update sys.path, reload gdb and auto-load packages.\"\"\"\n     global PYTHONDIR\n@@ -191,30 +197,37 @@ def GdbSetPythonDirectory(dir):\n     reload(__import__(__name__))\n     _auto_load_packages()\n \n+\n def current_progspace():\n     \"Return the current Progspace.\"\n     return selected_inferior().progspace\n \n+\n def objfiles():\n     \"Return a sequence of the current program space's objfiles.\"\n     return current_progspace().objfiles()\n \n-def solib_name (addr):\n+\n+def solib_name(addr):\n     \"\"\"solib_name (Long) -> String.\\n\\\n Return the name of the shared library holding a given address, or None.\"\"\"\n     return current_progspace().solib_name(addr)\n \n+\n def block_for_pc(pc):\n     \"Return the block containing the given pc value, or None.\"\n     return current_progspace().block_for_pc(pc)\n \n+\n def find_pc_line(pc):\n     \"\"\"find_pc_line (pc) -> Symtab_and_line.\n-Return the gdb.Symtab_and_line object corresponding to the pc value.\"\"\"\n+    Return the gdb.Symtab_and_line object corresponding to the pc value.\"\"\"\n     return current_progspace().find_pc_line(pc)\n \n+\n try:\n     from pygments import formatters, lexers, highlight\n+\n     def colorize(filename, contents):\n         # Don't want any errors.\n         try:\n@@ -223,6 +236,9 @@ def colorize(filename, contents):\n             return highlight(contents, lexer, formatter)\n         except:\n             return None\n+\n+\n except:\n+\n     def colorize(filename, contents):\n         return None"
    },
    {
      "sha": "ac45a0da81507ea401078ec523febc8b9ef17b06",
      "filename": "gdb/python/lib/gdb/command/__init__.py",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/__init__.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/__init__.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/__init__.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -12,5 +12,3 @@\n #\n # You should have received a copy of the GNU General Public License\n # along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-"
    },
    {
      "sha": "3b76d36cfb468195169bf381036f5034ad24a082",
      "filename": "gdb/python/lib/gdb/command/explore.py",
      "status": "modified",
      "additions": 191,
      "deletions": 151,
      "changes": 342,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/explore.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/explore.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/explore.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -22,12 +22,13 @@\n if sys.version_info[0] > 2:\n     # Python 3 renamed raw_input to input\n     raw_input = input\n-    \n+\n+\n class Explorer(object):\n     \"\"\"Internal class which invokes other explorers.\"\"\"\n \n     # This map is filled by the Explorer.init_env() function\n-    type_code_to_explorer_map = { }\n+    type_code_to_explorer_map = {}\n \n     _SCALAR_TYPE_LIST = (\n         gdb.TYPE_CODE_CHAR,\n@@ -43,14 +44,18 @@ def guard_expr(expr):\n         length = len(expr)\n         guard = False\n \n-        if expr[0] == '(' and expr[length-1] == ')':\n+        if expr[0] == \"(\" and expr[length - 1] == \")\":\n             pass\n         else:\n             i = 0\n             while i < length:\n                 c = expr[i]\n-                if (c == '_' or ('a' <= c and c <= 'z') or\n-                    ('A' <= c and c <= 'Z') or ('0' <= c and c <= '9')):\n+                if (\n+                    c == \"_\"\n+                    or (\"a\" <= c and c <= \"z\")\n+                    or (\"A\" <= c and c <= \"Z\")\n+                    or (\"0\" <= c and c <= \"9\")\n+                ):\n                     pass\n                 else:\n                     guard = True\n@@ -85,8 +90,7 @@ def explore_expr(expr, value, is_child):\n             while explorer_class.explore_expr(expr, value, is_child):\n                 pass\n         else:\n-            print (\"Explorer for type '%s' not yet available.\\n\" %\n-                   str(value.type))\n+            print(\"Explorer for type '%s' not yet available.\\n\" % str(value.type))\n \n     @staticmethod\n     def explore_type(name, datatype, is_child):\n@@ -111,8 +115,7 @@ def explore_type(name, datatype, is_child):\n             while explorer_class.explore_type(name, datatype, is_child):\n                 pass\n         else:\n-            print (\"Explorer for type '%s' not yet available.\\n\" %\n-                   str(datatype))\n+            print(\"Explorer for type '%s' not yet available.\\n\" % str(datatype))\n \n     @staticmethod\n     def init_env():\n@@ -122,19 +125,19 @@ def init_env():\n         explorations.\n         \"\"\"\n         Explorer.type_code_to_explorer_map = {\n-            gdb.TYPE_CODE_CHAR : ScalarExplorer,\n-            gdb.TYPE_CODE_INT : ScalarExplorer,\n-            gdb.TYPE_CODE_BOOL : ScalarExplorer,\n-            gdb.TYPE_CODE_FLT : ScalarExplorer,\n-            gdb.TYPE_CODE_VOID : ScalarExplorer,\n-            gdb.TYPE_CODE_ENUM : ScalarExplorer,\n-            gdb.TYPE_CODE_STRUCT : CompoundExplorer,\n-            gdb.TYPE_CODE_UNION : CompoundExplorer,\n-            gdb.TYPE_CODE_PTR : PointerExplorer,\n-            gdb.TYPE_CODE_REF : ReferenceExplorer,\n-            gdb.TYPE_CODE_RVALUE_REF : ReferenceExplorer,\n-            gdb.TYPE_CODE_TYPEDEF : TypedefExplorer,\n-            gdb.TYPE_CODE_ARRAY : ArrayExplorer\n+            gdb.TYPE_CODE_CHAR: ScalarExplorer,\n+            gdb.TYPE_CODE_INT: ScalarExplorer,\n+            gdb.TYPE_CODE_BOOL: ScalarExplorer,\n+            gdb.TYPE_CODE_FLT: ScalarExplorer,\n+            gdb.TYPE_CODE_VOID: ScalarExplorer,\n+            gdb.TYPE_CODE_ENUM: ScalarExplorer,\n+            gdb.TYPE_CODE_STRUCT: CompoundExplorer,\n+            gdb.TYPE_CODE_UNION: CompoundExplorer,\n+            gdb.TYPE_CODE_PTR: PointerExplorer,\n+            gdb.TYPE_CODE_REF: ReferenceExplorer,\n+            gdb.TYPE_CODE_RVALUE_REF: ReferenceExplorer,\n+            gdb.TYPE_CODE_TYPEDEF: TypedefExplorer,\n+            gdb.TYPE_CODE_ARRAY: ArrayExplorer,\n         }\n \n     @staticmethod\n@@ -161,23 +164,23 @@ def return_to_parent_value():\n         \"\"\"A utility function which prints that the current exploration session\n         is returning to the parent value. Useful when exploring values.\n         \"\"\"\n-        print (\"\\nReturning to parent value...\\n\")\n-        \n+        print(\"\\nReturning to parent value...\\n\")\n+\n     @staticmethod\n     def return_to_parent_value_prompt():\n         \"\"\"A utility function which prompts the user to press the 'enter' key\n         so that the exploration session can shift back to the parent value.\n         Useful when exploring values.\n         \"\"\"\n         raw_input(\"\\nPress enter to return to parent value: \")\n-        \n+\n     @staticmethod\n     def return_to_enclosing_type():\n         \"\"\"A utility function which prints that the current exploration session\n         is returning to the enclosing type.  Useful when exploring types.\n         \"\"\"\n-        print (\"\\nReturning to enclosing type...\\n\")\n-        \n+        print(\"\\nReturning to enclosing type...\\n\")\n+\n     @staticmethod\n     def return_to_enclosing_type_prompt():\n         \"\"\"A utility function which prompts the user to press the 'enter' key\n@@ -196,9 +199,8 @@ def explore_expr(expr, value, is_child):\n         See Explorer.explore_expr and Explorer.is_scalar_type for more\n         information.\n         \"\"\"\n-        print (\"'%s' is a scalar value of type '%s'.\" %\n-               (expr, value.type))\n-        print (\"%s = %s\" % (expr, str(value)))\n+        print(\"'%s' is a scalar value of type '%s'.\" % (expr, value.type))\n+        print(\"%s = %s\" % (expr, str(value)))\n \n         if is_child:\n             Explorer.return_to_parent_value_prompt()\n@@ -214,16 +216,14 @@ def explore_type(name, datatype, is_child):\n         \"\"\"\n         if datatype.code == gdb.TYPE_CODE_ENUM:\n             if is_child:\n-                print (\"%s is of an enumerated type '%s'.\" %\n-                       (name, str(datatype)))\n+                print(\"%s is of an enumerated type '%s'.\" % (name, str(datatype)))\n             else:\n-                print (\"'%s' is an enumerated type.\" % name)\n+                print(\"'%s' is an enumerated type.\" % name)\n         else:\n             if is_child:\n-                print (\"%s is of a scalar type '%s'.\" %\n-                       (name, str(datatype)))\n+                print(\"%s is of a scalar type '%s'.\" % (name, str(datatype)))\n             else:\n-                print (\"'%s' is a scalar type.\" % name)\n+                print(\"'%s' is a scalar type.\" % name)\n \n         if is_child:\n             Explorer.return_to_enclosing_type_prompt()\n@@ -240,41 +240,49 @@ def explore_expr(expr, value, is_child):\n         \"\"\"Function to explore pointer values.\n         See Explorer.explore_expr for more information.\n         \"\"\"\n-        print (\"'%s' is a pointer to a value of type '%s'\" %\n-               (expr, str(value.type.target())))\n-        option  = raw_input(\"Continue exploring it as a pointer to a single \"\n-                            \"value [y/n]: \")\n+        print(\n+            \"'%s' is a pointer to a value of type '%s'\"\n+            % (expr, str(value.type.target()))\n+        )\n+        option = raw_input(\n+            \"Continue exploring it as a pointer to a single \" \"value [y/n]: \"\n+        )\n         if option == \"y\":\n             deref_value = None\n             try:\n                 deref_value = value.dereference()\n                 str(deref_value)\n             except gdb.MemoryError:\n-                print (\"'%s' a pointer pointing to an invalid memory \"\n-                       \"location.\" % expr)\n+                print(\n+                    \"'%s' a pointer pointing to an invalid memory \" \"location.\" % expr\n+                )\n                 if is_child:\n                     Explorer.return_to_parent_value_prompt()\n                 return False\n-            Explorer.explore_expr(\"*%s\" % Explorer.guard_expr(expr),\n-                                  deref_value, is_child)\n+            Explorer.explore_expr(\n+                \"*%s\" % Explorer.guard_expr(expr), deref_value, is_child\n+            )\n             return False\n-        \n-        option  = raw_input(\"Continue exploring it as a pointer to an \"\n-                            \"array [y/n]: \")\n+\n+        option = raw_input(\"Continue exploring it as a pointer to an \" \"array [y/n]: \")\n         if option == \"y\":\n             while True:\n                 index = 0\n                 try:\n-                    index = int(raw_input(\"Enter the index of the element you \"\n-                                          \"want to explore in '%s': \" % expr))\n+                    index = int(\n+                        raw_input(\n+                            \"Enter the index of the element you \"\n+                            \"want to explore in '%s': \" % expr\n+                        )\n+                    )\n                 except ValueError:\n                     break\n                 element_expr = \"%s[%d]\" % (Explorer.guard_expr(expr), index)\n                 element = value[index]\n                 try:\n                     str(element)\n                 except gdb.MemoryError:\n-                    print (\"Cannot read value at index %d.\" % index)\n+                    print(\"Cannot read value at index %d.\" % index)\n                     continue\n                 Explorer.explore_expr(element_expr, element, True)\n             return False\n@@ -289,12 +297,9 @@ def explore_type(name, datatype, is_child):\n         See Explorer.explore_type for more information.\n         \"\"\"\n         target_type = datatype.target()\n-        print (\"\\n%s is a pointer to a value of type '%s'.\" %\n-               (name, str(target_type)))\n+        print(\"\\n%s is a pointer to a value of type '%s'.\" % (name, str(target_type)))\n \n-        Explorer.explore_type(\"the pointee type of %s\" % name,\n-                              target_type,\n-                              is_child)\n+        Explorer.explore_type(\"the pointee type of %s\" % name, target_type, is_child)\n         return False\n \n \n@@ -319,6 +324,7 @@ def explore_type(name, datatype, is_child):\n         Explorer.explore_type(name, target_type, is_child)\n         return False\n \n+\n class ArrayExplorer(object):\n     \"\"\"Internal class used to explore arrays.\"\"\"\n \n@@ -328,11 +334,15 @@ def explore_expr(expr, value, is_child):\n         See Explorer.explore_expr for more information.\n         \"\"\"\n         target_type = value.type.target()\n-        print (\"'%s' is an array of '%s'.\" % (expr, str(target_type)))\n+        print(\"'%s' is an array of '%s'.\" % (expr, str(target_type)))\n         index = 0\n         try:\n-            index = int(raw_input(\"Enter the index of the element you want to \"\n-                                  \"explore in '%s': \" % expr))\n+            index = int(\n+                raw_input(\n+                    \"Enter the index of the element you want to \"\n+                    \"explore in '%s': \" % expr\n+                )\n+            )\n         except ValueError:\n             if is_child:\n                 Explorer.return_to_parent_value()\n@@ -343,12 +353,13 @@ def explore_expr(expr, value, is_child):\n             element = value[index]\n             str(element)\n         except gdb.MemoryError:\n-            print (\"Cannot read value at index %d.\" % index)\n+            print(\"Cannot read value at index %d.\" % index)\n             raw_input(\"Press enter to continue... \")\n             return True\n-            \n-        Explorer.explore_expr(\"%s[%d]\" % (Explorer.guard_expr(expr), index),\n-                              element, True)\n+\n+        Explorer.explore_expr(\n+            \"%s[%d]\" % (Explorer.guard_expr(expr), index), element, True\n+        )\n         return True\n \n     @staticmethod\n@@ -357,10 +368,9 @@ def explore_type(name, datatype, is_child):\n         See Explorer.explore_type for more information.\n         \"\"\"\n         target_type = datatype.target()\n-        print (\"%s is an array of '%s'.\" % (name, str(target_type)))\n+        print(\"%s is an array of '%s'.\" % (name, str(target_type)))\n \n-        Explorer.explore_type(\"the array element of %s\" % name, target_type,\n-                              is_child)\n+        Explorer.explore_type(\"the array element of %s\" % name, target_type, is_child)\n         return False\n \n \n@@ -369,19 +379,18 @@ class CompoundExplorer(object):\n \n     @staticmethod\n     def _print_fields(print_list):\n-        \"\"\"Internal function which prints the fields of a struct/class/union.\n-        \"\"\"\n+        \"\"\"Internal function which prints the fields of a struct/class/union.\"\"\"\n         max_field_name_length = 0\n         for pair in print_list:\n             if max_field_name_length < len(pair[0]):\n                 max_field_name_length = len(pair[0])\n \n         for pair in print_list:\n-            print (\"  %*s = %s\" % (max_field_name_length, pair[0], pair[1]))\n+            print(\"  %*s = %s\" % (max_field_name_length, pair[0], pair[1]))\n \n     @staticmethod\n     def _get_real_field_count(fields):\n-        real_field_count = 0;\n+        real_field_count = 0\n         for field in fields:\n             if not field.artificial:\n                 real_field_count = real_field_count + 1\n@@ -403,19 +412,23 @@ def explore_expr(expr, value, is_child):\n             type_desc = \"union\"\n \n         if CompoundExplorer._get_real_field_count(fields) == 0:\n-            print (\"The value of '%s' is a %s of type '%s' with no fields.\" %\n-                   (expr, type_desc, str(value.type)))\n+            print(\n+                \"The value of '%s' is a %s of type '%s' with no fields.\"\n+                % (expr, type_desc, str(value.type))\n+            )\n             if is_child:\n                 Explorer.return_to_parent_value_prompt()\n             return False\n \n-        print (\"The value of '%s' is a %s of type '%s' with the following \"\n-              \"fields:\\n\" % (expr, type_desc, str(value.type)))\n+        print(\n+            \"The value of '%s' is a %s of type '%s' with the following \"\n+            \"fields:\\n\" % (expr, type_desc, str(value.type))\n+        )\n \n         has_explorable_fields = False\n-        choice_to_compound_field_map = { }\n+        choice_to_compound_field_map = {}\n         current_choice = 0\n-        print_list = [ ]\n+        print_list = []\n         for field in fields:\n             if field.artificial:\n                 continue\n@@ -426,39 +439,48 @@ def explore_expr(expr, value, is_child):\n                 field_value = value[field.name]\n             literal_value = \"\"\n             if type_code == gdb.TYPE_CODE_UNION:\n-                literal_value = (\"<Enter %d to explore this field of type \"\n-                                 \"'%s'>\" % (current_choice, str(field.type)))\n+                literal_value = \"<Enter %d to explore this field of type \" \"'%s'>\" % (\n+                    current_choice,\n+                    str(field.type),\n+                )\n                 has_explorable_fields = True\n             else:\n                 if Explorer.is_scalar_type(field.type):\n-                    literal_value = (\"%s .. (Value of type '%s')\" %\n-                                     (str(field_value), str(field.type)))\n+                    literal_value = \"%s .. (Value of type '%s')\" % (\n+                        str(field_value),\n+                        str(field.type),\n+                    )\n                 else:\n                     if field.is_base_class:\n                         field_desc = \"base class\"\n                     else:\n                         field_desc = \"field\"\n-                    literal_value = (\"<Enter %d to explore this %s of type \"\n-                                     \"'%s'>\" %\n-                                     (current_choice, field_desc,\n-                                      str(field.type)))\n+                    literal_value = \"<Enter %d to explore this %s of type \" \"'%s'>\" % (\n+                        current_choice,\n+                        field_desc,\n+                        str(field.type),\n+                    )\n                     has_explorable_fields = True\n \n             choice_to_compound_field_map[str(current_choice)] = (\n-                field_full_name, field_value)\n+                field_full_name,\n+                field_value,\n+            )\n             current_choice = current_choice + 1\n \n             print_list.append((field.name, literal_value))\n \n         CompoundExplorer._print_fields(print_list)\n-        print (\"\")\n+        print(\"\")\n \n         if has_explorable_fields:\n             choice = raw_input(\"Enter the field number of choice: \")\n             if choice in choice_to_compound_field_map:\n-                Explorer.explore_expr(choice_to_compound_field_map[choice][0],\n-                                      choice_to_compound_field_map[choice][1],\n-                                      True)\n+                Explorer.explore_expr(\n+                    choice_to_compound_field_map[choice][0],\n+                    choice_to_compound_field_map[choice][1],\n+                    True,\n+                )\n                 return True\n             else:\n                 if is_child:\n@@ -484,58 +506,68 @@ def explore_type(name, datatype, is_child):\n         fields = datatype.fields()\n         if CompoundExplorer._get_real_field_count(fields) == 0:\n             if is_child:\n-                print (\"%s is a %s of type '%s' with no fields.\" %\n-                       (name, type_desc, str(datatype)))\n+                print(\n+                    \"%s is a %s of type '%s' with no fields.\"\n+                    % (name, type_desc, str(datatype))\n+                )\n                 Explorer.return_to_enclosing_type_prompt()\n             else:\n-                print (\"'%s' is a %s with no fields.\" % (name, type_desc))\n+                print(\"'%s' is a %s with no fields.\" % (name, type_desc))\n             return False\n \n         if is_child:\n-            print (\"%s is a %s of type '%s' \"\n-                   \"with the following fields:\\n\" %\n-                   (name, type_desc, str(datatype)))\n+            print(\n+                \"%s is a %s of type '%s' \"\n+                \"with the following fields:\\n\" % (name, type_desc, str(datatype))\n+            )\n         else:\n-            print (\"'%s' is a %s with the following \"\n-                   \"fields:\\n\" %\n-                   (name, type_desc))\n+            print(\"'%s' is a %s with the following \" \"fields:\\n\" % (name, type_desc))\n \n         has_explorable_fields = False\n         current_choice = 0\n-        choice_to_compound_field_map = { }\n-        print_list = [ ]\n+        choice_to_compound_field_map = {}\n+        print_list = []\n         for field in fields:\n             if field.artificial:\n                 continue\n             if field.is_base_class:\n                 field_desc = \"base class\"\n             else:\n                 field_desc = \"field\"\n-            rhs = (\"<Enter %d to explore this %s of type '%s'>\" %\n-                   (current_choice, field_desc, str(field.type)))\n+            rhs = \"<Enter %d to explore this %s of type '%s'>\" % (\n+                current_choice,\n+                field_desc,\n+                str(field.type),\n+            )\n             print_list.append((field.name, rhs))\n             choice_to_compound_field_map[str(current_choice)] = (\n-                field.name, field.type, field_desc)\n+                field.name,\n+                field.type,\n+                field_desc,\n+            )\n             current_choice = current_choice + 1\n \n         CompoundExplorer._print_fields(print_list)\n-        print (\"\")\n+        print(\"\")\n \n         if len(choice_to_compound_field_map) > 0:\n             choice = raw_input(\"Enter the field number of choice: \")\n             if choice in choice_to_compound_field_map:\n                 if is_child:\n-                    new_name = (\"%s '%s' of %s\" % \n-                                (choice_to_compound_field_map[choice][2],\n-                                 choice_to_compound_field_map[choice][0],\n-                                 name))\n+                    new_name = \"%s '%s' of %s\" % (\n+                        choice_to_compound_field_map[choice][2],\n+                        choice_to_compound_field_map[choice][0],\n+                        name,\n+                    )\n                 else:\n-                    new_name = (\"%s '%s' of '%s'\" % \n-                                (choice_to_compound_field_map[choice][2],\n-                                 choice_to_compound_field_map[choice][0],\n-                                 name))\n-                Explorer.explore_type(new_name,\n-                    choice_to_compound_field_map[choice][1], True)\n+                    new_name = \"%s '%s' of '%s'\" % (\n+                        choice_to_compound_field_map[choice][2],\n+                        choice_to_compound_field_map[choice][0],\n+                        name,\n+                    )\n+                Explorer.explore_type(\n+                    new_name, choice_to_compound_field_map[choice][1], True\n+                )\n                 return True\n             else:\n                 if is_child:\n@@ -545,7 +577,7 @@ def explore_type(name, datatype, is_child):\n                 Explorer.return_to_enclosing_type_prompt()\n \n         return False\n-           \n+\n \n class TypedefExplorer(object):\n     \"\"\"Internal class used to explore values whose type is a typedef.\"\"\"\n@@ -556,9 +588,11 @@ def explore_expr(expr, value, is_child):\n         See Explorer.explore_expr for more information.\n         \"\"\"\n         actual_type = value.type.strip_typedefs()\n-        print (\"The value of '%s' is of type '%s' \"\n-               \"which is a typedef of type '%s'\" %\n-               (expr, str(value.type), str(actual_type)))\n+        print(\n+            \"The value of '%s' is of type '%s' \"\n+            \"which is a typedef of type '%s'\"\n+            % (expr, str(value.type), str(actual_type))\n+        )\n \n         Explorer.explore_expr(expr, value.cast(actual_type), is_child)\n         return False\n@@ -570,11 +604,11 @@ def explore_type(name, datatype, is_child):\n         \"\"\"\n         actual_type = datatype.strip_typedefs()\n         if is_child:\n-            print (\"The type of %s is a typedef of type '%s'.\" %\n-                   (name, str(actual_type)))\n+            print(\n+                \"The type of %s is a typedef of type '%s'.\" % (name, str(actual_type))\n+            )\n         else:\n-            print (\"The type '%s' is a typedef of type '%s'.\" %\n-                   (name, str(actual_type)))\n+            print(\"The type '%s' is a typedef of type '%s'.\" % (name, str(actual_type)))\n \n         Explorer.explore_type(name, actual_type, is_child)\n         return False\n@@ -599,8 +633,7 @@ def check_args(name, arg_str):\n             gdb.GdbError if adequate arguments are not passed.\n         \"\"\"\n         if len(arg_str) < 1:\n-            raise gdb.GdbError(\"ERROR: '%s' requires an argument.\"\n-                               % name)\n+            raise gdb.GdbError(\"ERROR: '%s' requires an argument.\" % name)\n             return False\n         else:\n             return True\n@@ -649,16 +682,16 @@ def get_value_from_str(value_str):\n class ExploreCommand(gdb.Command):\n     \"\"\"Explore a value or a type valid in the current context.\n \n-Usage: explore ARG\n+    Usage: explore ARG\n \n-- ARG is either a valid expression or a type name.\n-- At any stage of exploration, hit the return key (instead of a\n-choice, if any) to return to the enclosing type or value.\"\"\"\n+    - ARG is either a valid expression or a type name.\n+    - At any stage of exploration, hit the return key (instead of a\n+    choice, if any) to return to the enclosing type or value.\"\"\"\n \n     def __init__(self):\n-        super(ExploreCommand, self).__init__(name = \"explore\",\n-                                             command_class = gdb.COMMAND_DATA,\n-                                             prefix = True)\n+        super(ExploreCommand, self).__init__(\n+            name=\"explore\", command_class=gdb.COMMAND_DATA, prefix=True\n+        )\n \n     def invoke(self, arg_str, from_tty):\n         if ExploreUtils.check_args(\"explore\", arg_str) == False:\n@@ -678,23 +711,26 @@ def invoke(self, arg_str, from_tty):\n \n         # If it is neither a value nor a type, raise an error.\n         raise gdb.GdbError(\n-            (\"'%s' neither evaluates to a value nor is a type \"\n-             \"in the current context.\" %\n-             arg_str))\n+            (\n+                \"'%s' neither evaluates to a value nor is a type \"\n+                \"in the current context.\" % arg_str\n+            )\n+        )\n \n \n class ExploreValueCommand(gdb.Command):\n     \"\"\"Explore value of an expression valid in the current context.\n \n-Usage: explore value ARG\n+    Usage: explore value ARG\n+\n+    - ARG is a valid expression.\n+    - At any stage of exploration, hit the return key (instead of a\n+    choice, if any) to return to the enclosing value.\"\"\"\n \n-- ARG is a valid expression.\n-- At any stage of exploration, hit the return key (instead of a\n-choice, if any) to return to the enclosing value.\"\"\"\n- \n     def __init__(self):\n         super(ExploreValueCommand, self).__init__(\n-            name = \"explore value\", command_class = gdb.COMMAND_DATA)\n+            name=\"explore value\", command_class=gdb.COMMAND_DATA\n+        )\n \n     def invoke(self, arg_str, from_tty):\n         if ExploreUtils.check_args(\"explore value\", arg_str) == False:\n@@ -703,26 +739,29 @@ def invoke(self, arg_str, from_tty):\n         value = ExploreUtils.get_value_from_str(arg_str)\n         if value is None:\n             raise gdb.GdbError(\n-                (\" '%s' does not evaluate to a value in the current \"\n-                 \"context.\" %\n-                 arg_str))\n+                (\n+                    \" '%s' does not evaluate to a value in the current \"\n+                    \"context.\" % arg_str\n+                )\n+            )\n             return\n \n         Explorer.explore_expr(arg_str, value, False)\n \n \n-class ExploreTypeCommand(gdb.Command):            \n+class ExploreTypeCommand(gdb.Command):\n     \"\"\"Explore a type or the type of an expression.\n \n-Usage: explore type ARG\n+    Usage: explore type ARG\n \n-- ARG is a valid expression or a type name.\n-- At any stage of exploration, hit the return key (instead of a\n-choice, if any) to return to the enclosing type.\"\"\"\n+    - ARG is a valid expression or a type name.\n+    - At any stage of exploration, hit the return key (instead of a\n+    choice, if any) to return to the enclosing type.\"\"\"\n \n     def __init__(self):\n         super(ExploreTypeCommand, self).__init__(\n-            name = \"explore type\", command_class = gdb.COMMAND_DATA)\n+            name=\"explore type\", command_class=gdb.COMMAND_DATA\n+        )\n \n     def invoke(self, arg_str, from_tty):\n         if ExploreUtils.check_args(\"explore type\", arg_str) == False:\n@@ -735,12 +774,13 @@ def invoke(self, arg_str, from_tty):\n \n         value = ExploreUtils.get_value_from_str(arg_str)\n         if value is not None:\n-            print (\"'%s' is of type '%s'.\" % (arg_str, str(value.type)))\n+            print(\"'%s' is of type '%s'.\" % (arg_str, str(value.type)))\n             Explorer.explore_type(str(value.type), value.type, False)\n             return\n \n-        raise gdb.GdbError((\"'%s' is not a type or value in the current \"\n-                            \"context.\" % arg_str))\n+        raise gdb.GdbError(\n+            (\"'%s' is not a type or value in the current \" \"context.\" % arg_str)\n+        )\n \n \n Explorer.init_env()"
    },
    {
      "sha": "91e8ca2d43c9674a0bf7c2aacffe407f592a7567",
      "filename": "gdb/python/lib/gdb/command/frame_filters.py",
      "status": "modified",
      "additions": 116,
      "deletions": 89,
      "changes": 205,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/frame_filters.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/frame_filters.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/frame_filters.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -29,24 +29,28 @@ class SetFilterPrefixCmd(gdb.Command):\n     \"\"\"Prefix command for 'set' frame-filter related operations.\"\"\"\n \n     def __init__(self):\n-        super(SetFilterPrefixCmd, self).__init__(\"set frame-filter\",\n-                                                 gdb.COMMAND_OBSCURE,\n-                                                 gdb.COMPLETE_NONE, True)\n+        super(SetFilterPrefixCmd, self).__init__(\n+            \"set frame-filter\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, True\n+        )\n+\n \n class ShowFilterPrefixCmd(gdb.Command):\n     \"\"\"Prefix command for 'show' frame-filter related operations.\"\"\"\n+\n     def __init__(self):\n-        super(ShowFilterPrefixCmd, self).__init__(\"show frame-filter\",\n-                                                  gdb.COMMAND_OBSCURE,\n-                                                  gdb.COMPLETE_NONE, True)\n+        super(ShowFilterPrefixCmd, self).__init__(\n+            \"show frame-filter\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, True\n+        )\n+\n+\n class InfoFrameFilter(gdb.Command):\n     \"\"\"List all registered Python frame-filters.\n \n-Usage: info frame-filters\"\"\"\n+    Usage: info frame-filters\"\"\"\n \n     def __init__(self):\n-        super(InfoFrameFilter, self).__init__(\"info frame-filter\",\n-                                              gdb.COMMAND_DATA)\n+        super(InfoFrameFilter, self).__init__(\"info frame-filter\", gdb.COMMAND_DATA)\n+\n     @staticmethod\n     def enabled_string(state):\n         \"\"\"Return \"Yes\" if filter is enabled, otherwise \"No\".\"\"\"\n@@ -56,9 +60,11 @@ def enabled_string(state):\n             return \"No\"\n \n     def print_list(self, title, frame_filters, blank_line):\n-        sorted_frame_filters = sorted(frame_filters.items(),\n-                                      key=lambda i: gdb.frames.get_priority(i[1]),\n-                                      reverse=True)\n+        sorted_frame_filters = sorted(\n+            frame_filters.items(),\n+            key=lambda i: gdb.frames.get_priority(i[1]),\n+            reverse=True,\n+        )\n \n         if len(sorted_frame_filters) == 0:\n             return 0\n@@ -68,14 +74,14 @@ def print_list(self, title, frame_filters, blank_line):\n         for frame_filter in sorted_frame_filters:\n             name = frame_filter[0]\n             try:\n-                priority = '{:<8}'.format(\n-                    str(gdb.frames.get_priority(frame_filter[1])))\n-                enabled = '{:<7}'.format(\n-                    self.enabled_string(gdb.frames.get_enabled(frame_filter[1])))\n+                priority = \"{:<8}\".format(str(gdb.frames.get_priority(frame_filter[1])))\n+                enabled = \"{:<7}\".format(\n+                    self.enabled_string(gdb.frames.get_enabled(frame_filter[1]))\n+                )\n                 print(\"  %s  %s  %s\" % (priority, enabled, name))\n             except Exception:\n                 e = sys.exc_info()[1]\n-                print(\"  Error printing filter '\"+name+\"': \"+str(e))\n+                print(\"  Error printing filter '\" + name + \"': \" + str(e))\n         if blank_line:\n             print(\"\")\n         return 1\n@@ -84,20 +90,26 @@ def invoke(self, arg, from_tty):\n         any_printed = self.print_list(\"global frame-filters:\", gdb.frame_filters, True)\n \n         cp = gdb.current_progspace()\n-        any_printed += self.print_list(\"progspace %s frame-filters:\" % cp.filename,\n-                                       cp.frame_filters, True)\n+        any_printed += self.print_list(\n+            \"progspace %s frame-filters:\" % cp.filename, cp.frame_filters, True\n+        )\n \n         for objfile in gdb.objfiles():\n-            any_printed += self.print_list(\"objfile %s frame-filters:\" % objfile.filename,\n-                                           objfile.frame_filters, False)\n+            any_printed += self.print_list(\n+                \"objfile %s frame-filters:\" % objfile.filename,\n+                objfile.frame_filters,\n+                False,\n+            )\n \n         if any_printed == 0:\n-            print (\"No frame filters.\")\n+            print(\"No frame filters.\")\n+\n \n # Internal enable/disable functions.\n \n+\n def _enable_parse_arg(cmd_name, arg):\n-    \"\"\" Internal worker function to take an argument from\n+    \"\"\"Internal worker function to take an argument from\n     enable/disable and return a tuple of arguments.\n \n     Arguments:\n@@ -109,19 +121,21 @@ def _enable_parse_arg(cmd_name, arg):\n         the dictionary in the case of \"all\".\n     \"\"\"\n \n-    argv = gdb.string_to_argv(arg);\n+    argv = gdb.string_to_argv(arg)\n     argc = len(argv)\n     if argc == 0:\n         raise gdb.GdbError(cmd_name + \" requires an argument\")\n     if argv[0] == \"all\":\n         if argc > 1:\n-            raise gdb.GdbError(cmd_name + \": with 'all' \" \\\n-                               \"you may not specify a filter.\")\n+            raise gdb.GdbError(\n+                cmd_name + \": with 'all' \" \"you may not specify a filter.\"\n+            )\n     elif argc != 2:\n-            raise gdb.GdbError(cmd_name + \" takes exactly two arguments.\")\n+        raise gdb.GdbError(cmd_name + \" takes exactly two arguments.\")\n \n     return argv\n \n+\n def _do_enable_frame_filter(command_tuple, flag):\n     \"\"\"Worker for enabling/disabling frame_filters.\n \n@@ -148,6 +162,7 @@ def _do_enable_frame_filter(command_tuple, flag):\n \n         gdb.frames.set_enabled(ff, flag)\n \n+\n def _complete_frame_filter_list(text, word, all_flag):\n     \"\"\"Worker for frame filter dictionary name completion.\n \n@@ -160,7 +175,7 @@ def _complete_frame_filter_list(text, word, all_flag):\n         A list of suggested frame filter dictionary name completions\n         from text/word analysis.  This list can be empty when there\n         are no suggestions for completion.\n-        \"\"\"\n+    \"\"\"\n     if all_flag == True:\n         filter_locations = [\"all\", \"global\", \"progspace\"]\n     else:\n@@ -171,20 +186,21 @@ def _complete_frame_filter_list(text, word, all_flag):\n     # If the user just asked for completions with no completion\n     # hints, just return all the frame filter dictionaries we know\n     # about.\n-    if (text == \"\"):\n+    if text == \"\":\n         return filter_locations\n \n     # Otherwise filter on what we know.\n-    flist = filter(lambda x,y=text:x.startswith(y), filter_locations)\n+    flist = filter(lambda x, y=text: x.startswith(y), filter_locations)\n \n     # If we only have one completion, complete it and return it.\n     if len(flist) == 1:\n-        flist[0] = flist[0][len(text)-len(word):]\n+        flist[0] = flist[0][len(text) - len(word) :]\n \n     # Otherwise, return an empty list, or a list of frame filter\n     # dictionaries that the previous filter operation returned.\n     return flist\n \n+\n def _complete_frame_filter_name(word, printer_dict):\n     \"\"\"Worker for frame filter name completion.\n \n@@ -201,29 +217,31 @@ def _complete_frame_filter_name(word, printer_dict):\n     \"\"\"\n \n     printer_keys = printer_dict.keys()\n-    if (word == \"\"):\n+    if word == \"\":\n         return printer_keys\n \n-    flist = filter(lambda x,y=word:x.startswith(y), printer_keys)\n+    flist = filter(lambda x, y=word: x.startswith(y), printer_keys)\n     return flist\n \n+\n class EnableFrameFilter(gdb.Command):\n     \"\"\"GDB command to enable the specified frame-filter.\n \n-Usage: enable frame-filter DICTIONARY [NAME]\n+    Usage: enable frame-filter DICTIONARY [NAME]\n \n-DICTIONARY is the name of the frame filter dictionary on which to\n-operate.  If dictionary is set to \"all\", perform operations on all\n-dictionaries.  Named dictionaries are: \"global\" for the global\n-frame filter dictionary, \"progspace\" for the program space's frame\n-filter dictionary.  If either all, or the two named dictionaries\n-are not specified, the dictionary name is assumed to be the name\n-of an \"objfile\" -- a shared library or an executable.\n+    DICTIONARY is the name of the frame filter dictionary on which to\n+    operate.  If dictionary is set to \"all\", perform operations on all\n+    dictionaries.  Named dictionaries are: \"global\" for the global\n+    frame filter dictionary, \"progspace\" for the program space's frame\n+    filter dictionary.  If either all, or the two named dictionaries\n+    are not specified, the dictionary name is assumed to be the name\n+    of an \"objfile\" -- a shared library or an executable.\n+\n+    NAME matches the name of the frame-filter to operate on.\"\"\"\n \n-NAME matches the name of the frame-filter to operate on.\"\"\"\n     def __init__(self):\n-        super(EnableFrameFilter, self).__init__(\"enable frame-filter\",\n-                                                 gdb.COMMAND_DATA)\n+        super(EnableFrameFilter, self).__init__(\"enable frame-filter\", gdb.COMMAND_DATA)\n+\n     def complete(self, text, word):\n         \"\"\"Completion function for both frame filter dictionary, and\n         frame filter name.\"\"\"\n@@ -241,20 +259,22 @@ def invoke(self, arg, from_tty):\n class DisableFrameFilter(gdb.Command):\n     \"\"\"GDB command to disable the specified frame-filter.\n \n-Usage: disable frame-filter DICTIONARY [NAME]\n+    Usage: disable frame-filter DICTIONARY [NAME]\n \n-DICTIONARY is the name of the frame filter dictionary on which to\n-operate.  If dictionary is set to \"all\", perform operations on all\n-dictionaries.  Named dictionaries are: \"global\" for the global\n-frame filter dictionary, \"progspace\" for the program space's frame\n-filter dictionary.  If either all, or the two named dictionaries\n-are not specified, the dictionary name is assumed to be the name\n-of an \"objfile\" -- a shared library or an executable.\n+    DICTIONARY is the name of the frame filter dictionary on which to\n+    operate.  If dictionary is set to \"all\", perform operations on all\n+    dictionaries.  Named dictionaries are: \"global\" for the global\n+    frame filter dictionary, \"progspace\" for the program space's frame\n+    filter dictionary.  If either all, or the two named dictionaries\n+    are not specified, the dictionary name is assumed to be the name\n+    of an \"objfile\" -- a shared library or an executable.\n+\n+    NAME matches the name of the frame-filter to operate on.\"\"\"\n \n-NAME matches the name of the frame-filter to operate on.\"\"\"\n     def __init__(self):\n-        super(DisableFrameFilter, self).__init__(\"disable frame-filter\",\n-                                                  gdb.COMMAND_DATA)\n+        super(DisableFrameFilter, self).__init__(\n+            \"disable frame-filter\", gdb.COMMAND_DATA\n+        )\n \n     def complete(self, text, word):\n         \"\"\"Completion function for both frame filter dictionary, and\n@@ -269,27 +289,28 @@ def invoke(self, arg, from_tty):\n         command_tuple = _enable_parse_arg(\"disable frame-filter\", arg)\n         _do_enable_frame_filter(command_tuple, False)\n \n+\n class SetFrameFilterPriority(gdb.Command):\n     \"\"\"GDB command to set the priority of the specified frame-filter.\n \n-Usage: set frame-filter priority DICTIONARY NAME PRIORITY\n+    Usage: set frame-filter priority DICTIONARY NAME PRIORITY\n \n-DICTIONARY is the name of the frame filter dictionary on which to\n-operate.  Named dictionaries are: \"global\" for the global frame\n-filter dictionary, \"progspace\" for the program space's framefilter\n-dictionary.  If either of these two are not specified, the\n-dictionary name is assumed to be the name of an \"objfile\" -- a\n-shared library or an executable.\n+    DICTIONARY is the name of the frame filter dictionary on which to\n+    operate.  Named dictionaries are: \"global\" for the global frame\n+    filter dictionary, \"progspace\" for the program space's framefilter\n+    dictionary.  If either of these two are not specified, the\n+    dictionary name is assumed to be the name of an \"objfile\" -- a\n+    shared library or an executable.\n \n-NAME matches the name of the frame filter to operate on.\n+    NAME matches the name of the frame filter to operate on.\n \n-PRIORITY is the an integer to assign the new priority to the frame\n-filter.\"\"\"\n+    PRIORITY is the an integer to assign the new priority to the frame\n+    filter.\"\"\"\n \n     def __init__(self):\n-        super(SetFrameFilterPriority, self).__init__(\"set frame-filter \" \\\n-                                                     \"priority\",\n-                                                     gdb.COMMAND_DATA)\n+        super(SetFrameFilterPriority, self).__init__(\n+            \"set frame-filter \" \"priority\", gdb.COMMAND_DATA\n+        )\n \n     def _parse_pri_arg(self, arg):\n         \"\"\"Internal worker to parse a priority from a tuple.\n@@ -305,11 +326,10 @@ def _parse_pri_arg(self, arg):\n             gdb.GdbError: An error parsing the arguments.\n         \"\"\"\n \n-        argv = gdb.string_to_argv(arg);\n+        argv = gdb.string_to_argv(arg)\n         argc = len(argv)\n         if argc != 3:\n-            print(\"set frame-filter priority \" \\\n-                  \"takes exactly three arguments.\")\n+            print(\"set frame-filter priority \" \"takes exactly three arguments.\")\n             return None\n \n         return argv\n@@ -355,24 +375,25 @@ def invoke(self, arg, from_tty):\n         if command_tuple != None:\n             self._set_filter_priority(command_tuple)\n \n+\n class ShowFrameFilterPriority(gdb.Command):\n     \"\"\"GDB command to show the priority of the specified frame-filter.\n \n-Usage: show frame-filter priority DICTIONARY NAME\n+    Usage: show frame-filter priority DICTIONARY NAME\n \n-DICTIONARY is the name of the frame filter dictionary on which to\n-operate.  Named dictionaries are: \"global\" for the global frame\n-filter dictionary, \"progspace\" for the program space's framefilter\n-dictionary.  If either of these two are not specified, the\n-dictionary name is assumed to be the name of an \"objfile\" -- a\n-shared library or an executable.\n+    DICTIONARY is the name of the frame filter dictionary on which to\n+    operate.  Named dictionaries are: \"global\" for the global frame\n+    filter dictionary, \"progspace\" for the program space's framefilter\n+    dictionary.  If either of these two are not specified, the\n+    dictionary name is assumed to be the name of an \"objfile\" -- a\n+    shared library or an executable.\n \n-NAME matches the name of the frame-filter to operate on.\"\"\"\n+    NAME matches the name of the frame-filter to operate on.\"\"\"\n \n     def __init__(self):\n-        super(ShowFrameFilterPriority, self).__init__(\"show frame-filter \" \\\n-                                                      \"priority\",\n-                                                      gdb.COMMAND_DATA)\n+        super(ShowFrameFilterPriority, self).__init__(\n+            \"show frame-filter \" \"priority\", gdb.COMMAND_DATA\n+        )\n \n     def _parse_pri_arg(self, arg):\n         \"\"\"Internal worker to parse a dictionary and name from a\n@@ -388,11 +409,10 @@ def _parse_pri_arg(self, arg):\n             gdb.GdbError: An error parsing the arguments.\n         \"\"\"\n \n-        argv = gdb.string_to_argv(arg);\n+        argv = gdb.string_to_argv(arg)\n         argc = len(argv)\n         if argc != 2:\n-            print(\"show frame-filter priority \" \\\n-                  \"takes exactly two arguments.\")\n+            print(\"show frame-filter priority \" \"takes exactly two arguments.\")\n             return None\n \n         return argv\n@@ -438,13 +458,20 @@ def invoke(self, arg, from_tty):\n         filter_name = command_tuple[1]\n         list_name = command_tuple[0]\n         try:\n-            priority = self.get_filter_priority(list_name, filter_name);\n+            priority = self.get_filter_priority(list_name, filter_name)\n         except Exception:\n             e = sys.exc_info()[1]\n-            print(\"Error printing filter priority for '\"+name+\"':\"+str(e))\n+            print(\"Error printing filter priority for '\" + name + \"':\" + str(e))\n         else:\n-            print(\"Priority of filter '\" + filter_name + \"' in list '\" \\\n-                + list_name + \"' is: \" + str(priority))\n+            print(\n+                \"Priority of filter '\"\n+                + filter_name\n+                + \"' in list '\"\n+                + list_name\n+                + \"' is: \"\n+                + str(priority)\n+            )\n+\n \n # Register commands\n SetFilterPrefixCmd()"
    },
    {
      "sha": "9d579bcf0bdf3eea9c3d97ae945665e7bf0a4a56",
      "filename": "gdb/python/lib/gdb/command/pretty_printers.py",
      "status": "modified",
      "additions": 108,
      "deletions": 78,
      "changes": 186,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/pretty_printers.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/pretty_printers.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/pretty_printers.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -38,7 +38,7 @@ def parse_printer_regexps(arg):\n         SyntaxError: an error processing ARG\n     \"\"\"\n \n-    argv = gdb.string_to_argv(arg);\n+    argv = gdb.string_to_argv(arg)\n     argc = len(argv)\n     object_regexp = \"\"  # match everything\n     name_regexp = \"\"  # match everything\n@@ -60,7 +60,7 @@ def parse_printer_regexps(arg):\n     except SyntaxError:\n         raise SyntaxError(\"invalid object regexp: %s\" % object_regexp)\n     try:\n-        name_re = re.compile (name_regexp)\n+        name_re = re.compile(name_regexp)\n     except SyntaxError:\n         raise SyntaxError(\"invalid name regexp: %s\" % name_regexp)\n     if subname_regexp is not None:\n@@ -70,7 +70,7 @@ def parse_printer_regexps(arg):\n             raise SyntaxError(\"invalid subname regexp: %s\" % subname_regexp)\n     else:\n         subname_re = None\n-    return(object_re, name_re, subname_re)\n+    return (object_re, name_re, subname_re)\n \n \n def printer_enabled_p(printer):\n@@ -84,19 +84,18 @@ def printer_enabled_p(printer):\n class InfoPrettyPrinter(gdb.Command):\n     \"\"\"GDB command to list all registered pretty-printers.\n \n-Usage: info pretty-printer [OBJECT-REGEXP [NAME-REGEXP]]\n+    Usage: info pretty-printer [OBJECT-REGEXP [NAME-REGEXP]]\n \n-OBJECT-REGEXP is a regular expression matching the objects to list.\n-Objects are \"global\", the program space's file, and the objfiles within\n-that program space.\n+    OBJECT-REGEXP is a regular expression matching the objects to list.\n+    Objects are \"global\", the program space's file, and the objfiles within\n+    that program space.\n \n-NAME-REGEXP matches the name of the pretty-printer.\n-Individual printers in a collection are named as\n-printer-name;subprinter-name.\"\"\"\n+    NAME-REGEXP matches the name of the pretty-printer.\n+    Individual printers in a collection are named as\n+    printer-name;subprinter-name.\"\"\"\n \n-    def __init__ (self):\n-        super(InfoPrettyPrinter, self).__init__(\"info pretty-printer\",\n-                                                 gdb.COMMAND_DATA)\n+    def __init__(self):\n+        super(InfoPrettyPrinter, self).__init__(\"info pretty-printer\", gdb.COMMAND_DATA)\n \n     @staticmethod\n     def enabled_string(printer):\n@@ -123,53 +122,70 @@ def list_pretty_printers(self, pretty_printers, name_re, subname_re):\n         \"\"\"Print a list of pretty-printers.\"\"\"\n         # A potential enhancement is to provide an option to list printers in\n         # \"lookup order\" (i.e. unsorted).\n-        sorted_pretty_printers = sorted (copy.copy(pretty_printers),\n-                                         key = self.printer_name)\n+        sorted_pretty_printers = sorted(\n+            copy.copy(pretty_printers), key=self.printer_name\n+        )\n         for printer in sorted_pretty_printers:\n             name = self.printer_name(printer)\n             enabled = self.enabled_string(printer)\n             if name_re.match(name):\n-                print (\"  %s%s\" % (name, enabled))\n-                if (hasattr(printer, \"subprinters\") and\n-                    printer.subprinters is not None):\n-                    sorted_subprinters = sorted (copy.copy(printer.subprinters),\n-                                                 key = self.printer_name)\n+                print(\"  %s%s\" % (name, enabled))\n+                if hasattr(printer, \"subprinters\") and printer.subprinters is not None:\n+                    sorted_subprinters = sorted(\n+                        copy.copy(printer.subprinters), key=self.printer_name\n+                    )\n                     for subprinter in sorted_subprinters:\n-                        if (not subname_re or\n-                            subname_re.match(subprinter.name)):\n-                            print (\"    %s%s\" %\n-                                   (subprinter.name,\n-                                    self.enabled_string(subprinter)))\n-\n-    def invoke1(self, title, printer_list,\n-                obj_name_to_match, object_re, name_re, subname_re):\n+                        if not subname_re or subname_re.match(subprinter.name):\n+                            print(\n+                                \"    %s%s\"\n+                                % (subprinter.name, self.enabled_string(subprinter))\n+                            )\n+\n+    def invoke1(\n+        self, title, printer_list, obj_name_to_match, object_re, name_re, subname_re\n+    ):\n         \"\"\"Subroutine of invoke to simplify it.\"\"\"\n         if printer_list and object_re.match(obj_name_to_match):\n-            print (title)\n+            print(title)\n             self.list_pretty_printers(printer_list, name_re, subname_re)\n \n     def invoke(self, arg, from_tty):\n         \"\"\"GDB calls this to perform the command.\"\"\"\n         (object_re, name_re, subname_re) = parse_printer_regexps(arg)\n-        self.invoke1(\"global pretty-printers:\", gdb.pretty_printers,\n-                     \"global\", object_re, name_re, subname_re)\n+        self.invoke1(\n+            \"global pretty-printers:\",\n+            gdb.pretty_printers,\n+            \"global\",\n+            object_re,\n+            name_re,\n+            subname_re,\n+        )\n         cp = gdb.current_progspace()\n-        self.invoke1(\"progspace %s pretty-printers:\" % cp.filename,\n-                     cp.pretty_printers, \"progspace\",\n-                     object_re, name_re, subname_re)\n+        self.invoke1(\n+            \"progspace %s pretty-printers:\" % cp.filename,\n+            cp.pretty_printers,\n+            \"progspace\",\n+            object_re,\n+            name_re,\n+            subname_re,\n+        )\n         for objfile in gdb.objfiles():\n-            self.invoke1(\"objfile %s pretty-printers:\" % objfile.filename,\n-                         objfile.pretty_printers, objfile.filename,\n-                         object_re, name_re, subname_re)\n+            self.invoke1(\n+                \"objfile %s pretty-printers:\" % objfile.filename,\n+                objfile.pretty_printers,\n+                objfile.filename,\n+                object_re,\n+                name_re,\n+                subname_re,\n+            )\n \n \n def count_enabled_printers(pretty_printers):\n     \"\"\"Return a 2-tuple of number of enabled and total printers.\"\"\"\n     enabled = 0\n     total = 0\n     for printer in pretty_printers:\n-        if (hasattr(printer, \"subprinters\")\n-            and printer.subprinters is not None):\n+        if hasattr(printer, \"subprinters\") and printer.subprinters is not None:\n             if printer_enabled_p(printer):\n                 for subprinter in printer.subprinters:\n                     if printer_enabled_p(subprinter):\n@@ -191,7 +207,9 @@ def count_all_enabled_printers():\n     (t_enabled, t_total) = count_enabled_printers(gdb.pretty_printers)\n     enabled_count += t_enabled\n     total_count += t_total\n-    (t_enabled, t_total) = count_enabled_printers(gdb.current_progspace().pretty_printers)\n+    (t_enabled, t_total) = count_enabled_printers(\n+        gdb.current_progspace().pretty_printers\n+    )\n     enabled_count += t_enabled\n     total_count += t_total\n     for objfile in gdb.objfiles():\n@@ -214,10 +232,10 @@ def show_pretty_printer_enabled_summary():\n     We count subprinters individually.\n     \"\"\"\n     (enabled_count, total_count) = count_all_enabled_printers()\n-    print (\"%d of %d printers enabled\" % (enabled_count, total_count))\n+    print(\"%d of %d printers enabled\" % (enabled_count, total_count))\n \n \n-def do_enable_pretty_printer_1 (pretty_printers, name_re, subname_re, flag):\n+def do_enable_pretty_printer_1(pretty_printers, name_re, subname_re, flag):\n     \"\"\"Worker for enabling/disabling pretty-printers.\n \n     Arguments:\n@@ -233,10 +251,13 @@ def do_enable_pretty_printer_1 (pretty_printers, name_re, subname_re, flag):\n     \"\"\"\n     total = 0\n     for printer in pretty_printers:\n-        if (hasattr(printer, \"name\") and name_re.match(printer.name) or\n-            hasattr(printer, \"__name__\") and name_re.match(printer.__name__)):\n-            if (hasattr(printer, \"subprinters\") and\n-                printer.subprinters is not None):\n+        if (\n+            hasattr(printer, \"name\")\n+            and name_re.match(printer.name)\n+            or hasattr(printer, \"__name__\")\n+            and name_re.match(printer.__name__)\n+        ):\n+            if hasattr(printer, \"subprinters\") and printer.subprinters is not None:\n                 if not subname_re:\n                     # Only record printers that change state.\n                     if printer_enabled_p(printer) != flag:\n@@ -252,10 +273,12 @@ def do_enable_pretty_printer_1 (pretty_printers, name_re, subname_re, flag):\n                     for subprinter in printer.subprinters:\n                         if subname_re.match(subprinter.name):\n                             # Only record printers that change state.\n-                           if (printer_enabled_p(printer) and\n-                               printer_enabled_p(subprinter) != flag):\n-                               total += 1\n-                           subprinter.enabled = flag\n+                            if (\n+                                printer_enabled_p(printer)\n+                                and printer_enabled_p(subprinter) != flag\n+                            ):\n+                                total += 1\n+                            subprinter.enabled = flag\n             else:\n                 # This printer has no subprinters.\n                 # If the user does \"disable pretty-printer .* .* foo\"\n@@ -275,28 +298,31 @@ def do_enable_pretty_printer_1 (pretty_printers, name_re, subname_re, flag):\n     return total\n \n \n-def do_enable_pretty_printer (arg, flag):\n+def do_enable_pretty_printer(arg, flag):\n     \"\"\"Internal worker for enabling/disabling pretty-printers.\"\"\"\n     (object_re, name_re, subname_re) = parse_printer_regexps(arg)\n \n     total = 0\n     if object_re.match(\"global\"):\n-        total += do_enable_pretty_printer_1(gdb.pretty_printers,\n-                                            name_re, subname_re, flag)\n+        total += do_enable_pretty_printer_1(\n+            gdb.pretty_printers, name_re, subname_re, flag\n+        )\n     cp = gdb.current_progspace()\n     if object_re.match(\"progspace\"):\n-        total += do_enable_pretty_printer_1(cp.pretty_printers,\n-                                            name_re, subname_re, flag)\n+        total += do_enable_pretty_printer_1(\n+            cp.pretty_printers, name_re, subname_re, flag\n+        )\n     for objfile in gdb.objfiles():\n         if object_re.match(objfile.filename):\n-            total += do_enable_pretty_printer_1(objfile.pretty_printers,\n-                                                name_re, subname_re, flag)\n+            total += do_enable_pretty_printer_1(\n+                objfile.pretty_printers, name_re, subname_re, flag\n+            )\n \n     if flag:\n         state = \"enabled\"\n     else:\n         state = \"disabled\"\n-    print (\"%d %s %s\" % (total, pluralize(\"printer\", total), state))\n+    print(\"%d %s %s\" % (total, pluralize(\"printer\", total), state))\n \n     # Print the total list of printers currently enabled/disabled.\n     # This is to further assist the user in determining whether the result\n@@ -312,44 +338,47 @@ def do_enable_pretty_printer (arg, flag):\n #\n # A useful addition would be -v (verbose) to show each printer affected.\n \n-class EnablePrettyPrinter (gdb.Command):\n+\n+class EnablePrettyPrinter(gdb.Command):\n     \"\"\"GDB command to enable the specified pretty-printer.\n \n-Usage: enable pretty-printer [OBJECT-REGEXP [NAME-REGEXP]]\n+    Usage: enable pretty-printer [OBJECT-REGEXP [NAME-REGEXP]]\n \n-OBJECT-REGEXP is a regular expression matching the objects to examine.\n-Objects are \"global\", the program space's file, and the objfiles within\n-that program space.\n+    OBJECT-REGEXP is a regular expression matching the objects to examine.\n+    Objects are \"global\", the program space's file, and the objfiles within\n+    that program space.\n \n-NAME-REGEXP matches the name of the pretty-printer.\n-Individual printers in a collection are named as\n-printer-name;subprinter-name.\"\"\"\n+    NAME-REGEXP matches the name of the pretty-printer.\n+    Individual printers in a collection are named as\n+    printer-name;subprinter-name.\"\"\"\n \n     def __init__(self):\n-        super(EnablePrettyPrinter, self).__init__(\"enable pretty-printer\",\n-                                                   gdb.COMMAND_DATA)\n+        super(EnablePrettyPrinter, self).__init__(\n+            \"enable pretty-printer\", gdb.COMMAND_DATA\n+        )\n \n     def invoke(self, arg, from_tty):\n         \"\"\"GDB calls this to perform the command.\"\"\"\n         do_enable_pretty_printer(arg, True)\n \n \n-class DisablePrettyPrinter (gdb.Command):\n+class DisablePrettyPrinter(gdb.Command):\n     \"\"\"GDB command to disable the specified pretty-printer.\n \n-Usage: disable pretty-printer [OBJECT-REGEXP [NAME-REGEXP]]\n+    Usage: disable pretty-printer [OBJECT-REGEXP [NAME-REGEXP]]\n \n-OBJECT-REGEXP is a regular expression matching the objects to examine.\n-Objects are \"global\", the program space's file, and the objfiles within\n-that program space.\n+    OBJECT-REGEXP is a regular expression matching the objects to examine.\n+    Objects are \"global\", the program space's file, and the objfiles within\n+    that program space.\n \n-NAME-REGEXP matches the name of the pretty-printer.\n-Individual printers in a collection are named as\n-printer-name;subprinter-name.\"\"\"\n+    NAME-REGEXP matches the name of the pretty-printer.\n+    Individual printers in a collection are named as\n+    printer-name;subprinter-name.\"\"\"\n \n     def __init__(self):\n-        super(DisablePrettyPrinter, self).__init__(\"disable pretty-printer\",\n-                                                   gdb.COMMAND_DATA)\n+        super(DisablePrettyPrinter, self).__init__(\n+            \"disable pretty-printer\", gdb.COMMAND_DATA\n+        )\n \n     def invoke(self, arg, from_tty):\n         \"\"\"GDB calls this to perform the command.\"\"\"\n@@ -362,4 +391,5 @@ def register_pretty_printer_commands():\n     EnablePrettyPrinter()\n     DisablePrettyPrinter()\n \n+\n register_pretty_printer_commands()"
    },
    {
      "sha": "6e105a39973d3c7d79681c15298a78641159ef0e",
      "filename": "gdb/python/lib/gdb/command/prompt.py",
      "status": "modified",
      "additions": 16,
      "deletions": 14,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/prompt.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/prompt.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/prompt.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,17 +19,18 @@\n import gdb\n import gdb.prompt\n \n+\n class _ExtendedPrompt(gdb.Parameter):\n \n     \"\"\"Set the extended prompt.\n \n-Usage: set extended-prompt VALUE\n+    Usage: set extended-prompt VALUE\n \n-Substitutions are applied to VALUE to compute the real prompt.\n+    Substitutions are applied to VALUE to compute the real prompt.\n \n-The currently defined substitutions are:\n+    The currently defined substitutions are:\n+    \"\"\"\n \n-\"\"\"\n     # Add the prompt library's dynamically generated help to the\n     # __doc__ string.\n     __doc__ = __doc__ + gdb.prompt.prompt_help()\n@@ -38,22 +39,22 @@ class _ExtendedPrompt(gdb.Parameter):\n     show_doc = \"Show the extended prompt.\"\n \n     def __init__(self):\n-        super(_ExtendedPrompt, self).__init__(\"extended-prompt\",\n-                                              gdb.COMMAND_SUPPORT,\n-                                              gdb.PARAM_STRING_NOESCAPE)\n-        self.value = ''\n+        super(_ExtendedPrompt, self).__init__(\n+            \"extended-prompt\", gdb.COMMAND_SUPPORT, gdb.PARAM_STRING_NOESCAPE\n+        )\n+        self.value = \"\"\n         self.hook_set = False\n \n-    def get_show_string (self, pvalue):\n+    def get_show_string(self, pvalue):\n         if self.value:\n-           return \"The extended prompt is: \" + self.value\n+            return \"The extended prompt is: \" + self.value\n         else:\n-           return \"The extended prompt is not set.\"\n+            return \"The extended prompt is not set.\"\n \n-    def get_set_string (self):\n+    def get_set_string(self):\n         if self.hook_set == False:\n-           gdb.prompt_hook = self.before_prompt_hook\n-           self.hook_set = True\n+            gdb.prompt_hook = self.before_prompt_hook\n+            self.hook_set = True\n         return \"\"\n \n     def before_prompt_hook(self, current):\n@@ -62,4 +63,5 @@ def before_prompt_hook(self, current):\n         else:\n             return None\n \n+\n _ExtendedPrompt()"
    },
    {
      "sha": "560ec04e26b905f5f385c4d16079712e6132ee57",
      "filename": "gdb/python/lib/gdb/command/type_printers.py",
      "status": "modified",
      "additions": 22,
      "deletions": 19,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/type_printers.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/type_printers.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/type_printers.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,44 +19,44 @@\n \n \"\"\"GDB commands for working with type-printers.\"\"\"\n \n+\n class InfoTypePrinter(gdb.Command):\n     \"\"\"GDB command to list all registered type-printers.\n \n-Usage: info type-printers\"\"\"\n+    Usage: info type-printers\"\"\"\n \n-    def __init__ (self):\n-        super(InfoTypePrinter, self).__init__(\"info type-printers\",\n-                                              gdb.COMMAND_DATA)\n+    def __init__(self):\n+        super(InfoTypePrinter, self).__init__(\"info type-printers\", gdb.COMMAND_DATA)\n \n     def list_type_printers(self, type_printers):\n         \"\"\"Print a list of type printers.\"\"\"\n         # A potential enhancement is to provide an option to list printers in\n         # \"lookup order\" (i.e. unsorted).\n-        sorted_type_printers = sorted (copy.copy(type_printers),\n-                                       key = lambda x: x.name)\n+        sorted_type_printers = sorted(copy.copy(type_printers), key=lambda x: x.name)\n         for printer in sorted_type_printers:\n             if printer.enabled:\n-                enabled = ''\n+                enabled = \"\"\n             else:\n                 enabled = \" [disabled]\"\n-            print (\"  %s%s\" % (printer.name, enabled))\n+            print(\"  %s%s\" % (printer.name, enabled))\n \n     def invoke(self, arg, from_tty):\n         \"\"\"GDB calls this to perform the command.\"\"\"\n-        sep = ''\n+        sep = \"\"\n         for objfile in gdb.objfiles():\n             if objfile.type_printers:\n-                print (\"%sType printers for %s:\" % (sep, objfile.filename))\n+                print(\"%sType printers for %s:\" % (sep, objfile.filename))\n                 self.list_type_printers(objfile.type_printers)\n-                sep = '\\n'\n+                sep = \"\\n\"\n         if gdb.current_progspace().type_printers:\n-            print (\"%sType printers for program space:\" % sep)\n+            print(\"%sType printers for program space:\" % sep)\n             self.list_type_printers(gdb.current_progspace().type_printers)\n-            sep = '\\n'\n+            sep = \"\\n\"\n         if gdb.type_printers:\n-            print (\"%sGlobal type printers:\" % sep)\n+            print(\"%sGlobal type printers:\" % sep)\n             self.list_type_printers(gdb.type_printers)\n \n+\n class _EnableOrDisableCommand(gdb.Command):\n     def __init__(self, setting, name):\n         super(_EnableOrDisableCommand, self).__init__(name, gdb.COMMAND_DATA)\n@@ -82,7 +82,7 @@ def invoke(self, arg, from_tty):\n             if self.set_some(name, gdb.type_printers):\n                 ok = True\n             if not ok:\n-                print (\"No type printer named '%s'\" % name)\n+                print(\"No type printer named '%s'\" % name)\n \n     def add_some(self, result, word, printers):\n         for p in printers:\n@@ -97,26 +97,29 @@ def complete(self, text, word):\n         self.add_some(result, word, gdb.type_printers)\n         return result\n \n+\n class EnableTypePrinter(_EnableOrDisableCommand):\n     \"\"\"GDB command to enable the specified type printer.\n \n-Usage: enable type-printer NAME\n+    Usage: enable type-printer NAME\n \n-NAME is the name of the type-printer.\"\"\"\n+    NAME is the name of the type-printer.\"\"\"\n \n     def __init__(self):\n         super(EnableTypePrinter, self).__init__(True, \"enable type-printer\")\n \n+\n class DisableTypePrinter(_EnableOrDisableCommand):\n     \"\"\"GDB command to disable the specified type-printer.\n \n-Usage: disable type-printer NAME\n+    Usage: disable type-printer NAME\n \n-NAME is the name of the type-printer.\"\"\"\n+    NAME is the name of the type-printer.\"\"\"\n \n     def __init__(self):\n         super(DisableTypePrinter, self).__init__(False, \"disable type-printer\")\n \n+\n InfoTypePrinter()\n EnableTypePrinter()\n DisableTypePrinter()"
    },
    {
      "sha": "59ee67cc7b356b0b3a325a86da450e00fc3562cc",
      "filename": "gdb/python/lib/gdb/command/unwinders.py",
      "status": "modified",
      "additions": 49,
      "deletions": 45,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/unwinders.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/unwinders.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/unwinders.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -49,28 +49,29 @@ def parse_unwinder_command_args(arg):\n         locus_regexp = argv[0]\n         if argc >= 2:\n             name_regexp = argv[1]\n-    return (validate_regexp(locus_regexp, \"locus\"),\n-            validate_regexp(name_regexp, \"unwinder\"))\n+    return (\n+        validate_regexp(locus_regexp, \"locus\"),\n+        validate_regexp(name_regexp, \"unwinder\"),\n+    )\n \n \n class InfoUnwinder(gdb.Command):\n     \"\"\"GDB command to list unwinders.\n \n-Usage: info unwinder [LOCUS-REGEXP [NAME-REGEXP]]\n+    Usage: info unwinder [LOCUS-REGEXP [NAME-REGEXP]]\n \n-LOCUS-REGEXP is a regular expression matching the location of the\n-unwinder.  If it is omitted, all registered unwinders from all\n-loci are listed.  A locus can be 'global', 'progspace' to list\n-the unwinders from the current progspace, or a regular expression\n-matching filenames of objfiles.\n+    LOCUS-REGEXP is a regular expression matching the location of the\n+    unwinder.  If it is omitted, all registered unwinders from all\n+    loci are listed.  A locus can be 'global', 'progspace' to list\n+    the unwinders from the current progspace, or a regular expression\n+    matching filenames of objfiles.\n \n-NAME-REGEXP is a regular expression to filter unwinder names.  If\n-this omitted for a specified locus, then all registered unwinders\n-in the locus are listed.\"\"\"\n+    NAME-REGEXP is a regular expression to filter unwinder names.  If\n+    this omitted for a specified locus, then all registered unwinders\n+    in the locus are listed.\"\"\"\n \n     def __init__(self):\n-        super(InfoUnwinder, self).__init__(\"info unwinder\",\n-                                            gdb.COMMAND_STACK)\n+        super(InfoUnwinder, self).__init__(\"info unwinder\", gdb.COMMAND_STACK)\n \n     def list_unwinders(self, title, unwinders, name_re):\n         \"\"\"Lists the unwinders whose name matches regexp.\n@@ -85,22 +86,25 @@ def list_unwinders(self, title, unwinders, name_re):\n         print(title)\n         for unwinder in unwinders:\n             if name_re.match(unwinder.name):\n-                print(\"  %s%s\" % (unwinder.name,\n-                                  \"\" if unwinder.enabled else \" [disabled]\"))\n+                print(\n+                    \"  %s%s\"\n+                    % (unwinder.name, \"\" if unwinder.enabled else \" [disabled]\")\n+                )\n \n     def invoke(self, arg, from_tty):\n         locus_re, name_re = parse_unwinder_command_args(arg)\n         if locus_re.match(\"global\"):\n-            self.list_unwinders(\"Global:\", gdb.frame_unwinders,\n-                                name_re)\n+            self.list_unwinders(\"Global:\", gdb.frame_unwinders, name_re)\n         if locus_re.match(\"progspace\"):\n             cp = gdb.current_progspace()\n-            self.list_unwinders(\"Progspace %s:\" % cp.filename,\n-                                cp.frame_unwinders, name_re)\n+            self.list_unwinders(\n+                \"Progspace %s:\" % cp.filename, cp.frame_unwinders, name_re\n+            )\n         for objfile in gdb.objfiles():\n             if locus_re.match(objfile.filename):\n-                self.list_unwinders(\"Objfile %s:\" % objfile.filename,\n-                                    objfile.frame_unwinders, name_re)\n+                self.list_unwinders(\n+                    \"Objfile %s:\" % objfile.filename, objfile.frame_unwinders, name_re\n+                )\n \n \n def do_enable_unwinder1(unwinders, name_re, flag):\n@@ -129,34 +133,35 @@ def do_enable_unwinder(arg, flag):\n     if locus_re.match(\"global\"):\n         total += do_enable_unwinder1(gdb.frame_unwinders, name_re, flag)\n     if locus_re.match(\"progspace\"):\n-        total += do_enable_unwinder1(gdb.current_progspace().frame_unwinders,\n-                                     name_re, flag)\n+        total += do_enable_unwinder1(\n+            gdb.current_progspace().frame_unwinders, name_re, flag\n+        )\n     for objfile in gdb.objfiles():\n         if locus_re.match(objfile.filename):\n-            total += do_enable_unwinder1(objfile.frame_unwinders, name_re,\n-                                         flag)\n+            total += do_enable_unwinder1(objfile.frame_unwinders, name_re, flag)\n     if total > 0:\n         gdb.invalidate_cached_frames()\n-    print(\"%d unwinder%s %s\" % (total, \"\" if total == 1 else \"s\",\n-                                \"enabled\" if flag else \"disabled\"))\n+    print(\n+        \"%d unwinder%s %s\"\n+        % (total, \"\" if total == 1 else \"s\", \"enabled\" if flag else \"disabled\")\n+    )\n \n \n class EnableUnwinder(gdb.Command):\n     \"\"\"GDB command to enable unwinders.\n \n-Usage: enable unwinder [LOCUS-REGEXP [NAME-REGEXP]]\n+    Usage: enable unwinder [LOCUS-REGEXP [NAME-REGEXP]]\n \n-LOCUS-REGEXP is a regular expression specifying the unwinders to\n-enable.  It can 'global', 'progspace', or the name of an objfile\n-within that progspace.\n+    LOCUS-REGEXP is a regular expression specifying the unwinders to\n+    enable.  It can 'global', 'progspace', or the name of an objfile\n+    within that progspace.\n \n-NAME_REGEXP is a regular expression to filter unwinder names.  If\n-this omitted for a specified locus, then all registered unwinders\n-in the locus are affected.\"\"\"\n+    NAME_REGEXP is a regular expression to filter unwinder names.  If\n+    this omitted for a specified locus, then all registered unwinders\n+    in the locus are affected.\"\"\"\n \n     def __init__(self):\n-        super(EnableUnwinder, self).__init__(\"enable unwinder\",\n-                                             gdb.COMMAND_STACK)\n+        super(EnableUnwinder, self).__init__(\"enable unwinder\", gdb.COMMAND_STACK)\n \n     def invoke(self, arg, from_tty):\n         \"\"\"GDB calls this to perform the command.\"\"\"\n@@ -166,19 +171,18 @@ def invoke(self, arg, from_tty):\n class DisableUnwinder(gdb.Command):\n     \"\"\"GDB command to disable the specified unwinder.\n \n-Usage: disable unwinder [LOCUS-REGEXP [NAME-REGEXP]]\n+    Usage: disable unwinder [LOCUS-REGEXP [NAME-REGEXP]]\n \n-LOCUS-REGEXP is a regular expression specifying the unwinders to\n-disable.  It can 'global', 'progspace', or the name of an objfile\n-within that progspace.\n+    LOCUS-REGEXP is a regular expression specifying the unwinders to\n+    disable.  It can 'global', 'progspace', or the name of an objfile\n+    within that progspace.\n \n-NAME_REGEXP is a regular expression to filter unwinder names.  If\n-this omitted for a specified locus, then all registered unwinders\n-in the locus are affected.\"\"\"\n+    NAME_REGEXP is a regular expression to filter unwinder names.  If\n+    this omitted for a specified locus, then all registered unwinders\n+    in the locus are affected.\"\"\"\n \n     def __init__(self):\n-        super(DisableUnwinder, self).__init__(\"disable unwinder\",\n-                                              gdb.COMMAND_STACK)\n+        super(DisableUnwinder, self).__init__(\"disable unwinder\", gdb.COMMAND_STACK)\n \n     def invoke(self, arg, from_tty):\n         \"\"\"GDB calls this to perform the command.\"\"\""
    },
    {
      "sha": "cda234f9ce1be37df744396d46204002e007d054",
      "filename": "gdb/python/lib/gdb/command/xmethods.py",
      "status": "modified",
      "additions": 66,
      "deletions": 67,
      "changes": 133,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/xmethods.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/command/xmethods.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/command/xmethods.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -56,9 +56,11 @@ def parse_xm_command_args(arg):\n         name_re = validate_xm_regexp(\"xmethod name\", xm_name_regexp)\n     else:\n         name_re = None\n-    return (validate_xm_regexp(\"locus\", locus_regexp),\n-            validate_xm_regexp(\"matcher name\", matcher_name_regexp),\n-            name_re)\n+    return (\n+        validate_xm_regexp(\"locus\", locus_regexp),\n+        validate_xm_regexp(\"matcher name\", matcher_name_regexp),\n+        name_re,\n+    )\n \n \n def get_global_method_matchers(locus_re, matcher_re):\n@@ -75,10 +77,9 @@ def get_global_method_matchers(locus_re, matcher_re):\n         key in the dict will be 'global'.\n     \"\"\"\n     locus_str = \"global\"\n-    xm_dict = { locus_str: [] }\n+    xm_dict = {locus_str: []}\n     if locus_re.match(\"global\"):\n-        xm_dict[locus_str].extend(\n-            [m for m in gdb.xmethods if matcher_re.match(m.name)])\n+        xm_dict[locus_str].extend([m for m in gdb.xmethods if matcher_re.match(m.name)])\n     return xm_dict\n \n \n@@ -102,40 +103,40 @@ def get_method_matchers_in_loci(loci, locus_re, matcher_re):\n     xm_dict = {}\n     for locus in loci:\n         if isinstance(locus, gdb.Progspace):\n-            if not locus_re.match('progspace'):\n+            if not locus_re.match(\"progspace\"):\n                 continue\n             locus_type = \"progspace\"\n         else:\n             if not locus_re.match(locus.filename):\n                 continue\n             locus_type = \"objfile\"\n         locus_str = \"%s %s\" % (locus_type, locus.filename)\n-        xm_dict[locus_str] = [\n-            m for m in locus.xmethods if matcher_re.match(m.name)]\n+        xm_dict[locus_str] = [m for m in locus.xmethods if matcher_re.match(m.name)]\n     return xm_dict\n \n \n def print_xm_info(xm_dict, name_re):\n     \"\"\"Print a dictionary of xmethods.\"\"\"\n+\n     def get_status_string(m):\n         if not m.enabled:\n             return \" [disabled]\"\n         else:\n-          return \"\"\n+            return \"\"\n \n     if not xm_dict:\n         return\n     for locus_str in xm_dict:\n         if not xm_dict[locus_str]:\n             continue\n-        print (\"Xmethods in %s:\" % locus_str)\n+        print(\"Xmethods in %s:\" % locus_str)\n         for matcher in xm_dict[locus_str]:\n-            print (\"  %s%s\" % (matcher.name, get_status_string(matcher)))\n+            print(\"  %s%s\" % (matcher.name, get_status_string(matcher)))\n             if not matcher.methods:\n                 continue\n             for m in matcher.methods:\n                 if name_re is None or name_re.match(m.name):\n-                    print (\"    %s%s\" % (m.name, get_status_string(m)))\n+                    print(\"    %s%s\" % (m.name, get_status_string(m)))\n \n \n def set_xm_status1(xm_dict, name_re, status):\n@@ -161,75 +162,74 @@ def set_xm_status(arg, status):\n     argument string passed to the commands.\n     \"\"\"\n     locus_re, matcher_re, name_re = parse_xm_command_args(arg)\n-    set_xm_status1(get_global_method_matchers(locus_re, matcher_re), name_re,\n-                   status)\n+    set_xm_status1(get_global_method_matchers(locus_re, matcher_re), name_re, status)\n     set_xm_status1(\n-        get_method_matchers_in_loci(\n-            [gdb.current_progspace()], locus_re, matcher_re),\n+        get_method_matchers_in_loci([gdb.current_progspace()], locus_re, matcher_re),\n         name_re,\n-        status)\n+        status,\n+    )\n     set_xm_status1(\n         get_method_matchers_in_loci(gdb.objfiles(), locus_re, matcher_re),\n         name_re,\n-        status)\n+        status,\n+    )\n \n \n class InfoXMethod(gdb.Command):\n     \"\"\"GDB command to list registered xmethod matchers.\n \n-Usage: info xmethod [LOCUS-REGEXP [NAME-REGEXP]]\n+    Usage: info xmethod [LOCUS-REGEXP [NAME-REGEXP]]\n \n-LOCUS-REGEXP is a regular expression matching the location of the\n-xmethod matchers.  If it is omitted, all registered xmethod matchers\n-from all loci are listed.  A locus could be 'global', a regular expression\n-matching the current program space's filename, or a regular expression\n-matching filenames of objfiles.  Locus could be 'progspace' to specify that\n-only xmethods from the current progspace should be listed.\n+    LOCUS-REGEXP is a regular expression matching the location of the\n+    xmethod matchers.  If it is omitted, all registered xmethod matchers\n+    from all loci are listed.  A locus could be 'global', a regular expression\n+    matching the current program space's filename, or a regular expression\n+    matching filenames of objfiles.  Locus could be 'progspace' to specify that\n+    only xmethods from the current progspace should be listed.\n \n-NAME-REGEXP is a regular expression matching the names of xmethod\n-matchers.  If this omitted for a specified locus, then all registered\n-xmethods in the locus are listed.  To list only a certain xmethods\n-managed by a single matcher, the name regexp can be specified as\n-matcher-name-regexp;xmethod-name-regexp.\"\"\"\n+    NAME-REGEXP is a regular expression matching the names of xmethod\n+    matchers.  If this omitted for a specified locus, then all registered\n+    xmethods in the locus are listed.  To list only a certain xmethods\n+    managed by a single matcher, the name regexp can be specified as\n+    matcher-name-regexp;xmethod-name-regexp.\"\"\"\n \n     def __init__(self):\n-        super(InfoXMethod, self).__init__(\"info xmethod\",\n-                                          gdb.COMMAND_DATA)\n+        super(InfoXMethod, self).__init__(\"info xmethod\", gdb.COMMAND_DATA)\n \n     def invoke(self, arg, from_tty):\n         locus_re, matcher_re, name_re = parse_xm_command_args(arg)\n-        print_xm_info(get_global_method_matchers(locus_re, matcher_re),\n-                      name_re)\n+        print_xm_info(get_global_method_matchers(locus_re, matcher_re), name_re)\n         print_xm_info(\n             get_method_matchers_in_loci(\n-                [gdb.current_progspace()], locus_re, matcher_re),\n-            name_re)\n+                [gdb.current_progspace()], locus_re, matcher_re\n+            ),\n+            name_re,\n+        )\n         print_xm_info(\n-            get_method_matchers_in_loci(gdb.objfiles(), locus_re, matcher_re),\n-            name_re)\n+            get_method_matchers_in_loci(gdb.objfiles(), locus_re, matcher_re), name_re\n+        )\n \n \n class EnableXMethod(gdb.Command):\n     \"\"\"GDB command to enable a specified (group of) xmethod(s).\n \n-Usage: enable xmethod [LOCUS-REGEXP [NAME-REGEXP]]\n+    Usage: enable xmethod [LOCUS-REGEXP [NAME-REGEXP]]\n \n-LOCUS-REGEXP is a regular expression matching the location of the\n-xmethod matchers.  If it is omitted, all registered xmethods matchers\n-from all loci are enabled.  A locus could be 'global', a regular expression\n-matching the current program space's filename, or a regular expression\n-matching filenames of objfiles.  Locus could be 'progspace' to specify that\n-only xmethods from the current progspace should be enabled.\n+    LOCUS-REGEXP is a regular expression matching the location of the\n+    xmethod matchers.  If it is omitted, all registered xmethods matchers\n+    from all loci are enabled.  A locus could be 'global', a regular expression\n+    matching the current program space's filename, or a regular expression\n+    matching filenames of objfiles.  Locus could be 'progspace' to specify that\n+    only xmethods from the current progspace should be enabled.\n \n-NAME-REGEXP is a regular expression matching the names of xmethods\n-within a given locus.  If this omitted for a specified locus, then all\n-registered xmethod matchers in the locus are enabled.  To enable only\n-a certain xmethods managed by a single matcher, the name regexp can be\n-specified as matcher-name-regexp;xmethod-name-regexp.\"\"\"\n+    NAME-REGEXP is a regular expression matching the names of xmethods\n+    within a given locus.  If this omitted for a specified locus, then all\n+    registered xmethod matchers in the locus are enabled.  To enable only\n+    a certain xmethods managed by a single matcher, the name regexp can be\n+    specified as matcher-name-regexp;xmethod-name-regexp.\"\"\"\n \n     def __init__(self):\n-        super(EnableXMethod, self).__init__(\"enable xmethod\",\n-                                            gdb.COMMAND_DATA)\n+        super(EnableXMethod, self).__init__(\"enable xmethod\", gdb.COMMAND_DATA)\n \n     def invoke(self, arg, from_tty):\n         set_xm_status(arg, True)\n@@ -238,24 +238,23 @@ def invoke(self, arg, from_tty):\n class DisableXMethod(gdb.Command):\n     \"\"\"GDB command to disable a specified (group of) xmethod(s).\n \n-Usage: disable xmethod [LOCUS-REGEXP [NAME-REGEXP]]\n+    Usage: disable xmethod [LOCUS-REGEXP [NAME-REGEXP]]\n \n-LOCUS-REGEXP is a regular expression matching the location of the\n-xmethod matchers.  If it is omitted, all registered xmethod matchers\n-from all loci are disabled.  A locus could be 'global', a regular\n-expression matching the current program space's filename, or a regular\n-expression filenames of objfiles. Locus could be 'progspace' to specify\n-that only xmethods from the current progspace should be disabled.\n+    LOCUS-REGEXP is a regular expression matching the location of the\n+    xmethod matchers.  If it is omitted, all registered xmethod matchers\n+    from all loci are disabled.  A locus could be 'global', a regular\n+    expression matching the current program space's filename, or a regular\n+    expression filenames of objfiles. Locus could be 'progspace' to specify\n+    that only xmethods from the current progspace should be disabled.\n \n-NAME-REGEXP is a regular expression matching the names of xmethods\n-within a given locus.  If this omitted for a specified locus, then all\n-registered xmethod matchers in the locus are disabled.  To disable\n-only a certain xmethods managed by a single matcher, the name regexp\n-can be specified as matcher-name-regexp;xmethod-name-regexp.\"\"\"\n+    NAME-REGEXP is a regular expression matching the names of xmethods\n+    within a given locus.  If this omitted for a specified locus, then all\n+    registered xmethod matchers in the locus are disabled.  To disable\n+    only a certain xmethods managed by a single matcher, the name regexp\n+    can be specified as matcher-name-regexp;xmethod-name-regexp.\"\"\"\n \n     def __init__(self):\n-        super(DisableXMethod, self).__init__(\"disable xmethod\",\n-                                             gdb.COMMAND_DATA)\n+        super(DisableXMethod, self).__init__(\"disable xmethod\", gdb.COMMAND_DATA)\n \n     def invoke(self, arg, from_tty):\n         set_xm_status(arg, False)"
    },
    {
      "sha": "a9397a881fe0f03fb3bafa5c3a5feb3607e28eb2",
      "filename": "gdb/python/lib/gdb/frames.py",
      "status": "modified",
      "additions": 19,
      "deletions": 14,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/frames.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/frames.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/frames.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -22,8 +22,9 @@\n import itertools\n import collections\n \n+\n def get_priority(filter_item):\n-    \"\"\" Internal worker function to return the frame-filter's priority\n+    \"\"\"Internal worker function to return the frame-filter's priority\n     from a frame filter object.  This is a fail free function as it is\n     used in sorting and filtering.  If a badly implemented frame\n     filter does not implement the priority attribute, return zero\n@@ -42,8 +43,9 @@ def get_priority(filter_item):\n     # (incorrectly) set a priority, set it to zero.\n     return getattr(filter_item, \"priority\", 0)\n \n+\n def set_priority(filter_item, priority):\n-    \"\"\" Internal worker function to set the frame-filter's priority.\n+    \"\"\"Internal worker function to set the frame-filter's priority.\n \n     Arguments:\n         filter_item: An object conforming to the frame filter\n@@ -53,8 +55,9 @@ def set_priority(filter_item, priority):\n \n     filter_item.priority = priority\n \n+\n def get_enabled(filter_item):\n-    \"\"\" Internal worker function to return a filter's enabled state\n+    \"\"\"Internal worker function to return a filter's enabled state\n     from a frame filter object.  This is a fail free function as it is\n     used in sorting and filtering.  If a badly implemented frame\n     filter does not implement the enabled attribute, return False\n@@ -75,8 +78,9 @@ def get_enabled(filter_item):\n     # enabled to False.\n     return getattr(filter_item, \"enabled\", False)\n \n+\n def set_enabled(filter_item, state):\n-    \"\"\" Internal Worker function to set the frame-filter's enabled\n+    \"\"\"Internal Worker function to set the frame-filter's enabled\n     state.\n \n     Arguments:\n@@ -87,8 +91,9 @@ def set_enabled(filter_item, state):\n \n     filter_item.enabled = state\n \n+\n def return_list(name):\n-    \"\"\" Internal Worker function to return the frame filter\n+    \"\"\"Internal Worker function to return the frame filter\n     dictionary, depending on the name supplied as an argument.  If the\n     name is not \"all\", \"global\" or \"progspace\", it is assumed to name\n     an object-file.\n@@ -132,8 +137,9 @@ def return_list(name):\n     msg = \"Cannot find frame-filter dictionary for '\" + name + \"'\"\n     raise gdb.GdbError(msg)\n \n+\n def _sort_list():\n-    \"\"\" Internal Worker function to merge all known frame-filter\n+    \"\"\"Internal Worker function to merge all known frame-filter\n     lists, prune any filters with the state set to \"disabled\", and\n     sort the list on the frame-filter's \"priority\" attribute.\n \n@@ -143,16 +149,15 @@ def _sort_list():\n     \"\"\"\n \n     all_filters = return_list(\"all\")\n-    sorted_frame_filters = sorted(all_filters, key = get_priority,\n-                                  reverse = True)\n+    sorted_frame_filters = sorted(all_filters, key=get_priority, reverse=True)\n \n-    sorted_frame_filters = filter(get_enabled,\n-                                  sorted_frame_filters)\n+    sorted_frame_filters = filter(get_enabled, sorted_frame_filters)\n \n     return sorted_frame_filters\n \n+\n def execute_frame_filters(frame, frame_low, frame_high):\n-    \"\"\" Internal function called from GDB that will execute the chain\n+    \"\"\"Internal function called from GDB that will execute the chain\n     of frame filters.  Each filter is executed in priority order.\n     After the execution completes, slice the iterator to frame_low -\n     frame_high range.\n@@ -187,7 +192,7 @@ def execute_frame_filters(frame, frame_low, frame_high):\n     # Apply a basic frame decorator to all gdb.Frames.  This unifies\n     # the interface.  Python 3.x moved the itertools.imap\n     # functionality to map(), so check if it is available.\n-    if hasattr(itertools,\"imap\"):\n+    if hasattr(itertools, \"imap\"):\n         frame_iterator = itertools.imap(FrameDecorator, frame_iterator)\n     else:\n         frame_iterator = map(FrameDecorator, frame_iterator)\n@@ -207,7 +212,7 @@ def execute_frame_filters(frame, frame_low, frame_high):\n \n         for frame_item in frame_iterator:\n             if count >= slice_length:\n-                sliced.popleft();\n+                sliced.popleft()\n             count = count + 1\n             sliced.append(frame_item)\n \n@@ -221,7 +226,7 @@ def execute_frame_filters(frame, frame_low, frame_high):\n     else:\n         # As frames start from 0, add one to frame_high so islice\n         # correctly finds the end\n-        frame_high = frame_high + 1;\n+        frame_high = frame_high + 1\n \n     sliced = itertools.islice(frame_iterator, frame_low, frame_high)\n "
    },
    {
      "sha": "b0a996ee799314f56ee3e662aad8fe8056dd4df9",
      "filename": "gdb/python/lib/gdb/function/as_string.py",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/function/as_string.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/function/as_string.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/function/as_string.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,19 +19,20 @@\n class _AsString(gdb.Function):\n     \"\"\"Return the string representation of a value.\n \n-Usage: $_as_string (VALUE)\n+    Usage: $_as_string (VALUE)\n \n-Arguments:\n+    Arguments:\n \n-  VALUE: any value\n+      VALUE: any value\n \n-Returns:\n-  The string representation of the value.\"\"\"\n+    Returns:\n+      The string representation of the value.\"\"\"\n \n     def __init__(self):\n         super(_AsString, self).__init__(\"_as_string\")\n \n     def invoke(self, val):\n         return str(val)\n \n+\n _AsString()"
    },
    {
      "sha": "922e2f4b6aa4287b69611bb9fad632d6116e1441",
      "filename": "gdb/python/lib/gdb/function/caller_is.py",
      "status": "modified",
      "additions": 46,
      "deletions": 41,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/function/caller_is.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/function/caller_is.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/function/caller_is.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,27 +17,28 @@\n import gdb\n import re\n \n+\n class CallerIs(gdb.Function):\n     \"\"\"Check the calling function's name.\n \n-Usage: $_caller_is (NAME [, NUMBER-OF-FRAMES])\n+    Usage: $_caller_is (NAME [, NUMBER-OF-FRAMES])\n \n-Arguments:\n+    Arguments:\n \n-  NAME: The name of the function to search for.\n+      NAME: The name of the function to search for.\n \n-  NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n-    selected frame to compare with.  If the value is greater than the depth of\n-    the stack from that point then the result is False.\n-    The default is 1.\n+      NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n+        selected frame to compare with.  If the value is greater than the depth of\n+        the stack from that point then the result is False.\n+        The default is 1.\n \n-Returns:\n-  True if the function's name at the specified frame is equal to NAME.\"\"\"\n+    Returns:\n+      True if the function's name at the specified frame is equal to NAME.\"\"\"\n \n     def __init__(self):\n         super(CallerIs, self).__init__(\"_caller_is\")\n \n-    def invoke(self, name, nframes = 1):\n+    def invoke(self, name, nframes=1):\n         if nframes < 0:\n             raise ValueError(\"nframes must be >= 0\")\n         frame = gdb.selected_frame()\n@@ -48,27 +49,28 @@ def invoke(self, name, nframes = 1):\n             nframes = nframes - 1\n         return frame.name() == name.string()\n \n+\n class CallerMatches(gdb.Function):\n     \"\"\"Compare the calling function's name with a regexp.\n \n-Usage: $_caller_matches (REGEX [, NUMBER-OF-FRAMES])\n+    Usage: $_caller_matches (REGEX [, NUMBER-OF-FRAMES])\n \n-Arguments:\n+    Arguments:\n \n-  REGEX: The regular expression to compare the function's name with.\n+      REGEX: The regular expression to compare the function's name with.\n \n-  NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n-    selected frame to compare with.  If the value is greater than the depth of\n-    the stack from that point then the result is False.\n-    The default is 1.\n+      NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n+        selected frame to compare with.  If the value is greater than the depth of\n+        the stack from that point then the result is False.\n+        The default is 1.\n \n-Returns:\n-  True if the function's name at the specified frame matches REGEX.\"\"\"\n+    Returns:\n+      True if the function's name at the specified frame matches REGEX.\"\"\"\n \n     def __init__(self):\n         super(CallerMatches, self).__init__(\"_caller_matches\")\n \n-    def invoke(self, name, nframes = 1):\n+    def invoke(self, name, nframes=1):\n         if nframes < 0:\n             raise ValueError(\"nframes must be >= 0\")\n         frame = gdb.selected_frame()\n@@ -79,60 +81,62 @@ def invoke(self, name, nframes = 1):\n             nframes = nframes - 1\n         return re.match(name.string(), frame.name()) is not None\n \n+\n class AnyCallerIs(gdb.Function):\n     \"\"\"Check all calling function's names.\n \n-Usage: $_any_caller_is (NAME [, NUMBER-OF-FRAMES])\n+    Usage: $_any_caller_is (NAME [, NUMBER-OF-FRAMES])\n \n-Arguments:\n+    Arguments:\n \n-  NAME: The name of the function to search for.\n+      NAME: The name of the function to search for.\n \n-  NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n-    selected frame to compare with.  If the value is greater than the depth of\n-    the stack from that point then the result is False.\n-    The default is 1.\n+      NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n+        selected frame to compare with.  If the value is greater than the depth of\n+        the stack from that point then the result is False.\n+        The default is 1.\n \n-Returns:\n-  True if any function's name is equal to NAME.\"\"\"\n+    Returns:\n+      True if any function's name is equal to NAME.\"\"\"\n \n     def __init__(self):\n         super(AnyCallerIs, self).__init__(\"_any_caller_is\")\n \n-    def invoke(self, name, nframes = 1):\n+    def invoke(self, name, nframes=1):\n         if nframes < 0:\n             raise ValueError(\"nframes must be >= 0\")\n         frame = gdb.selected_frame()\n         while nframes >= 0:\n             if frame.name() == name.string():\n-                return True \n+                return True\n             frame = frame.older()\n             if frame is None:\n                 return False\n             nframes = nframes - 1\n         return False\n \n+\n class AnyCallerMatches(gdb.Function):\n     \"\"\"Compare all calling function's names with a regexp.\n \n-Usage: $_any_caller_matches (REGEX [, NUMBER-OF-FRAMES])\n+    Usage: $_any_caller_matches (REGEX [, NUMBER-OF-FRAMES])\n \n-Arguments:\n+    Arguments:\n \n-  REGEX: The regular expression to compare the function's name with.\n+      REGEX: The regular expression to compare the function's name with.\n \n-  NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n-    selected frame to compare with.  If the value is greater than the depth of\n-    the stack from that point then the result is False.\n-    The default is 1.\n+      NUMBER-OF-FRAMES: How many stack frames to traverse back from the currently\n+        selected frame to compare with.  If the value is greater than the depth of\n+        the stack from that point then the result is False.\n+        The default is 1.\n \n-Returns:\n-  True if any function's name matches REGEX.\"\"\"\n+    Returns:\n+      True if any function's name matches REGEX.\"\"\"\n \n     def __init__(self):\n         super(AnyCallerMatches, self).__init__(\"_any_caller_matches\")\n \n-    def invoke(self, name, nframes = 1):\n+    def invoke(self, name, nframes=1):\n         if nframes < 0:\n             raise ValueError(\"nframes must be >= 0\")\n         frame = gdb.selected_frame()\n@@ -146,6 +150,7 @@ def invoke(self, name, nframes = 1):\n             nframes = nframes - 1\n         return False\n \n+\n CallerIs()\n CallerMatches()\n AnyCallerIs()"
    },
    {
      "sha": "596f4d1bfc743cca90f5585d2f0297e3275fd4eb",
      "filename": "gdb/python/lib/gdb/function/strfns.py",
      "status": "modified",
      "additions": 52,
      "deletions": 48,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/function/strfns.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/function/strfns.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/function/strfns.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -21,76 +21,80 @@\n \n \n class _MemEq(gdb.Function):\n-  \"\"\"$_memeq - compare bytes of memory.\n+    \"\"\"$_memeq - compare bytes of memory.\n \n-Usage: $_memeq (A, B, LEN)\n+    Usage: $_memeq (A, B, LEN)\n \n-Returns:\n-  True if LEN bytes at A and B compare equally.\"\"\"\n-  def __init__(self):\n-    super(_MemEq, self).__init__(\"_memeq\")\n+    Returns:\n+      True if LEN bytes at A and B compare equally.\"\"\"\n \n-  def invoke(self, a, b, length):\n-    if length < 0:\n-      raise ValueError(\"length must be non-negative\")\n-    if length == 0:\n-      return True\n-    # The argument(s) to vector are [low_bound,]high_bound.\n-    byte_vector = gdb.lookup_type(\"char\").vector(length - 1)\n-    ptr_byte_vector = byte_vector.pointer()\n-    a_ptr = a.reinterpret_cast(ptr_byte_vector)\n-    b_ptr = b.reinterpret_cast(ptr_byte_vector)\n-    return a_ptr.dereference() == b_ptr.dereference()\n+    def __init__(self):\n+        super(_MemEq, self).__init__(\"_memeq\")\n+\n+    def invoke(self, a, b, length):\n+        if length < 0:\n+            raise ValueError(\"length must be non-negative\")\n+        if length == 0:\n+            return True\n+        # The argument(s) to vector are [low_bound,]high_bound.\n+        byte_vector = gdb.lookup_type(\"char\").vector(length - 1)\n+        ptr_byte_vector = byte_vector.pointer()\n+        a_ptr = a.reinterpret_cast(ptr_byte_vector)\n+        b_ptr = b.reinterpret_cast(ptr_byte_vector)\n+        return a_ptr.dereference() == b_ptr.dereference()\n \n \n class _StrLen(gdb.Function):\n-  \"\"\"$_strlen - compute string length.\n+    \"\"\"$_strlen - compute string length.\n+\n+    Usage: $_strlen (A)\n \n-Usage: $_strlen (A)\n+    Returns:\n+      Length of string A, assumed to be a string in the current language.\"\"\"\n \n-Returns:\n-  Length of string A, assumed to be a string in the current language.\"\"\"\n-  def __init__(self):\n-    super(_StrLen, self).__init__(\"_strlen\")\n+    def __init__(self):\n+        super(_StrLen, self).__init__(\"_strlen\")\n \n-  def invoke(self, a):\n-    s = a.string()\n-    return len(s)\n+    def invoke(self, a):\n+        s = a.string()\n+        return len(s)\n \n \n class _StrEq(gdb.Function):\n-  \"\"\"$_streq - check string equality.\n+    \"\"\"$_streq - check string equality.\n \n-Usage: $_streq (A, B)\n+    Usage: $_streq (A, B)\n \n-Returns:\n-  True if A and B are identical strings in the current language.\n+    Returns:\n+      True if A and B are identical strings in the current language.\n \n-Example (amd64-linux):\n-  catch syscall open\n-  cond $bpnum $_streq((char*) $rdi, \"foo\")\"\"\"\n-  def __init__(self):\n-    super(_StrEq, self).__init__(\"_streq\")\n+    Example (amd64-linux):\n+      catch syscall open\n+      cond $bpnum $_streq((char*) $rdi, \"foo\")\"\"\"\n \n-  def invoke(self, a, b):\n-    return a.string() == b.string()\n+    def __init__(self):\n+        super(_StrEq, self).__init__(\"_streq\")\n+\n+    def invoke(self, a, b):\n+        return a.string() == b.string()\n \n \n class _RegEx(gdb.Function):\n-  \"\"\"$_regex - check if a string matches a regular expression.\n+    \"\"\"$_regex - check if a string matches a regular expression.\n+\n+    Usage: $_regex (STRING, REGEX)\n \n-Usage: $_regex (STRING, REGEX)\n+    Returns:\n+      True if string STRING (in the current language) matches the\n+      regular expression REGEX.\"\"\"\n \n-Returns:\n-  True if string STRING (in the current language) matches the\n-  regular expression REGEX.\"\"\"\n-  def __init__(self):\n-    super(_RegEx, self).__init__(\"_regex\")\n+    def __init__(self):\n+        super(_RegEx, self).__init__(\"_regex\")\n \n-  def invoke(self, string, regex):\n-    s = string.string()\n-    r = re.compile(regex.string())\n-    return bool(r.match(s))\n+    def invoke(self, string, regex):\n+        s = string.string()\n+        r = re.compile(regex.string())\n+        return bool(r.match(s))\n \n \n # GDB will import us automagically via gdb/__init__.py."
    },
    {
      "sha": "f0d0a3eab2fe781b24c67dc97b391271dfec3020",
      "filename": "gdb/python/lib/gdb/printer/bound_registers.py",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/printer/bound_registers.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/printer/bound_registers.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/printer/bound_registers.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -23,21 +23,23 @@\n     basestring = str\n     long = int\n \n+\n class MpxBound128Printer:\n     \"\"\"Adds size field to a mpx __gdb_builtin_type_bound128 type.\"\"\"\n \n-    def __init__ (self, val):\n+    def __init__(self, val):\n         self.val = val\n \n-    def to_string (self):\n+    def to_string(self):\n         upper = self.val[\"ubound\"]\n         lower = self.val[\"lbound\"]\n-        size  = (long) ((upper) - (lower))\n+        size = (long)((upper) - (lower))\n         if size > -1:\n             size = size + 1\n-        result = '{lbound = %s, ubound = %s} : size %s' % (lower, upper, size)\n+        result = \"{lbound = %s, ubound = %s} : size %s\" % (lower, upper, size)\n         return result\n \n-gdb.printing.add_builtin_pretty_printer ('mpx_bound128',\n-                                         '^builtin_type_bound128',\n-                                         MpxBound128Printer)\n+\n+gdb.printing.add_builtin_pretty_printer(\n+    \"mpx_bound128\", \"^builtin_type_bound128\", MpxBound128Printer\n+)"
    },
    {
      "sha": "aaa0115224f1783f6722e7af5eaee9e04de76d88",
      "filename": "gdb/python/lib/gdb/printing.py",
      "status": "modified",
      "additions": 16,
      "deletions": 11,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/printing.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/printing.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/printing.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -26,6 +26,7 @@\n     basestring = str\n     long = int\n \n+\n class PrettyPrinter(object):\n     \"\"\"A basic pretty-printer.\n \n@@ -110,22 +111,23 @@ def register_pretty_printer(obj, printer, replace=False):\n     if not hasattr(printer, \"__name__\") and not hasattr(printer, \"name\"):\n         raise TypeError(\"printer missing attribute: name\")\n     if hasattr(printer, \"name\") and not hasattr(printer, \"enabled\"):\n-        raise TypeError(\"printer missing attribute: enabled\") \n+        raise TypeError(\"printer missing attribute: enabled\")\n     if not hasattr(printer, \"__call__\"):\n         raise TypeError(\"printer missing attribute: __call__\")\n \n     if hasattr(printer, \"name\"):\n-      name = printer.name\n+        name = printer.name\n     else:\n-      name = printer.__name__\n+        name = printer.__name__\n     if obj is None or obj is gdb:\n         if gdb.parameter(\"verbose\"):\n             gdb.write(\"Registering global %s pretty-printer ...\\n\" % name)\n         obj = gdb\n     else:\n         if gdb.parameter(\"verbose\"):\n-            gdb.write(\"Registering %s pretty-printer for %s ...\\n\" % (\n-                name, obj.filename))\n+            gdb.write(\n+                \"Registering %s pretty-printer for %s ...\\n\" % (name, obj.filename)\n+            )\n \n     # Printers implemented as functions are old-style.  In order to not risk\n     # breaking anything we do not check __name__ here.\n@@ -148,8 +150,9 @@ def register_pretty_printer(obj, printer, replace=False):\n                     del obj.pretty_printers[i]\n                     break\n                 else:\n-                  raise RuntimeError(\"pretty-printer already registered: %s\" %\n-                                     printer.name)\n+                    raise RuntimeError(\n+                        \"pretty-printer already registered: %s\" % printer.name\n+                    )\n             i = i + 1\n \n     obj.pretty_printers.insert(0, printer)\n@@ -197,8 +200,7 @@ def add_printer(self, name, regexp, gen_printer):\n         # cumbersome to make a regexp of a regexp).  So now the name is a\n         # separate parameter.\n \n-        self.subprinters.append(self.RegexpSubprinter(name, regexp,\n-                                                      gen_printer))\n+        self.subprinters.append(self.RegexpSubprinter(name, regexp, gen_printer))\n \n     def __call__(self, val):\n         \"\"\"Lookup the pretty-printer for the provided value.\"\"\"\n@@ -220,6 +222,7 @@ def __call__(self, val):\n         # Cannot find a pretty printer.  Return None.\n         return None\n \n+\n # A helper class for printing enum types.  This class is instantiated\n # with a list of enumerators to print a particular Value.\n class _EnumInstance:\n@@ -238,9 +241,10 @@ def to_string(self):\n                 any_found = True\n         if not any_found or v != 0:\n             # Leftover value.\n-            flag_list.append('<unknown: 0x%x>' % v)\n+            flag_list.append(\"<unknown: 0x%x>\" % v)\n         return \"0x%x [%s]\" % (int(self.val), \" | \".join(flag_list))\n \n+\n class FlagEnumerationPrinter(PrettyPrinter):\n     \"\"\"A pretty-printer which can be used to print a flag-style enumeration.\n     A flag-style enumeration is one where the enumerators are or'd\n@@ -263,7 +267,7 @@ def __call__(self, val):\n                 self.enumerators.append((field.name, field.enumval))\n             # Sorting the enumerators by value usually does the right\n             # thing.\n-            self.enumerators.sort(key = lambda x: x[1])\n+            self.enumerators.sort(key=lambda x: x[1])\n \n         if self.enabled:\n             return _EnumInstance(self.enumerators, val)\n@@ -281,5 +285,6 @@ def __call__(self, val):\n \n # Add a builtin pretty-printer.\n \n+\n def add_builtin_pretty_printer(name, regexp, printer):\n     _builtin_pretty_printers.add_printer(name, regexp, printer)"
    },
    {
      "sha": "9b6c322e61e0ded5e808b366af807359eae1e75e",
      "filename": "gdb/python/lib/gdb/prompt.py",
      "status": "modified",
      "additions": 45,
      "deletions": 30,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/prompt.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/prompt.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/prompt.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,102 +19,117 @@\n import gdb\n import os\n \n+\n def _prompt_pwd(ignore):\n     \"The current working directory.\"\n     return os.getcwd()\n \n+\n def _prompt_object_attr(func, what, attr, nattr):\n     \"\"\"Internal worker for fetching GDB attributes.\"\"\"\n     if attr is None:\n         attr = nattr\n     try:\n         obj = func()\n     except gdb.error:\n-        return '<no %s>' % what\n+        return \"<no %s>\" % what\n     if hasattr(obj, attr):\n         result = getattr(obj, attr)\n         if callable(result):\n             result = result()\n         return result\n     else:\n-        return '<no attribute %s on current %s>' % (attr, what)\n+        return \"<no attribute %s on current %s>\" % (attr, what)\n+\n \n def _prompt_frame(attr):\n     \"The selected frame; an argument names a frame parameter.\"\n-    return _prompt_object_attr(gdb.selected_frame, 'frame', attr, 'name')\n+    return _prompt_object_attr(gdb.selected_frame, \"frame\", attr, \"name\")\n+\n \n def _prompt_thread(attr):\n     \"The selected thread; an argument names a thread parameter.\"\n-    return _prompt_object_attr(gdb.selected_thread, 'thread', attr, 'num')\n+    return _prompt_object_attr(gdb.selected_thread, \"thread\", attr, \"num\")\n+\n \n def _prompt_version(attr):\n     \"The version of GDB.\"\n     return gdb.VERSION\n \n+\n def _prompt_esc(attr):\n     \"The ESC character.\"\n-    return '\\033'\n+    return \"\\033\"\n+\n \n def _prompt_bs(attr):\n     \"A backslash.\"\n-    return '\\\\'\n+    return \"\\\\\"\n+\n \n def _prompt_n(attr):\n     \"A newline.\"\n-    return '\\n'\n+    return \"\\n\"\n+\n \n def _prompt_r(attr):\n     \"A carriage return.\"\n-    return '\\r'\n+    return \"\\r\"\n+\n \n def _prompt_param(attr):\n     \"A parameter's value; the argument names the parameter.\"\n     return gdb.parameter(attr)\n \n+\n def _prompt_noprint_begin(attr):\n     \"Begins a sequence of non-printing characters.\"\n-    return '\\001'\n+    return \"\\001\"\n+\n \n def _prompt_noprint_end(attr):\n-     \"Ends a sequence of non-printing characters.\"\n-     return '\\002'\n+    \"Ends a sequence of non-printing characters.\"\n+    return \"\\002\"\n+\n \n prompt_substitutions = {\n-    'e': _prompt_esc,\n-    '\\\\': _prompt_bs,\n-    'n': _prompt_n,\n-    'r': _prompt_r,\n-    'v': _prompt_version,\n-    'w': _prompt_pwd,\n-    'f': _prompt_frame,\n-    't': _prompt_thread,\n-    'p': _prompt_param,\n-    '[': _prompt_noprint_begin,\n-    ']': _prompt_noprint_end\n+    \"e\": _prompt_esc,\n+    \"\\\\\": _prompt_bs,\n+    \"n\": _prompt_n,\n+    \"r\": _prompt_r,\n+    \"v\": _prompt_version,\n+    \"w\": _prompt_pwd,\n+    \"f\": _prompt_frame,\n+    \"t\": _prompt_thread,\n+    \"p\": _prompt_param,\n+    \"[\": _prompt_noprint_begin,\n+    \"]\": _prompt_noprint_end,\n }\n \n+\n def prompt_help():\n     \"\"\"Generate help dynamically from the __doc__ strings of attribute\n     functions.\"\"\"\n \n-    result = ''\n-    keys = sorted (prompt_substitutions.keys())\n+    result = \"\"\n+    keys = sorted(prompt_substitutions.keys())\n     for key in keys:\n-        result += '  \\\\%s\\t%s\\n' % (key, prompt_substitutions[key].__doc__)\n+        result += \"  \\\\%s\\t%s\\n\" % (key, prompt_substitutions[key].__doc__)\n     result += \"\"\"\n A substitution can be used in a simple form, like \"\\\\f\".\n An argument can also be passed to it, like \"\\\\f{name}\".\n The meaning of the argument depends on the particular substitution.\"\"\"\n     return result\n \n+\n def substitute_prompt(prompt):\n     \"Perform substitutions on PROMPT.\"\n \n-    result = ''\n+    result = \"\"\n     plen = len(prompt)\n     i = 0\n     while i < plen:\n-        if prompt[i] == '\\\\':\n+        if prompt[i] == \"\\\\\":\n             i = i + 1\n             if i >= plen:\n                 break\n@@ -123,12 +138,12 @@ def substitute_prompt(prompt):\n             if cmdch in prompt_substitutions:\n                 cmd = prompt_substitutions[cmdch]\n \n-                if i + 1 < plen and prompt[i + 1] == '{':\n+                if i + 1 < plen and prompt[i + 1] == \"{\":\n                     j = i + 1\n-                    while j < plen and prompt[j] != '}':\n+                    while j < plen and prompt[j] != \"}\":\n                         j = j + 1\n                     # Just ignore formatting errors.\n-                    if j >= plen or prompt[j] != '}':\n+                    if j >= plen or prompt[j] != \"}\":\n                         arg = None\n                     else:\n                         arg = prompt[i + 2 : j]"
    },
    {
      "sha": "c7de68adb4c7a75ca7852d6a95cbf1ba8bc13619",
      "filename": "gdb/python/lib/gdb/types.py",
      "status": "modified",
      "additions": 15,
      "deletions": 10,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/types.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/types.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/types.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -30,11 +30,12 @@ def get_basic_type(type_):\n         and typedefs/references converted to the underlying type.\n     \"\"\"\n \n-    while (type_.code == gdb.TYPE_CODE_REF or\n-           type_.code == gdb.TYPE_CODE_RVALUE_REF or\n-           type_.code == gdb.TYPE_CODE_TYPEDEF):\n-        if (type_.code == gdb.TYPE_CODE_REF or\n-            type_.code == gdb.TYPE_CODE_RVALUE_REF):\n+    while (\n+        type_.code == gdb.TYPE_CODE_REF\n+        or type_.code == gdb.TYPE_CODE_RVALUE_REF\n+        or type_.code == gdb.TYPE_CODE_TYPEDEF\n+    ):\n+        if type_.code == gdb.TYPE_CODE_REF or type_.code == gdb.TYPE_CODE_RVALUE_REF:\n             type_ = type_.target()\n         else:\n             type_ = type_.strip_typedefs()\n@@ -57,8 +58,7 @@ def has_field(type_, field):\n     \"\"\"\n \n     type_ = get_basic_type(type_)\n-    if (type_.code != gdb.TYPE_CODE_STRUCT and\n-        type_.code != gdb.TYPE_CODE_UNION):\n+    if type_.code != gdb.TYPE_CODE_STRUCT and type_.code != gdb.TYPE_CODE_UNION:\n         raise TypeError(\"not a struct or union\")\n     for f in type_.fields():\n         if f.is_base_class:\n@@ -93,7 +93,7 @@ def make_enum_dict(enum_type):\n     return enum_dict\n \n \n-def deep_items (type_):\n+def deep_items(type_):\n     \"\"\"Return an iterator that recursively traverses anonymous fields.\n \n     Arguments:\n@@ -105,13 +105,14 @@ def deep_items (type_):\n         pairs of key, value, but for any anonymous struct or union\n         field that field is traversed recursively, depth-first.\n     \"\"\"\n-    for k, v in type_.iteritems ():\n+    for k, v in type_.iteritems():\n         if k:\n             yield k, v\n         else:\n-            for i in deep_items (v.type):\n+            for i in deep_items(v.type):\n                 yield i\n \n+\n class TypePrinter(object):\n     \"\"\"The base class for type printers.\n \n@@ -134,6 +135,7 @@ def __init__(self, name):\n     def instantiate(self):\n         return None\n \n+\n # Helper function for computing the list of type recognizers.\n def _get_some_type_recognizers(result, plist):\n     for printer in plist:\n@@ -143,6 +145,7 @@ def _get_some_type_recognizers(result, plist):\n                 result.append(inst)\n     return None\n \n+\n def get_type_recognizers():\n     \"Return a list of the enabled type recognizers for the current context.\"\n     result = []\n@@ -157,6 +160,7 @@ def get_type_recognizers():\n \n     return result\n \n+\n def apply_type_recognizers(recognizers, type_obj):\n     \"\"\"Apply the given list of type recognizers to the type TYPE_OBJ.\n     If any recognizer in the list recognizes TYPE_OBJ, returns the name\n@@ -167,6 +171,7 @@ def apply_type_recognizers(recognizers, type_obj):\n             return result\n     return None\n \n+\n def register_type_printer(locus, printer):\n     \"\"\"Register a type printer.\n     PRINTER is the type printer instance."
    },
    {
      "sha": "ef2aa5bdf6c2eeb002fcdd3d34533f9cb440e477",
      "filename": "gdb/python/lib/gdb/unwinder.py",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/unwinder.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/unwinder.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/unwinder.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -77,8 +77,9 @@ def register_unwinder(locus, unwinder, replace=False):\n         locus = gdb\n     elif isinstance(locus, gdb.Objfile) or isinstance(locus, gdb.Progspace):\n         if gdb.parameter(\"verbose\"):\n-            gdb.write(\"Registering %s unwinder for %s ...\\n\" %\n-                      (unwinder.name, locus.filename))\n+            gdb.write(\n+                \"Registering %s unwinder for %s ...\\n\" % (unwinder.name, locus.filename)\n+            )\n     else:\n         raise TypeError(\"locus should be gdb.Objfile or gdb.Progspace or None\")\n \n@@ -88,8 +89,7 @@ def register_unwinder(locus, unwinder, replace=False):\n             if replace:\n                 del locus.frame_unwinders[i]\n             else:\n-                raise RuntimeError(\"Unwinder %s already exists.\" %\n-                                   unwinder.name)\n+                raise RuntimeError(\"Unwinder %s already exists.\" % unwinder.name)\n         i += 1\n     locus.frame_unwinders.insert(0, unwinder)\n     gdb.invalidate_cached_frames()"
    },
    {
      "sha": "44eb4dd88c1429188ff85916aeb080405f5fcedc",
      "filename": "gdb/python/lib/gdb/xmethod.py",
      "status": "modified",
      "additions": 15,
      "deletions": 10,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/xmethod.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/lib/gdb/xmethod.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/lib/gdb/xmethod.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -172,9 +172,9 @@ def get_arg_types(self):\n         def __call__(self, *args):\n             return self._method_function(*args)\n \n-\n-    def __init__(self, name, class_matcher, method_matcher, method_function,\n-                 *arg_types):\n+    def __init__(\n+        self, name, class_matcher, method_matcher, method_function, *arg_types\n+    ):\n         \"\"\"\n         Args:\n             name: Name of the xmethod matcher.\n@@ -195,7 +195,8 @@ class whose method this xmethod is implementing/replacing.\n         XMethodMatcher.__init__(self, name)\n         assert callable(method_function), (\n             \"The 'method_function' argument to 'SimpleXMethodMatcher' \"\n-            \"__init__ method should be a callable.\")\n+            \"__init__ method should be a callable.\"\n+        )\n         self._method_function = method_function\n         self._class_matcher = class_matcher\n         self._method_matcher = method_matcher\n@@ -206,13 +207,15 @@ def match(self, class_type, method_name):\n         mm = re.match(self._method_matcher, method_name)\n         if cm and mm:\n             return SimpleXMethodMatcher.SimpleXMethodWorker(\n-                self._method_function, self._arg_types)\n+                self._method_function, self._arg_types\n+            )\n \n \n # A helper function for register_xmethod_matcher which returns an error\n # object if MATCHER is not having the requisite attributes in the proper\n # format.\n \n+\n def _validate_xmethod_matcher(matcher):\n     if not hasattr(matcher, \"match\"):\n         return TypeError(\"Xmethod matcher is missing method: match\")\n@@ -221,17 +224,17 @@ def _validate_xmethod_matcher(matcher):\n     if not hasattr(matcher, \"enabled\"):\n         return TypeError(\"Xmethod matcher is missing attribute: enabled\")\n     if not isinstance(matcher.name, basestring):\n-        return TypeError(\"Attribute 'name' of xmethod matcher is not a \"\n-                         \"string\")\n+        return TypeError(\"Attribute 'name' of xmethod matcher is not a \" \"string\")\n     if matcher.name.find(\";\") >= 0:\n         return ValueError(\"Xmethod matcher name cannot contain ';' in it\")\n \n \n-# A helper function for register_xmethod_matcher which looks up an \n+# A helper function for register_xmethod_matcher which looks up an\n # xmethod matcher with NAME in LOCUS.  Returns the index of the xmethod\n # matcher in 'xmethods' sequence attribute of the LOCUS.  If NAME is not\n # found in LOCUS, then -1 is returned.\n \n+\n def _lookup_xmethod_matcher(locus, name):\n     for i in range(0, len(locus.xmethods)):\n         if locus.xmethods[i].name == name:\n@@ -268,8 +271,10 @@ def register_xmethod_matcher(locus, matcher, replace=False):\n         if replace:\n             del locus.xmethods[index]\n         else:\n-            raise RuntimeError(\"Xmethod matcher already registered with \"\n-                               \"%s: %s\" % (locus_name, matcher.name))\n+            raise RuntimeError(\n+                \"Xmethod matcher already registered with \"\n+                \"%s: %s\" % (locus_name, matcher.name)\n+            )\n     if gdb.parameter(\"verbose\"):\n         gdb.write(\"Registering xmethod matcher '%s' with %s' ...\\n\")\n     locus.xmethods.insert(0, matcher)"
    },
    {
      "sha": "027d80dcc86c85050ed2e00c6e1e28e31feba1ae",
      "filename": "gdb/python/python-config.py",
      "status": "modified",
      "additions": 44,
      "deletions": 39,
      "changes": 83,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/python-config.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/python/python-config.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python-config.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -6,31 +6,34 @@\n import getopt\n from distutils import sysconfig\n \n-valid_opts = ['prefix', 'exec-prefix', 'includes', 'libs', 'cflags',\n-              'ldflags', 'help']\n+valid_opts = [\"prefix\", \"exec-prefix\", \"includes\", \"libs\", \"cflags\", \"ldflags\", \"help\"]\n+\n \n def exit_with_usage(code=1):\n-    sys.stderr.write (\"Usage: %s [%s]\\n\" % (sys.argv[0],\n-                                          '|'.join('--'+opt for opt in valid_opts)))\n+    sys.stderr.write(\n+        \"Usage: %s [%s]\\n\" % (sys.argv[0], \"|\".join(\"--\" + opt for opt in valid_opts))\n+    )\n     sys.exit(code)\n \n+\n try:\n-    opts, args = getopt.getopt(sys.argv[1:], '', valid_opts)\n+    opts, args = getopt.getopt(sys.argv[1:], \"\", valid_opts)\n except getopt.error:\n     exit_with_usage()\n \n if not opts:\n     exit_with_usage()\n \n-pyver = sysconfig.get_config_var('VERSION')\n+pyver = sysconfig.get_config_var(\"VERSION\")\n getvar = sysconfig.get_config_var\n-abiflags = getattr (sys, \"abiflags\", \"\")\n+abiflags = getattr(sys, \"abiflags\", \"\")\n \n opt_flags = [flag for (flag, val) in opts]\n \n-if '--help' in opt_flags:\n+if \"--help\" in opt_flags:\n     exit_with_usage(code=0)\n \n+\n def to_unix_path(path):\n     \"\"\"On Windows, returns the given path with all backslashes\n     converted into forward slashes.  This is to help prevent problems\n@@ -39,39 +42,41 @@ def to_unix_path(path):\n \n     On Unix systems, returns the path unchanged.\n     \"\"\"\n-    if os.name == 'nt':\n-        path = path.replace('\\\\', '/')\n+    if os.name == \"nt\":\n+        path = path.replace(\"\\\\\", \"/\")\n     return path\n \n+\n for opt in opt_flags:\n-    if opt == '--prefix':\n-        print (to_unix_path(sysconfig.PREFIX))\n-\n-    elif opt == '--exec-prefix':\n-        print (to_unix_path(sysconfig.EXEC_PREFIX))\n-\n-    elif opt in ('--includes', '--cflags'):\n-        flags = ['-I' + sysconfig.get_python_inc(),\n-                 '-I' + sysconfig.get_python_inc(plat_specific=True)]\n-        if opt == '--cflags':\n-            flags.extend(getvar('CFLAGS').split())\n-        print (to_unix_path(' '.join(flags)))\n-\n-    elif opt in ('--libs', '--ldflags'):\n-        libs = ['-lpython' + pyver + abiflags]\n-        if getvar('LIBS') is not None:\n-            libs.extend(getvar('LIBS').split())\n-        if getvar('SYSLIBS') is not None:\n-            libs.extend(getvar('SYSLIBS').split())\n+    if opt == \"--prefix\":\n+        print(to_unix_path(sysconfig.PREFIX))\n+\n+    elif opt == \"--exec-prefix\":\n+        print(to_unix_path(sysconfig.EXEC_PREFIX))\n+\n+    elif opt in (\"--includes\", \"--cflags\"):\n+        flags = [\n+            \"-I\" + sysconfig.get_python_inc(),\n+            \"-I\" + sysconfig.get_python_inc(plat_specific=True),\n+        ]\n+        if opt == \"--cflags\":\n+            flags.extend(getvar(\"CFLAGS\").split())\n+        print(to_unix_path(\" \".join(flags)))\n+\n+    elif opt in (\"--libs\", \"--ldflags\"):\n+        libs = [\"-lpython\" + pyver + abiflags]\n+        if getvar(\"LIBS\") is not None:\n+            libs.extend(getvar(\"LIBS\").split())\n+        if getvar(\"SYSLIBS\") is not None:\n+            libs.extend(getvar(\"SYSLIBS\").split())\n         # add the prefix/lib/pythonX.Y/config dir, but only if there is no\n         # shared library in prefix/lib/.\n-        if opt == '--ldflags':\n-            if not getvar('Py_ENABLE_SHARED'):\n-                if getvar('LIBPL') is not None:\n-                    libs.insert(0, '-L' + getvar('LIBPL'))\n-                elif os.name == 'nt':\n-                    libs.insert(0, '-L' + sysconfig.PREFIX + '/libs')\n-            if getvar('LINKFORSHARED') is not None:\n-                libs.extend(getvar('LINKFORSHARED').split())\n-        print (to_unix_path(' '.join(libs)))\n-\n+        if opt == \"--ldflags\":\n+            if not getvar(\"Py_ENABLE_SHARED\"):\n+                if getvar(\"LIBPL\") is not None:\n+                    libs.insert(0, \"-L\" + getvar(\"LIBPL\"))\n+                elif os.name == \"nt\":\n+                    libs.insert(0, \"-L\" + sysconfig.PREFIX + \"/libs\")\n+            if getvar(\"LINKFORSHARED\") is not None:\n+                libs.extend(getvar(\"LINKFORSHARED\").split())\n+        print(to_unix_path(\" \".join(libs)))"
    },
    {
      "sha": "e9cd00bf085c41048f68b2815a6ed829dc165c6e",
      "filename": "gdb/syscalls/arm-linux.py",
      "status": "modified",
      "additions": 16,
      "deletions": 13,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/syscalls/arm-linux.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/syscalls/arm-linux.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/syscalls/arm-linux.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -12,7 +12,8 @@\n infname = sys.argv[1]\n inf = file(infname)\n \n-print(\"\"\"\\\n+print(\n+    \"\"\"\\\n <?xml version=\"1.0\"?>\n <!-- Copyright (C) 2009-%s Free Software Foundation, Inc.\n \n@@ -30,31 +31,33 @@\n      The file mentioned above belongs to the Linux Kernel.\n      Some small hand-edits were made. -->\n \n-<syscalls_info>\"\"\" % (time.strftime(\"%Y\"), infname))\n+<syscalls_info>\"\"\"\n+    % (time.strftime(\"%Y\"), infname)\n+)\n+\n \n def record(name, number, comment=None):\n-    #nm = 'name=\"%s\"' % name\n-    #s = '  <syscall %-30s number=\"%d\"/>' % (nm, number)\n+    # nm = 'name=\"%s\"' % name\n+    # s = '  <syscall %-30s number=\"%d\"/>' % (nm, number)\n     s = '  <syscall name=\"%s\" number=\"%d\"/>' % (name, number)\n     if comment:\n-        s += ' <!-- %s -->' % comment\n+        s += \" <!-- %s -->\" % comment\n     print(s)\n \n+\n for line in inf:\n-    m = re.match(r'^#define __NR_(\\w+)\\s+\\(__NR_SYSCALL_BASE\\+\\s*(\\d+)\\)',\n-                 line)\n+    m = re.match(r\"^#define __NR_(\\w+)\\s+\\(__NR_SYSCALL_BASE\\+\\s*(\\d+)\\)\", line)\n     if m:\n         record(m.group(1), int(m.group(2)))\n         continue\n \n-    m = re.match(r'^\\s+/\\* (\\d+) was sys_(\\w+) \\*/$', line)\n+    m = re.match(r\"^\\s+/\\* (\\d+) was sys_(\\w+) \\*/$\", line)\n     if m:\n-        record(m.group(2), int(m.group(1)), 'removed')\n+        record(m.group(2), int(m.group(1)), \"removed\")\n \n-    m = re.match(r'^#define __ARM_NR_(\\w+)\\s+\\(__ARM_NR_BASE\\+\\s*(\\d+)\\)',\n-                 line)\n+    m = re.match(r\"^#define __ARM_NR_(\\w+)\\s+\\(__ARM_NR_BASE\\+\\s*(\\d+)\\)\", line)\n     if m:\n-        record('ARM_'+m.group(1), 0x0f0000+int(m.group(2)))\n+        record(\"ARM_\" + m.group(1), 0x0F0000 + int(m.group(2)))\n         continue\n \n-print('</syscalls_info>')\n+print(\"</syscalls_info>\")"
    },
    {
      "sha": "486fa4e366f8f0ff3921609ecfe221240e3d1cb0",
      "filename": "gdb/system-gdbinit/elinos.py",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/system-gdbinit/elinos.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/system-gdbinit/elinos.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/system-gdbinit/elinos.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -79,9 +79,8 @@ def elinos_init():\n     if elinos_env[\"project\"] is None:\n         warn(\"Xenomai libraries may not be loaded\")\n     else:\n-        for dir in elinos_env['xenomai']:\n-            solib_dirs += [\"%s/%s\"\n-                           % (dir, \"xenomai-build/usr/realtime/lib\")]\n+        for dir in elinos_env[\"xenomai\"]:\n+            solib_dirs += [\"%s/%s\" % (dir, \"xenomai-build/usr/realtime/lib\")]\n \n     if len(solib_dirs) != 0:\n         gdb.execute(\"set solib-search-path %s\" % \":\".join(solib_dirs))"
    },
    {
      "sha": "87c435b52166f1e8d706ceae0572314b96de7e74",
      "filename": "gdb/system-gdbinit/wrs-linux.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/system-gdbinit/wrs-linux.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/system-gdbinit/wrs-linux.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/system-gdbinit/wrs-linux.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,8 +17,8 @@\n \n import os\n \n-if 'ENV_PREFIX' in os.environ:\n-    gdb.execute('set sysroot %s' % os.environ['ENV_PREFIX'])\n+if \"ENV_PREFIX\" in os.environ:\n+    gdb.execute(\"set sysroot %s\" % os.environ[\"ENV_PREFIX\"])\n \n else:\n     print \"warning: ENV_PREFIX environment variable missing.\""
    },
    {
      "sha": "3813c19ac5bf2b69aae415fefd42294d65f62839",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -1,3 +1,8 @@\n+2021-05-07  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* Re-format all Python files using black.\n+\t* gdb.python/py-prettyprint.exp (run_lang_tests): Adjust.\n+\n 2021-05-06  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.guile/scm-breakpoint.exp (test_watchpoints): Print the"
    },
    {
      "sha": "604a272831c126526a82a15564455823ad419f14",
      "filename": "gdb/testsuite/analyze-racy-logs.py",
      "status": "modified",
      "additions": 52,
      "deletions": 48,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/analyze-racy-logs.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/analyze-racy-logs.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/analyze-racy-logs.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -45,35 +45,36 @@\n #                                   }\n #                   }\n \n-files_and_tests = dict ()\n+files_and_tests = dict()\n \n # The relatioships between various states of the same tests that\n # should be ignored.  For example, if the same test PASSes on a\n # testcase run but KFAILs on another, this test should be considered\n # racy because a known-failure is...  known.\n \n-ignore_relations = { 'PASS' : 'KFAIL' }\n+ignore_relations = {\"PASS\": \"KFAIL\"}\n \n # We are interested in lines that start with '.?(PASS|FAIL)'.  In\n # other words, we don't process errors (maybe we should).\n \n-sum_matcher = re.compile('^(.?(PASS|FAIL)): (.*)$')\n+sum_matcher = re.compile(\"^(.?(PASS|FAIL)): (.*)$\")\n \n-def parse_sum_line (line, dic):\n+\n+def parse_sum_line(line, dic):\n     \"\"\"Parse a single LINE from a sumfile, and store the results in the\n-dictionary referenced by DIC.\"\"\"\n+    dictionary referenced by DIC.\"\"\"\n     global sum_matcher\n \n-    line = line.rstrip ()\n-    m = re.match (sum_matcher, line)\n+    line = line.rstrip()\n+    m = re.match(sum_matcher, line)\n     if m:\n-        result = m.group (1)\n-        test_name = m.group (3)\n+        result = m.group(1)\n+        test_name = m.group(3)\n         # Remove tail parentheses.  These are likely to be '(timeout)'\n         # and other extra information that will only confuse us.\n-        test_name = re.sub ('(\\s+)?\\(.*$', '', test_name)\n-        if result not in dic.keys ():\n-            dic[result] = set ()\n+        test_name = re.sub(\"(\\s+)?\\(.*$\", \"\", test_name)\n+        if result not in dic.keys():\n+            dic[result] = set()\n         if test_name in dic[result]:\n             # If the line is already present in the dictionary, then\n             # we include a unique identifier in the end of it, in the\n@@ -84,35 +85,37 @@ def parse_sum_line (line, dic):\n             # in order to identify the racy test.\n             i = 2\n             while True:\n-                nname = test_name + ' <<' + str (i) + '>>'\n+                nname = test_name + \" <<\" + str(i) + \">>\"\n                 if nname not in dic[result]:\n                     break\n                 i += 1\n             test_name = nname\n-        dic[result].add (test_name)\n+        dic[result].add(test_name)\n+\n \n-def read_sum_files (files):\n+def read_sum_files(files):\n     \"\"\"Read the sumfiles (passed as a list in the FILES variable), and\n-process each one, filling the FILES_AND_TESTS global dictionary with\n-information about them. \"\"\"\n+    process each one, filling the FILES_AND_TESTS global dictionary with\n+    information about them.\"\"\"\n     global files_and_tests\n \n     for x in files:\n-        with open (x, 'r') as f:\n-            files_and_tests[x] = dict ()\n-            for line in f.readlines ():\n-                parse_sum_line (line, files_and_tests[x])\n+        with open(x, \"r\") as f:\n+            files_and_tests[x] = dict()\n+            for line in f.readlines():\n+                parse_sum_line(line, files_and_tests[x])\n \n-def identify_racy_tests ():\n+\n+def identify_racy_tests():\n     \"\"\"Identify and print the racy tests.  This function basically works\n-on sets, and the idea behind it is simple.  It takes all the sets that\n-refer to the same result (for example, all the sets that contain PASS\n-tests), and compare them.  If a test is present in all PASS sets, then\n-it is not racy.  Otherwise, it is.\n-\n-This function does that for all sets (PASS, FAIL, KPASS, KFAIL, etc.),\n-and then print a sorted list (without duplicates) of all the tests\n-that were found to be racy.\"\"\"\n+    on sets, and the idea behind it is simple.  It takes all the sets that\n+    refer to the same result (for example, all the sets that contain PASS\n+    tests), and compare them.  If a test is present in all PASS sets, then\n+    it is not racy.  Otherwise, it is.\n+\n+    This function does that for all sets (PASS, FAIL, KPASS, KFAIL, etc.),\n+    and then print a sorted list (without duplicates) of all the tests\n+    that were found to be racy.\"\"\"\n     global files_and_tests\n \n     # First, construct two dictionaries that will hold one set of\n@@ -124,31 +127,31 @@ def identify_racy_tests ():\n     #\n     # Each set in ALL_TESTS will contain all tests, racy or not, for\n     # that state.\n-    nonracy_tests = dict ()\n-    all_tests = dict ()\n+    nonracy_tests = dict()\n+    all_tests = dict()\n     for f in files_and_tests:\n         for state in files_and_tests[f]:\n             try:\n-                nonracy_tests[state] &= files_and_tests[f][state].copy ()\n+                nonracy_tests[state] &= files_and_tests[f][state].copy()\n             except KeyError:\n-                nonracy_tests[state] = files_and_tests[f][state].copy ()\n+                nonracy_tests[state] = files_and_tests[f][state].copy()\n \n             try:\n-                all_tests[state] |= files_and_tests[f][state].copy ()\n+                all_tests[state] |= files_and_tests[f][state].copy()\n             except KeyError:\n-                all_tests[state] = files_and_tests[f][state].copy ()\n+                all_tests[state] = files_and_tests[f][state].copy()\n \n     # Now, we eliminate the tests that are present in states that need\n     # to be ignored.  For example, tests both in the PASS and KFAIL\n     # states should not be considered racy.\n-    ignored_tests = set ()\n-    for s1, s2 in ignore_relations.iteritems ():\n+    ignored_tests = set()\n+    for s1, s2 in ignore_relations.iteritems():\n         try:\n-            ignored_tests |= (all_tests[s1] & all_tests[s2])\n+            ignored_tests |= all_tests[s1] & all_tests[s2]\n         except:\n             continue\n \n-    racy_tests = set ()\n+    racy_tests = set()\n     for f in files_and_tests:\n         for state in files_and_tests[f]:\n             racy_tests |= files_and_tests[f][state] - nonracy_tests[state]\n@@ -159,19 +162,20 @@ def identify_racy_tests ():\n     print \"\\t\\t=== gdb racy tests ===\\n\"\n \n     # Print each test.\n-    for line in sorted (racy_tests):\n+    for line in sorted(racy_tests):\n         print line\n \n     # Print the summary.\n     print \"\\n\"\n     print \"\\t\\t=== gdb Summary ===\\n\"\n-    print \"# of racy tests:\\t\\t%d\" % len (racy_tests)\n+    print \"# of racy tests:\\t\\t%d\" % len(racy_tests)\n+\n \n-if __name__ == '__main__':\n-    if len (sys.argv) < 3:\n+if __name__ == \"__main__\":\n+    if len(sys.argv) < 3:\n         # It only makes sense to invoke this program if you pass two\n         # or more files to be analyzed.\n-        sys.exit (\"Usage: %s [FILE] [FILE] ...\" % sys.argv[0])\n-    read_sum_files (sys.argv[1:])\n-    identify_racy_tests ()\n-    exit (0)\n+        sys.exit(\"Usage: %s [FILE] [FILE] ...\" % sys.argv[0])\n+    read_sum_files(sys.argv[1:])\n+    identify_racy_tests()\n+    exit(0)"
    },
    {
      "sha": "477a663b6681cb52f9fda9519d24b58b91b138f2",
      "filename": "gdb/testsuite/gdb.ada/pp-rec-component.py",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.ada/pp-rec-component.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.ada/pp-rec-component.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/pp-rec-component.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -22,7 +22,7 @@ def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        secs = int(self.val['secs'])\n+        secs = int(self.val[\"secs\"])\n         return \"%s (%d)\" % (asctime(gmtime(secs)), secs)\n \n "
    },
    {
      "sha": "3f7aa69b67ff2c4aacb64a9f918722a065ae4506",
      "filename": "gdb/testsuite/gdb.perf/backtrace.py",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/backtrace.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/backtrace.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/backtrace.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,21 +15,22 @@\n \n from perftest import perftest\n \n-class BackTrace (perftest.TestCaseWithBasicMeasurements):\n+\n+class BackTrace(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, depth):\n-        super (BackTrace, self).__init__ (\"backtrace\")\n+        super(BackTrace, self).__init__(\"backtrace\")\n         self.depth = depth\n \n     def warm_up(self):\n         # Warm up.\n-        gdb.execute (\"bt\", False, True)\n-        gdb.execute (\"bt\", False, True)\n+        gdb.execute(\"bt\", False, True)\n+        gdb.execute(\"bt\", False, True)\n \n     def _do_test(self):\n         \"\"\"Do backtrace multiple times.\"\"\"\n         do_test_command = \"bt %d\" % self.depth\n         for _ in range(1, 15):\n-            gdb.execute (do_test_command, False, True)\n+            gdb.execute(do_test_command, False, True)\n \n     def execute_test(self):\n \n@@ -40,8 +41,8 @@ def execute_test(self):\n             line_size_command = \"set dcache line-size %d\" % (line_size)\n             size_command = \"set dcache size %d\" % (4096 * 64 / line_size)\n             # Cache is cleared by changing line-size or size.\n-            gdb.execute (line_size_command)\n-            gdb.execute (size_command)\n+            gdb.execute(line_size_command)\n+            gdb.execute(size_command)\n \n             func = lambda: self._do_test()\n "
    },
    {
      "sha": "89634912fbae8c827c68429a0dbf1e15986e91b9",
      "filename": "gdb/testsuite/gdb.perf/disassemble.py",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/disassemble.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/disassemble.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/disassemble.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,24 +15,28 @@\n \n from perftest import perftest\n \n+\n class Disassemble(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self):\n-        super (Disassemble, self).__init__ (\"disassemble\")\n+        super(Disassemble, self).__init__(\"disassemble\")\n \n     def warm_up(self):\n         do_test_command = \"disassemble ada_evaluate_subexp\"\n-        gdb.execute (do_test_command, False, True)\n+        gdb.execute(do_test_command, False, True)\n \n     def _do_test(self, c):\n-        for func in [\"evaluate_subexp_standard\", \"handle_inferior_event\", \"c_parse_internal\"]:\n+        for func in [\n+            \"evaluate_subexp_standard\",\n+            \"handle_inferior_event\",\n+            \"c_parse_internal\",\n+        ]:\n             do_test_command = \"disassemble %s\" % func\n-            for _ in range(c+1):\n-                gdb.execute (do_test_command, False, True)\n+            for _ in range(c + 1):\n+                gdb.execute(do_test_command, False, True)\n \n     def execute_test(self):\n         for i in range(3):\n             # Flush code cache.\n-            gdb.execute(\"set code-cache off\");\n-            gdb.execute(\"set code-cache on\");\n+            gdb.execute(\"set code-cache off\")\n+            gdb.execute(\"set code-cache on\")\n             self.measure.measure(lambda: self._do_test(i), i)\n-"
    },
    {
      "sha": "35fefe28f2eaa33f0ec2f6efb14d61ce9df21d01",
      "filename": "gdb/testsuite/gdb.perf/gmonster-null-lookup.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-null-lookup.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-null-lookup.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/gmonster-null-lookup.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -21,6 +21,7 @@\n from perftest import measure\n from perftest import utils\n \n+\n class NullLookup(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, run_names, binfile):\n         # We want to measure time in this test.\n@@ -33,8 +34,7 @@ def warm_up(self):\n \n     def execute_test(self):\n         for run in self.run_names:\n-            this_run_binfile = \"%s-%s\" % (self.binfile,\n-                                          utils.convert_spaces(run))\n+            this_run_binfile = \"%s-%s\" % (self.binfile, utils.convert_spaces(run))\n             utils.select_file(this_run_binfile)\n             utils.runto_main()\n             utils.safe_execute(\"mt expand-symtabs\")"
    },
    {
      "sha": "6b869ec04456bde6c5c949d246eac40f444ff002",
      "filename": "gdb/testsuite/gdb.perf/gmonster-pervasive-typedef.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-pervasive-typedef.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-pervasive-typedef.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/gmonster-pervasive-typedef.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -21,6 +21,7 @@\n from perftest import measure\n from perftest import utils\n \n+\n class PervasiveTypedef(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, run_names, binfile):\n         # We want to measure time in this test.\n@@ -37,8 +38,7 @@ def func(self):\n \n     def execute_test(self):\n         for run in self.run_names:\n-            self.this_run_binfile = \"%s-%s\" % (self.binfile,\n-                                               utils.convert_spaces(run))\n+            self.this_run_binfile = \"%s-%s\" % (self.binfile, utils.convert_spaces(run))\n             iteration = 5\n             while iteration > 0:\n                 self.measure.measure(self.func, run)"
    },
    {
      "sha": "4047b3908a57e5f42155884b0ba8e05168bc7a7b",
      "filename": "gdb/testsuite/gdb.perf/gmonster-print-cerr.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-print-cerr.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-print-cerr.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/gmonster-print-cerr.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -29,6 +29,7 @@\n from perftest import measure\n from perftest import utils\n \n+\n class PrintCerr(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, run_names, binfile):\n         super(PrintCerr, self).__init__(name)\n@@ -40,8 +41,7 @@ def warm_up(self):\n \n     def execute_test(self):\n         for run in self.run_names:\n-            this_run_binfile = \"%s-%s\" % (self.binfile,\n-                                          utils.convert_spaces(run))\n+            this_run_binfile = \"%s-%s\" % (self.binfile, utils.convert_spaces(run))\n             utils.select_file(this_run_binfile)\n             utils.runto_main()\n             iteration = 5"
    },
    {
      "sha": "e92da44620a6898a7d44007c510467f62a76f11f",
      "filename": "gdb/testsuite/gdb.perf/gmonster-ptype-string.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-ptype-string.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-ptype-string.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/gmonster-ptype-string.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -23,6 +23,7 @@\n from perftest import measure\n from perftest import utils\n \n+\n class GmonsterPtypeString(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, run_names, binfile):\n         super(GmonsterPtypeString, self).__init__(name)\n@@ -34,8 +35,7 @@ def warm_up(self):\n \n     def execute_test(self):\n         for run in self.run_names:\n-            this_run_binfile = \"%s-%s\" % (self.binfile,\n-                                          utils.convert_spaces(run))\n+            this_run_binfile = \"%s-%s\" % (self.binfile, utils.convert_spaces(run))\n             utils.select_file(this_run_binfile)\n             utils.runto_main()\n             utils.safe_execute(\"mt expand-symtabs\")"
    },
    {
      "sha": "d56482f0cb79612a93020a89ec403fc0de652d41",
      "filename": "gdb/testsuite/gdb.perf/gmonster-runto-main.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-runto-main.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-runto-main.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/gmonster-runto-main.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,6 +19,7 @@\n from perftest import measure\n from perftest import utils\n \n+\n class GmonsterRuntoMain(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, run_names, binfile):\n         super(GmonsterRuntoMain, self).__init__(name)\n@@ -30,8 +31,7 @@ def warm_up(self):\n \n     def execute_test(self):\n         for run in self.run_names:\n-            this_run_binfile = \"%s-%s\" % (self.binfile,\n-                                          utils.convert_spaces(run))\n+            this_run_binfile = \"%s-%s\" % (self.binfile, utils.convert_spaces(run))\n             utils.select_file(this_run_binfile)\n             iteration = 5\n             while iteration > 0:"
    },
    {
      "sha": "53f5ab710f67227ede1df6f8b1f006c618a5e166",
      "filename": "gdb/testsuite/gdb.perf/gmonster-select-file.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-select-file.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/gmonster-select-file.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/gmonster-select-file.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,6 +19,7 @@\n from perftest import measure\n from perftest import utils\n \n+\n class GmonsterSelectFile(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, run_names, binfile):\n         super(GmonsterSelectFile, self).__init__(name)\n@@ -34,8 +35,7 @@ def _doit(self, binfile):\n \n     def execute_test(self):\n         for run in self.run_names:\n-            this_run_binfile = \"%s-%s\" % (self.binfile,\n-                                          utils.convert_spaces(run))\n+            this_run_binfile = \"%s-%s\" % (self.binfile, utils.convert_spaces(run))\n             iteration = 5\n             while iteration > 0:\n                 func = lambda: self._doit(this_run_binfile)"
    },
    {
      "sha": "2a20c5eafb290df40b972db1ff0ea1312d2561c5",
      "filename": "gdb/testsuite/gdb.perf/lib/perftest/measure.py",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/measure.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/measure.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/lib/perftest/measure.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,6 +17,7 @@\n import os\n import gc\n \n+\n class Measure(object):\n     \"\"\"A class that measure and collect the interesting data for a given testcase.\n \n@@ -55,6 +56,7 @@ def report(self, reporter, name):\n         for m in self.measurements:\n             m.report(reporter, name)\n \n+\n class Measurement(object):\n     \"\"\"A measurement for a certain aspect.\"\"\"\n \n@@ -63,7 +65,7 @@ def __init__(self, name, result):\n \n         Attribute result is the TestResult associated with measurement.\n         \"\"\"\n-        self.name = name;\n+        self.name = name\n         self.result = result\n \n     def start(self, id):\n@@ -82,8 +84,10 @@ def report(self, reporter, name):\n         \"\"\"Report the measured data by argument reporter.\"\"\"\n         self.result.report(reporter, name + \" \" + self.name)\n \n+\n class MeasurementCpuTime(Measurement):\n     \"\"\"Measurement on CPU time.\"\"\"\n+\n     # On UNIX, time.clock() measures the amount of CPU time that has\n     # been used by the current process.  On Windows it will measure\n     # wall-clock seconds elapsed since the first call to the function.\n@@ -98,11 +102,12 @@ def start(self, id):\n         self.start_time = time.clock()\n \n     def stop(self, id):\n-        if os.name == 'nt':\n+        if os.name == \"nt\":\n             cpu_time = 0\n         else:\n             cpu_time = time.clock() - self.start_time\n-        self.result.record (id, cpu_time)\n+        self.result.record(id, cpu_time)\n+\n \n class MeasurementWallTime(Measurement):\n     \"\"\"Measurement on Wall time.\"\"\"\n@@ -116,7 +121,8 @@ def start(self, id):\n \n     def stop(self, id):\n         wall_time = time.time() - self.start_time\n-        self.result.record (id, wall_time)\n+        self.result.record(id, wall_time)\n+\n \n class MeasurementVmSize(Measurement):\n     \"\"\"Measurement on memory usage represented by VmSize.\"\"\"\n@@ -143,4 +149,4 @@ def start(self, id):\n \n     def stop(self, id):\n         memory_used = self._compute_process_memory_usage(\"VmSize:\")\n-        self.result.record (id, memory_used)\n+        self.result.record(id, memory_used)"
    },
    {
      "sha": "07266413fb09a76d1eca47b38aec0730de5c92e1",
      "filename": "gdb/testsuite/gdb.perf/lib/perftest/perftest.py",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/perftest.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/perftest.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/lib/perftest/perftest.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -65,12 +65,15 @@ def run(self, warm_up=True, append=True):\n         self.execute_test()\n         self.measure.report(reporter.TextReporter(append), self.name)\n \n+\n class TestCaseWithBasicMeasurements(TestCase):\n     \"\"\"Test case measuring CPU time, wall time and memory usage.\"\"\"\n \n     def __init__(self, name):\n         result_factory = testresult.SingleStatisticResultFactory()\n-        measurements = [MeasurementCpuTime(result_factory.create_result()),\n-                        MeasurementWallTime(result_factory.create_result()),\n-                        MeasurementVmSize(result_factory.create_result())]\n-        super (TestCaseWithBasicMeasurements, self).__init__ (name, Measure(measurements))\n+        measurements = [\n+            MeasurementCpuTime(result_factory.create_result()),\n+            MeasurementWallTime(result_factory.create_result()),\n+            MeasurementVmSize(result_factory.create_result()),\n+        ]\n+        super(TestCaseWithBasicMeasurements, self).__init__(name, Measure(measurements))"
    },
    {
      "sha": "5569ece6c1390f89fcc3a8674c0475f1dc6ca091",
      "filename": "gdb/testsuite/gdb.perf/lib/perftest/reporter.py",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/reporter.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/reporter.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/lib/perftest/reporter.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -57,29 +57,30 @@ class TextReporter(Reporter):\n     \"\"\"Report results in a plain text file 'perftest.log'.\"\"\"\n \n     def __init__(self, append):\n-        super (TextReporter, self).__init__(Reporter(append))\n+        super(TextReporter, self).__init__(Reporter(append))\n         self.txt_sum = None\n         self.txt_log = None\n \n     def report(self, test_name, measurement_name, data_points):\n         if len(data_points) == 0:\n-            self.txt_sum.write(\"%s %s *no data recorded*\\n\" % (\n-                test_name, measurement_name))\n+            self.txt_sum.write(\n+                \"%s %s *no data recorded*\\n\" % (test_name, measurement_name)\n+            )\n             return\n         average = sum(data_points) / len(data_points)\n         data_min = min(data_points)\n         data_max = max(data_points)\n-        self.txt_sum.write(\"%s %s %s\\n\" % (\n-            test_name, measurement_name, average))\n-        self.txt_log.write(\"%s %s %s, min %s, max %s, data %s\\n\" % (\n-            test_name, measurement_name, average, data_min, data_max,\n-            data_points))\n+        self.txt_sum.write(\"%s %s %s\\n\" % (test_name, measurement_name, average))\n+        self.txt_log.write(\n+            \"%s %s %s, min %s, max %s, data %s\\n\"\n+            % (test_name, measurement_name, average, data_min, data_max, data_points)\n+        )\n \n     def start(self):\n         mode = \"a+\" if self.append else \"w\"\n-        self.txt_sum = open (SUM_FILE_NAME, mode);\n-        self.txt_log = open (LOG_FILE_NAME, mode);\n+        self.txt_sum = open(SUM_FILE_NAME, mode)\n+        self.txt_log = open(LOG_FILE_NAME, mode)\n \n     def end(self):\n-        self.txt_sum.close ()\n-        self.txt_log.close ()\n+        self.txt_sum.close()\n+        self.txt_log.close()"
    },
    {
      "sha": "fab9b68bfda1a1563680c55d25fb49c53863d8e0",
      "filename": "gdb/testsuite/gdb.perf/lib/perftest/testresult.py",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/testresult.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/testresult.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/lib/perftest/testresult.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -13,6 +13,7 @@\n # You should have received a copy of the GNU General Public License\n # along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n+\n class TestResult(object):\n     \"\"\"Base class to record and report test results.\n \n@@ -27,12 +28,13 @@ def report(self, reporter, name):\n         \"\"\"Report the test results by reporter.\"\"\"\n         raise NotImplementedError(\"Abstract Method:report.\")\n \n+\n class SingleStatisticTestResult(TestResult):\n     \"\"\"Test results for the test case with a single statistic.\"\"\"\n \n     def __init__(self):\n-        super (SingleStatisticTestResult, self).__init__ ()\n-        self.results = dict ()\n+        super(SingleStatisticTestResult, self).__init__()\n+        self.results = dict()\n \n     def record(self, parameter, result):\n         if parameter in self.results:\n@@ -46,13 +48,15 @@ def report(self, reporter, name):\n             reporter.report(name, key, self.results[key])\n         reporter.end()\n \n+\n class ResultFactory(object):\n     \"\"\"A factory to create an instance of TestResult.\"\"\"\n \n     def create_result(self):\n         \"\"\"Create an instance of TestResult.\"\"\"\n         raise NotImplementedError(\"Abstract Method:create_result.\")\n \n+\n class SingleStatisticResultFactory(ResultFactory):\n     \"\"\"A factory to create an instance of SingleStatisticTestResult.\"\"\"\n "
    },
    {
      "sha": "fe5ae93895ef5b1e0fe7e7902ea912c9b09aa272",
      "filename": "gdb/testsuite/gdb.perf/lib/perftest/utils.py",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/utils.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/lib/perftest/utils.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/lib/perftest/utils.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,6 +15,7 @@\n \n import gdb\n \n+\n def safe_execute(command):\n     \"\"\"Execute command, ignoring any gdb errors.\"\"\"\n     result = None\n@@ -37,7 +38,7 @@ def select_file(file_name):\n     \"\"\"\n     safe_execute(\"set confirm off\")\n     safe_execute(\"kill\")\n-    print (\"Selecting file %s\" % (file_name))\n+    print(\"Selecting file %s\" % (file_name))\n     if file_name is None:\n         gdb.execute(\"file\")\n     else:"
    },
    {
      "sha": "08d6ae19bb0d69e07baa768d19c92dbadd82e01f",
      "filename": "gdb/testsuite/gdb.perf/single-step.py",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/single-step.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/single-step.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/single-step.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,9 +15,10 @@\n \n from perftest import perftest\n \n-class SingleStep (perftest.TestCaseWithBasicMeasurements):\n+\n+class SingleStep(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, step):\n-        super (SingleStep, self).__init__ (\"single-step\")\n+        super(SingleStep, self).__init__(\"single-step\")\n         self.step = step\n \n     def warm_up(self):"
    },
    {
      "sha": "9586042cbafdbd28692a1c36339e83a1491766c5",
      "filename": "gdb/testsuite/gdb.perf/skip-command.py",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/skip-command.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/skip-command.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/skip-command.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,9 +15,10 @@\n \n from perftest import perftest\n \n-class SkipCommand (perftest.TestCaseWithBasicMeasurements):\n+\n+class SkipCommand(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, name, step):\n-        super (SkipCommand, self).__init__ (name)\n+        super(SkipCommand, self).__init__(name)\n         self.step = step\n \n     def warm_up(self):"
    },
    {
      "sha": "ee1b57952add45146b4b12b76a6d791689301e59",
      "filename": "gdb/testsuite/gdb.perf/skip-prologue.py",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/skip-prologue.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/skip-prologue.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/skip-prologue.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -18,6 +18,7 @@\n \n from perftest import perftest\n \n+\n class SkipPrologue(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, count):\n         super(SkipPrologue, self).__init__(\"skip-prologue\")"
    },
    {
      "sha": "f3ce5fa751d1d6115f5f1bced5e6b29c4e9a8e4b",
      "filename": "gdb/testsuite/gdb.perf/solib.py",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/solib.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/solib.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/solib.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,14 +19,15 @@\n from perftest import perftest\n from perftest import measure\n \n+\n class SolibLoadUnload1(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self, solib_count, measure_load):\n         if measure_load:\n             name = \"solib_load\"\n         else:\n             name = \"solib_unload\"\n         # We want to measure time in this test.\n-        super (SolibLoadUnload1, self).__init__ (name)\n+        super(SolibLoadUnload1, self).__init__(name)\n         self.solib_count = solib_count\n         self.measure_load = measure_load\n \n@@ -38,35 +39,36 @@ def warm_up(self):\n \n     def execute_test(self):\n         num = self.solib_count\n-        iteration = 5;\n+        iteration = 5\n \n         while num > 0 and iteration > 0:\n             # Do inferior calls to do_test_load and do_test_unload in pairs,\n             # but measure differently.\n             if self.measure_load:\n                 do_test_load = \"call do_test_load (%d)\" % num\n-                func = lambda: gdb.execute (do_test_load)\n+                func = lambda: gdb.execute(do_test_load)\n \n                 self.measure.measure(func, num)\n \n                 do_test_unload = \"call do_test_unload (%d)\" % num\n-                gdb.execute (do_test_unload)\n+                gdb.execute(do_test_unload)\n \n             else:\n                 do_test_load = \"call do_test_load (%d)\" % num\n-                gdb.execute (do_test_load)\n+                gdb.execute(do_test_load)\n \n                 do_test_unload = \"call do_test_unload (%d)\" % num\n-                func = lambda: gdb.execute (do_test_unload)\n+                func = lambda: gdb.execute(do_test_unload)\n \n                 self.measure.measure(func, num)\n \n             num = num / 2\n             iteration -= 1\n \n+\n class SolibLoadUnload(object):\n     def __init__(self, solib_count):\n-        self.solib_count = solib_count;\n+        self.solib_count = solib_count\n \n     def run(self):\n         SolibLoadUnload1(self.solib_count, True).run()"
    },
    {
      "sha": "05a874840bc49f4c747f9c2d3ca4004184c03ea6",
      "filename": "gdb/testsuite/gdb.perf/template-breakpoints.py",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/template-breakpoints.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.perf/template-breakpoints.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.perf/template-breakpoints.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,9 +15,10 @@\n \n from perftest import perftest\n \n-class TemplateBreakpoints (perftest.TestCaseWithBasicMeasurements):\n+\n+class TemplateBreakpoints(perftest.TestCaseWithBasicMeasurements):\n     def __init__(self):\n-        super (TemplateBreakpoints, self).__init__ (\"template-breakpoints\")\n+        super(TemplateBreakpoints, self).__init__(\"template-breakpoints\")\n \n     def warm_up(self):\n         for _ in range(0, 2):"
    },
    {
      "sha": "e15e19664c0fbfde1d5024121f133dfaf7f2ec89",
      "filename": "gdb/testsuite/gdb.python/py-auto-load-chaining-f1.o-gdb.py",
      "status": "modified",
      "additions": 10,
      "deletions": 12,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-auto-load-chaining-f1.o-gdb.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-auto-load-chaining-f1.o-gdb.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-auto-load-chaining-f1.o-gdb.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -18,20 +18,18 @@\n \n import re\n \n-print (\"Entering f1.o auto-load script\")\n+print(\"Entering f1.o auto-load script\")\n \n-print (\"Current objfile is: %s\"\n-       % gdb.current_objfile ().filename)\n+print(\"Current objfile is: %s\" % gdb.current_objfile().filename)\n \n-print (\"Chain loading f2.o...\")\n+print(\"Chain loading f2.o...\")\n \n-filename = gdb.current_objfile ().filename\n-filename = re.sub (r\"-f1.o$\", \"-f2.o\", filename)\n-r2 = gdb.lookup_global_symbol ('region_2').value ()\n-gdb.execute (\"add-symbol-file %s 0x%x\" % (filename, r2))\n+filename = gdb.current_objfile().filename\n+filename = re.sub(r\"-f1.o$\", \"-f2.o\", filename)\n+r2 = gdb.lookup_global_symbol(\"region_2\").value()\n+gdb.execute(\"add-symbol-file %s 0x%x\" % (filename, r2))\n \n-print (\"After loading f2.o...\")\n-print (\"Current objfile is: %s\"\n-       % gdb.current_objfile ().filename)\n+print(\"After loading f2.o...\")\n+print(\"Current objfile is: %s\" % gdb.current_objfile().filename)\n \n-print (\"Leaving f1.o auto-load script\")\n+print(\"Leaving f1.o auto-load script\")"
    },
    {
      "sha": "b94a9da986e9dc244956f957178ada51a0c8efb9",
      "filename": "gdb/testsuite/gdb.python/py-auto-load-chaining-f2.o-gdb.py",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-auto-load-chaining-f2.o-gdb.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-auto-load-chaining-f2.o-gdb.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-auto-load-chaining-f2.o-gdb.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -16,9 +16,8 @@\n # This script is auto-loaded when the py-auto-load-chaining-f2.o\n # object is loaded.\n \n-print (\"Entering f2.o auto-load script\")\n+print(\"Entering f2.o auto-load script\")\n \n-print (\"Current objfile is: %s\"\n-       % gdb.current_objfile ().filename)\n+print(\"Current objfile is: %s\" % gdb.current_objfile().filename)\n \n-print (\"Leaving f2.o auto-load script\")\n+print(\"Leaving f2.o auto-load script\")"
    },
    {
      "sha": "8e13f3d94179d06b29d60641599c9b8a352c5516",
      "filename": "gdb/testsuite/gdb.python/py-bad-printers.py",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-bad-printers.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-bad-printers.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-bad-printers.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -29,18 +29,18 @@ def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'container %s with %d elements' % (self.val['name'], self.val['len'])\n+        return \"container %s with %d elements\" % (self.val[\"name\"], self.val[\"len\"])\n \n     @staticmethod\n     def _bad_iterator(pointer, len):\n         start = pointer\n         end = pointer + len\n         while pointer != end:\n-            yield 'intentional violation of children iterator protocol'\n+            yield \"intentional violation of children iterator protocol\"\n             pointer += 1\n \n     def children(self):\n-        return self._bad_iterator(self.val['elements'], self.val['len'])\n+        return self._bad_iterator(self.val[\"elements\"], self.val[\"len\"])\n \n \n class BadChildrenContainerPrinter2(object):\n@@ -50,28 +50,26 @@ def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'container %s with %d elements' % (self.val['name'], self.val['len'])\n+        return \"container %s with %d elements\" % (self.val[\"name\"], self.val[\"len\"])\n \n     @staticmethod\n     def _bad_iterator(pointer, len):\n         start = pointer\n         end = pointer + len\n         while pointer != end:\n             # The first argument is supposed to be a string.\n-            yield (42, 'intentional violation of children iterator protocol')\n+            yield (42, \"intentional violation of children iterator protocol\")\n             pointer += 1\n \n     def children(self):\n-        return self._bad_iterator(self.val['elements'], self.val['len'])\n+        return self._bad_iterator(self.val[\"elements\"], self.val[\"len\"])\n \n \n def build_pretty_printer():\n     pp = gdb.printing.RegexpCollectionPrettyPrinter(\"bad-printers\")\n \n-    pp.add_printer('container1', '^container$',\n-                   BadChildrenContainerPrinter1)\n-    pp.add_printer('container2', '^container$',\n-                   BadChildrenContainerPrinter2)\n+    pp.add_printer(\"container1\", \"^container$\", BadChildrenContainerPrinter1)\n+    pp.add_printer(\"container2\", \"^container$\", BadChildrenContainerPrinter2)\n \n     return pp\n "
    },
    {
      "sha": "f44126b590bf8903608ce69e16be7337e87ebf9d",
      "filename": "gdb/testsuite/gdb.python/py-breakpoint-create-fail.py",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-breakpoint-create-fail.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-breakpoint-create-fail.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-breakpoint-create-fail.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -18,13 +18,13 @@\n \n class MyBP(gdb.Breakpoint):\n     def stop(self):\n-        print('MyBP.stop was invoked!')\n+        print(\"MyBP.stop was invoked!\")\n         # Don't make this breakpoint stop\n         return False\n \n \n try:\n-    bp = MyBP('does_not_exist', gdb.BP_WATCHPOINT)\n+    bp = MyBP(\"does_not_exist\", gdb.BP_WATCHPOINT)\n except RuntimeError:\n     pass\n else:"
    },
    {
      "sha": "a34c3a7245d717b0ff4377adeacf1bc0a72ad024",
      "filename": "gdb/testsuite/gdb.python/py-completion.py",
      "status": "modified",
      "additions": 154,
      "deletions": 87,
      "changes": 241,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-completion.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-completion.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-completion.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,123 +17,190 @@\n \n import gdb\n \n+\n class CompleteFileInit(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completefileinit',gdb.COMMAND_USER,gdb.COMPLETE_FILENAME)\n+    def __init__(self):\n+        gdb.Command.__init__(\n+            self, \"completefileinit\", gdb.COMMAND_USER, gdb.COMPLETE_FILENAME\n+        )\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n \n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n \n class CompleteFileMethod(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completefilemethod',gdb.COMMAND_USER)\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completefilemethod\", gdb.COMMAND_USER)\n \n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return gdb.COMPLETE_FILENAME\n \n-\tdef complete(self,text,word):\n-\t\treturn gdb.COMPLETE_FILENAME\n \n class CompleteFileCommandCond(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completefilecommandcond',gdb.COMMAND_USER)\n-\n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n-\n-\tdef complete(self,text,word):\n-\t\t# This is a test made to know if the command\n-\t\t# completion still works fine.  When the user asks to\n-\t\t# complete something like \"completefilecommandcond\n-\t\t# /path/to/py-completion-t\", it should not complete to\n-\t\t# \"/path/to/py-completion-test/\", but instead just\n-\t\t# wait for input.\n-\t\tif \"py-completion-t\" in text:\n-\t\t\treturn gdb.COMPLETE_COMMAND\n-\t\telse:\n-\t\t\treturn gdb.COMPLETE_FILENAME\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completefilecommandcond\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        # This is a test made to know if the command\n+        # completion still works fine.  When the user asks to\n+        # complete something like \"completefilecommandcond\n+        # /path/to/py-completion-t\", it should not complete to\n+        # \"/path/to/py-completion-test/\", but instead just\n+        # wait for input.\n+        if \"py-completion-t\" in text:\n+            return gdb.COMPLETE_COMMAND\n+        else:\n+            return gdb.COMPLETE_FILENAME\n+\n \n class CompleteLimit1(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit1',gdb.COMMAND_USER)\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit1\", gdb.COMMAND_USER)\n \n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n \n-\tdef complete(self,text,word):\n-                return [\"cl11\", \"cl12\", \"cl13\"]\n+    def complete(self, text, word):\n+        return [\"cl11\", \"cl12\", \"cl13\"]\n \n-class CompleteLimit2(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit2',\n-                                     gdb.COMMAND_USER)\n \n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+class CompleteLimit2(gdb.Command):\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit2\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return [\n+            \"cl21\",\n+            \"cl23\",\n+            \"cl25\",\n+            \"cl27\",\n+            \"cl29\",\n+            \"cl22\",\n+            \"cl24\",\n+            \"cl26\",\n+            \"cl28\",\n+            \"cl210\",\n+        ]\n \n-\tdef complete(self,text,word):\n-\t\treturn [\"cl21\", \"cl23\", \"cl25\", \"cl27\", \"cl29\",\n-                        \"cl22\", \"cl24\", \"cl26\", \"cl28\", \"cl210\"]\n \n class CompleteLimit3(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit3',\n-                                     gdb.COMMAND_USER)\n-\n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit3\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return [\n+            \"cl31\",\n+            \"cl33\",\n+            \"cl35\",\n+            \"cl37\",\n+            \"cl39\",\n+            \"cl32\",\n+            \"cl34\",\n+            \"cl36\",\n+            \"cl38\",\n+            \"cl310\",\n+        ]\n \n-\tdef complete(self,text,word):\n-\t\treturn [\"cl31\", \"cl33\", \"cl35\", \"cl37\", \"cl39\",\n-                        \"cl32\", \"cl34\", \"cl36\", \"cl38\", \"cl310\"]\n \n class CompleteLimit4(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit4',\n-                                     gdb.COMMAND_USER)\n-\n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit4\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return [\n+            \"cl41\",\n+            \"cl43\",\n+            \"cl45\",\n+            \"cl47\",\n+            \"cl49\",\n+            \"cl42\",\n+            \"cl44\",\n+            \"cl46\",\n+            \"cl48\",\n+            \"cl410\",\n+        ]\n \n-\tdef complete(self,text,word):\n-\t\treturn [\"cl41\", \"cl43\", \"cl45\", \"cl47\", \"cl49\",\n-                        \"cl42\", \"cl44\", \"cl46\", \"cl48\", \"cl410\"]\n \n class CompleteLimit5(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit5',\n-                                     gdb.COMMAND_USER)\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit5\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return [\n+            \"cl51\",\n+            \"cl53\",\n+            \"cl55\",\n+            \"cl57\",\n+            \"cl59\",\n+            \"cl52\",\n+            \"cl54\",\n+            \"cl56\",\n+            \"cl58\",\n+            \"cl510\",\n+        ]\n \n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n-\n-\tdef complete(self,text,word):\n-\t\treturn [\"cl51\", \"cl53\", \"cl55\", \"cl57\", \"cl59\",\n-                        \"cl52\", \"cl54\", \"cl56\", \"cl58\", \"cl510\"]\n \n class CompleteLimit6(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit6',\n-                                     gdb.COMMAND_USER)\n-\n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit6\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return [\n+            \"cl61\",\n+            \"cl63\",\n+            \"cl65\",\n+            \"cl67\",\n+            \"cl69\",\n+            \"cl62\",\n+            \"cl64\",\n+            \"cl66\",\n+            \"cl68\",\n+            \"cl610\",\n+        ]\n \n-\tdef complete(self,text,word):\n-\t\treturn [\"cl61\", \"cl63\", \"cl65\", \"cl67\", \"cl69\",\n-                        \"cl62\", \"cl64\", \"cl66\", \"cl68\", \"cl610\"]\n \n class CompleteLimit7(gdb.Command):\n-\tdef __init__(self):\n-\t\tgdb.Command.__init__(self,'completelimit7',\n-                                     gdb.COMMAND_USER)\n-\n-\tdef invoke(self,argument,from_tty):\n-\t\traise gdb.GdbError('not implemented')\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"completelimit7\", gdb.COMMAND_USER)\n+\n+    def invoke(self, argument, from_tty):\n+        raise gdb.GdbError(\"not implemented\")\n+\n+    def complete(self, text, word):\n+        return [\n+            \"cl71\",\n+            \"cl73\",\n+            \"cl75\",\n+            \"cl77\",\n+            \"cl79\",\n+            \"cl72\",\n+            \"cl74\",\n+            \"cl76\",\n+            \"cl78\",\n+            \"cl710\",\n+        ]\n \n-\tdef complete(self,text,word):\n-\t\treturn [\"cl71\", \"cl73\", \"cl75\", \"cl77\", \"cl79\",\n-                        \"cl72\", \"cl74\", \"cl76\", \"cl78\", \"cl710\"]\n \n CompleteFileInit()\n CompleteFileMethod()"
    },
    {
      "sha": "9ef3af9771e1cf52497909c0a2c5a0583c8f18af",
      "filename": "gdb/testsuite/gdb.python/py-error.py",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-error.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-error.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-error.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,11 +15,15 @@\n \n import gdb\n \n+\n class ClassName(gdb.Command):\n-    'a'\n+    \"a\"\n+\n     def __init__(self):\n-        gdb.Command.__init__ (self, \"ClassName\", gdb.COMMAND_DATA, prefix=True)\n+        gdb.Command.__init__(self, \"ClassName\", gdb.COMMAND_DATA, prefix=True)\n+\n     def invoke(self, args, from_tty):\n         print\n \n+\n ClassName()"
    },
    {
      "sha": "6a676271b41641dc1a1679c78035c9620e1a4eb3",
      "filename": "gdb/testsuite/gdb.python/py-events.py",
      "status": "modified",
      "additions": 94,
      "deletions": 82,
      "changes": 176,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-events.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-events.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-events.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,102 +17,114 @@\n # printers.\n import gdb\n \n-def signal_stop_handler (event):\n-    if (isinstance (event, gdb.StopEvent)):\n-        print (\"event type: stop\")\n-    if (isinstance (event, gdb.SignalEvent)):\n-        print (\"stop reason: signal\")\n-        print (\"stop signal: %s\" % (event.stop_signal))\n-        if ( event.inferior_thread is not None) :\n-            print (\"thread num: %s\" % (event.inferior_thread.num))\n-\n-def breakpoint_stop_handler (event):\n-    if (isinstance (event, gdb.StopEvent)):\n-        print (\"event type: stop\")\n-    if (isinstance (event, gdb.BreakpointEvent)):\n-        print (\"stop reason: breakpoint\")\n-        print (\"first breakpoint number: %s\" % (event.breakpoint.number))\n+\n+def signal_stop_handler(event):\n+    if isinstance(event, gdb.StopEvent):\n+        print(\"event type: stop\")\n+    if isinstance(event, gdb.SignalEvent):\n+        print(\"stop reason: signal\")\n+        print(\"stop signal: %s\" % (event.stop_signal))\n+        if event.inferior_thread is not None:\n+            print(\"thread num: %s\" % (event.inferior_thread.num))\n+\n+\n+def breakpoint_stop_handler(event):\n+    if isinstance(event, gdb.StopEvent):\n+        print(\"event type: stop\")\n+    if isinstance(event, gdb.BreakpointEvent):\n+        print(\"stop reason: breakpoint\")\n+        print(\"first breakpoint number: %s\" % (event.breakpoint.number))\n         for bp in event.breakpoints:\n-        \tprint (\"breakpoint number: %s\" % (bp.number))\n-        if ( event.inferior_thread is not None) :\n-            print (\"thread num: %s\" % (event.inferior_thread.num))\n+            print(\"breakpoint number: %s\" % (bp.number))\n+        if event.inferior_thread is not None:\n+            print(\"thread num: %s\" % (event.inferior_thread.num))\n         else:\n-            print (\"all threads stopped\")\n-\n-def exit_handler (event):\n-    assert (isinstance (event, gdb.ExitedEvent))\n-    print (\"event type: exit\")\n-    print (\"exit code: %d\" % (event.exit_code))\n-    print (\"exit inf: %d\" % (event.inferior.num))\n-    print (\"dir ok: %s\" % str('exit_code' in dir(event)))\n-\n-def continue_handler (event):\n-    assert (isinstance (event, gdb.ContinueEvent))\n-    print (\"event type: continue\")\n-    if ( event.inferior_thread is not None) :\n-        print (\"thread num: %s\" % (event.inferior_thread.num))\n-\n-def new_objfile_handler (event):\n-    assert (isinstance (event, gdb.NewObjFileEvent))\n-    print (\"event type: new_objfile\")\n-    print (\"new objfile name: %s\" % (event.new_objfile.filename))\n-\n-def clear_objfiles_handler (event):\n-    assert (isinstance (event, gdb.ClearObjFilesEvent))\n-    print (\"event type: clear_objfiles\")\n-    print (\"progspace: %s\" % (event.progspace.filename))\n-\n-def inferior_call_handler (event):\n-    if (isinstance (event, gdb.InferiorCallPreEvent)):\n-        print (\"event type: pre-call\")\n-    elif (isinstance (event, gdb.InferiorCallPostEvent)):\n-        print (\"event type: post-call\")\n+            print(\"all threads stopped\")\n+\n+\n+def exit_handler(event):\n+    assert isinstance(event, gdb.ExitedEvent)\n+    print(\"event type: exit\")\n+    print(\"exit code: %d\" % (event.exit_code))\n+    print(\"exit inf: %d\" % (event.inferior.num))\n+    print(\"dir ok: %s\" % str(\"exit_code\" in dir(event)))\n+\n+\n+def continue_handler(event):\n+    assert isinstance(event, gdb.ContinueEvent)\n+    print(\"event type: continue\")\n+    if event.inferior_thread is not None:\n+        print(\"thread num: %s\" % (event.inferior_thread.num))\n+\n+\n+def new_objfile_handler(event):\n+    assert isinstance(event, gdb.NewObjFileEvent)\n+    print(\"event type: new_objfile\")\n+    print(\"new objfile name: %s\" % (event.new_objfile.filename))\n+\n+\n+def clear_objfiles_handler(event):\n+    assert isinstance(event, gdb.ClearObjFilesEvent)\n+    print(\"event type: clear_objfiles\")\n+    print(\"progspace: %s\" % (event.progspace.filename))\n+\n+\n+def inferior_call_handler(event):\n+    if isinstance(event, gdb.InferiorCallPreEvent):\n+        print(\"event type: pre-call\")\n+    elif isinstance(event, gdb.InferiorCallPostEvent):\n+        print(\"event type: post-call\")\n     else:\n         assert False\n-    print (\"ptid: %s\" % (event.ptid,))\n-    print (\"address: 0x%x\" % (event.address))\n+    print(\"ptid: %s\" % (event.ptid,))\n+    print(\"address: 0x%x\" % (event.address))\n+\n \n-def register_changed_handler (event):\n-    assert (isinstance (event, gdb.RegisterChangedEvent))\n-    print (\"event type: register-changed\")\n-    assert (isinstance (event.frame, gdb.Frame))\n-    print (\"frame: %s\" % (event.frame))\n-    print (\"num: %s\" % (event.regnum))\n+def register_changed_handler(event):\n+    assert isinstance(event, gdb.RegisterChangedEvent)\n+    print(\"event type: register-changed\")\n+    assert isinstance(event.frame, gdb.Frame)\n+    print(\"frame: %s\" % (event.frame))\n+    print(\"num: %s\" % (event.regnum))\n \n-def memory_changed_handler (event):\n-    assert (isinstance (event, gdb.MemoryChangedEvent))\n-    print (\"event type: memory-changed\")\n-    print (\"address: %s\" % (event.address))\n-    print (\"length: %s\" % (event.length))\n \n+def memory_changed_handler(event):\n+    assert isinstance(event, gdb.MemoryChangedEvent)\n+    print(\"event type: memory-changed\")\n+    print(\"address: %s\" % (event.address))\n+    print(\"length: %s\" % (event.length))\n \n-class test_events (gdb.Command):\n+\n+class test_events(gdb.Command):\n     \"\"\"Test events.\"\"\"\n \n-    def __init__ (self):\n-        gdb.Command.__init__ (self, \"test-events\", gdb.COMMAND_STACK)\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"test-events\", gdb.COMMAND_STACK)\n+\n+    def invoke(self, arg, from_tty):\n+        gdb.events.stop.connect(signal_stop_handler)\n+        gdb.events.stop.connect(breakpoint_stop_handler)\n+        gdb.events.exited.connect(exit_handler)\n+        gdb.events.cont.connect(continue_handler)\n+        gdb.events.inferior_call.connect(inferior_call_handler)\n+        gdb.events.memory_changed.connect(memory_changed_handler)\n+        gdb.events.register_changed.connect(register_changed_handler)\n+        print(\"Event testers registered.\")\n \n-    def invoke (self, arg, from_tty):\n-        gdb.events.stop.connect (signal_stop_handler)\n-        gdb.events.stop.connect (breakpoint_stop_handler)\n-        gdb.events.exited.connect (exit_handler)\n-        gdb.events.cont.connect (continue_handler)\n-        gdb.events.inferior_call.connect (inferior_call_handler)\n-        gdb.events.memory_changed.connect (memory_changed_handler)\n-        gdb.events.register_changed.connect (register_changed_handler)\n-        print (\"Event testers registered.\")\n \n-test_events ()\n+test_events()\n \n-class test_newobj_events (gdb.Command):\n+\n+class test_newobj_events(gdb.Command):\n     \"\"\"NewObj events.\"\"\"\n \n-    def __init__ (self):\n-        gdb.Command.__init__ (self, \"test-objfile-events\", gdb.COMMAND_STACK)\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"test-objfile-events\", gdb.COMMAND_STACK)\n+\n+    def invoke(self, arg, from_tty):\n+        gdb.events.new_objfile.connect(new_objfile_handler)\n+        gdb.events.clear_objfiles.connect(clear_objfiles_handler)\n+        print(\"Object file events registered.\")\n \n-    def invoke (self, arg, from_tty):\n-        gdb.events.new_objfile.connect (new_objfile_handler)\n-        gdb.events.clear_objfiles.connect (clear_objfiles_handler)\n-        print (\"Object file events registered.\")\n \n-test_newobj_events ()\n+test_newobj_events()"
    },
    {
      "sha": "7791079b1f42377acea488e7cdf837d24343dcbd",
      "filename": "gdb/testsuite/gdb.python/py-finish-breakpoint.py",
      "status": "modified",
      "additions": 56,
      "deletions": 52,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-finish-breakpoint.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-finish-breakpoint.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-finish-breakpoint.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,75 +15,79 @@\n \n # This file is part of the GDB testsuite.  It tests python Finish\n # Breakpoints.\n-                \n-class MyFinishBreakpoint (gdb.FinishBreakpoint):\n-        def __init__(self, val, frame):\n-                gdb.FinishBreakpoint.__init__ (self, frame)\n-                print (\"MyFinishBreakpoint init\")\n-                self.val = val\n-                \n-        def stop(self):\n-                print (\"MyFinishBreakpoint stop with %d\" % int (self.val.dereference ()))\n-                print (\"return_value is: %d\" % int (self.return_value))\n-                gdb.execute (\"where 1\")\n-                return True\n-        \n-        def out_of_scope(self):\n-                print (\"MyFinishBreakpoint out of scope\")\n+\n+\n+class MyFinishBreakpoint(gdb.FinishBreakpoint):\n+    def __init__(self, val, frame):\n+        gdb.FinishBreakpoint.__init__(self, frame)\n+        print(\"MyFinishBreakpoint init\")\n+        self.val = val\n+\n+    def stop(self):\n+        print(\"MyFinishBreakpoint stop with %d\" % int(self.val.dereference()))\n+        print(\"return_value is: %d\" % int(self.return_value))\n+        gdb.execute(\"where 1\")\n+        return True\n+\n+    def out_of_scope(self):\n+        print(\"MyFinishBreakpoint out of scope\")\n+\n \n class TestBreakpoint(gdb.Breakpoint):\n     def __init__(self):\n-        gdb.Breakpoint.__init__ (self, spec=\"test_1\", internal=1)\n+        gdb.Breakpoint.__init__(self, spec=\"test_1\", internal=1)\n         self.silent = True\n         self.count = 0\n-        print (\"TestBreakpoint init\")\n-        \n+        print(\"TestBreakpoint init\")\n+\n     def stop(self):\n         self.count += 1\n         try:\n-                TestFinishBreakpoint (gdb.newest_frame (), self.count)\n+            TestFinishBreakpoint(gdb.newest_frame(), self.count)\n         except ValueError as e:\n-                print (e)\n+            print(e)\n         return False\n \n-class TestFinishBreakpoint (gdb.FinishBreakpoint):\n-    def __init__ (self, frame, count):\n+\n+class TestFinishBreakpoint(gdb.FinishBreakpoint):\n+    def __init__(self, frame, count):\n         self.count = count\n-        gdb.FinishBreakpoint.__init__ (self, frame, internal=1)\n-        \n-        \n+        gdb.FinishBreakpoint.__init__(self, frame, internal=1)\n+\n     def stop(self):\n-        print (\"-->\", self.number)\n-        if (self.count == 3):\n-            print (\"test stop: %d\" % self.count)\n+        print(\"-->\", self.number)\n+        if self.count == 3:\n+            print(\"test stop: %d\" % self.count)\n             return True\n         else:\n-            print (\"test don't stop: %d\" % self.count)\n-            return False \n-        \n-    \n+            print(\"test don't stop: %d\" % self.count)\n+            return False\n+\n     def out_of_scope(self):\n-        print (\"test didn't finish: %d\" % self.count)\n+        print(\"test didn't finish: %d\" % self.count)\n+\n \n class TestExplicitBreakpoint(gdb.Breakpoint):\n-        def stop(self):\n-                try:\n-                        SimpleFinishBreakpoint (gdb.newest_frame ())\n-                except ValueError as e:\n-                        print (e)\n-                return False\n+    def stop(self):\n+        try:\n+            SimpleFinishBreakpoint(gdb.newest_frame())\n+        except ValueError as e:\n+            print(e)\n+        return False\n+\n \n class SimpleFinishBreakpoint(gdb.FinishBreakpoint):\n-        def __init__(self, frame):\n-                gdb.FinishBreakpoint.__init__ (self, frame)\n-                \n-                print (\"SimpleFinishBreakpoint init\")\n-                \n-        def stop(self):\n-                print (\"SimpleFinishBreakpoint stop\" )\n-                return True\n-        \n-        def out_of_scope(self):\n-                print (\"SimpleFinishBreakpoint out of scope\")\n-\n-print (\"Python script imported\")\n+    def __init__(self, frame):\n+        gdb.FinishBreakpoint.__init__(self, frame)\n+\n+        print(\"SimpleFinishBreakpoint init\")\n+\n+    def stop(self):\n+        print(\"SimpleFinishBreakpoint stop\")\n+        return True\n+\n+    def out_of_scope(self):\n+        print(\"SimpleFinishBreakpoint out of scope\")\n+\n+\n+print(\"Python script imported\")"
    },
    {
      "sha": "9cf3c4d2ab978cf6f3e2649ee805ba38147ce3bf",
      "filename": "gdb/testsuite/gdb.python/py-finish-breakpoint2.py",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-finish-breakpoint2.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-finish-breakpoint2.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-finish-breakpoint2.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -16,18 +16,19 @@\n # This file is part of the GDB testsuite.  It tests python Finish\n # Breakpoints.\n \n+\n class ExceptionFinishBreakpoint(gdb.FinishBreakpoint):\n     def __init__(self, frame):\n-        gdb.FinishBreakpoint.__init__ (self, frame, internal=1)\n+        gdb.FinishBreakpoint.__init__(self, frame, internal=1)\n         self.silent = True\n-        print (\"init ExceptionFinishBreakpoint\")\n-        \n+        print(\"init ExceptionFinishBreakpoint\")\n+\n     def stop(self):\n-        print (\"stopped at ExceptionFinishBreakpoint\")\n-        return True \n-    \n+        print(\"stopped at ExceptionFinishBreakpoint\")\n+        return True\n+\n     def out_of_scope(self):\n-        print (\"exception did not finish ...\")\n+        print(\"exception did not finish ...\")\n \n \n-print (\"Python script imported\")\n+print(\"Python script imported\")"
    },
    {
      "sha": "f346c2e5032143853f5197191993c5f79a6ce713",
      "filename": "gdb/testsuite/gdb.python/py-format-string.py",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-format-string.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-format-string.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-format-string.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -18,32 +18,35 @@\n \n import gdb\n \n-class PointPrinter (object):\n-    def __init__ (self, val):\n+\n+class PointPrinter(object):\n+    def __init__(self, val):\n         self.val = val\n \n-    def to_string (self):\n-        return 'Pretty Point (%s, %s)' % (self.val['x'], self.val['y'])\n+    def to_string(self):\n+        return \"Pretty Point (%s, %s)\" % (self.val[\"x\"], self.val[\"y\"])\n+\n \n-def test_lookup_function (val):\n+def test_lookup_function(val):\n     \"Look-up and return a pretty-printer that can print val.\"\n \n     # Get the type.\n     type = val.type\n \n     # If it points to a reference, get the reference.\n     if type.code == gdb.TYPE_CODE_REF:\n-        type = type.target ()\n+        type = type.target()\n \n     # Get the unqualified type, stripped of typedefs.\n-    type = type.unqualified ().strip_typedefs ()\n+    type = type.unqualified().strip_typedefs()\n \n     # Get the type name.\n     typename = type.tag\n \n-    if typename == 'point':\n-        return PointPrinter (val)\n+    if typename == \"point\":\n+        return PointPrinter(val)\n \n     return None\n \n-gdb.pretty_printers.append (test_lookup_function)\n+\n+gdb.pretty_printers.append(test_lookup_function)"
    },
    {
      "sha": "32d7204a5bd5ad999106ab3918b789e68de52bc1",
      "filename": "gdb/testsuite/gdb.python/py-frame-args.py",
      "status": "modified",
      "additions": 20,
      "deletions": 17,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-frame-args.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-frame-args.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-frame-args.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -16,40 +16,42 @@\n import re\n import gdb\n \n-class pp_s (object):\n+\n+class pp_s(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         m = self.val[\"m\"]\n         return \"m=<\" + str(self.val[\"m\"]) + \">\"\n \n-class pp_ss (object):\n+\n+class pp_ss(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         return \"super struct\"\n \n-    def children (self):\n-        yield 'a', self.val['a']\n-        yield 'b', self.val['b']\n+    def children(self):\n+        yield \"a\", self.val[\"a\"]\n+        yield \"b\", self.val[\"b\"]\n \n \n-def lookup_function (val):\n+def lookup_function(val):\n     \"Look-up and return a pretty-printer that can print val.\"\n \n     # Get the type.\n     type = val.type\n \n     # If it points to a reference, get the reference.\n     if type.code == gdb.TYPE_CODE_REF:\n-        type = type.target ()\n+        type = type.target()\n \n     # Get the unqualified type, stripped of typedefs.\n-    type = type.unqualified ().strip_typedefs ()\n+    type = type.unqualified().strip_typedefs()\n \n-    # Get the type name.    \n+    # Get the type name.\n     typename = type.tag\n     if typename == None:\n         return None\n@@ -58,18 +60,19 @@ def lookup_function (val):\n     # if a printer is registered for that type.  Return an\n     # instantiation of the printer if found.\n     for function in pretty_printers_dict:\n-        if function.match (typename):\n-            return pretty_printers_dict[function] (val)\n-        \n+        if function.match(typename):\n+            return pretty_printers_dict[function](val)\n+\n     # Cannot find a pretty printer.  Return None.\n     return None\n \n \n-def register_pretty_printers ():\n-    pretty_printers_dict[re.compile ('^s$')] = pp_s\n-    pretty_printers_dict[re.compile ('^ss$')] = pp_ss\n+def register_pretty_printers():\n+    pretty_printers_dict[re.compile(\"^s$\")] = pp_s\n+    pretty_printers_dict[re.compile(\"^ss$\")] = pp_ss\n+\n \n pretty_printers_dict = {}\n \n-register_pretty_printers ()\n-gdb.pretty_printers.append (lookup_function)\n+register_pretty_printers()\n+gdb.pretty_printers.append(lookup_function)"
    },
    {
      "sha": "f994f019bf9adccbb74107c14b715768955a609f",
      "filename": "gdb/testsuite/gdb.python/py-framefilter-addr.py",
      "status": "modified",
      "additions": 11,
      "deletions": 12,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-framefilter-addr.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-framefilter-addr.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-framefilter-addr.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -20,33 +20,32 @@\n \n # A FrameDecorator that just returns gdb.Frame.pc () from 'function'.\n # We want to ensure that GDB correctly handles this case.\n-class Function_Returns_Address (FrameDecorator):\n-\n+class Function_Returns_Address(FrameDecorator):\n     def __init__(self, fobj):\n-        super (Function_Returns_Address, self).__init__ (fobj)\n+        super(Function_Returns_Address, self).__init__(fobj)\n         self._fobj = fobj\n \n-    def function (self):\n-        frame = self.inferior_frame ()\n-        return frame.pc ()\n+    def function(self):\n+        frame = self.inferior_frame()\n+        return frame.pc()\n \n-class Frame_Filter ():\n \n-    def __init__ (self):\n+class Frame_Filter:\n+    def __init__(self):\n         self.name = \"function_returns_address\"\n         self.priority = 100\n         self.enabled = True\n-        gdb.frame_filters [self.name] = self\n+        gdb.frame_filters[self.name] = self\n \n-    def filter (self, frame_iter):\n+    def filter(self, frame_iter):\n         # Python 3.x moved the itertools.imap functionality to map(),\n         # so check if it is available.\n         if hasattr(itertools, \"imap\"):\n-            frame_iter = itertools.imap (Function_Returns_Address,\n-                                         frame_iter)\n+            frame_iter = itertools.imap(Function_Returns_Address, frame_iter)\n         else:\n             frame_iter = map(Function_Returns_Address, frame_iter)\n \n         return frame_iter\n \n+\n Frame_Filter()"
    },
    {
      "sha": "609ff80a88f5d52a29bda23c8a7b121a16906193",
      "filename": "gdb/testsuite/gdb.python/py-framefilter-invalidarg.py",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-framefilter-invalidarg.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-framefilter-invalidarg.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-framefilter-invalidarg.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -20,40 +20,40 @@\n from gdb.FrameDecorator import FrameDecorator\n import copy\n \n-class Reverse_Function (FrameDecorator):\n \n+class Reverse_Function(FrameDecorator):\n     def __init__(self, fobj):\n         super(Reverse_Function, self).__init__(fobj)\n         self.fobj = fobj\n \n-    def function (self):\n-        fname = str (self.fobj.function())\n-        if (fname == None or fname == \"\"):\n+    def function(self):\n+        fname = str(self.fobj.function())\n+        if fname == None or fname == \"\":\n             return None\n-        if fname == 'end_func':\n-            extra = self.fobj.inferior_frame().read_var('str').string()\n+        if fname == \"end_func\":\n+            extra = self.fobj.inferior_frame().read_var(\"str\").string()\n         else:\n-            extra = ''\n+            extra = \"\"\n         fname = fname[::-1] + extra\n         return fname\n \n-class FrameFilter ():\n \n-    def __init__ (self):\n+class FrameFilter:\n+    def __init__(self):\n         self.name = \"Reverse\"\n         self.priority = 100\n         self.enabled = True\n-        gdb.frame_filters [self.name] = self\n+        gdb.frame_filters[self.name] = self\n \n-    def filter (self, frame_iter):\n+    def filter(self, frame_iter):\n         # Python 3.x moved the itertools.imap functionality to map(),\n         # so check if it is available.\n         if hasattr(itertools, \"imap\"):\n-            frame_iter = itertools.imap (Reverse_Function,\n-                                         frame_iter)\n+            frame_iter = itertools.imap(Reverse_Function, frame_iter)\n         else:\n             frame_iter = map(Reverse_Function, frame_iter)\n \n         return frame_iter\n \n+\n FrameFilter()"
    },
    {
      "sha": "ce5a35d17a98645fc96d75f02c9a4898d49fc1c7",
      "filename": "gdb/testsuite/gdb.python/py-framefilter.py",
      "status": "modified",
      "additions": 40,
      "deletions": 37,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-framefilter.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-framefilter.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-framefilter.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -20,83 +20,83 @@\n from gdb.FrameDecorator import FrameDecorator\n import copy\n \n-class Reverse_Function (FrameDecorator):\n \n+class Reverse_Function(FrameDecorator):\n     def __init__(self, fobj):\n         super(Reverse_Function, self).__init__(fobj)\n         self.fobj = fobj\n \n-    def function (self):\n-        fname = str (self.fobj.function())\n-        if (fname == None or fname == \"\"):\n+    def function(self):\n+        fname = str(self.fobj.function())\n+        if fname == None or fname == \"\":\n             return None\n-        if fname == 'end_func':\n-            extra = self.fobj.inferior_frame().read_var('str').string()\n+        if fname == \"end_func\":\n+            extra = self.fobj.inferior_frame().read_var(\"str\").string()\n         else:\n-            extra = ''\n+            extra = \"\"\n         fname = fname[::-1] + extra\n         return fname\n \n-class Dummy (FrameDecorator):\n \n+class Dummy(FrameDecorator):\n     def __init__(self, fobj):\n         super(Dummy, self).__init__(fobj)\n         self.fobj = fobj\n \n-    def function (self):\n+    def function(self):\n         return \"Dummy function\"\n \n-    def address (self):\n+    def address(self):\n         return 0x123\n \n-    def filename (self):\n+    def filename(self):\n         return \"Dummy filename\"\n \n-    def frame_args (self):\n-        return [(\"Foo\",gdb.Value(12)),(\"Bar\",\"Stuff\"), (\"FooBar\",42)]\n+    def frame_args(self):\n+        return [(\"Foo\", gdb.Value(12)), (\"Bar\", \"Stuff\"), (\"FooBar\", 42)]\n \n-    def frame_locals (self):\n+    def frame_locals(self):\n         return []\n \n-    def line (self):\n+    def line(self):\n         return 0\n \n-    def elided (self):\n+    def elided(self):\n         return None\n \n-class FrameFilter ():\n \n-    def __init__ (self):\n+class FrameFilter:\n+    def __init__(self):\n         self.name = \"Reverse\"\n         self.priority = 100\n         self.enabled = True\n-        gdb.frame_filters [self.name] = self\n+        gdb.frame_filters[self.name] = self\n \n-    def filter (self, frame_iter):\n+    def filter(self, frame_iter):\n         # Python 3.x moved the itertools.imap functionality to map(),\n         # so check if it is available.\n         if hasattr(itertools, \"imap\"):\n-            frame_iter = itertools.imap (Reverse_Function,\n-                                         frame_iter)\n+            frame_iter = itertools.imap(Reverse_Function, frame_iter)\n         else:\n             frame_iter = map(Reverse_Function, frame_iter)\n \n         return frame_iter\n \n-class ElidingFrameDecorator(FrameDecorator):\n \n+class ElidingFrameDecorator(FrameDecorator):\n     def __init__(self, frame, elided_frames):\n         super(ElidingFrameDecorator, self).__init__(frame)\n         self.elided_frames = elided_frames\n \n     def elided(self):\n         return iter(self.elided_frames)\n \n-    def address (self):\n+    def address(self):\n         # Regression test for an overflow in the python layer.\n-        bitsize = 8 * gdb.lookup_type('void').pointer().sizeof\n+        bitsize = 8 * gdb.lookup_type(\"void\").pointer().sizeof\n         mask = (1 << bitsize) - 1\n-        return 0xffffffffffffffff & mask\n+        return 0xFFFFFFFFFFFFFFFF & mask\n+\n \n class ElidingIterator:\n     def __init__(self, ii):\n@@ -107,7 +107,7 @@ def __iter__(self):\n \n     def next(self):\n         frame = next(self.input_iterator)\n-        if str(frame.function()) != 'func1':\n+        if str(frame.function()) != \"func1\":\n             return frame\n \n         # Suppose we want to return the 'func1' frame but elide the\n@@ -123,16 +123,17 @@ def next(self):\n     def __next__(self):\n         return self.next()\n \n-class FrameElider ():\n \n-    def __init__ (self):\n+class FrameElider:\n+    def __init__(self):\n         self.name = \"Elider\"\n         self.priority = 900\n         self.enabled = True\n-        gdb.frame_filters [self.name] = self\n+        gdb.frame_filters[self.name] = self\n+\n+    def filter(self, frame_iter):\n+        return ElidingIterator(frame_iter)\n \n-    def filter (self, frame_iter):\n-        return ElidingIterator (frame_iter)\n \n # This is here so the test can change the kind of error that is\n # thrown.\n@@ -144,24 +145,26 @@ def __init__(self, frame):\n         FrameDecorator.__init__(self, frame)\n \n     def function(self):\n-        raise name_error('whoops')\n+        raise name_error(\"whoops\")\n+\n \n # A filter that supplies buggy frames.  Disabled by default.\n-class ErrorFilter():\n-    def __init__ (self):\n+class ErrorFilter:\n+    def __init__(self):\n         self.name = \"Error\"\n         self.priority = 1\n         self.enabled = False\n-        gdb.frame_filters [self.name] = self\n+        gdb.frame_filters[self.name] = self\n \n     def filter(self, frame_iter):\n         # Python 3.x moved the itertools.imap functionality to map(),\n         # so check if it is available.\n         if hasattr(itertools, \"imap\"):\n-            return itertools.imap (ErrorInName, frame_iter)\n+            return itertools.imap(ErrorInName, frame_iter)\n         else:\n             return map(ErrorInName, frame_iter)\n \n+\n FrameFilter()\n FrameElider()\n ErrorFilter()"
    },
    {
      "sha": "c60bab2ab368915c864c6f37d5c59d11724bc2f2",
      "filename": "gdb/testsuite/gdb.python/py-mi-events-gdb.py",
      "status": "modified",
      "additions": 14,
      "deletions": 12,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-mi-events-gdb.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-mi-events-gdb.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-mi-events-gdb.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -22,31 +22,33 @@\n stop_handler_str = \"\"\n cont_handler_str = \"\"\n \n-def signal_stop_handler (event):\n+\n+def signal_stop_handler(event):\n     \"\"\"Stop event handler\"\"\"\n-    assert (isinstance (event, gdb.StopEvent))\n+    assert isinstance(event, gdb.StopEvent)\n     global stop_handler_str\n     stop_handler_str = \"stop_handler\\n\"\n     stop_handler_str += gdb.execute(\"info break\", False, True)\n \n \n-def continue_handler (event):\n+def continue_handler(event):\n     \"\"\"Continue event handler\"\"\"\n-    assert (isinstance (event, gdb.ContinueEvent))\n+    assert isinstance(event, gdb.ContinueEvent)\n     global cont_handler_str\n     cont_handler_str = \"continue_handler\\n\"\n     cont_handler_str += gdb.execute(\"info break\", False, True)\n \n \n-class test_events (gdb.Command):\n+class test_events(gdb.Command):\n     \"\"\"Test events.\"\"\"\n \n-    def __init__ (self):\n-        gdb.Command.__init__ (self, \"test-events\", gdb.COMMAND_STACK)\n+    def __init__(self):\n+        gdb.Command.__init__(self, \"test-events\", gdb.COMMAND_STACK)\n+\n+    def invoke(self, arg, from_tty):\n+        gdb.events.stop.connect(signal_stop_handler)\n+        gdb.events.cont.connect(continue_handler)\n+        print(\"Event testers registered.\")\n \n-    def invoke (self, arg, from_tty):\n-        gdb.events.stop.connect (signal_stop_handler)\n-        gdb.events.cont.connect (continue_handler)\n-        print (\"Event testers registered.\")\n \n-test_events ()\n+test_events()"
    },
    {
      "sha": "d9ba2e20e9964da9b6f4b05b4c22e089df1de4e5",
      "filename": "gdb/testsuite/gdb.python/py-mi-var-info-path-expression.py",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-mi-var-info-path-expression.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-mi-var-info-path-expression.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-mi-var-info-path-expression.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -23,35 +23,35 @@\n \n \n class cons_pp(object):\n-  def __init__(self, val):\n-    self._val = val\n-\n-  def to_string(self):\n-    if long(self._val) == 0:\n-      return \"nil\"\n-    elif long(self._val['type']) == 0:\n-      return \"( . )\"\n-    else:\n-      return \"%d\" % self._val['atom']['ival']\n-\n-  def children(self):\n-    if long(self._val) == 0:\n-      return []\n-    elif long(self._val['type']) == 0:\n-      return [\n-        ('atom', self._val['atom'])\n-      ]\n-    else:\n-      return [\n-        ('car' ,  self._val[\"slots\"][0]),\n-        ('cdr' ,  self._val[\"slots\"][1]),\n-      ]\n+    def __init__(self, val):\n+        self._val = val\n+\n+    def to_string(self):\n+        if long(self._val) == 0:\n+            return \"nil\"\n+        elif long(self._val[\"type\"]) == 0:\n+            return \"( . )\"\n+        else:\n+            return \"%d\" % self._val[\"atom\"][\"ival\"]\n+\n+    def children(self):\n+        if long(self._val) == 0:\n+            return []\n+        elif long(self._val[\"type\"]) == 0:\n+            return [(\"atom\", self._val[\"atom\"])]\n+        else:\n+            return [\n+                (\"car\", self._val[\"slots\"][0]),\n+                (\"cdr\", self._val[\"slots\"][1]),\n+            ]\n+\n \n def cons_pp_lookup(val):\n-  if str(val.type) == 'struct cons *':\n-    return cons_pp(val)\n-  else:\n-    return None\n+    if str(val.type) == \"struct cons *\":\n+        return cons_pp(val)\n+    else:\n+        return None\n+\n \n del gdb.pretty_printers[1:]\n gdb.pretty_printers.append(cons_pp_lookup)"
    },
    {
      "sha": "163fc865866c603c0de8ea08330dbbe2b84bd6c4",
      "filename": "gdb/testsuite/gdb.python/py-nested-maps.py",
      "status": "modified",
      "additions": 38,
      "deletions": 33,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-nested-maps.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-nested-maps.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-nested-maps.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,69 +19,71 @@\n import re\n import gdb\n \n-def _iterator1 (pointer, len):\n+\n+def _iterator1(pointer, len):\n     while len > 0:\n         map = pointer.dereference()\n-        yield ('', map['name'])\n-        yield ('', map.dereference())\n+        yield (\"\", map[\"name\"])\n+        yield (\"\", map.dereference())\n         pointer += 1\n         len -= 1\n \n-def _iterator2 (pointer1, pointer2, len):\n+\n+def _iterator2(pointer1, pointer2, len):\n     while len > 0:\n         yield (\"\", pointer1.dereference())\n         yield (\"\", pointer2.dereference())\n         pointer1 += 1\n         pointer2 += 1\n         len -= 1\n \n-class pp_map (object):\n+\n+class pp_map(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        if (self.val['show_header'] == 0):\n+        if self.val[\"show_header\"] == 0:\n             return None\n         else:\n             return \"pp_map\"\n \n     def children(self):\n-        return _iterator2(self.val['keys'],\n-                          self.val['values'],\n-                          self.val['length'])\n+        return _iterator2(self.val[\"keys\"], self.val[\"values\"], self.val[\"length\"])\n+\n+    def display_hint(self):\n+        return \"map\"\n \n-    def display_hint (self):\n-        return 'map'\n \n-class pp_map_map (object):\n+class pp_map_map(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        if (self.val['show_header'] == 0):\n+        if self.val[\"show_header\"] == 0:\n             return None\n         else:\n             return \"pp_map_map\"\n \n     def children(self):\n-        return _iterator1(self.val['values'],\n-                          self.val['length'])\n+        return _iterator1(self.val[\"values\"], self.val[\"length\"])\n \n-    def display_hint (self):\n-        return 'map'\n+    def display_hint(self):\n+        return \"map\"\n \n-def lookup_function (val):\n+\n+def lookup_function(val):\n     \"Look-up and return a pretty-printer that can print val.\"\n \n     # Get the type.\n     type = val.type\n \n     # If it points to a reference, get the reference.\n     if type.code == gdb.TYPE_CODE_REF:\n-        type = type.target ()\n+        type = type.target()\n \n     # Get the unqualified type, stripped of typedefs.\n-    type = type.unqualified ().strip_typedefs ()\n+    type = type.unqualified().strip_typedefs()\n \n     # Get the type name.\n     typename = type.tag\n@@ -93,14 +95,15 @@ def lookup_function (val):\n     # if a printer is registered for that type.  Return an\n     # instantiation of the printer if found.\n     for function in pretty_printers_dict:\n-        if function.match (typename):\n-            return pretty_printers_dict[function] (val)\n+        if function.match(typename):\n+            return pretty_printers_dict[function](val)\n \n     # Cannot find a pretty printer.  Return None.\n     return None\n \n+\n # Lookup a printer for VAL in the typedefs dict.\n-def lookup_typedefs_function (val):\n+def lookup_typedefs_function(val):\n     \"Look-up and return a pretty-printer that can print val (typedefs).\"\n \n     # Get the type.\n@@ -113,23 +116,25 @@ def lookup_typedefs_function (val):\n     # printer is registered for that type.  Return an instantiation of\n     # the printer if found.\n     for function in typedefs_pretty_printers_dict:\n-        if function.match (type.name):\n-            return typedefs_pretty_printers_dict[function] (val)\n+        if function.match(type.name):\n+            return typedefs_pretty_printers_dict[function](val)\n \n     # Cannot find a pretty printer.\n     return None\n \n-def register_pretty_printers ():\n-    pretty_printers_dict[re.compile ('^struct map_t$')] = pp_map\n-    pretty_printers_dict[re.compile ('^map_t$')] = pp_map\n-    pretty_printers_dict[re.compile ('^struct map_map_t$')] = pp_map_map\n-    pretty_printers_dict[re.compile ('^map_map_t$')] = pp_map_map\n+\n+def register_pretty_printers():\n+    pretty_printers_dict[re.compile(\"^struct map_t$\")] = pp_map\n+    pretty_printers_dict[re.compile(\"^map_t$\")] = pp_map\n+    pretty_printers_dict[re.compile(\"^struct map_map_t$\")] = pp_map_map\n+    pretty_printers_dict[re.compile(\"^map_map_t$\")] = pp_map_map\n+\n \n # Dict for struct types with typedefs fully stripped.\n pretty_printers_dict = {}\n # Dict for typedef types.\n typedefs_pretty_printers_dict = {}\n \n-register_pretty_printers ()\n-gdb.pretty_printers.append (lookup_function)\n-gdb.pretty_printers.append (lookup_typedefs_function)\n+register_pretty_printers()\n+gdb.pretty_printers.append(lookup_function)\n+gdb.pretty_printers.append(lookup_typedefs_function)"
    },
    {
      "sha": "88372e41a19278d4f39a2e76773d021325bf676e",
      "filename": "gdb/testsuite/gdb.python/py-objfile-script-gdb.py",
      "status": "modified",
      "additions": 15,
      "deletions": 11,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-objfile-script-gdb.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-objfile-script-gdb.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-objfile-script-gdb.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,27 +17,29 @@\n \n import re\n \n+\n class pp_ss:\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         return \"a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n-def lookup_function (val):\n+\n+def lookup_function(val):\n     \"Look-up and return a pretty-printer that can print val.\"\n \n     # Get the type.\n     type = val.type\n \n     # If it points to a reference, get the reference.\n     if type.code == gdb.TYPE_CODE_REF:\n-        type = type.target ()\n+        type = type.target()\n \n     # Get the unqualified type, stripped of typedefs.\n-    type = type.unqualified ().strip_typedefs ()\n+    type = type.unqualified().strip_typedefs()\n \n-    # Get the type name.    \n+    # Get the type name.\n     typename = type.tag\n \n     if typename == None:\n@@ -47,17 +49,19 @@ def lookup_function (val):\n     # if a printer is registered for that type.  Return an\n     # instantiation of the printer if found.\n     for function in pretty_printers_dict:\n-        if function.match (typename):\n-            return pretty_printers_dict[function] (val)\n-        \n+        if function.match(typename):\n+            return pretty_printers_dict[function](val)\n+\n     # Cannot find a pretty printer.  Return None.\n \n     return None\n \n-def register_pretty_printers ():\n-    pretty_printers_dict[re.compile ('^ss$')]  = pp_ss\n+\n+def register_pretty_printers():\n+    pretty_printers_dict[re.compile(\"^ss$\")] = pp_ss\n+\n \n pretty_printers_dict = {}\n \n-register_pretty_printers ()\n-gdb.current_progspace().pretty_printers.append (lookup_function)\n+register_pretty_printers()\n+gdb.current_progspace().pretty_printers.append(lookup_function)"
    },
    {
      "sha": "fddef703bfb3ddceb2094bf6a8506c9d0019bd41",
      "filename": "gdb/testsuite/gdb.python/py-pp-integral.py",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-integral.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-integral.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-pp-integral.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -27,7 +27,7 @@ def to_string(self):\n \n \n def time_sniffer(val):\n-    if hasattr(val.type, 'name') and val.type.name == \"time_t\":\n+    if hasattr(val.type, \"name\") and val.type.name == \"time_t\":\n         return TimePrinter(val)\n     return None\n "
    },
    {
      "sha": "4375430188499eef14e76dc79db12b979b7ec900",
      "filename": "gdb/testsuite/gdb.python/py-pp-maint.py",
      "status": "modified",
      "additions": 13,
      "deletions": 11,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-maint.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-maint.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-pp-maint.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -27,8 +27,7 @@ def __init__(self, val):\n             self.val = val\n \n         def to_string(self):\n-            return (\"x=<\" + str(self.val[\"x\"]) +\n-                    \"> y=<\" + str(self.val[\"y\"]) + \">\")\n+            return \"x=<\" + str(self.val[\"x\"]) + \"> y=<\" + str(self.val[\"y\"]) + \">\"\n \n     typename = gdb.types.get_basic_type(val.type).tag\n     # Note: typename could be None.\n@@ -37,7 +36,7 @@ def to_string(self):\n     return None\n \n \n-class pp_s (object):\n+class pp_s(object):\n     def __init__(self, val):\n         self.val = val\n \n@@ -49,7 +48,7 @@ def to_string(self):\n         return \"a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n \n-class pp_ss (object):\n+class pp_ss(object):\n     def __init__(self, val):\n         self.val = val\n \n@@ -60,15 +59,18 @@ def to_string(self):\n def build_pretty_printer():\n     pp = gdb.printing.RegexpCollectionPrettyPrinter(\"pp-test\")\n \n-    pp.add_printer('struct s', '^struct s$', pp_s)\n-    pp.add_printer('s', '^s$', pp_s)\n+    pp.add_printer(\"struct s\", \"^struct s$\", pp_s)\n+    pp.add_printer(\"s\", \"^s$\", pp_s)\n \n     # Use a lambda this time to exercise doing things this way.\n-    pp.add_printer('struct ss', '^struct ss$', lambda val: pp_ss(val))\n-    pp.add_printer('ss', '^ss$', lambda val: pp_ss(val))\n-\n-    pp.add_printer('enum flag_enum', '^flag_enum$',\n-                   gdb.printing.FlagEnumerationPrinter('enum flag_enum'))\n+    pp.add_printer(\"struct ss\", \"^struct ss$\", lambda val: pp_ss(val))\n+    pp.add_printer(\"ss\", \"^ss$\", lambda val: pp_ss(val))\n+\n+    pp.add_printer(\n+        \"enum flag_enum\",\n+        \"^flag_enum$\",\n+        gdb.printing.FlagEnumerationPrinter(\"enum flag_enum\"),\n+    )\n \n     return pp\n "
    },
    {
      "sha": "cd873bddfab2d387af1a1a0fe3a275432c4838b8",
      "filename": "gdb/testsuite/gdb.python/py-pp-re-notag.py",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-re-notag.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-re-notag.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-pp-re-notag.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -28,7 +28,7 @@ def to_string(self):\n \n def build_pretty_printer():\n     pp = gdb.printing.RegexpCollectionPrettyPrinter(\"pp-notag\")\n-    pp.add_printer('time_t', 'time_t', TimePrinter)\n+    pp.add_printer(\"time_t\", \"time_t\", TimePrinter)\n     return pp\n \n "
    },
    {
      "sha": "f34936e82a2f724a6fd4893274af51fbc7d97225",
      "filename": "gdb/testsuite/gdb.python/py-pp-registration.py",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-registration.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-pp-registration.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-pp-registration.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -27,8 +27,7 @@ def __init__(self, val):\n             self.val = val\n \n         def to_string(self):\n-            return (\"x=<\" + str(self.val[\"x\"]) +\n-                    \"> y=<\" + str(self.val[\"y\"]) + \">\")\n+            return \"x=<\" + str(self.val[\"x\"]) + \"> y=<\" + str(self.val[\"y\"]) + \">\"\n \n     typename = gdb.types.get_basic_type(val.type).tag\n     # Note: typename could be None.\n@@ -37,7 +36,7 @@ def to_string(self):\n     return None\n \n \n-class pp_s1 (object):\n+class pp_s1(object):\n     def __init__(self, val):\n         self.val = val\n \n@@ -47,7 +46,7 @@ def to_string(self):\n         return \"s1 a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n \n-class pp_s2 (object):\n+class pp_s2(object):\n     def __init__(self, val):\n         self.val = val\n \n@@ -60,8 +59,8 @@ def to_string(self):\n def build_pretty_printer1():\n     pp = gdb.printing.RegexpCollectionPrettyPrinter(\"pp-test\")\n \n-    pp.add_printer('struct s', '^struct s$', pp_s1)\n-    pp.add_printer('s', '^s$', pp_s1)\n+    pp.add_printer(\"struct s\", \"^struct s$\", pp_s1)\n+    pp.add_printer(\"s\", \"^s$\", pp_s1)\n \n     return pp\n \n@@ -72,9 +71,10 @@ def build_pretty_printer2():\n     # register_pretty_printer.\n     pp = gdb.printing.RegexpCollectionPrettyPrinter(\"pp-test\")\n \n-    pp.add_printer('struct s', '^struct s$', pp_s2)\n-    pp.add_printer('s', '^s$', pp_s2)\n+    pp.add_printer(\"struct s\", \"^struct s$\", pp_s2)\n+    pp.add_printer(\"s\", \"^s$\", pp_s2)\n \n     return pp\n \n+\n # Note: Registering the printers is done in the .exp file."
    },
    {
      "sha": "1a5b43fcf28f01cbef4a2116079768f126471d55",
      "filename": "gdb/testsuite/gdb.python/py-prettyprint.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-prettyprint.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-prettyprint.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-prettyprint.exp?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -127,7 +127,7 @@ proc run_lang_tests {exefile lang} {\n \t[multi_line \\\n \t     \"Traceback\\[^\\r\\n\\]+\" \\\n \t     \"\\\\s+File \\\"\\[^\\r\\n\\]+/py-prettyprint.py\\\", line \\[0-9\\]+, in display_hint\" \\\n-\t     \"\\\\s+raise Exception \\[^\\r\\n\\]+\" \\\n+\t     \"\\\\s+raise Exception\\[^\\r\\n\\]+\" \\\n \t     \"Exception: invalid object state found in display_hint\"]\n     gdb_test \"print c\" \\\n \t[multi_line \\"
    },
    {
      "sha": "84dbc3ba3a4e666f52bed78fc54bef51a0f5f52c",
      "filename": "gdb/testsuite/gdb.python/py-prettyprint.py",
      "status": "modified",
      "additions": 175,
      "deletions": 137,
      "changes": 312,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-prettyprint.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-prettyprint.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-prettyprint.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,102 +19,108 @@\n import re\n import gdb\n \n-def _iterator (pointer, len):\n+\n+def _iterator(pointer, len):\n     start = pointer\n     end = pointer + len\n     while pointer != end:\n-        yield ('[%d]' % int (pointer - start), pointer.dereference())\n+        yield (\"[%d]\" % int(pointer - start), pointer.dereference())\n         pointer += 1\n \n+\n # Same as _iterator but can be told to raise an exception.\n-def _iterator_except (pointer, len):\n+def _iterator_except(pointer, len):\n     start = pointer\n     end = pointer + len\n     while pointer != end:\n         if exception_flag:\n-            raise gdb.MemoryError ('hi bob')\n-        yield ('[%d]' % int (pointer - start), pointer.dereference())\n+            raise gdb.MemoryError(\"hi bob\")\n+        yield (\"[%d]\" % int(pointer - start), pointer.dereference())\n         pointer += 1\n \n+\n # Test returning a Value from a printer.\n-class string_print (object):\n+class string_print(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return self.val['whybother']['contents']\n+        return self.val[\"whybother\"][\"contents\"]\n \n-# Test a class-based printer.\n-class ContainerPrinter (object):\n \n+# Test a class-based printer.\n+class ContainerPrinter(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'container %s with %d elements' % (self.val['name'], self.val['len'])\n+        return \"container %s with %d elements\" % (self.val[\"name\"], self.val[\"len\"])\n \n     def children(self):\n-        return _iterator(self.val['elements'], self.val['len'])\n+        return _iterator(self.val[\"elements\"], self.val[\"len\"])\n \n-    def display_hint (self):\n-        if (self.val['is_map_p'] and self.val['is_array_p']):\n-            raise Exception (\"invalid object state found in display_hint\")\n+    def display_hint(self):\n+        if self.val[\"is_map_p\"] and self.val[\"is_array_p\"]:\n+            raise Exception(\"invalid object state found in display_hint\")\n \n-        if (self.val['is_map_p']):\n-            return 'map'\n-        elif (self.val['is_array_p']):\n-            return 'array'\n+        if self.val[\"is_map_p\"]:\n+            return \"map\"\n+        elif self.val[\"is_array_p\"]:\n+            return \"array\"\n         else:\n             return None\n \n+\n # Treats a container as array.\n-class ArrayPrinter (object):\n+class ArrayPrinter(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'array %s with %d elements' % (self.val['name'], self.val['len'])\n+        return \"array %s with %d elements\" % (self.val[\"name\"], self.val[\"len\"])\n \n     def children(self):\n-        return _iterator(self.val['elements'], self.val['len'])\n+        return _iterator(self.val[\"elements\"], self.val[\"len\"])\n+\n+    def display_hint(self):\n+        return \"array\"\n \n-    def display_hint (self):\n-        return 'array'\n \n # Flag to make NoStringContainerPrinter throw an exception.\n exception_flag = False\n \n # Test a printer where to_string is None\n-class NoStringContainerPrinter (object):\n+class NoStringContainerPrinter(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         return None\n \n     def children(self):\n-        return _iterator_except (self.val['elements'], self.val['len'])\n+        return _iterator_except(self.val[\"elements\"], self.val[\"len\"])\n+\n \n # See ToStringReturnsValueWrapper.\n class ToStringReturnsValueInner:\n-\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'Inner to_string {}'.format(int(self.val['val']))\n+        return \"Inner to_string {}\".format(int(self.val[\"val\"]))\n+\n \n # Test a printer that returns a gdb.Value in its to_string.  That gdb.Value\n # also has its own pretty-printer.\n class ToStringReturnsValueWrapper:\n-\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return self.val['inner']\n+        return self.val[\"inner\"]\n+\n \n-class pp_s (object):\n+class pp_s(object):\n     def __init__(self, val):\n         self.val = val\n \n@@ -125,168 +131,187 @@ def to_string(self):\n             raise Exception(\"&a(%s) != b(%s)\" % (str(a.address), str(b)))\n         return \" a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n-class pp_ss (object):\n+\n+class pp_ss(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         return \"a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n-class pp_sss (object):\n+\n+class pp_sss(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return \"a=<\" + str(self.val['a']) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n+        return \"a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n-class pp_multiple_virtual (object):\n-    def __init__ (self, val):\n+\n+class pp_multiple_virtual(object):\n+    def __init__(self, val):\n         self.val = val\n \n-    def to_string (self):\n-        return \"pp value variable is: \" + str (self.val['value'])\n+    def to_string(self):\n+        return \"pp value variable is: \" + str(self.val[\"value\"])\n+\n \n-class pp_vbase1 (object):\n-    def __init__ (self, val):\n+class pp_vbase1(object):\n+    def __init__(self, val):\n         self.val = val\n \n-    def to_string (self):\n+    def to_string(self):\n         return \"pp class name: \" + self.val.type.tag\n \n-class pp_nullstr (object):\n+\n+class pp_nullstr(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return self.val['s'].string(gdb.target_charset())\n+        return self.val[\"s\"].string(gdb.target_charset())\n+\n \n-class pp_ns (object):\n+class pp_ns(object):\n     \"Print a std::basic_string of some kind\"\n \n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        len = self.val['length']\n-        return self.val['null_str'].string (gdb.target_charset(), length = len)\n+        len = self.val[\"length\"]\n+        return self.val[\"null_str\"].string(gdb.target_charset(), length=len)\n+\n+    def display_hint(self):\n+        return \"string\"\n \n-    def display_hint (self):\n-        return 'string'\n \n pp_ls_encoding = None\n \n-class pp_ls (object):\n+\n+class pp_ls(object):\n     \"Print a std::basic_string of some kind\"\n \n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        length = self.val['len']\n+        length = self.val[\"len\"]\n         if pp_ls_encoding is not None:\n             if length >= 0:\n-                return self.val['lazy_str'].lazy_string(\n-                        encoding = pp_ls_encoding,\n-                        length = length)\n+                return self.val[\"lazy_str\"].lazy_string(\n+                    encoding=pp_ls_encoding, length=length\n+                )\n             else:\n-                return self.val['lazy_str'].lazy_string(\n-                        encoding = pp_ls_encoding)\n+                return self.val[\"lazy_str\"].lazy_string(encoding=pp_ls_encoding)\n         else:\n             if length >= 0:\n-                return self.val['lazy_str'].lazy_string(length = length)\n+                return self.val[\"lazy_str\"].lazy_string(length=length)\n             else:\n-                return self.val['lazy_str'].lazy_string()\n+                return self.val[\"lazy_str\"].lazy_string()\n+\n+    def display_hint(self):\n+        return \"string\"\n \n-    def display_hint (self):\n-        return 'string'\n \n-class pp_hint_error (object):\n+class pp_hint_error(object):\n     \"Throw error from display_hint\"\n \n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'hint_error_val'\n+        return \"hint_error_val\"\n \n-    def display_hint (self):\n+    def display_hint(self):\n         raise Exception(\"hint failed\")\n \n-class pp_children_as_list (object):\n+\n+class pp_children_as_list(object):\n     \"Throw error from display_hint\"\n \n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        return 'children_as_list_val'\n+        return \"children_as_list_val\"\n+\n+    def children(self):\n+        return [(\"one\", 1)]\n \n-    def children (self):\n-        return [('one', 1)]\n \n-class pp_outer (object):\n+class pp_outer(object):\n     \"Print struct outer\"\n \n-    def __init__ (self, val):\n+    def __init__(self, val):\n         self.val = val\n \n-    def to_string (self):\n-        return \"x = %s\" % self.val['x']\n+    def to_string(self):\n+        return \"x = %s\" % self.val[\"x\"]\n+\n+    def children(self):\n+        yield \"s\", self.val[\"s\"]\n+        yield \"x\", self.val[\"x\"]\n \n-    def children (self):\n-        yield 's', self.val['s']\n-        yield 'x', self.val['x']\n \n-class MemoryErrorString (object):\n+class MemoryErrorString(object):\n     \"Raise an error\"\n \n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n-        raise gdb.MemoryError (\"Cannot access memory.\")\n+        raise gdb.MemoryError(\"Cannot access memory.\")\n \n-    def display_hint (self):\n-        return 'string'\n+    def display_hint(self):\n+        return \"string\"\n \n-class pp_eval_type (object):\n+\n+class pp_eval_type(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         gdb.execute(\"bt\", to_string=True)\n-        return \"eval=<\" + str(gdb.parse_and_eval(\"eval_func (123456789, 2, 3, 4, 5, 6, 7, 8)\")) + \">\"\n+        return (\n+            \"eval=<\"\n+            + str(gdb.parse_and_eval(\"eval_func (123456789, 2, 3, 4, 5, 6, 7, 8)\"))\n+            + \">\"\n+        )\n+\n \n-class pp_int_typedef (object):\n+class pp_int_typedef(object):\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         return \"type=%s, val=%s\" % (self.val.type, int(self.val))\n \n-class pp_int_typedef3 (object):\n+\n+class pp_int_typedef3(object):\n     \"A printer without a to_string method\"\n \n     def __init__(self, val):\n         self.val = val\n \n     def children(self):\n-        yield 's', 27\n+        yield \"s\", 27\n \n-def lookup_function (val):\n+\n+def lookup_function(val):\n     \"Look-up and return a pretty-printer that can print val.\"\n \n     # Get the type.\n     type = val.type\n \n     # If it points to a reference, get the reference.\n     if type.code == gdb.TYPE_CODE_REF:\n-        type = type.target ()\n+        type = type.target()\n \n     # Get the unqualified type, stripped of typedefs.\n-    type = type.unqualified ().strip_typedefs ()\n+    type = type.unqualified().strip_typedefs()\n \n-    # Get the type name.    \n+    # Get the type name.\n     typename = type.tag\n \n     if typename == None:\n@@ -296,21 +321,24 @@ def lookup_function (val):\n     # if a printer is registered for that type.  Return an\n     # instantiation of the printer if found.\n     for function in pretty_printers_dict:\n-        if function.match (typename):\n-            return pretty_printers_dict[function] (val)\n-        \n+        if function.match(typename):\n+            return pretty_printers_dict[function](val)\n+\n     # Cannot find a pretty printer.  Return None.\n \n     return None\n \n-def disable_lookup_function ():\n+\n+def disable_lookup_function():\n     lookup_function.enabled = False\n \n-def enable_lookup_function ():\n+\n+def enable_lookup_function():\n     lookup_function.enabled = True\n \n+\n # Lookup a printer for VAL in the typedefs dict.\n-def lookup_typedefs_function (val):\n+def lookup_typedefs_function(val):\n     \"Look-up and return a pretty-printer that can print val (typedefs).\"\n \n     # Get the type.\n@@ -323,72 +351,82 @@ def lookup_typedefs_function (val):\n     # printer is registered for that type.  Return an instantiation of\n     # the printer if found.\n     for function in typedefs_pretty_printers_dict:\n-        if function.match (type.name):\n-            return typedefs_pretty_printers_dict[function] (val)\n+        if function.match(type.name):\n+            return typedefs_pretty_printers_dict[function](val)\n \n     # Cannot find a pretty printer.\n     return None\n \n-def register_pretty_printers ():\n-    pretty_printers_dict[re.compile ('^struct s$')]   = pp_s\n-    pretty_printers_dict[re.compile ('^s$')]   = pp_s\n-    pretty_printers_dict[re.compile ('^S$')]   = pp_s\n-\n-    pretty_printers_dict[re.compile ('^struct ss$')]  = pp_ss\n-    pretty_printers_dict[re.compile ('^ss$')]  = pp_ss\n-    pretty_printers_dict[re.compile ('^const S &$')]   = pp_s\n-    pretty_printers_dict[re.compile ('^SSS$')]  = pp_sss\n-    \n-    pretty_printers_dict[re.compile ('^VirtualTest$')] =  pp_multiple_virtual\n-    pretty_printers_dict[re.compile ('^Vbase1$')] =  pp_vbase1\n-\n-    pretty_printers_dict[re.compile ('^struct nullstr$')] = pp_nullstr\n-    pretty_printers_dict[re.compile ('^nullstr$')] = pp_nullstr\n-    \n+\n+def register_pretty_printers():\n+    pretty_printers_dict[re.compile(\"^struct s$\")] = pp_s\n+    pretty_printers_dict[re.compile(\"^s$\")] = pp_s\n+    pretty_printers_dict[re.compile(\"^S$\")] = pp_s\n+\n+    pretty_printers_dict[re.compile(\"^struct ss$\")] = pp_ss\n+    pretty_printers_dict[re.compile(\"^ss$\")] = pp_ss\n+    pretty_printers_dict[re.compile(\"^const S &$\")] = pp_s\n+    pretty_printers_dict[re.compile(\"^SSS$\")] = pp_sss\n+\n+    pretty_printers_dict[re.compile(\"^VirtualTest$\")] = pp_multiple_virtual\n+    pretty_printers_dict[re.compile(\"^Vbase1$\")] = pp_vbase1\n+\n+    pretty_printers_dict[re.compile(\"^struct nullstr$\")] = pp_nullstr\n+    pretty_printers_dict[re.compile(\"^nullstr$\")] = pp_nullstr\n+\n     # Note that we purposely omit the typedef names here.\n     # Printer lookup is based on canonical name.\n     # However, we do need both tagged and untagged variants, to handle\n     # both the C and C++ cases.\n-    pretty_printers_dict[re.compile ('^struct string_repr$')] = string_print\n-    pretty_printers_dict[re.compile ('^struct container$')] = ContainerPrinter\n-    pretty_printers_dict[re.compile ('^struct justchildren$')] = NoStringContainerPrinter\n-    pretty_printers_dict[re.compile ('^string_repr$')] = string_print\n-    pretty_printers_dict[re.compile ('^container$')] = ContainerPrinter\n-    pretty_printers_dict[re.compile ('^justchildren$')] = NoStringContainerPrinter\n+    pretty_printers_dict[re.compile(\"^struct string_repr$\")] = string_print\n+    pretty_printers_dict[re.compile(\"^struct container$\")] = ContainerPrinter\n+    pretty_printers_dict[re.compile(\"^struct justchildren$\")] = NoStringContainerPrinter\n+    pretty_printers_dict[re.compile(\"^string_repr$\")] = string_print\n+    pretty_printers_dict[re.compile(\"^container$\")] = ContainerPrinter\n+    pretty_printers_dict[re.compile(\"^justchildren$\")] = NoStringContainerPrinter\n+\n+    pretty_printers_dict[\n+        re.compile(\"^struct to_string_returns_value_inner$\")\n+    ] = ToStringReturnsValueInner\n+    pretty_printers_dict[\n+        re.compile(\"^to_string_returns_value_inner$\")\n+    ] = ToStringReturnsValueInner\n+    pretty_printers_dict[\n+        re.compile(\"^struct to_string_returns_value_wrapper$\")\n+    ] = ToStringReturnsValueWrapper\n+    pretty_printers_dict[\n+        re.compile(\"^to_string_returns_value_wrapper$\")\n+    ] = ToStringReturnsValueWrapper\n \n-    pretty_printers_dict[re.compile ('^struct to_string_returns_value_inner$')] = ToStringReturnsValueInner\n-    pretty_printers_dict[re.compile ('^to_string_returns_value_inner$')] = ToStringReturnsValueInner\n-    pretty_printers_dict[re.compile ('^struct to_string_returns_value_wrapper$')] = ToStringReturnsValueWrapper\n-    pretty_printers_dict[re.compile ('^to_string_returns_value_wrapper$')] = ToStringReturnsValueWrapper\n+    pretty_printers_dict[re.compile(\"^struct ns$\")] = pp_ns\n+    pretty_printers_dict[re.compile(\"^ns$\")] = pp_ns\n \n-    pretty_printers_dict[re.compile ('^struct ns$')]  = pp_ns\n-    pretty_printers_dict[re.compile ('^ns$')]  = pp_ns\n+    pretty_printers_dict[re.compile(\"^struct lazystring$\")] = pp_ls\n+    pretty_printers_dict[re.compile(\"^lazystring$\")] = pp_ls\n \n-    pretty_printers_dict[re.compile ('^struct lazystring$')]  = pp_ls\n-    pretty_printers_dict[re.compile ('^lazystring$')]  = pp_ls\n+    pretty_printers_dict[re.compile(\"^struct outerstruct$\")] = pp_outer\n+    pretty_printers_dict[re.compile(\"^outerstruct$\")] = pp_outer\n \n-    pretty_printers_dict[re.compile ('^struct outerstruct$')]  = pp_outer\n-    pretty_printers_dict[re.compile ('^outerstruct$')]  = pp_outer\n+    pretty_printers_dict[re.compile(\"^struct hint_error$\")] = pp_hint_error\n+    pretty_printers_dict[re.compile(\"^hint_error$\")] = pp_hint_error\n \n-    pretty_printers_dict[re.compile ('^struct hint_error$')]  = pp_hint_error\n-    pretty_printers_dict[re.compile ('^hint_error$')]  = pp_hint_error\n+    pretty_printers_dict[re.compile(\"^struct children_as_list$\")] = pp_children_as_list\n+    pretty_printers_dict[re.compile(\"^children_as_list$\")] = pp_children_as_list\n \n-    pretty_printers_dict[re.compile ('^struct children_as_list$')]  = pp_children_as_list\n-    pretty_printers_dict[re.compile ('^children_as_list$')]  = pp_children_as_list\n+    pretty_printers_dict[re.compile(\"^memory_error$\")] = MemoryErrorString\n \n-    pretty_printers_dict[re.compile ('^memory_error$')]  = MemoryErrorString\n+    pretty_printers_dict[re.compile(\"^eval_type_s$\")] = pp_eval_type\n \n-    pretty_printers_dict[re.compile ('^eval_type_s$')] = pp_eval_type\n+    typedefs_pretty_printers_dict[re.compile(\"^int_type$\")] = pp_int_typedef\n+    typedefs_pretty_printers_dict[re.compile(\"^int_type2$\")] = pp_int_typedef\n+    typedefs_pretty_printers_dict[re.compile(\"^int_type3$\")] = pp_int_typedef3\n \n-    typedefs_pretty_printers_dict[re.compile ('^int_type$')] = pp_int_typedef\n-    typedefs_pretty_printers_dict[re.compile ('^int_type2$')] = pp_int_typedef\n-    typedefs_pretty_printers_dict[re.compile ('^int_type3$')] = pp_int_typedef3\n \n # Dict for struct types with typedefs fully stripped.\n pretty_printers_dict = {}\n # Dict for typedef types.\n typedefs_pretty_printers_dict = {}\n \n-register_pretty_printers ()\n-gdb.pretty_printers.append (lookup_function)\n-gdb.pretty_printers.append (lookup_typedefs_function)\n+register_pretty_printers()\n+gdb.pretty_printers.append(lookup_function)\n+gdb.pretty_printers.append(lookup_typedefs_function)"
    },
    {
      "sha": "1545614468b62351a6234c2792fdbea91fe7b52b",
      "filename": "gdb/testsuite/gdb.python/py-recurse-unwind.py",
      "status": "modified",
      "additions": 15,
      "deletions": 13,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-recurse-unwind.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-recurse-unwind.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-recurse-unwind.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -16,7 +16,7 @@\n # This unwinder never does any unwinding.  It'll (pretend to) \"sniff\"\n # the frame and ultimately return None, indicating that actual unwinding\n # should be performed by some other unwinder.\n-# \n+#\n # But, prior to returning None, it will attempt to obtain the value\n # associated with a symbol via a call to gdb.parse_and_eval().  In\n # the course of doing this evaluation, GDB will potentially access\n@@ -28,23 +28,24 @@\n import gdb\n from gdb.unwinder import Unwinder\n \n+\n class TestUnwinder(Unwinder):\n \n     count = 0\n \n     @classmethod\n-    def reset_count (cls):\n+    def reset_count(cls):\n         cls.count = 0\n \n     @classmethod\n-    def inc_count (cls):\n+    def inc_count(cls):\n         cls.count += 1\n \n-    test = 'check_undefined_symbol'\n+    test = \"check_undefined_symbol\"\n \n     @classmethod\n-    def set_test (cls, test) :\n-       cls.test = test\n+    def set_test(cls, test):\n+        cls.test = test\n \n     def __init__(self):\n         Unwinder.__init__(self, \"test unwinder\")\n@@ -59,19 +60,19 @@ def __call__(self, pending_frame):\n         self.recurse_level += 1\n         TestUnwinder.inc_count()\n \n-        if TestUnwinder.test == 'check_user_reg_pc' :\n+        if TestUnwinder.test == \"check_user_reg_pc\":\n \n-            pc = pending_frame.read_register('pc')\n-            pc_as_int = int(pc.cast(gdb.lookup_type('int')))\n+            pc = pending_frame.read_register(\"pc\")\n+            pc_as_int = int(pc.cast(gdb.lookup_type(\"int\")))\n             # gdb.write(\"In unwinder: pc=%x\\n\" % pc_as_int)\n \n-        elif TestUnwinder.test == 'check_pae_pc' :\n+        elif TestUnwinder.test == \"check_pae_pc\":\n \n-            pc = gdb.parse_and_eval('$pc')\n-            pc_as_int = int(pc.cast(gdb.lookup_type('int')))\n+            pc = gdb.parse_and_eval(\"$pc\")\n+            pc_as_int = int(pc.cast(gdb.lookup_type(\"int\")))\n             # gdb.write(\"In unwinder: pc=%x\\n\" % pc_as_int)\n \n-        elif TestUnwinder.test == 'check_undefined_symbol' :\n+        elif TestUnwinder.test == \"check_undefined_symbol\":\n \n             try:\n                 val = gdb.parse_and_eval(\"undefined_symbol\")\n@@ -83,5 +84,6 @@ def __call__(self, pending_frame):\n \n         return None\n \n+\n gdb.unwinder.register_unwinder(None, TestUnwinder(), True)\n gdb.write(\"Python script imported\\n\")"
    },
    {
      "sha": "aac70a0a8f5e2d5686a65078a0bc4470cca363a4",
      "filename": "gdb/testsuite/gdb.python/py-section-script.py",
      "status": "modified",
      "additions": 15,
      "deletions": 11,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-section-script.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-section-script.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-section-script.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -17,27 +17,29 @@\n \n import re\n \n+\n class pp_ss:\n     def __init__(self, val):\n         self.val = val\n \n     def to_string(self):\n         return \"a=<\" + str(self.val[\"a\"]) + \"> b=<\" + str(self.val[\"b\"]) + \">\"\n \n-def lookup_function (val):\n+\n+def lookup_function(val):\n     \"Look-up and return a pretty-printer that can print val.\"\n \n     # Get the type.\n     type = val.type\n \n     # If it points to a reference, get the reference.\n     if type.code == gdb.TYPE_CODE_REF:\n-        type = type.target ()\n+        type = type.target()\n \n     # Get the unqualified type, stripped of typedefs.\n-    type = type.unqualified ().strip_typedefs ()\n+    type = type.unqualified().strip_typedefs()\n \n-    # Get the type name.    \n+    # Get the type name.\n     typename = type.tag\n \n     if typename == None:\n@@ -47,17 +49,19 @@ def lookup_function (val):\n     # if a printer is registered for that type.  Return an\n     # instantiation of the printer if found.\n     for function in pretty_printers_dict:\n-        if function.match (typename):\n-            return pretty_printers_dict[function] (val)\n-        \n+        if function.match(typename):\n+            return pretty_printers_dict[function](val)\n+\n     # Cannot find a pretty printer.  Return None.\n \n     return None\n \n-def register_pretty_printers ():\n-    pretty_printers_dict[re.compile ('^ss$')]  = pp_ss\n+\n+def register_pretty_printers():\n+    pretty_printers_dict[re.compile(\"^ss$\")] = pp_ss\n+\n \n pretty_printers_dict = {}\n \n-register_pretty_printers ()\n-gdb.current_progspace().pretty_printers.append (lookup_function)\n+register_pretty_printers()\n+gdb.current_progspace().pretty_printers.append(lookup_function)"
    },
    {
      "sha": "557707f8046d4290b6cbd97d7bbe0213cd057236",
      "filename": "gdb/testsuite/gdb.python/py-typeprint.py",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-typeprint.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-typeprint.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-typeprint.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,21 +15,24 @@\n \n import gdb\n \n+\n class Recognizer(object):\n     def __init__(self):\n         self.enabled = True\n \n     def recognize(self, type_obj):\n-        if type_obj.tag == 'basic_string':\n-            return 'string'\n+        if type_obj.tag == \"basic_string\":\n+            return \"string\"\n         return None\n \n+\n class StringTypePrinter(object):\n     def __init__(self):\n-        self.name = 'string'\n+        self.name = \"string\"\n         self.enabled = True\n \n     def instantiate(self):\n         return Recognizer()\n \n+\n gdb.type_printers.append(StringTypePrinter())"
    },
    {
      "sha": "3042472bff55a681be531c30cdc9a51490eebc81",
      "filename": "gdb/testsuite/gdb.python/py-unwind-inline.py",
      "status": "modified",
      "additions": 19,
      "deletions": 18,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-unwind-inline.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-unwind-inline.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-unwind-inline.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -23,49 +23,50 @@\n \n apb_global = None\n \n-class dummy_unwinder (Unwinder):\n-    \"\"\" A dummy unwinder that looks at a bunch of registers as part of\n+\n+class dummy_unwinder(Unwinder):\n+    \"\"\"A dummy unwinder that looks at a bunch of registers as part of\n     the unwinding process.\"\"\"\n \n-    class frame_id (object):\n-        \"\"\" Basic frame id.\"\"\"\n+    class frame_id(object):\n+        \"\"\"Basic frame id.\"\"\"\n \n-        def __init__ (self, sp, pc):\n-            \"\"\" Create the frame id.\"\"\"\n+        def __init__(self, sp, pc):\n+            \"\"\"Create the frame id.\"\"\"\n             self.sp = sp\n             self.pc = pc\n \n-    def __init__ (self):\n+    def __init__(self):\n         \"\"\"Create the unwinder.\"\"\"\n-        Unwinder.__init__ (self, \"dummy stack unwinder\")\n+        Unwinder.__init__(self, \"dummy stack unwinder\")\n         self.void_ptr_t = gdb.lookup_type(\"void\").pointer()\n         self.regs = None\n \n-    def get_regs (self, pending_frame):\n+    def get_regs(self, pending_frame):\n         \"\"\"Return a list of register names that should be read.  Only\n         gathers the list once, then caches the result.\"\"\"\n-        if (self.regs != None):\n+        if self.regs != None:\n             return self.regs\n \n         # Collect the names of all registers to read.\n-        self.regs = list (pending_frame.architecture ()\n-                          .register_names ())\n+        self.regs = list(pending_frame.architecture().register_names())\n \n         return self.regs\n \n-    def __call__ (self, pending_frame):\n+    def __call__(self, pending_frame):\n         \"\"\"Actually performs the unwind, or at least sniffs this frame\n         to see if the unwinder should claim it, which is never does.\"\"\"\n         try:\n-            for r in (self.get_regs (pending_frame)):\n-                v = pending_frame.read_register (r).cast (self.void_ptr_t)\n+            for r in self.get_regs(pending_frame):\n+                v = pending_frame.read_register(r).cast(self.void_ptr_t)\n         except:\n-            print (\"Dummy unwinder, exception\")\n+            print(\"Dummy unwinder, exception\")\n             raise\n \n         return None\n \n+\n # Register the ComRV stack unwinder.\n-gdb.unwinder.register_unwinder (None, dummy_unwinder (), True)\n+gdb.unwinder.register_unwinder(None, dummy_unwinder(), True)\n \n-print (\"Python script imported\")\n+print(\"Python script imported\")"
    },
    {
      "sha": "426fe76a705d3c34e4415f0e823083f565344cb2",
      "filename": "gdb/testsuite/gdb.python/py-unwind-maint.py",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-unwind-maint.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-unwind-maint.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-unwind-maint.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,6 +19,7 @@\n import gdb.types\n from gdb.unwinder import Unwinder, register_unwinder\n \n+\n class TestGlobalUnwinder(Unwinder):\n     def __init__(self):\n         super(TestGlobalUnwinder, self).__init__(\"global_unwinder\")\n@@ -27,6 +28,7 @@ def __call__(self, unwinder_info):\n         print(\"%s called\" % self.name)\n         return None\n \n+\n class TestProgspaceUnwinder(Unwinder):\n     def __init__(self, name):\n         super(TestProgspaceUnwinder, self).__init__(\"%s_ps_unwinder\" % name)\n@@ -35,6 +37,7 @@ def __call__(self, unwinder_info):\n         print(\"%s called\" % self.name)\n         return None\n \n+\n class TestObjfileUnwinder(Unwinder):\n     def __init__(self, name):\n         super(TestObjfileUnwinder, self).__init__(\"%s_obj_unwinder\" % name)\n@@ -44,7 +47,6 @@ def __call__(self, unwinder_info):\n         return None\n \n \n-\n gdb.unwinder.register_unwinder(None, TestGlobalUnwinder())\n saw_runtime_error = False\n try:\n@@ -54,6 +56,7 @@ def __call__(self, unwinder_info):\n if not saw_runtime_error:\n     raise RuntimeError(\"Missing runtime error from register_unwinder.\")\n gdb.unwinder.register_unwinder(None, TestGlobalUnwinder(), replace=True)\n-gdb.unwinder.register_unwinder(gdb.current_progspace(),\n-                               TestProgspaceUnwinder(\"py_unwind_maint\"))\n+gdb.unwinder.register_unwinder(\n+    gdb.current_progspace(), TestProgspaceUnwinder(\"py_unwind_maint\")\n+)\n print(\"Python script imported\")"
    },
    {
      "sha": "931e979d28ebed9b6af3ab562c7978fafa61ca87",
      "filename": "gdb/testsuite/gdb.python/py-unwind.py",
      "status": "modified",
      "additions": 14,
      "deletions": 12,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-unwind.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-unwind.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-unwind.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -16,8 +16,8 @@\n import gdb\n from gdb.unwinder import Unwinder\n \n-class FrameId(object):\n \n+class FrameId(object):\n     def __init__(self, sp, pc):\n         self._sp = sp\n         self._pc = pc\n@@ -30,6 +30,7 @@ def sp(self):\n     def pc(self):\n         return self._pc\n \n+\n class TestUnwinder(Unwinder):\n     AMD64_RBP = 6\n     AMD64_RSP = 7\n@@ -42,9 +43,9 @@ def __init__(self):\n         self._last_arch = None\n \n     # Update the register descriptor AMD64_RIP based on ARCH.\n-    def _update_register_descriptors (self, arch):\n-        if (self._last_arch != arch):\n-            TestUnwinder.AMD64_RIP = arch.registers ().find (\"rip\")\n+    def _update_register_descriptors(self, arch):\n+        if self._last_arch != arch:\n+            TestUnwinder.AMD64_RIP = arch.registers().find(\"rip\")\n             self._last_arch = arch\n \n     def _read_word(self, address):\n@@ -79,12 +80,12 @@ def __call__(self, pending_frame):\n         # Check that we can access the architecture of the pending\n         # frame, and that this is the same architecture as for the\n         # currently selected inferior.\n-        inf_arch = gdb.selected_inferior ().architecture ()\n-        frame_arch = pending_frame.architecture ()\n-        if (inf_arch != frame_arch):\n-            raise gdb.GdbError (\"architecture mismatch\")\n+        inf_arch = gdb.selected_inferior().architecture()\n+        frame_arch = pending_frame.architecture()\n+        if inf_arch != frame_arch:\n+            raise gdb.GdbError(\"architecture mismatch\")\n \n-        self._update_register_descriptors (frame_arch)\n+        self._update_register_descriptors(frame_arch)\n \n         try:\n             # NOTE: the registers in Unwinder API can be referenced\n@@ -102,15 +103,16 @@ def __call__(self, pending_frame):\n \n             frame_id = FrameId(\n                 pending_frame.read_register(TestUnwinder.AMD64_RSP),\n-                pending_frame.read_register(TestUnwinder.AMD64_RIP))\n+                pending_frame.read_register(TestUnwinder.AMD64_RIP),\n+            )\n             unwind_info = pending_frame.create_unwind_info(frame_id)\n-            unwind_info.add_saved_register(TestUnwinder.AMD64_RBP,\n-                                           previous_bp)\n+            unwind_info.add_saved_register(TestUnwinder.AMD64_RBP, previous_bp)\n             unwind_info.add_saved_register(\"rip\", previous_ip)\n             unwind_info.add_saved_register(\"rsp\", previous_sp)\n             return unwind_info\n         except (gdb.error, RuntimeError):\n             return None\n \n+\n gdb.unwinder.register_unwinder(None, TestUnwinder(), True)\n print(\"Python script imported\")"
    },
    {
      "sha": "1df3bd07e5279d417077054ce942f9af17790676",
      "filename": "gdb/testsuite/gdb.python/py-xmethods.py",
      "status": "modified",
      "additions": 62,
      "deletions": 74,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-xmethods.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/py-xmethods.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-xmethods.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -25,52 +25,55 @@\n \n \n def A_plus_A(obj, opr):\n-  print('From Python <A_plus_A>:')\n-  return obj['a'] + opr['a']\n+    print(\"From Python <A_plus_A>:\")\n+    return obj[\"a\"] + opr[\"a\"]\n \n \n def plus_plus_A(obj):\n-  print('From Python <plus_plus_A>:')\n-  return obj['a'] + 1\n+    print(\"From Python <plus_plus_A>:\")\n+    return obj[\"a\"] + 1\n \n \n def A_geta(obj):\n-  print('From Python <A_geta>:')\n-  return obj['a']\n+    print(\"From Python <A_geta>:\")\n+    return obj[\"a\"]\n \n \n def A_getarrayind(obj, index):\n-  print('From Python <A_getarrayind>:')\n-  return obj['array'][index]\n+    print(\"From Python <A_getarrayind>:\")\n+    return obj[\"array\"][index]\n+\n \n def A_indexoper(obj, index):\n-  return obj['array'][index].reference_value()\n+    return obj[\"array\"][index].reference_value()\n+\n \n def B_indexoper(obj, index):\n-  return obj['array'][index].const_value().reference_value()\n+    return obj[\"array\"][index].const_value().reference_value()\n \n \n-type_A = gdb.parse_and_eval('(dop::A *) 0').type.target()\n-type_B = gdb.parse_and_eval('(dop::B *) 0').type.target()\n-type_int = gdb.parse_and_eval('(int *) 0').type.target()\n+type_A = gdb.parse_and_eval(\"(dop::A *) 0\").type.target()\n+type_B = gdb.parse_and_eval(\"(dop::B *) 0\").type.target()\n+type_int = gdb.parse_and_eval(\"(int *) 0\").type.target()\n \n \n # The E class matcher and worker test two things:\n #   1. xmethod returning None.\n #   2. Matcher returning a list of workers.\n \n+\n class E_method_char_worker(XMethodWorker):\n     def __init__(self):\n         pass\n \n     def get_arg_types(self):\n-        return gdb.lookup_type('char')\n+        return gdb.lookup_type(\"char\")\n \n     def get_result_type(self, obj, arg):\n-        return gdb.lookup_type('void')\n+        return gdb.lookup_type(\"void\")\n \n     def __call__(self, obj, arg):\n-        print('From Python <E_method_char>')\n+        print(\"From Python <E_method_char>\")\n         return None\n \n \n@@ -79,25 +82,25 @@ def __init__(self):\n         pass\n \n     def get_arg_types(self):\n-        return gdb.lookup_type('int')\n+        return gdb.lookup_type(\"int\")\n \n     # Note: get_result_type method elided on purpose\n \n     def __call__(self, obj, arg):\n-        print('From Python <E_method_int>')\n+        print(\"From Python <E_method_int>\")\n         return None\n \n \n class E_method_matcher(XMethodMatcher):\n     def __init__(self):\n-        XMethodMatcher.__init__(self, 'E_methods')\n-        self.methods = [XMethod('method_int'), XMethod('method_char')]\n+        XMethodMatcher.__init__(self, \"E_methods\")\n+        self.methods = [XMethod(\"method_int\"), XMethod(\"method_char\")]\n \n     def match(self, class_type, method_name):\n         class_tag = class_type.unqualified().tag\n-        if not re.match('^dop::E$', class_tag):\n+        if not re.match(\"^dop::E$\", class_tag):\n             return None\n-        if not re.match('^method$', method_name):\n+        if not re.match(\"^method$\", method_name):\n             return None\n         workers = []\n         if self.methods[0].enabled:\n@@ -111,6 +114,7 @@ def match(self, class_type, method_name):\n # xmethod matchers and workers for template classes and template\n # methods.\n \n+\n class G_size_diff_worker(XMethodWorker):\n     def __init__(self, class_template_type, method_template_type):\n         self._class_template_type = class_template_type\n@@ -120,9 +124,8 @@ def get_arg_types(self):\n         pass\n \n     def __call__(self, obj):\n-        print('From Python G<>::size_diff()')\n-        return (self._method_template_type.sizeof -\n-                self._class_template_type.sizeof)\n+        print(\"From Python G<>::size_diff()\")\n+        return self._method_template_type.sizeof - self._class_template_type.sizeof\n \n \n class G_size_mul_worker(XMethodWorker):\n@@ -134,7 +137,7 @@ def get_arg_types(self):\n         pass\n \n     def __call__(self, obj):\n-        print('From Python G<>::size_mul()')\n+        print(\"From Python G<>::size_mul()\")\n         return self._class_template_type.sizeof * self._method_template_val\n \n \n@@ -147,16 +150,14 @@ def get_arg_types(self):\n         return self._method_template_type\n \n     def __call__(self, obj, arg):\n-        print('From Python G<>::mul()')\n-        return obj['t'] * arg\n+        print(\"From Python G<>::mul()\")\n+        return obj[\"t\"] * arg\n \n \n class G_methods_matcher(XMethodMatcher):\n     def __init__(self):\n-        XMethodMatcher.__init__(self, 'G_methods')\n-        self.methods = [XMethod('size_diff'),\n-                        XMethod('size_mul'),\n-                        XMethod('mul')]\n+        XMethodMatcher.__init__(self, \"G_methods\")\n+        self.methods = [XMethod(\"size_diff\"), XMethod(\"size_mul\"), XMethod(\"mul\")]\n \n     def _is_enabled(self, name):\n         for method in self.methods:\n@@ -165,30 +166,29 @@ def _is_enabled(self, name):\n \n     def match(self, class_type, method_name):\n         class_tag = class_type.unqualified().tag\n-        if not re.match('^dop::G<[ ]*[_a-zA-Z][ _a-zA-Z0-9]*>$',\n-                        class_tag):\n+        if not re.match(\"^dop::G<[ ]*[_a-zA-Z][ _a-zA-Z0-9]*>$\", class_tag):\n             return None\n         t_name = class_tag[7:-1]\n         try:\n             t_type = gdb.lookup_type(t_name)\n         except gdb.error:\n             return None\n-        if re.match('^size_diff<[ ]*[_a-zA-Z][ _a-zA-Z0-9]*>$', method_name):\n-            if not self._is_enabled('size_diff'):\n+        if re.match(\"^size_diff<[ ]*[_a-zA-Z][ _a-zA-Z0-9]*>$\", method_name):\n+            if not self._is_enabled(\"size_diff\"):\n                 return None\n             t1_name = method_name[10:-1]\n             try:\n                 t1_type = gdb.lookup_type(t1_name)\n                 return G_size_diff_worker(t_type, t1_type)\n             except gdb.error:\n                 return None\n-        if re.match('^size_mul<[ ]*[0-9]+[ ]*>$', method_name):\n-            if not self._is_enabled('size_mul'):\n+        if re.match(\"^size_mul<[ ]*[0-9]+[ ]*>$\", method_name):\n+            if not self._is_enabled(\"size_mul\"):\n                 return None\n             m_val = int(method_name[9:-1])\n             return G_size_mul_worker(t_type, m_val)\n-        if re.match('^mul<[ ]*[_a-zA-Z][ _a-zA-Z0-9]*>$', method_name):\n-            if not self._is_enabled('mul'):\n+        if re.match(\"^mul<[ ]*[_a-zA-Z][ _a-zA-Z0-9]*>$\", method_name):\n+            if not self._is_enabled(\"mul\"):\n                 return None\n             t1_name = method_name[4:-1]\n             try:\n@@ -199,41 +199,29 @@ def match(self, class_type, method_name):\n \n \n global_dm_list = [\n-    SimpleXMethodMatcher(r'A_plus_A',\n-                         r'^dop::A$',\n-                         r'operator\\+',\n-                         A_plus_A,\n-                         # This is a replacement, hence match the arg type\n-                         # exactly!\n-                         type_A.const().reference()),\n-    SimpleXMethodMatcher(r'plus_plus_A',\n-                         r'^dop::A$',\n-                         r'operator\\+\\+',\n-                         plus_plus_A),\n-    SimpleXMethodMatcher(r'A_geta',\n-                         r'^dop::A$',\n-                         r'^geta$',\n-                         A_geta),\n-    SimpleXMethodMatcher(r'A_getarrayind',\n-                         r'^dop::A$',\n-                         r'^getarrayind$',\n-                         A_getarrayind,\n-                         type_int),\n-    SimpleXMethodMatcher(r'A_indexoper',\n-                         r'^dop::A$',\n-                         r'operator\\[\\]',\n-                         A_indexoper,\n-                         type_int),\n-    SimpleXMethodMatcher(r'B_indexoper',\n-                         r'^dop::B$',\n-                         r'operator\\[\\]',\n-                         B_indexoper,\n-                         type_int)\n+    SimpleXMethodMatcher(\n+        r\"A_plus_A\",\n+        r\"^dop::A$\",\n+        r\"operator\\+\",\n+        A_plus_A,\n+        # This is a replacement, hence match the arg type\n+        # exactly!\n+        type_A.const().reference(),\n+    ),\n+    SimpleXMethodMatcher(r\"plus_plus_A\", r\"^dop::A$\", r\"operator\\+\\+\", plus_plus_A),\n+    SimpleXMethodMatcher(r\"A_geta\", r\"^dop::A$\", r\"^geta$\", A_geta),\n+    SimpleXMethodMatcher(\n+        r\"A_getarrayind\", r\"^dop::A$\", r\"^getarrayind$\", A_getarrayind, type_int\n+    ),\n+    SimpleXMethodMatcher(\n+        r\"A_indexoper\", r\"^dop::A$\", r\"operator\\[\\]\", A_indexoper, type_int\n+    ),\n+    SimpleXMethodMatcher(\n+        r\"B_indexoper\", r\"^dop::B$\", r\"operator\\[\\]\", B_indexoper, type_int\n+    ),\n ]\n \n for matcher in global_dm_list:\n     gdb.xmethod.register_xmethod_matcher(gdb, matcher)\n-gdb.xmethod.register_xmethod_matcher(gdb.current_progspace(),\n-                                     G_methods_matcher())\n-gdb.xmethod.register_xmethod_matcher(gdb.current_progspace(),\n-                                     E_method_matcher())\n+gdb.xmethod.register_xmethod_matcher(gdb.current_progspace(), G_methods_matcher())\n+gdb.xmethod.register_xmethod_matcher(gdb.current_progspace(), E_method_matcher())"
    },
    {
      "sha": "a2cff76536733284e78d69f7bc0cf62ec4cfc861",
      "filename": "gdb/testsuite/gdb.python/source2.py",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/source2.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/source2.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/source2.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -15,4 +15,4 @@\n #  You should have received a copy of the GNU General Public License\n #  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n-print ('y%ss' % 'e')\n+print(\"y%ss\" % \"e\")"
    },
    {
      "sha": "2510f13ca13e5d9e1ddb17ad5e0af78a7e165af8",
      "filename": "gdb/testsuite/gdb.python/tui-window-disabled.py",
      "status": "modified",
      "additions": 26,
      "deletions": 23,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/tui-window-disabled.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/tui-window-disabled.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/tui-window-disabled.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -28,62 +28,65 @@\n # A global place into which we can write the window title.\n titles_at_the_close = {}\n \n+\n class EventWindow:\n-    def __init__ (self, win):\n+    def __init__(self, win):\n         self._win = win\n         self._count = 0\n         win.title = \"This Is The Event Window\"\n-        self._stop_listener = lambda e : self._event ('stop', e)\n-        gdb.events.stop.connect (self._stop_listener)\n-        self._exit_listener = lambda e : self._event ('exit', e)\n-        gdb.events.exited.connect (self._exit_listener)\n+        self._stop_listener = lambda e: self._event(\"stop\", e)\n+        gdb.events.stop.connect(self._stop_listener)\n+        self._exit_listener = lambda e: self._event(\"exit\", e)\n+        gdb.events.exited.connect(self._exit_listener)\n         self._events = []\n \n         # Ensure we can erase and write to the window from the\n         # constructor, the window should be valid by this point.\n-        self._win.erase ()\n-        self._win.write (\"Hello world...\")\n+        self._win.erase()\n+        self._win.write(\"Hello world...\")\n \n-    def close (self):\n+    def close(self):\n         global cleanup_properly\n         global titles_at_the_close\n \n         # Ensure that window properties can be read within the close method.\n-        titles_at_the_close[self._win.title] = dict (width=self._win.width,\n-                                                     height=self._win.height)\n+        titles_at_the_close[self._win.title] = dict(\n+            width=self._win.width, height=self._win.height\n+        )\n \n         # The following calls are pretty pointless, but this ensures\n         # that we can erase and write to a window from the close\n         # method, the last moment a window should be valid.\n-        self._win.erase ()\n-        self._win.write (\"Goodbye cruel world...\")\n+        self._win.erase()\n+        self._win.write(\"Goodbye cruel world...\")\n \n         if cleanup_properly:\n             # Disconnect the listeners and delete the lambda functions.\n             # This removes cyclic references to SELF, and so alows SELF to\n             # be deleted.\n-            gdb.events.stop.disconnect (self._stop_listener)\n-            gdb.events.exited.disconnect (self._exit_listener)\n+            gdb.events.stop.disconnect(self._stop_listener)\n+            gdb.events.exited.disconnect(self._exit_listener)\n             self._stop_listener = None\n             self._exit_listener = None\n \n-    def _event (self, type, event):\n+    def _event(self, type, event):\n         global perform_valid_check\n         global update_title\n \n         self._count += 1\n-        self._events.insert (0, type)\n-        if not perform_valid_check or self._win.is_valid ():\n+        self._events.insert(0, type)\n+        if not perform_valid_check or self._win.is_valid():\n             if update_title:\n-                self._win.title = \"This Is The Event Window (\" + str (self._count) + \")\"\n+                self._win.title = \"This Is The Event Window (\" + str(self._count) + \")\"\n             else:\n-                self.render ()\n+                self.render()\n \n-    def render (self):\n-        self._win.erase ()\n+    def render(self):\n+        self._win.erase()\n         w = self._win.width\n         h = self._win.height\n-        for i in range (min (h, len (self._events))):\n-            self._win.write (self._events[i] + \"\\n\")\n+        for i in range(min(h, len(self._events))):\n+            self._win.write(self._events[i] + \"\\n\")\n+\n \n gdb.register_window_type(\"events\", EventWindow)"
    },
    {
      "sha": "db824e9883470cb9666863d032f8f16be6596172",
      "filename": "gdb/testsuite/gdb.python/tui-window.py",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/tui-window.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/gdb.python/tui-window.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/tui-window.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -19,6 +19,7 @@\n \n the_window = None\n \n+\n class TestWindow:\n     def __init__(self, win):\n         global the_window\n@@ -38,14 +39,17 @@ def render(self):\n     def remove_title(self):\n         del self.win.title\n \n+\n gdb.register_window_type(\"test\", TestWindow)\n \n # Call REMOVE_TITLE on the global window object.\n-def delete_window_title ():\n-    the_window.remove_title ()\n+def delete_window_title():\n+    the_window.remove_title()\n+\n \n # A TUI window \"constructor\" that always fails.\n def failwin(win):\n     raise RuntimeError(\"Whoops\")\n \n+\n gdb.register_window_type(\"fail\", failwin)"
    },
    {
      "sha": "29e053a1e1d30da51cc8fd426817b9fee4e99fdb",
      "filename": "gdb/testsuite/print-ts.py",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/print-ts.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d/gdb/testsuite/print-ts.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/print-ts.py?ref=13123da89a2c7e06a5312ca6b4b24c68ba1c6c2d",
      "patch": "@@ -38,11 +38,12 @@\n if len(sys.argv) > 1:\n     fmt = sys.argv[1]\n else:\n-    fmt = '[%b %d %H:%M:%S]'\n+    fmt = \"[%b %d %H:%M:%S]\"\n \n mypid = os.getpid()\n \n-for line in fileinput.input('-'):\n-    sys.stdout.write(\"{} [{}] {}\".format(datetime.datetime.now().strftime(fmt),\n-                                         mypid, line))\n+for line in fileinput.input(\"-\"):\n+    sys.stdout.write(\n+        \"{} [{}] {}\".format(datetime.datetime.now().strftime(fmt), mypid, line)\n+    )\n     sys.stdout.flush()"
    }
  ]
}