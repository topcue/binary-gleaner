{
  "sha": "ecbf5d4f9b716c50908f62cbb9917ed42d45a254",
  "node_id": "C_kwDOANOeidoAKGVjYmY1ZDRmOWI3MTZjNTA5MDhmNjJjYmI5OTE3ZWQ0MmQ0NWEyNTQ",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-10-04T16:56:43Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-10-11T19:03:52Z"
    },
    "message": "[ARM] Refactor pseudo register numbering\n\nThe pseudo register handling for ARM uses some hardcoded constants to\ndetermine types and names.  In preparation to the upcoming MVE support\npatch (that will add another pseudo register), this patch refactors and\nreorganizes things in order to simplify handling of future pseudo registers.\n\nWe keep track of the first pseudo register number in a group and the number of\npseudo registers in that group.\n\nRight now we only have the S and Q pseudo registers.",
    "tree": {
      "sha": "324ced2777be84902c17eed80ae86802d15fbb88",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/324ced2777be84902c17eed80ae86802d15fbb88"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ecbf5d4f9b716c50908f62cbb9917ed42d45a254",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ecbf5d4f9b716c50908f62cbb9917ed42d45a254",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ecbf5d4f9b716c50908f62cbb9917ed42d45a254",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ecbf5d4f9b716c50908f62cbb9917ed42d45a254/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dc22c61a1600639046407fb171613a3192fc0608",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dc22c61a1600639046407fb171613a3192fc0608",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dc22c61a1600639046407fb171613a3192fc0608"
    }
  ],
  "stats": {
    "total": 160,
    "additions": 115,
    "deletions": 45
  },
  "files": [
    {
      "sha": "11f5e87445af9daf5bbdc84834f89fcde091189a",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 104,
      "deletions": 41,
      "changes": 145,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ecbf5d4f9b716c50908f62cbb9917ed42d45a254/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ecbf5d4f9b716c50908f62cbb9917ed42d45a254/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=ecbf5d4f9b716c50908f62cbb9917ed42d45a254",
      "patch": "@@ -4122,20 +4122,57 @@ arm_neon_quad_type (struct gdbarch *gdbarch)\n   return tdep->neon_quad_type;\n }\n \n+/* Return true if REGNUM is a Q pseudo register.  Return false\n+   otherwise.\n+\n+   REGNUM is the raw register number and not a pseudo-relative register\n+   number.  */\n+\n+static bool\n+is_q_pseudo (struct gdbarch *gdbarch, int regnum)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n+  /* Q pseudo registers are available for NEON (Q0~Q15).  */\n+  if (tdep->have_q_pseudos\n+      && regnum >= tdep->q_pseudo_base\n+      && regnum < (tdep->q_pseudo_base + tdep->q_pseudo_count))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if REGNUM is a VFP S pseudo register.  Return false\n+   otherwise.\n+\n+   REGNUM is the raw register number and not a pseudo-relative register\n+   number.  */\n+\n+static bool\n+is_s_pseudo (struct gdbarch *gdbarch, int regnum)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n+  if (tdep->have_s_pseudos\n+      && regnum >= tdep->s_pseudo_base\n+      && regnum < (tdep->s_pseudo_base + tdep->s_pseudo_count))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return the GDB type object for the \"standard\" data type of data in\n    register N.  */\n \n static struct type *\n arm_register_type (struct gdbarch *gdbarch, int regnum)\n {\n-  int num_regs = gdbarch_num_regs (gdbarch);\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  if (gdbarch_tdep (gdbarch)->have_vfp_pseudos\n-      && regnum >= num_regs && regnum < num_regs + 32)\n+  if (is_s_pseudo (gdbarch, regnum))\n     return builtin_type (gdbarch)->builtin_float;\n \n-  if (gdbarch_tdep (gdbarch)->have_neon_pseudos\n-      && regnum >= num_regs + 32 && regnum < num_regs + 32 + 16)\n+  if (is_q_pseudo (gdbarch, regnum))\n     return arm_neon_quad_type (gdbarch);\n \n   /* If the target description has register information, we are only\n@@ -4147,15 +4184,15 @@ arm_register_type (struct gdbarch *gdbarch, int regnum)\n \n       if (regnum >= ARM_D0_REGNUM && regnum < ARM_D0_REGNUM + 32\n \t  && t->code () == TYPE_CODE_FLT\n-\t  && gdbarch_tdep (gdbarch)->have_neon)\n+\t  && tdep->have_neon)\n \treturn arm_neon_double_type (gdbarch);\n       else\n \treturn t;\n     }\n \n   if (regnum >= ARM_F0_REGNUM && regnum < ARM_F0_REGNUM + NUM_FREGS)\n     {\n-      if (!gdbarch_tdep (gdbarch)->have_fpa_registers)\n+      if (!tdep->have_fpa_registers)\n \treturn builtin_type (gdbarch)->builtin_void;\n \n       return arm_ext_type (gdbarch);\n@@ -8551,37 +8588,36 @@ show_disassembly_style_sfunc (struct ui_file *file, int from_tty,\n static const char *\n arm_register_name (struct gdbarch *gdbarch, int i)\n {\n-  const int num_regs = gdbarch_num_regs (gdbarch);\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  if (gdbarch_tdep (gdbarch)->have_vfp_pseudos\n-      && i >= num_regs && i < num_regs + 32)\n+  if (is_s_pseudo (gdbarch, i))\n     {\n-      static const char *const vfp_pseudo_names[] = {\n+      static const char *const s_pseudo_names[] = {\n \t\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\",\n \t\"s8\", \"s9\", \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\n \t\"s16\", \"s17\", \"s18\", \"s19\", \"s20\", \"s21\", \"s22\", \"s23\",\n \t\"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\", \"s31\",\n       };\n \n-      return vfp_pseudo_names[i - num_regs];\n+      return s_pseudo_names[i - tdep->s_pseudo_base];\n     }\n \n-  if (gdbarch_tdep (gdbarch)->have_neon_pseudos\n-      && i >= num_regs + 32 && i < num_regs + 32 + 16)\n+  if (is_q_pseudo (gdbarch, i))\n     {\n-      static const char *const neon_pseudo_names[] = {\n+      static const char *const q_pseudo_names[] = {\n \t\"q0\", \"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\",\n \t\"q8\", \"q9\", \"q10\", \"q11\", \"q12\", \"q13\", \"q14\", \"q15\",\n       };\n \n-      return neon_pseudo_names[i - num_regs - 32];\n+      return q_pseudo_names[i - tdep->q_pseudo_base];\n     }\n \n   if (i >= ARRAY_SIZE (arm_register_names))\n     /* These registers are only supported on targets which supply\n        an XML description.  */\n     return \"\";\n \n+  /* Non-pseudo registers.  */\n   return arm_register_names[i];\n }\n \n@@ -8719,15 +8755,20 @@ arm_pseudo_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n   int offset, double_regnum;\n \n   gdb_assert (regnum >= num_regs);\n-  regnum -= num_regs;\n \n-  if (gdbarch_tdep (gdbarch)->have_neon_pseudos && regnum >= 32 && regnum < 48)\n-    /* Quad-precision register.  */\n-    return arm_neon_quad_read (gdbarch, regcache, regnum - 32, buf);\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n+  if (is_q_pseudo (gdbarch, regnum))\n+    {\n+      /* Quad-precision register.  */\n+      return arm_neon_quad_read (gdbarch, regcache,\n+\t\t\t\t regnum - tdep->q_pseudo_base, buf);\n+    }\n   else\n     {\n       enum register_status status;\n \n+      regnum -= tdep->s_pseudo_base;\n       /* Single-precision register.  */\n       gdb_assert (regnum < 32);\n \n@@ -8787,13 +8828,18 @@ arm_pseudo_write (struct gdbarch *gdbarch, struct regcache *regcache,\n   int offset, double_regnum;\n \n   gdb_assert (regnum >= num_regs);\n-  regnum -= num_regs;\n \n-  if (gdbarch_tdep (gdbarch)->have_neon_pseudos && regnum >= 32 && regnum < 48)\n-    /* Quad-precision register.  */\n-    arm_neon_quad_write (gdbarch, regcache, regnum - 32, buf);\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n+  if (is_q_pseudo (gdbarch, regnum))\n+    {\n+      /* Quad-precision register.  */\n+      arm_neon_quad_write (gdbarch, regcache,\n+\t\t\t   regnum - tdep->q_pseudo_base, buf);\n+    }\n   else\n     {\n+      regnum -= tdep->s_pseudo_base;\n       /* Single-precision register.  */\n       gdb_assert (regnum < 32);\n \n@@ -8940,11 +8986,12 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   int i;\n   bool is_m = false;\n   int vfp_register_count = 0;\n-  bool have_vfp_pseudos = false, have_neon_pseudos = false;\n+  bool have_s_pseudos = false, have_q_pseudos = false;\n   bool have_wmmx_registers = false;\n   bool have_neon = false;\n   bool have_fpa_registers = true;\n   const struct target_desc *tdesc = info.target_desc;\n+  int register_count = ARM_NUM_REGS;\n \n   /* If we have an object to base this architecture on, try to determine\n      its ABI.  */\n@@ -9229,7 +9276,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t    return NULL;\n \n \t  if (tdesc_unnumbered_register (feature, \"s0\") == 0)\n-\t    have_vfp_pseudos = true;\n+\t    have_s_pseudos = true;\n \n \t  vfp_register_count = i;\n \n@@ -9248,7 +9295,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t\t their type; otherwise (normally) provide them with\n \t\t the default type.  */\n \t      if (tdesc_unnumbered_register (feature, \"q0\") == 0)\n-\t\thave_neon_pseudos = true;\n+\t\thave_q_pseudos = true;\n \n \t      have_neon = true;\n \t    }\n@@ -9298,8 +9345,8 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t      || vfp_register_count == 16\n \t      || vfp_register_count == 32);\n   tdep->vfp_register_count = vfp_register_count;\n-  tdep->have_vfp_pseudos = have_vfp_pseudos;\n-  tdep->have_neon_pseudos = have_neon_pseudos;\n+  tdep->have_s_pseudos = have_s_pseudos;\n+  tdep->have_q_pseudos = have_q_pseudos;\n   tdep->have_neon = have_neon;\n \n   arm_register_g_packet_guesses (gdbarch);\n@@ -9387,7 +9434,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Information about registers, etc.  */\n   set_gdbarch_sp_regnum (gdbarch, ARM_SP_REGNUM);\n   set_gdbarch_pc_regnum (gdbarch, ARM_PC_REGNUM);\n-  set_gdbarch_num_regs (gdbarch, ARM_NUM_REGS);\n+  set_gdbarch_num_regs (gdbarch, register_count);\n   set_gdbarch_register_type (gdbarch, arm_register_type);\n   set_gdbarch_register_reggroup_p (gdbarch, arm_register_reggroup_p);\n \n@@ -9475,21 +9522,29 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       set_tdesc_pseudo_register_name (gdbarch, arm_register_name);\n \n       tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n+      register_count = gdbarch_num_regs (gdbarch);\n \n       /* Override tdesc_register_type to adjust the types of VFP\n \t registers for NEON.  */\n       set_gdbarch_register_type (gdbarch, arm_register_type);\n     }\n \n-  if (have_vfp_pseudos)\n+  /* Initialize the pseudo register data.  */\n+  if (tdep->have_s_pseudos)\n     {\n-      /* NOTE: These are the only pseudo registers used by\n-\t the ARM target at the moment.  If more are added, a\n-\t little more care in numbering will be needed.  */\n+      /* VFP single precision pseudo registers (S0~S31).  */\n+      tdep->s_pseudo_base = register_count;\n+      tdep->s_pseudo_count = 32;\n+      int num_pseudos = tdep->s_pseudo_count;\n+\n+      if (tdep->have_q_pseudos)\n+\t{\n+\t  /* NEON quad precision pseudo registers (Q0~Q15).  */\n+\t  tdep->q_pseudo_base = register_count + num_pseudos;\n+\t  tdep->q_pseudo_count = 16;\n+\t  num_pseudos += tdep->q_pseudo_count;\n+\t}\n \n-      int num_pseudos = 32;\n-      if (have_neon_pseudos)\n-\tnum_pseudos += 16;\n       set_gdbarch_num_pseudo_regs (gdbarch, num_pseudos);\n       set_gdbarch_pseudo_register_read (gdbarch, arm_pseudo_read);\n       set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_write);\n@@ -9526,10 +9581,18 @@ arm_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n \t\t      (int) tdep->have_wmmx_registers);\n   fprintf_unfiltered (file, _(\"arm_dump_tdep: vfp_register_count = %i\\n\"),\n \t\t      (int) tdep->vfp_register_count);\n-  fprintf_unfiltered (file, _(\"arm_dump_tdep: have_vfp_pseudos = %i\\n\"),\n-\t\t      (int) tdep->have_vfp_pseudos);\n-  fprintf_unfiltered (file, _(\"arm_dump_tdep: have_neon_pseudos = %i\\n\"),\n-\t\t      (int) tdep->have_neon_pseudos);\n+  fprintf_unfiltered (file, _(\"arm_dump_tdep: have_s_pseudos = %s\\n\"),\n+\t\t      tdep->have_s_pseudos? \"true\" : \"false\");\n+  fprintf_unfiltered (file, _(\"arm_dump_tdep: s_pseudo_base = %i\\n\"),\n+\t\t      (int) tdep->s_pseudo_base);\n+  fprintf_unfiltered (file, _(\"arm_dump_tdep: s_pseudo_count = %i\\n\"),\n+\t\t      (int) tdep->s_pseudo_count);\n+  fprintf_unfiltered (file, _(\"arm_dump_tdep: have_q_pseudos = %s\\n\"),\n+\t\t      tdep->have_q_pseudos? \"true\" : \"false\");\n+  fprintf_unfiltered (file, _(\"arm_dump_tdep: q_pseudo_base = %i\\n\"),\n+\t\t      (int) tdep->q_pseudo_base);\n+  fprintf_unfiltered (file, _(\"arm_dump_tdep: q_pseudo_count = %i\\n\"),\n+\t\t      (int) tdep->q_pseudo_count);\n   fprintf_unfiltered (file, _(\"arm_dump_tdep: have_neon = %i\\n\"),\n \t\t      (int) tdep->have_neon);\n   fprintf_unfiltered (file, _(\"arm_dump_tdep: Lowest pc = 0x%lx\\n\"),"
    },
    {
      "sha": "63b89520c898fabbe50f1fffbb5c6dc86707e142",
      "filename": "gdb/arm-tdep.h",
      "status": "modified",
      "additions": 11,
      "deletions": 4,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ecbf5d4f9b716c50908f62cbb9917ed42d45a254/gdb/arm-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ecbf5d4f9b716c50908f62cbb9917ed42d45a254/gdb/arm-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.h?ref=ecbf5d4f9b716c50908f62cbb9917ed42d45a254",
      "patch": "@@ -100,11 +100,18 @@ struct gdbarch_tdep\n   /* The number of VFP registers reported by the target.  It is zero\n      if VFP registers are not supported.  */\n   int vfp_register_count;\n-  bool have_vfp_pseudos;\t/* Are we synthesizing the single precision\n+  bool have_s_pseudos;\t\t/* Are we synthesizing the single precision\n \t\t\t\t   VFP registers?  */\n-  bool have_neon_pseudos;\t/* Are we synthesizing the quad precision\n-\t\t\t\t   NEON registers?  Requires\n-\t\t\t\t   have_vfp_pseudos.  */\n+  int s_pseudo_base;\t\t/* Register number for the first S pseudo\n+\t\t\t\t   register.  */\n+  int s_pseudo_count;\t\t/* Number of S pseudo registers.  */\n+  bool have_q_pseudos;\t\t/* Are we synthesizing the quad precision\n+\t\t\t\t   Q (NEON or MVE) registers?  Requires\n+\t\t\t\t   have_s_pseudos.  */\n+  int q_pseudo_base;\t\t/* Register number for the first quad\n+\t\t\t\t   precision pseudo register.  */\n+  int q_pseudo_count;\t\t/* Number of quad precision pseudo\n+\t\t\t\t   registers.  */\n   bool have_neon;\t\t/* Do we have a NEON unit?  */\n \n   bool is_m;\t\t\t/* Does the target follow the \"M\" profile.  */"
    }
  ]
}