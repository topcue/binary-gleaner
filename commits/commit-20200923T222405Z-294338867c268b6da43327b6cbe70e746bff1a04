{
  "sha": "294338867c268b6da43327b6cbe70e746bff1a04",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mjk0MzM4ODY3YzI2OGI2ZGE0MzMyN2I2Y2JlNzBlNzQ2YmZmMWEwNA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-09-22T13:21:42Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-09-23T22:24:05Z"
    },
    "message": "PR26656, power10 libstdc++.so segfault in __cxxabiv1::__cxa_throw\n\nThis adds missing support for a power10 version of the __tls_get_addr\ncall stub implementing DT_PPC64_OPT PPC64_OPT_TLS.  Without this,\npower10 code using __tls_get_addr fails miserably at runtime unless\nthe --no-tls-get-addr-optimize option is given.\n\n\tPR 26656\n\t* elf64-ppc.c (plt_stub_size): Add \"odd\" param.  Use it with\n\tsize_power10_offset rather than calculating from start of stub.\n\tAdd size for notoc tls_get_addr_opt stub.\n\t(plt_stub_pad): Add \"odd\" param, pass to plt_stub_size.\n\t(build_tls_get_addr_head, build_tls_get_addr_tail): New functions.\n\t(build_tls_get_addr_stub): Delete.\n\t(ppc_build_one_stub): Use a temp for htab->params->stub_bfd.\n\tEmit notoc tls_get_addr_opt stub.  Move eh_frame code to\n\tsuit.  Adjust code to use bfd_tls_get_addr_head/tail in place\n\tof build_tls_get_addr_stub.\n\t(ppc_size_one_stub): Size notoc tls_get_addr_opt stub.\n\tAdjust plt_stub_size and plt_stub_pad calls.  Correct \"odd\"\n\twhen padding stub.  Size eh_frame for notoc stub too.\n\tCorrect lr_restore value.\n\t(ppc64_elf_relocate_section): Don't skip over first insn of\n\tnotoc tls_get_addr_opt stub.",
    "tree": {
      "sha": "5a92aab3be8a1fcc30d2778739111b09d2146a2c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5a92aab3be8a1fcc30d2778739111b09d2146a2c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/294338867c268b6da43327b6cbe70e746bff1a04",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/294338867c268b6da43327b6cbe70e746bff1a04",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/294338867c268b6da43327b6cbe70e746bff1a04",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/294338867c268b6da43327b6cbe70e746bff1a04/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c94053440e29421dd8846530da73f09c9ede2e0f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c94053440e29421dd8846530da73f09c9ede2e0f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c94053440e29421dd8846530da73f09c9ede2e0f"
    }
  ],
  "stats": {
    "total": 444,
    "additions": 259,
    "deletions": 185
  },
  "files": [
    {
      "sha": "f642403309bf1f93905cf674dfa823db574bc7c6",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294338867c268b6da43327b6cbe70e746bff1a04/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294338867c268b6da43327b6cbe70e746bff1a04/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=294338867c268b6da43327b6cbe70e746bff1a04",
      "patch": "@@ -1,3 +1,23 @@\n+2020-09-24  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 26656\n+\t* elf64-ppc.c (plt_stub_size): Add \"odd\" param.  Use it with\n+\tsize_power10_offset rather than calculating from start of stub.\n+\tAdd size for notoc tls_get_addr_opt stub.\n+\t(plt_stub_pad): Add \"odd\" param, pass to plt_stub_size.\n+\t(build_tls_get_addr_head, build_tls_get_addr_tail): New functions.\n+\t(build_tls_get_addr_stub): Delete.\n+\t(ppc_build_one_stub): Use a temp for htab->params->stub_bfd.\n+\tEmit notoc tls_get_addr_opt stub.  Move eh_frame code to\n+\tsuit.  Adjust code to use bfd_tls_get_addr_head/tail in place\n+\tof build_tls_get_addr_stub.\n+\t(ppc_size_one_stub): Size notoc tls_get_addr_opt stub.\n+\tAdjust plt_stub_size and plt_stub_pad calls.  Correct \"odd\"\n+\twhen padding stub.  Size eh_frame for notoc stub too.\n+\tCorrect lr_restore value.\n+\t(ppc64_elf_relocate_section): Don't skip over first insn of\n+\tnotoc tls_get_addr_opt stub.\n+\n 2020-09-24  Alan Modra  <amodra@gmail.com>\n \n \tPR 26655"
    },
    {
      "sha": "320717cb4539a28ce807c161b98d1f92f071a7c1",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 239,
      "deletions": 185,
      "changes": 424,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294338867c268b6da43327b6cbe70e746bff1a04/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294338867c268b6da43327b6cbe70e746bff1a04/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=294338867c268b6da43327b6cbe70e746bff1a04",
      "patch": "@@ -10842,62 +10842,60 @@ eh_advance_size (unsigned int delta)\n static inline unsigned int\n plt_stub_size (struct ppc_link_hash_table *htab,\n \t       struct ppc_stub_hash_entry *stub_entry,\n-\t       bfd_vma off)\n+\t       bfd_vma off,\n+\t       unsigned int odd)\n {\n   unsigned size;\n \n   if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)\n     {\n       if (htab->params->power10_stubs != 0)\n-\t{\n-\t  bfd_vma start = (stub_entry->stub_offset\n-\t\t\t   + stub_entry->group->stub_sec->output_offset\n-\t\t\t   + stub_entry->group->stub_sec->output_section->vma);\n-\t  if (stub_entry->stub_type > ppc_stub_plt_call_notoc)\n-\t    start += 4;\n-\t  size = 8 + size_power10_offset (off, start & 4);\n-\t}\n+\tsize = 8 + size_power10_offset (off, odd);\n       else\n \tsize = 8 + size_offset (off - 8);\n       if (stub_entry->stub_type > ppc_stub_plt_call_notoc)\n \tsize += 4;\n-      return size;\n     }\n-\n-  size = 12;\n-  if (ALWAYS_EMIT_R2SAVE\n-      || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n-    size += 4;\n-  if (PPC_HA (off) != 0)\n-    size += 4;\n-  if (htab->opd_abi)\n+  else\n     {\n-      size += 4;\n-      if (htab->params->plt_static_chain)\n+      size = 12;\n+      if (ALWAYS_EMIT_R2SAVE\n+\t  || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n \tsize += 4;\n-      if (htab->params->plt_thread_safe\n-\t  && htab->elf.dynamic_sections_created\n-\t  && stub_entry->h != NULL\n-\t  && stub_entry->h->elf.dynindx != -1)\n-\tsize += 8;\n-      if (PPC_HA (off + 8 + 8 * htab->params->plt_static_chain) != PPC_HA (off))\n+      if (PPC_HA (off) != 0)\n \tsize += 4;\n+      if (htab->opd_abi)\n+\t{\n+\t  size += 4;\n+\t  if (htab->params->plt_static_chain)\n+\t    size += 4;\n+\t  if (htab->params->plt_thread_safe\n+\t      && htab->elf.dynamic_sections_created\n+\t      && stub_entry->h != NULL\n+\t      && stub_entry->h->elf.dynindx != -1)\n+\t    size += 8;\n+\t  if (PPC_HA (off + 8 + 8 * htab->params->plt_static_chain)\n+\t      != PPC_HA (off))\n+\t    size += 4;\n+\t}\n     }\n   if (stub_entry->h != NULL\n       && is_tls_get_addr (&stub_entry->h->elf, htab)\n       && htab->params->tls_get_addr_opt)\n     {\n-      if (htab->params->no_tls_get_addr_regsave)\n+      if (!htab->params->no_tls_get_addr_regsave)\n \t{\n-\t  size += 7 * 4;\n-\t  if (stub_entry->stub_type == ppc_stub_plt_call_r2save)\n-\t    size += 6 * 4;\n+\t  size += 30 * 4;\n+\t  if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t      || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t    size += 4;\n \t}\n       else\n \t{\n-\t  size += 30 * 4;\n-\t  if (stub_entry->stub_type == ppc_stub_plt_call_r2save)\n-\t    size += 4;\n+\t  size += 7 * 4;\n+\t  if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t      || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t    size += 6 * 4;\n \t}\n     }\n   return size;\n@@ -10912,7 +10910,8 @@ plt_stub_size (struct ppc_link_hash_table *htab,\n static inline unsigned int\n plt_stub_pad (struct ppc_link_hash_table *htab,\n \t      struct ppc_stub_hash_entry *stub_entry,\n-\t      bfd_vma plt_off)\n+\t      bfd_vma plt_off,\n+\t      unsigned int odd)\n {\n   int stub_align;\n   unsigned stub_size;\n@@ -10927,7 +10926,7 @@ plt_stub_pad (struct ppc_link_hash_table *htab,\n     }\n \n   stub_align = 1 << -htab->params->plt_stub_align;\n-  stub_size = plt_stub_size (htab, stub_entry, plt_off);\n+  stub_size = plt_stub_size (htab, stub_entry, plt_off, odd);\n   if (((stub_off + stub_size - 1) & -stub_align) - (stub_off & -stub_align)\n       > ((stub_size - 1) & -stub_align))\n     return stub_align - (stub_off & (stub_align - 1));\n@@ -11123,14 +11122,12 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n #define MR_R3_R0\t0x7c030378\n #define BCTRL\t\t0x4e800421\n \n-static inline bfd_byte *\n-build_tls_get_addr_stub (struct ppc_link_hash_table *htab,\n+static bfd_byte *\n+build_tls_get_addr_head (struct ppc_link_hash_table *htab,\n \t\t\t struct ppc_stub_hash_entry *stub_entry,\n-\t\t\t bfd_byte *p, bfd_vma offset, Elf_Internal_Rela *r)\n+\t\t\t bfd_byte *p)\n {\n   bfd *obfd = htab->params->stub_bfd;\n-  bfd_byte *loc = p;\n-  unsigned int i;\n \n   bfd_put_32 (obfd, LD_R0_0R3 + 0, p),\t\tp += 4;\n   bfd_put_32 (obfd, LD_R12_0R3 + 8, p),\t\tp += 4;\n@@ -11139,21 +11136,43 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,\n   bfd_put_32 (obfd, ADD_R3_R12_R13, p),\t\tp += 4;\n   bfd_put_32 (obfd, BEQLR, p),\t\t\tp += 4;\n   bfd_put_32 (obfd, MR_R3_R0, p),\t\tp += 4;\n-  if (htab->params->no_tls_get_addr_regsave)\n-    {\n-      if (r != NULL)\n-\tr[0].r_offset += 7 * 4;\n-      if (stub_entry->stub_type != ppc_stub_plt_call_r2save)\n-\treturn build_plt_stub (htab, stub_entry, p, offset, r);\n \n+  if (!htab->params->no_tls_get_addr_regsave)\n+    p = tls_get_addr_prologue (obfd, p, htab);\n+  else if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n+    {\n       bfd_put_32 (obfd, MFLR_R0, p);\n       p += 4;\n       bfd_put_32 (obfd, STD_R0_0R1 + STK_LINKER (htab), p);\n       p += 4;\n+    }\n+  return p;\n+}\n \n-      if (r != NULL)\n-\tr[0].r_offset += 2 * 4;\n-      p = build_plt_stub (htab, stub_entry, p, offset, r);\n+static bfd_byte *\n+build_tls_get_addr_tail (struct ppc_link_hash_table *htab,\n+\t\t\t struct ppc_stub_hash_entry *stub_entry,\n+\t\t\t bfd_byte *p,\n+\t\t\t bfd_byte *loc)\n+{\n+  bfd *obfd = htab->params->stub_bfd;\n+\n+  if (!htab->params->no_tls_get_addr_regsave)\n+    {\n+      bfd_put_32 (obfd, BCTRL, p - 4);\n+\n+      if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t  || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t{\n+\t  bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);\n+\t  p += 4;\n+\t}\n+      p = tls_get_addr_epilogue (obfd, p, htab);\n+    }\n+  else if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n+    {\n       bfd_put_32 (obfd, BCTRL, p - 4);\n \n       bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);\n@@ -11165,24 +11184,6 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,\n       bfd_put_32 (obfd, BLR, p);\n       p += 4;\n     }\n-  else\n-    {\n-      p = tls_get_addr_prologue (obfd, p, htab);\n-\n-      if (r != NULL)\n-\tr[0].r_offset += 18 * 4;\n-\n-      p = build_plt_stub (htab, stub_entry, p, offset, r);\n-      bfd_put_32 (obfd, BCTRL, p - 4);\n-\n-      if (stub_entry->stub_type == ppc_stub_plt_call_r2save)\n-\t{\n-\t  bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);\n-\t  p += 4;\n-\t}\n-\n-      p = tls_get_addr_epilogue (obfd, p, htab);\n-    }\n \n   if (htab->glink_eh_frame != NULL\n       && htab->glink_eh_frame->size != 0)\n@@ -11191,21 +11192,11 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,\n \n       base = htab->glink_eh_frame->contents + stub_entry->group->eh_base + 17;\n       eh = base + stub_entry->group->eh_size;\n-      if (htab->params->no_tls_get_addr_regsave)\n-\t{\n-\t  unsigned int lr_used, delta;\n-\t  lr_used = stub_entry->stub_offset + (p - 20 - loc);\n-\t  delta = lr_used - stub_entry->group->lr_restore;\n-\t  stub_entry->group->lr_restore = lr_used + 16;\n-\t  eh = eh_advance (htab->elf.dynobj, eh, delta);\n-\t  *eh++ = DW_CFA_offset_extended_sf;\n-\t  *eh++ = 65;\n-\t  *eh++ = -(STK_LINKER (htab) / 8) & 0x7f;\n-\t  *eh++ = DW_CFA_advance_loc + 4;\n-\t}\n-      else\n+\n+      if (!htab->params->no_tls_get_addr_regsave)\n \t{\n-\t  unsigned int cfa_updt, delta;\n+\t  unsigned int cfa_updt, delta, i;\n+\n \t  /* After the bctrl, lr has been modified so we need to emit\n \t     .eh_frame info saying the return address is on the stack.  In\n \t     fact we must put the EH info at or before the call rather\n@@ -11244,10 +11235,27 @@ build_tls_get_addr_stub (struct ppc_link_hash_table *htab,\n \t  for (i = 4; i < 12; i++)\n \t    *eh++ = DW_CFA_restore + i;\n \t  *eh++ = DW_CFA_advance_loc + 2;\n+\t  *eh++ = DW_CFA_restore_extended;\n+\t  *eh++ = 65;\n+\t  stub_entry->group->eh_size = eh - base;\n+\t}\n+      else if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t       || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t{\n+\t  unsigned int lr_used, delta;\n+\n+\t  lr_used = stub_entry->stub_offset + (p - 20 - loc);\n+\t  delta = lr_used - stub_entry->group->lr_restore;\n+\t  stub_entry->group->lr_restore = lr_used + 16;\n+\t  eh = eh_advance (htab->elf.dynobj, eh, delta);\n+\t  *eh++ = DW_CFA_offset_extended_sf;\n+\t  *eh++ = 65;\n+\t  *eh++ = -(STK_LINKER (htab) / 8) & 0x7f;\n+\t  *eh++ = DW_CFA_advance_loc + 4;\n+\t  *eh++ = DW_CFA_restore_extended;\n+\t  *eh++ = 65;\n+\t  stub_entry->group->eh_size = eh - base;\n \t}\n-      *eh++ = DW_CFA_restore_extended;\n-      *eh++ = 65;\n-      stub_entry->group->eh_size = eh - base;\n     }\n   return p;\n }\n@@ -11381,13 +11389,15 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n   struct ppc_branch_hash_entry *br_entry;\n   struct bfd_link_info *info;\n   struct ppc_link_hash_table *htab;\n+  bfd *obfd;\n   bfd_byte *loc;\n   bfd_byte *p, *relp;\n   bfd_vma targ, off;\n   Elf_Internal_Rela *r;\n   asection *plt;\n   int num_rel;\n   int odd;\n+  bfd_boolean is_tga;\n \n   /* Massage our args to the form they really have.  */\n   stub_entry = (struct ppc_stub_hash_entry *) gen_entry;\n@@ -11437,6 +11447,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       off = targ - off;\n \n       p = loc;\n+      obfd = htab->params->stub_bfd;\n       if (stub_entry->stub_type == ppc_stub_long_branch_r2off)\n \t{\n \t  bfd_vma r2off = get_r2off (info, stub_entry);\n@@ -11446,23 +11457,21 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      htab->stub_error = TRUE;\n \t      return FALSE;\n \t    }\n-\t  bfd_put_32 (htab->params->stub_bfd, STD_R2_0R1 + STK_TOC (htab), p);\n+\t  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);\n \t  p += 4;\n \t  if (PPC_HA (r2off) != 0)\n \t    {\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  ADDIS_R2_R2 | PPC_HA (r2off), p);\n+\t      bfd_put_32 (obfd, ADDIS_R2_R2 | PPC_HA (r2off), p);\n \t      p += 4;\n \t    }\n \t  if (PPC_LO (r2off) != 0)\n \t    {\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  ADDI_R2_R2 | PPC_LO (r2off), p);\n+\t      bfd_put_32 (obfd, ADDI_R2_R2 | PPC_LO (r2off), p);\n \t      p += 4;\n \t    }\n \t  off -= p - loc;\n \t}\n-      bfd_put_32 (htab->params->stub_bfd, B_DOT | (off & 0x3fffffc), p);\n+      bfd_put_32 (obfd, B_DOT | (off & 0x3fffffc), p);\n       p += 4;\n \n       if (off + (1 << 25) >= (bfd_vma) (1 << 26))\n@@ -11588,19 +11597,17 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t}\n \n       p = loc;\n+      obfd = htab->params->stub_bfd;\n       if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)\n \t{\n \t  if (PPC_HA (off) != 0)\n \t    {\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  ADDIS_R12_R2 | PPC_HA (off), p);\n+\t      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (off), p);\n \t      p += 4;\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  LD_R12_0R12 | PPC_LO (off), p);\n+\t      bfd_put_32 (obfd, LD_R12_0R12 | PPC_LO (off), p);\n \t    }\n \t  else\n-\t    bfd_put_32 (htab->params->stub_bfd,\n-\t\t\tLD_R12_0R2 | PPC_LO (off), p);\n+\t    bfd_put_32 (obfd, LD_R12_0R2 | PPC_LO (off), p);\n \t}\n       else\n \t{\n@@ -11612,36 +11619,32 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      return FALSE;\n \t    }\n \n-\t  bfd_put_32 (htab->params->stub_bfd, STD_R2_0R1 + STK_TOC (htab), p);\n+\t  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);\n \t  p += 4;\n \t  if (PPC_HA (off) != 0)\n \t    {\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  ADDIS_R12_R2 | PPC_HA (off), p);\n+\t      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (off), p);\n \t      p += 4;\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  LD_R12_0R12 | PPC_LO (off), p);\n+\t      bfd_put_32 (obfd, LD_R12_0R12 | PPC_LO (off), p);\n \t    }\n \t  else\n-\t    bfd_put_32 (htab->params->stub_bfd, LD_R12_0R2 | PPC_LO (off), p);\n+\t    bfd_put_32 (obfd, LD_R12_0R2 | PPC_LO (off), p);\n \n \t  if (PPC_HA (r2off) != 0)\n \t    {\n \t      p += 4;\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  ADDIS_R2_R2 | PPC_HA (r2off), p);\n+\t      bfd_put_32 (obfd, ADDIS_R2_R2 | PPC_HA (r2off), p);\n \t    }\n \t  if (PPC_LO (r2off) != 0)\n \t    {\n \t      p += 4;\n-\t      bfd_put_32 (htab->params->stub_bfd,\n-\t\t\t  ADDI_R2_R2 | PPC_LO (r2off), p);\n+\t      bfd_put_32 (obfd, ADDI_R2_R2 | PPC_LO (r2off), p);\n \t    }\n \t}\n       p += 4;\n-      bfd_put_32 (htab->params->stub_bfd, MTCTR_R12, p);\n+      bfd_put_32 (obfd, MTCTR_R12, p);\n       p += 4;\n-      bfd_put_32 (htab->params->stub_bfd, BCTR, p);\n+      bfd_put_32 (obfd, BCTR, p);\n       p += 4;\n       break;\n \n@@ -11655,12 +11658,22 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       off = (stub_entry->stub_offset\n \t     + stub_entry->group->stub_sec->output_offset\n \t     + stub_entry->group->stub_sec->output_section->vma);\n+      obfd = htab->params->stub_bfd;\n+      is_tga = ((stub_entry->stub_type == ppc_stub_plt_call_notoc\n+\t\t || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t\t&& is_tls_get_addr (&stub_entry->h->elf, htab)\n+\t\t&& htab->params->tls_get_addr_opt);\n+      if (is_tga)\n+\t{\n+\t  p = build_tls_get_addr_head (htab, stub_entry, p);\n+\t  off += p - loc;\n+\t}\n       if (stub_entry->stub_type == ppc_stub_long_branch_both\n \t  || stub_entry->stub_type == ppc_stub_plt_branch_both\n \t  || stub_entry->stub_type == ppc_stub_plt_call_both)\n \t{\n \t  off += 4;\n-\t  bfd_put_32 (htab->params->stub_bfd, STD_R2_0R1 + STK_TOC (htab), p);\n+\t  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);\n \t  p += 4;\n \t}\n       if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)\n@@ -11693,17 +11706,39 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       if (htab->params->power10_stubs != 0)\n \t{\n \t  bfd_boolean load = stub_entry->stub_type >= ppc_stub_plt_call_notoc;\n-\t  p = build_power10_offset (htab->params->stub_bfd, p, off, odd, load);\n+\t  p = build_power10_offset (obfd, p, off, odd, load);\n \t}\n       else\n \t{\n+\t  if (htab->glink_eh_frame != NULL\n+\t      && htab->glink_eh_frame->size != 0)\n+\t    {\n+\t      bfd_byte *base, *eh;\n+\t      unsigned int lr_used, delta;\n+\n+\t      base = (htab->glink_eh_frame->contents\n+\t\t      + stub_entry->group->eh_base + 17);\n+\t      eh = base + stub_entry->group->eh_size;\n+\t      lr_used = stub_entry->stub_offset + (p - loc) + 8;\n+\t      delta = lr_used - stub_entry->group->lr_restore;\n+\t      stub_entry->group->lr_restore = lr_used + 8;\n+\t      eh = eh_advance (htab->elf.dynobj, eh, delta);\n+\t      *eh++ = DW_CFA_register;\n+\t      *eh++ = 65;\n+\t      *eh++ = 12;\n+\t      *eh++ = DW_CFA_advance_loc + 2;\n+\t      *eh++ = DW_CFA_restore_extended;\n+\t      *eh++ = 65;\n+\t      stub_entry->group->eh_size = eh - base;\n+\t    }\n+\n \t  /* The notoc stubs calculate their target (either a PLT entry or\n \t     the global entry point of a function) relative to the PC\n \t     returned by the \"bcl\" two instructions past the start of the\n \t     sequence emitted by build_offset.  The offset is therefore 8\n \t     less than calculated from the start of the sequence.  */\n \t  off -= 8;\n-\t  p = build_offset (htab->params->stub_bfd, p, off,\n+\t  p = build_offset (obfd, p, off,\n \t\t\t    stub_entry->stub_type >= ppc_stub_plt_call_notoc);\n \t}\n \n@@ -11715,17 +11750,19 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t\t  + stub_entry->group->stub_sec->output_offset\n \t\t  + stub_entry->group->stub_sec->output_section->vma\n \t\t  + (p - loc));\n-\t  bfd_put_32 (htab->params->stub_bfd,\n-\t\t      B_DOT | ((targ - from) & 0x3fffffc), p);\n+\t  bfd_put_32 (obfd, B_DOT | ((targ - from) & 0x3fffffc), p);\n \t}\n       else\n \t{\n-\t  bfd_put_32 (htab->params->stub_bfd, MTCTR_R12, p);\n+\t  bfd_put_32 (obfd, MTCTR_R12, p);\n \t  p += 4;\n-\t  bfd_put_32 (htab->params->stub_bfd, BCTR, p);\n+\t  bfd_put_32 (obfd, BCTR, p);\n \t}\n       p += 4;\n \n+      if (is_tga)\n+\tp = build_tls_get_addr_tail (htab, stub_entry, p, loc);\n+\n       if (info->emitrelocations)\n \t{\n \t  bfd_vma roff = relp - stub_entry->group->stub_sec->contents;\n@@ -11756,33 +11793,6 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t\treturn FALSE;\n \t    }\n \t}\n-\n-      if (htab->params->power10_stubs == 0\n-\t  && htab->glink_eh_frame != NULL\n-\t  && htab->glink_eh_frame->size != 0)\n-\t{\n-\t  bfd_byte *base, *eh;\n-\t  unsigned int lr_used, delta;\n-\n-\t  base = (htab->glink_eh_frame->contents\n-\t\t  + stub_entry->group->eh_base + 17);\n-\t  eh = base + stub_entry->group->eh_size;\n-\t  lr_used = stub_entry->stub_offset + 8;\n-\t  if (stub_entry->stub_type == ppc_stub_long_branch_both\n-\t      || stub_entry->stub_type == ppc_stub_plt_branch_both\n-\t      || stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t    lr_used += 4;\n-\t  delta = lr_used - stub_entry->group->lr_restore;\n-\t  stub_entry->group->lr_restore = lr_used + 8;\n-\t  eh = eh_advance (htab->elf.dynobj, eh, delta);\n-\t  *eh++ = DW_CFA_register;\n-\t  *eh++ = 65;\n-\t  *eh++ = 12;\n-\t  *eh++ = DW_CFA_advance_loc + 2;\n-\t  *eh++ = DW_CFA_restore_extended;\n-\t  *eh++ = 65;\n-\t  stub_entry->group->eh_size = eh - base;\n-\t}\n       break;\n \n     case ppc_stub_plt_call:\n@@ -11851,12 +11861,20 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    r[0].r_offset += 2;\n \t  r[0].r_addend = targ;\n \t}\n-      if (stub_entry->h != NULL\n-\t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n-\t  && htab->params->tls_get_addr_opt)\n-\tp = build_tls_get_addr_stub (htab, stub_entry, loc, off, r);\n-      else\n-\tp = build_plt_stub (htab, stub_entry, loc, off, r);\n+      p = loc;\n+      obfd = htab->params->stub_bfd;\n+      is_tga = (stub_entry->h != NULL\n+\t\t&& is_tls_get_addr (&stub_entry->h->elf, htab)\n+\t\t&& htab->params->tls_get_addr_opt);\n+      if (is_tga)\n+\t{\n+\t  p = build_tls_get_addr_head (htab, stub_entry, p);\n+\t  if (r != NULL)\n+\t    r[0].r_offset += p - loc;\n+\t}\n+      p = build_plt_stub (htab, stub_entry, p, off, r);\n+      if (is_tga)\n+\tp = build_tls_get_addr_tail (htab, stub_entry, p, loc);\n       break;\n \n     case ppc_stub_save_res:\n@@ -12152,11 +12170,18 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n     case ppc_stub_plt_call_notoc:\n     case ppc_stub_plt_call_both:\n-      off = (stub_entry->stub_offset\n-\t     + stub_entry->group->stub_sec->output_offset\n-\t     + stub_entry->group->stub_sec->output_section->vma);\n+      lr_used = 0;\n+      if (is_tls_get_addr (&stub_entry->h->elf, htab)\n+\t  && htab->params->tls_get_addr_opt)\n+\t{\n+\t  lr_used += 7 * 4;\n+\t  if (!htab->params->no_tls_get_addr_regsave)\n+\t    lr_used += 11 * 4;\n+\t  else if (stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t    lr_used += 2 * 4;\n+\t}\n       if (stub_entry->stub_type == ppc_stub_plt_call_both)\n-\toff += 4;\n+\tlr_used += 4;\n       targ = stub_entry->plt_ent->plt.offset & ~1;\n       if (targ >= (bfd_vma) -2)\n \tabort ();\n@@ -12172,16 +12197,21 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    plt = htab->pltlocal;\n \t}\n       targ += plt->output_offset + plt->output_section->vma;\n+      off = (stub_entry->stub_offset\n+\t     + stub_entry->group->stub_sec->output_offset\n+\t     + stub_entry->group->stub_sec->output_section->vma\n+\t     + lr_used);\n       odd = off & 4;\n       off = targ - off;\n \n       if (htab->params->plt_stub_align != 0)\n \t{\n-\t  unsigned pad = plt_stub_pad (htab, stub_entry, off);\n+\t  unsigned pad = plt_stub_pad (htab, stub_entry, off, odd);\n \n \t  stub_entry->group->stub_sec->size += pad;\n \t  stub_entry->stub_offset = stub_entry->group->stub_sec->size;\n \t  off -= pad;\n+\t  odd ^= pad & 4;\n \t}\n \n       if (info->emitrelocations)\n@@ -12195,22 +12225,43 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t}\n \n-      size = plt_stub_size (htab, stub_entry, off);\n+      size = plt_stub_size (htab, stub_entry, off, odd);\n \n       if (htab->params->power10_stubs == 0)\n \t{\n \t  /* After the bcl, lr has been modified so we need to emit\n \t     .eh_frame info saying the return address is in r12.  */\n-\t  lr_used = stub_entry->stub_offset + 8;\n-\t  if (stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t    lr_used += 4;\n+\t  lr_used += stub_entry->stub_offset + 8;\n \t  /* The eh_frame info will consist of a DW_CFA_advance_loc or\n \t     variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n \t     DW_CFA_restore_extended 65.  */\n \t  delta = lr_used - stub_entry->group->lr_restore;\n \t  stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n \t  stub_entry->group->lr_restore = lr_used + 8;\n \t}\n+      if ((stub_entry->stub_type == ppc_stub_plt_call_notoc\n+\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n+\t  && htab->params->tls_get_addr_opt)\n+\t{\n+\t  if (!htab->params->no_tls_get_addr_regsave)\n+\t    {\n+\t      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;\n+\t      delta = cfa_updt - stub_entry->group->lr_restore;\n+\t      stub_entry->group->eh_size += eh_advance_size (delta);\n+\t      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;\n+\t      stub_entry->group->lr_restore\n+\t\t= stub_entry->stub_offset + size - 4;\n+\t    }\n+\t  else if (stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t    {\n+\t      lr_used = stub_entry->stub_offset + size - 20;\n+\t      delta = lr_used - stub_entry->group->lr_restore;\n+\t      stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n+\t      stub_entry->group->lr_restore\n+\t\t= stub_entry->stub_offset + size - 4;\n+\t    }\n+\t}\n       break;\n \n     case ppc_stub_plt_call:\n@@ -12236,7 +12287,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       if (htab->params->plt_stub_align != 0)\n \t{\n-\t  unsigned pad = plt_stub_pad (htab, stub_entry, off);\n+\t  unsigned pad = plt_stub_pad (htab, stub_entry, off, 0);\n \n \t  stub_entry->group->stub_sec->size += pad;\n \t  stub_entry->stub_offset = stub_entry->group->stub_sec->size;\n@@ -12253,14 +12304,22 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t}\n \n-      size = plt_stub_size (htab, stub_entry, off);\n+      size = plt_stub_size (htab, stub_entry, off, 0);\n \n       if (stub_entry->h != NULL\n \t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n \t  && htab->params->tls_get_addr_opt\n \t  && stub_entry->stub_type == ppc_stub_plt_call_r2save)\n \t{\n-\t  if (htab->params->no_tls_get_addr_regsave)\n+\t  if (!htab->params->no_tls_get_addr_regsave)\n+\t    {\n+\t      /* Adjustments to r1 need to be described.  */\n+\t      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;\n+\t      delta = cfa_updt - stub_entry->group->lr_restore;\n+\t      stub_entry->group->eh_size += eh_advance_size (delta);\n+\t      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;\n+\t    }\n+\t  else\n \t    {\n \t      lr_used = stub_entry->stub_offset + size - 20;\n \t      /* The eh_frame info will consist of a DW_CFA_advance_loc\n@@ -12269,15 +12328,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      delta = lr_used - stub_entry->group->lr_restore;\n \t      stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n \t    }\n-\t  else\n-\t    {\n-\t      /* Adjustments to r1 need to be described.  */\n-\t      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;\n-\t      delta = cfa_updt - stub_entry->group->lr_restore;\n-\t      stub_entry->group->eh_size += eh_advance_size (delta);\n-\t      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;\n-\t    }\n-\t  stub_entry->group->lr_restore = size - 4;\n+\t  stub_entry->group->lr_restore = stub_entry->stub_offset + size - 4;\n \t}\n       break;\n \n@@ -15890,22 +15941,25 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      addend = 0;\n \t      reloc_dest = DEST_STUB;\n \n-\t      if (((stub_entry->stub_type == ppc_stub_plt_call\n-\t\t    && ALWAYS_EMIT_R2SAVE)\n-\t\t   || stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t\t  && !(h != NULL\n-\t\t       && is_tls_get_addr (&h->elf, htab)\n-\t\t       && htab->params->tls_get_addr_opt)\n-\t\t  && rel + 1 < relend\n-\t\t  && rel[1].r_offset == rel->r_offset + 4\n-\t\t  && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)\n-\t\trelocation += 4;\n-\t      else if ((stub_entry->stub_type == ppc_stub_long_branch_both\n-\t\t\t|| stub_entry->stub_type == ppc_stub_plt_branch_both\n-\t\t\t|| stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t\t       && r_type == R_PPC64_REL24_NOTOC)\n-\t\trelocation += 4;\n+\t      if ((((stub_entry->stub_type == ppc_stub_plt_call\n+\t\t     && ALWAYS_EMIT_R2SAVE)\n+\t\t    || stub_entry->stub_type == ppc_stub_plt_call_r2save\n+\t\t    || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t\t   && rel + 1 < relend\n+\t\t   && rel[1].r_offset == rel->r_offset + 4\n+\t\t   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)\n+\t\t  || ((stub_entry->stub_type == ppc_stub_long_branch_both\n+\t\t       || stub_entry->stub_type == ppc_stub_plt_branch_both\n+\t\t       || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t\t      && r_type == R_PPC64_REL24_NOTOC))\n+\t\t{\n+\t\t  /* Skip over the r2 store at the start of the stub.  */\n+\t\t  if (!(stub_entry->stub_type >= ppc_stub_plt_call\n+\t\t\t&& htab->params->tls_get_addr_opt\n+\t\t\t&& h != NULL\n+\t\t\t&& is_tls_get_addr (&h->elf, htab)))\n+\t\t    relocation += 4;\n+\t\t}\n \n \t      if (r_type == R_PPC64_REL24_NOTOC\n \t\t  && (stub_entry->stub_type == ppc_stub_plt_call_notoc"
    }
  ]
}