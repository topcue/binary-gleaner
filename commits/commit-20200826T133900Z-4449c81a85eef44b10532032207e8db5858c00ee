{
  "sha": "4449c81a85eef44b10532032207e8db5858c00ee",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDQ0OWM4MWE4NWVlZjQ0YjEwNTMyMDMyMjA3ZThkYjU4NThjMDBlZQ==",
  "commit": {
    "author": {
      "name": "David Faust",
      "email": "david.faust@oracle.com",
      "date": "2020-08-26T13:39:00Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-08-26T13:39:00Z"
    },
    "message": "bpf: add xBPF ISA\n\nThis patch adds support for xBPF, another ISA targetting the BPF\nvirtual architecture. For now, the primary difference between eBPF\nand xBPF is that xBPF supports indirect calls through the\n'call %reg' form of the call instruction.\n\nbfd/\n\t* archures.c (bfd_mach_xbpf): Define.\n\t* bfd-in2.h: Regenerate.\n\t* cpu-bpf.c (bfd_xbpf_arch) New.\n\t(bfd_bpf_arch) Update next in list field to point to xbpf arch.\n\ncpu/\n\t* bpf.cpu (arch bpf): Add xbpf mach and isas.\n\t(define-xbpf-isa) New pmacro.\n\t(all-isas) Add xbpfle,xbpfbe.\n\t(endian-isas): New pmacro.\n\t(mach xbpf): New.\n\t(model xbpf-def): Likewise.\n\t(h-gpr): Add xbpf mach.\n\t(f-dstle, f-srcle, dstle, srcle): Add xbpfle isa.\n\t(f-dstbe, f-srcbe, dstbe, srcbe): Add xbpfbe isa.\n\t(define-alu-insn-un): Use new endian-isas pmacro.\n\t(define-alu-insn-bin, define-alu-insn-mov): Likewise.\n\t(define-endian-insn, define-lddw): Likewise.\n\t(dlind, dxli, dxsi, dsti): Likewise.\n\t(define-cond-jump-insn, define-call-insn): Likewise.\n\t(define-atomic-insns): Likewise.\n\ngas/\n\t* config/tc-bpf.c: Add option -mxbpf to select xbpf isa.\n\t* testsuite/gas/bpf/indcall-1.d: New file.\n\t* testsuite/gas/bpf/indcall-1.s: Likewise.\n\t* testsuite/gas/bpf/indcall-bad-1.l: Likewise.\n\t* testsuite/gas/bpf/indcall-bad-1.s: Likewise.\n\t* testsuite/gas/bpf/bpf.exp: Run new tests.\n\nopcodes/\n\t* bpf-desc.c: Regenerate.\n\t* bpf-desc.h: Likewise.\n\t* bpf-opc.c: Likewise.\n\t* bpf-opc.h: Likewise.\n\t* disassemble.c (disassemble_init_for_target): Set bits for xBPF\n\tISA when appropriate.",
    "tree": {
      "sha": "654bfee49c2ea7d88e009f2a37ce6b15d1edd18f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/654bfee49c2ea7d88e009f2a37ce6b15d1edd18f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4449c81a85eef44b10532032207e8db5858c00ee",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4449c81a85eef44b10532032207e8db5858c00ee",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4449c81a85eef44b10532032207e8db5858c00ee",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4449c81a85eef44b10532032207e8db5858c00ee/comments",
  "author": {
    "login": "dafaust",
    "id": 4460334,
    "node_id": "MDQ6VXNlcjQ0NjAzMzQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/dafaust",
    "html_url": "https://github.com/dafaust",
    "followers_url": "https://api.github.com/users/dafaust/followers",
    "following_url": "https://api.github.com/users/dafaust/following{/other_user}",
    "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions",
    "organizations_url": "https://api.github.com/users/dafaust/orgs",
    "repos_url": "https://api.github.com/users/dafaust/repos",
    "events_url": "https://api.github.com/users/dafaust/events{/privacy}",
    "received_events_url": "https://api.github.com/users/dafaust/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "37f628c34d2d1f7e30c95b21f9c4c21819cb4534",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/37f628c34d2d1f7e30c95b21f9c4c21819cb4534",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/37f628c34d2d1f7e30c95b21f9c4c21819cb4534"
    }
  ],
  "stats": {
    "total": 866,
    "additions": 543,
    "deletions": 323
  },
  "files": [
    {
      "sha": "616b22f1600ea7b349dc81254a8c05af655fd63f",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -1,3 +1,10 @@\n+2020-08-26  David Faust  <david.faust@oracle.com>\n+\n+\t* archures.c (bfd_mach_xbpf): Define.\n+\t* bfd-in2.h: Regenerate.\n+\t* cpu-bpf.c (bfd_xbpf_arch) New.\n+\t(bfd_bpf_arch) Update next in list field to point to xbpf arch.\n+\n 2020-08-26  Alan Modra  <amodra@gmail.com>\n \n \t* archures.c (bfd_mach_ck860): Define."
    },
    {
      "sha": "969fa20873997a2c641c9cbd10d23d50b8319f0d",
      "filename": "bfd/archures.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/bfd/archures.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/bfd/archures.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/archures.c?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -411,6 +411,7 @@ DESCRIPTION\n .#define bfd_mach_iq10\t\t2\n .  bfd_arch_bpf,       {* Linux eBPF.  *}\n .#define bfd_mach_bpf\t\t1\n+.#define bfd_mach_xbpf\t\t2\n .  bfd_arch_epiphany,  {* Adapteva EPIPHANY.  *}\n .#define bfd_mach_epiphany16\t1\n .#define bfd_mach_epiphany32\t2"
    },
    {
      "sha": "3c85b073013872dc2023e0f7b647b30eebd8dd83",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -1811,6 +1811,7 @@ enum bfd_architecture\n #define bfd_mach_iq10          2\n   bfd_arch_bpf,       /* Linux eBPF.  */\n #define bfd_mach_bpf           1\n+#define bfd_mach_xbpf          2\n   bfd_arch_epiphany,  /* Adapteva EPIPHANY.  */\n #define bfd_mach_epiphany16    1\n #define bfd_mach_epiphany32    2"
    },
    {
      "sha": "947d7861331f933f45ca275cc5f3d6ec5a7aea66",
      "filename": "bfd/cpu-bpf.c",
      "status": "modified",
      "additions": 21,
      "deletions": 1,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/bfd/cpu-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/bfd/cpu-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-bpf.c?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -23,6 +23,26 @@\n #include \"bfd.h\"\n #include \"libbfd.h\"\n \n+\n+static const bfd_arch_info_type bfd_xbpf_arch =\n+{\n+  64,\t\t\t\t/* Bits per word.  */\n+  64,\t\t\t\t/* Bits per address.  */\n+  8,\t\t\t\t/* Bits per byte.  */\n+  bfd_arch_bpf,\t\t\t/* Architecture.  */\n+  bfd_mach_xbpf,\t\t/* Machine.  */\n+  \"bpf\",\t\t\t/* Architecture name.  */\n+  \"xbpf\",\t\t\t/* Machine name.  */\n+  3,\t\t\t\t/* Section align power.  */\n+  FALSE,\t\t\t/* The default ?  */\n+  bfd_default_compatible,\t/* Architecture comparison fn.  */\n+  bfd_default_scan,\t\t/* String to architecture convert fn.  */\n+  bfd_arch_default_fill,\t/* Default fill.  */\n+  NULL,\t\t\t\t/* Next in list.  */\n+  0 /* Maximum offset of a reloc from the start of an insn.  */\n+};\n+\n+\n const bfd_arch_info_type bfd_bpf_arch =\n {\n   64,\t\t\t\t/* Bits per word.  */\n@@ -37,6 +57,6 @@ const bfd_arch_info_type bfd_bpf_arch =\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */\n-  NULL,\t\t\t\t/* Next in list.  */\n+  &bfd_xbpf_arch,\t\t/* Next in list.  */\n   0 /* Maximum offset of a reloc from the start of an insn.  */\n };"
    },
    {
      "sha": "f81024848258a865ea947e6ec0477fd0e2731473",
      "filename": "cpu/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/cpu/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/cpu/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/ChangeLog?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -1,3 +1,21 @@\n+2020-08-26  David Faust  <david.faust@oracle.com>\n+\n+\t* bpf.cpu (arch bpf): Add xbpf mach and isas.\n+\t(define-xbpf-isa) New pmacro.\n+\t(all-isas) Add xbpfle,xbpfbe.\n+\t(endian-isas): New pmacro.\n+\t(mach xbpf): New.\n+\t(model xbpf-def): Likewise.\n+\t(h-gpr): Add xbpf mach.\n+\t(f-dstle, f-srcle, dstle, srcle): Add xbpfle isa.\n+\t(f-dstbe, f-srcbe, dstbe, srcbe): Add xbpfbe isa.\n+\t(define-alu-insn-un): Use new endian-isas pmacro.\n+\t(define-alu-insn-bin, define-alu-insn-mov): Likewise.\n+\t(define-endian-insn, define-lddw): Likewise.\n+\t(dlind, dxli, dxsi, dsti): Likewise.\n+\t(define-cond-jump-insn, define-call-insn): Likewise.\n+\t(define-atomic-insns): Likewise.\n+\n 2020-07-04  Nick Clifton  <nickc@redhat.com>\n \n \tBinutils 2.35 branch created."
    },
    {
      "sha": "966500e36d188c94b88acbbfe73791d89aea6608",
      "filename": "cpu/bpf.cpu",
      "status": "modified",
      "additions": 83,
      "deletions": 35,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/cpu/bpf.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/cpu/bpf.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/bpf.cpu?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -36,8 +36,8 @@\n   ;; It is confusing that the simulator follows the emulated memory\n   ;; access conventions for fetching instructions by pieces...\n   (default-alignment unaligned)\n-  (machs bpf)\n-  (isas ebpfle ebpfbe))\n+  (machs bpf xbpf)\n+  (isas ebpfle ebpfbe xbpfle xbpfbe))\n \n ;;;; The ISAs\n \n@@ -105,18 +105,33 @@\n (define-bpf-isa le)\n (define-bpf-isa be)\n \n-(define-pmacro all-isas () (ISA ebpfle,ebpfbe))\n+(define-pmacro (define-xbpf-isa x-endian)\n+  (define-isa\n+    (name (.sym xbpf x-endian))\n+    (comment \"The xBPF instruction set\")\n+    (default-insn-word-bitsize 64)\n+    (default-insn-bitsize 64)\n+    (base-insn-bitsize 64)))\n+\n+(define-xbpf-isa le)\n+(define-xbpf-isa be)\n+\n+(define-pmacro all-isas () (ISA ebpfle,ebpfbe,xbpfle,xbpfbe))\n+(define-pmacro xbpf-isas () (ISA xbpfle,xbpfbe))\n+\n+(define-pmacro (endian-isas x-endian)\n+  ((ISA (.sym ebpf x-endian) (.sym xbpf x-endian))))\n \n ;;;; Hardware Hierarchy\n \n ;;\n-;;     bpf         architecture\n-;;      |\n-;;    bpfbf        cpu-family\n-;;      |\n-;;     bpf         machine\n-;;      |\n-;;   bpf-def       model\n+;;         bpf            architecture\n+;;          |\n+;;        bpfbf           cpu-family\n+;;      /       \\\n+;;     bpf     xbpf       machine\n+;;      |       |\n+;;   bpf-def  xbpf-def    model\n \n (define-cpu\n   (name bpfbf)\n@@ -143,6 +158,25 @@\n     () ; profile action (default)\n     ))\n \n+(define-mach\n+  (name xbpf)\n+  (comment \"Experimental BPF\")\n+  (cpu bpfbf)\n+  (isas ebpfle ebpfbe xbpfle xbpfbe))\n+\n+(define-model\n+  (name xbpf-def)\n+  (comment \"xBPF default model\")\n+  (mach xbpf)\n+  (unit u-exec \"execution unit\" ()\n+    1 ; issue\n+    1 ; done\n+    () ; state\n+    () ; inputs\n+    () ; outputs\n+    () ; profile action (default)\n+    ))\n+\n ;;;; Hardware Elements\n \n ;; eBPF programs can access 10 general-purpose registers which are\n@@ -151,7 +185,7 @@\n (define-hardware\n   (name h-gpr)\n   (comment \"General Purpose Registers\")\n-  (attrs all-isas (MACH bpf))\n+  (attrs all-isas (MACH bpf xbpf))\n   (type register DI (16))\n   (indices keyword \"%\"\n            ;; XXX the frame pointer fp is read-only, so it should\n@@ -259,11 +293,11 @@\n ;; NOT use registers, where endianness is irrelevant i.e. f-regs is a\n ;; constant 0 opcode.\n \n-(dwf f-dstle \"eBPF dst register field\" ((ISA ebpfle)) 8 8 3 4 UINT)\n-(dwf f-srcle \"eBPF source register field\" ((ISA ebpfle)) 8 8 7 4 UINT)\n+(dwf f-dstle \"eBPF dst register field\" ((ISA ebpfle xbpfle)) 8 8 3 4 UINT)\n+(dwf f-srcle \"eBPF source register field\" ((ISA ebpfle xbpfle)) 8 8 7 4 UINT)\n \n-(dwf f-dstbe \"eBPF dst register field\" ((ISA ebpfbe)) 8 8 7 4 UINT)\n-(dwf f-srcbe \"eBPF source register field\" ((ISA ebpfbe)) 8 8 3 4 UINT)\n+(dwf f-dstbe \"eBPF dst register field\" ((ISA ebpfbe xbpfbe)) 8 8 7 4 UINT)\n+(dwf f-srcbe \"eBPF source register field\" ((ISA ebpfbe xbpfbe)) 8 8 3 4 UINT)\n \n (dwf f-regs \"eBPF registers field\" (all-isas) 8 8 7 8 UINT)\n \n@@ -303,11 +337,11 @@\n ;; A couple of source and destination register operands are defined\n ;; for each ISA: ebpfle and ebpfbe.\n \n-(dno dstle \"destination register\" ((ISA ebpfle)) h-gpr f-dstle)\n-(dno srcle \"source register\" ((ISA ebpfle)) h-gpr f-srcle)\n+(dno dstle \"destination register\" ((ISA ebpfle xbpfle)) h-gpr f-dstle)\n+(dno srcle \"source register\" ((ISA ebpfle xbpfle)) h-gpr f-srcle)\n \n-(dno dstbe \"destination register\" ((ISA ebpfbe)) h-gpr f-dstbe)\n-(dno srcbe \"source register\" ((ISA ebpfbe)) h-gpr f-srcbe)\n+(dno dstbe \"destination register\" ((ISA ebpfbe xbpfbe)) h-gpr f-dstbe)\n+(dno srcbe \"source register\" ((ISA ebpfbe xbpfbe)) h-gpr f-srcbe)\n \n ;; Jump instructions have a 16-bit PC-relative address.\n ;; CALL instructions have a 32-bit PC-relative address.\n@@ -378,7 +412,7 @@\n                  x-endian x-mode x-semop)\n   (dni (.sym x-basename x-suffix x-endian)\n        (.str x-basename x-suffix)\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str x-basename x-suffix \" $dst\" x-endian)\n        (+ (f-imm32 0) (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n           x-op-class OP_SRC_K x-op-code)\n@@ -391,7 +425,7 @@\n     ;; dst = dst OP immediate\n     (dni (.sym x-basename x-suffix \"i\" x-endian)\n          (.str x-basename x-suffix \" immediate\")\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str x-basename x-suffix \" $dst\" x-endian \",$imm32\")\n          (+ imm32 (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n             x-op-class OP_SRC_K x-op-code)\n@@ -400,7 +434,7 @@\n     ;; dst = dst OP src\n     (dni (.sym x-basename x-suffix \"r\" x-endian)\n          (.str x-basename x-suffix \" register\")\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str x-basename x-suffix \" $dst\" x-endian \",$src\" x-endian)\n          (+ (f-imm32 0) (f-offset16 0) (.sym src x-endian) (.sym dst x-endian)\n             x-op-class OP_SRC_X x-op-code)\n@@ -413,15 +447,15 @@\n   (begin\n     (dni (.sym mov x-suffix \"i\" x-endian)\n          (.str mov x-suffix \" immediate\")\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str x-basename x-suffix \" $dst\" x-endian \",$imm32\")\n          (+ imm32 (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n             x-op-class OP_SRC_K x-op-code)\n          (set x-mode (.sym dst x-endian) imm32)\n          ())\n     (dni (.sym mov x-suffix \"r\" x-endian)\n          (.str mov x-suffix \" register\")\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str x-basename x-suffix \" $dst\" x-endian \",$src\" x-endian)\n          (+ (f-imm32 0) (f-offset16 0) (.sym src x-endian) (.sym dst x-endian)\n             x-op-class OP_SRC_X x-op-code)\n@@ -483,7 +517,7 @@\n (define-pmacro (define-endian-insn x-suffix x-op-src x-endian)\n   (dni (.sym \"end\" x-suffix x-endian)\n        (.str \"end\" x-suffix \" register\")\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str \"end\" x-suffix \" $dst\" x-endian \",$endsize\")\n        (+  (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian) endsize\n            OP_CLASS_ALU x-op-src OP_CODE_END)\n@@ -508,7 +542,7 @@\n (define-pmacro (define-lddw x-endian)\n   (dni (.sym lddw x-endian)\n        (.str \"lddw\" x-endian)\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str \"lddw $dst\" x-endian \",$imm64\")\n        (+ imm64 (f-offset16 0) ((.sym f-src x-endian) 0)\n           (.sym dst x-endian)\n@@ -557,7 +591,7 @@\n (define-pmacro (dlind x-suffix x-size x-endian x-smode)\n   (dni (.sym \"ldind\" x-suffix x-endian)\n        (.str \"ldind\" x-suffix)\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str \"ldind\" x-suffix \" $src\" x-endian \",$imm32\")\n        (+ imm32 (f-offset16 0) ((.sym f-dst x-endian) 0) (.sym src x-endian)\n           OP_CLASS_LD OP_MODE_IND (.sym OP_SIZE_ x-size))\n@@ -598,7 +632,7 @@\n (define-pmacro (dxli x-basename x-suffix x-size x-endian x-mode)\n   (dni (.sym x-basename x-suffix x-endian)\n        (.str x-basename x-suffix)\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str x-basename x-suffix \" $dst\" x-endian \",[$src\" x-endian \"+$offset16]\")\n        (+ (f-imm32 0) offset16 (.sym src x-endian) (.sym dst x-endian)\n           OP_CLASS_LDX (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n@@ -610,7 +644,7 @@\n (define-pmacro (dxsi x-basename x-suffix x-size x-endian x-mode)\n   (dni (.sym x-basename x-suffix x-endian)\n        (.str x-basename x-suffix)\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str x-basename x-suffix \" [$dst\" x-endian \"+$offset16],$src\" x-endian)\n        (+ (f-imm32 0) offset16 (.sym src x-endian) (.sym dst x-endian)\n           OP_CLASS_STX (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n@@ -643,7 +677,7 @@\n (define-pmacro (dsti x-suffix x-size x-endian x-mode)\n   (dni (.sym \"st\" x-suffix x-endian)\n        (.str \"st\" x-suffix)\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        (.str \"st\" x-suffix \" [$dst\" x-endian \"+$offset16],$imm32\")\n        (+ imm32 offset16 ((.sym f-src x-endian) 0) (.sym dst x-endian)\n           OP_CLASS_ST (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n@@ -677,7 +711,7 @@\n   (begin\n     (dni (.sym j x-cond x-suffix i x-endian)\n          (.str j x-cond x-suffix \" i\")\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str \"j\" x-cond x-suffix \" $dst\" x-endian \",$imm32,$disp16\")\n          (+ imm32 disp16 ((.sym f-src x-endian) 0) (.sym dst x-endian)\n             x-op-class OP_SRC_K (.sym OP_CODE_ x-op-code))\n@@ -688,7 +722,7 @@\n          ())\n     (dni (.sym j x-cond x-suffix r x-endian)\n          (.str j x-cond x-suffix \" r\")\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str \"j\" x-cond x-suffix \" $dst\" x-endian \",$src\" x-endian \",$disp16\")\n          (+ (f-imm32 0) disp16 (.sym src x-endian) (.sym dst x-endian)\n             x-op-class OP_SRC_X (.sym OP_CODE_ x-op-code))\n@@ -728,7 +762,7 @@\n (define-pmacro (define-call-insn x-endian)\n   (dni (.sym call x-endian)\n        \"call\"\n-       ((ISA (.sym ebpf x-endian)))\n+       (endian-isas x-endian)\n        \"call $disp32\"\n        (+ disp32 (f-offset16 0) (f-regs 0)\n           OP_CLASS_JMP OP_SRC_K OP_CODE_CALL)\n@@ -739,6 +773,20 @@\n (define-call-insn le)\n (define-call-insn be)\n \n+(define-pmacro (define-callr-insn x-endian)\n+  (dni (.sym callr x-endian)\n+       \"callr\"\n+       ((ISA (.sym xbpf x-endian)))\n+       (.str \"call $dst\" x-endian)\n+       (+ (f-imm32 0) (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n+          OP_CLASS_JMP OP_SRC_X OP_CODE_CALL)\n+       (c-call VOID\n+               \"bpfbf_callr\" (ifield (.sym f-dst x-endian)))\n+       ()))\n+\n+(define-callr-insn le)\n+(define-callr-insn be)\n+\n ;; The jump-always and `exit' instructions dont make use of either\n ;; source nor destination registers, so only one variant per\n ;; instruction is defined.\n@@ -773,15 +821,15 @@\n   (begin\n     (dni (.str \"xadddw\" x-endian)\n          \"xadddw\"\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str \"xadddw [$dst\" x-endian \"+$offset16],$src\" x-endian)\n          (+ (f-imm32 0) (.sym src x-endian) (.sym dst x-endian)\n             offset16 OP_MODE_XADD OP_SIZE_DW OP_CLASS_STX)\n          (sem-exchange-and-add x-endian DI)\n          ())\n     (dni (.str \"xaddw\" x-endian)\n          \"xaddw\"\n-         ((ISA (.sym ebpf x-endian)))\n+         (endian-isas x-endian)\n          (.str \"xaddw [$dst\" x-endian \"+$offset16],$src\" x-endian)\n          (+ (f-imm32 0) (.sym src x-endian) (.sym dst x-endian)\n             offset16 OP_MODE_XADD OP_SIZE_W OP_CLASS_STX)"
    },
    {
      "sha": "4e367a4dade743075a219b24b822a134ae77a104",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -1,3 +1,12 @@\n+2020-08-26  David Faust  <david.faust@oracle.com>\n+\n+\t* config/tc-bpf.c: Add option -mxbpf to select xbpf isa.\n+\t* testsuite/gas/bpf/indcall-1.d: New file.\n+\t* testsuite/gas/bpf/indcall-1.s: Likewise.\n+\t* testsuite/gas/bpf/indcall-bad-1.l: Likewise.\n+\t* testsuite/gas/bpf/indcall-bad-1.s: Likewise.\n+\t* testsuite/gas/bpf/bpf.exp: Run new tests.\n+\n 2020-08-25  Alan Modra  <amodra@gmail.com>\n \n \tPR26501"
    },
    {
      "sha": "34b2adfc682add543bbe69d546cdb7cb8fbe471c",
      "filename": "gas/config/tc-bpf.c",
      "status": "modified",
      "additions": 30,
      "deletions": 4,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/config/tc-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/config/tc-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-bpf.c?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -97,13 +97,15 @@ static CGEN_BITSET *bpf_isa;\n enum options\n {\n   OPTION_LITTLE_ENDIAN = OPTION_MD_BASE,\n-  OPTION_BIG_ENDIAN\n+  OPTION_BIG_ENDIAN,\n+  OPTION_XBPF\n };\n \n struct option md_longopts[] =\n {\n   { \"EL\", no_argument, NULL, OPTION_LITTLE_ENDIAN },\n   { \"EB\", no_argument, NULL, OPTION_BIG_ENDIAN },\n+  { \"mxbpf\", no_argument, NULL, OPTION_XBPF },\n   { NULL,          no_argument, NULL, 0 },\n };\n \n@@ -117,6 +119,10 @@ extern int target_big_endian;\n    arguments.  */\n static int set_target_endian = 0;\n \n+static int target_xbpf = 0;\n+\n+static int set_xbpf = 0;\n+\n int\n md_parse_option (int c, const char * arg ATTRIBUTE_UNUSED)\n {\n@@ -130,6 +136,10 @@ md_parse_option (int c, const char * arg ATTRIBUTE_UNUSED)\n       set_target_endian = 1;\n       target_big_endian = 0;\n       break;\n+    case OPTION_XBPF:\n+      set_xbpf = 1;\n+      target_xbpf = 1;\n+      break;\n     default:\n       return 0;\n     }\n@@ -143,7 +153,8 @@ md_show_usage (FILE * stream)\n   fprintf (stream, _(\"\\nBPF options:\\n\"));\n   fprintf (stream, _(\"\\\n   --EL\t\t\tgenerate code for a little endian machine\\n\\\n-  --EB\t\t\tgenerate code for a big endian machine\\n\"));\n+  --EB\t\t\tgenerate code for a big endian machine\\n\\\n+  -mxbpf                generate xBPF instructions\\n\"));\n }\n \n \f\n@@ -163,12 +174,27 @@ md_begin (void)\n #endif\n     }\n \n+  /* If not specified in the command line, use eBPF rather\n+     than xBPF.  */\n+  if (!set_xbpf)\n+      target_xbpf = 0;\n+\n   /* Set the ISA, which depends on the target endianness. */\n   bpf_isa = cgen_bitset_create (ISA_MAX);\n   if (target_big_endian)\n-    cgen_bitset_set (bpf_isa, ISA_EBPFBE);\n+    {\n+      if (target_xbpf)\n+\tcgen_bitset_set (bpf_isa, ISA_XBPFBE);\n+      else\n+\tcgen_bitset_set (bpf_isa, ISA_EBPFBE);\n+    }\n   else\n-    cgen_bitset_set (bpf_isa, ISA_EBPFLE);\n+    {\n+      if (target_xbpf)\n+\tcgen_bitset_set (bpf_isa, ISA_XBPFLE);\n+      else\n+\tcgen_bitset_set (bpf_isa, ISA_EBPFLE);\n+    }\n \n   /* Set the machine number and endian.  */\n   gas_cgen_cpu_desc = bpf_cgen_cpu_open (CGEN_CPU_OPEN_ENDIAN,"
    },
    {
      "sha": "242b1902ba024342b05899a825c2db25969eca05",
      "filename": "gas/testsuite/gas/bpf/bpf.exp",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/bpf.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/bpf.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/bpf/bpf.exp?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -38,4 +38,7 @@ if {[istarget bpf*-*-*]} {\n     run_dump_test exit-be\n     run_dump_test atomic-be\n     run_dump_test data-be\n+\n+    run_dump_test indcall-1\n+    run_list_test indcall-bad-1\n }"
    },
    {
      "sha": "e61e1259fe557a4f1ad1eb4ff38db220416af47a",
      "filename": "gas/testsuite/gas/bpf/indcall-1.d",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-1.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-1.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/bpf/indcall-1.d?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -0,0 +1,22 @@\n+#as: -mxbpf --EL\n+#objdump: -mxbpf -dr\n+#name: BPF indirect call 1\n+\n+.*: +file format .*bpf.*\n+\n+Disassembly of section \\.text:\n+\n+0000000000000000 <main>:\n+   0:\tb7 00 00 00 01 00 00 00 \tmov %r0,1\n+   8:\tb7 01 00 00 01 00 00 00 \tmov %r1,1\n+  10:\tb7 02 00 00 02 00 00 00 \tmov %r2,2\n+  18:\t18 06 00 00 38 00 00 00 \tlddw %r6,0x38\n+  20:\t00 00 00 00 00 00 00 00[    ]*\n+\t\t\t18: R_BPF_INSN_64\t.text\n+  28:\t8d 06 00 00 00 00 00 00 \tcall %r6\n+  30:\t95 00 00 00 00 00 00 00 \texit\n+\n+0000000000000038 <bar>:\n+  38:\tb7 00 00 00 00 00 00 00 \tmov %r0,0\n+  40:\t95 00 00 00 00 00 00 00 \texit\n+#pass"
    },
    {
      "sha": "5d49e41040a231ea71f84e436502f85be670a211",
      "filename": "gas/testsuite/gas/bpf/indcall-1.s",
      "status": "added",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-1.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-1.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/bpf/indcall-1.s?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -0,0 +1,14 @@\n+\n+    .text\n+    .align 4\n+main:\n+    mov %r0, 1\n+    mov %r1, 1\n+    mov %r2, 2\n+    lddw %r6, bar\n+    call %r6\n+    exit\n+\n+bar:\n+    mov %r0, 0\n+    exit"
    },
    {
      "sha": "510ec6eabf217385c52289b0a5a19e39d6eb930a",
      "filename": "gas/testsuite/gas/bpf/indcall-bad-1.l",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-bad-1.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-bad-1.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/bpf/indcall-bad-1.l?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -0,0 +1,3 @@\n+.*: Assembler messages:\n+.* Error: illegal operand `call %r6'\n+#pass"
    },
    {
      "sha": "0cdc4ab7acaf80129e3b5963ef13ac8bb0219dda",
      "filename": "gas/testsuite/gas/bpf/indcall-bad-1.s",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-bad-1.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/gas/testsuite/gas/bpf/indcall-bad-1.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/bpf/indcall-bad-1.s?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -0,0 +1 @@\n+    call %r6"
    },
    {
      "sha": "af4dac6105dbee5704602480a34cf2277f21811b",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -1,3 +1,12 @@\n+2020-08-26  David Faust  <david.faust@oracle.com>\n+\n+\t* bpf-desc.c: Regenerate.\n+\t* bpf-desc.h: Likewise.\n+\t* bpf-opc.c: Likewise.\n+\t* bpf-opc.h: Likewise.\n+\t* disassemble.c (disassemble_init_for_target): Set bits for xBPF\n+\tISA when appropriate.\n+\n 2020-08-25  Alan Modra  <amodra@gmail.com>\n \n \tPR 26504"
    },
    {
      "sha": "6914ce98e62d6074cb65986534b95defee1c2045",
      "filename": "opcodes/bpf-desc.c",
      "status": "modified",
      "additions": 292,
      "deletions": 276,
      "changes": 568,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-desc.c?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -48,6 +48,7 @@ static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =\n {\n   { \"base\", MACH_BASE },\n   { \"bpf\", MACH_BPF },\n+  { \"xbpf\", MACH_XBPF },\n   { \"max\", MACH_MAX },\n   { 0, 0 }\n };\n@@ -56,6 +57,8 @@ static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =\n {\n   { \"ebpfle\", ISA_EBPFLE },\n   { \"ebpfbe\", ISA_EBPFBE },\n+  { \"xbpfle\", ISA_XBPFLE },\n+  { \"xbpfbe\", ISA_XBPFBE },\n   { \"max\", ISA_MAX },\n   { 0, 0 }\n };\n@@ -121,13 +124,16 @@ const CGEN_ATTR_TABLE bpf_cgen_insn_attr_table[] =\n static const CGEN_ISA bpf_cgen_isa_table[] = {\n   { \"ebpfle\", 64, 64, 64, 128 },\n   { \"ebpfbe\", 64, 64, 64, 128 },\n+  { \"xbpfle\", 64, 64, 64, 128 },\n+  { \"xbpfbe\", 64, 64, 64, 128 },\n   { 0, 0, 0, 0, 0 }\n };\n \n /* Machine variants.  */\n \n static const CGEN_MACH bpf_cgen_mach_table[] = {\n   { \"bpf\", \"bpf\", MACH_BPF, 0 },\n+  { \"xbpf\", \"xbpf\", MACH_XBPF, 0 },\n   { 0, 0, 0, 0 }\n };\n \n@@ -163,14 +169,14 @@ CGEN_KEYWORD bpf_cgen_opval_h_gpr =\n \n const CGEN_HW_ENTRY bpf_cgen_hw_table[] =\n {\n-  { \"h-memory\", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-sint\", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-uint\", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-addr\", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-iaddr\", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-gpr\", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & bpf_cgen_opval_h_gpr, { 0, { { { (1<<MACH_BPF), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-pc\", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-sint64\", HW_H_SINT64, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-memory\", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-sint\", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-uint\", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-addr\", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-iaddr\", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-gpr\", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & bpf_cgen_opval_h_gpr, { 0, { { { (1<<MACH_BPF)|(1<<MACH_XBPF), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-pc\", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n+  { \"h-sint64\", HW_H_SINT64, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } } },\n   { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } }\n };\n \n@@ -183,24 +189,24 @@ const CGEN_HW_ENTRY bpf_cgen_hw_table[] =\n \n const CGEN_IFLD bpf_cgen_ifld_table[] =\n {\n-  { BPF_F_NIL, \"f-nil\", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_ANYOF, \"f-anyof\", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_OP_CODE, \"f-op-code\", 0, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_OP_SRC, \"f-op-src\", 0, 8, 3, 1, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_OP_CLASS, \"f-op-class\", 0, 8, 2, 3, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_OP_MODE, \"f-op-mode\", 0, 8, 7, 3, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_OP_SIZE, \"f-op-size\", 0, 8, 4, 2, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_DSTLE, \"f-dstle\", 8, 8, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n-  { BPF_F_SRCLE, \"f-srcle\", 8, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n-  { BPF_F_DSTBE, \"f-dstbe\", 8, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n-  { BPF_F_SRCBE, \"f-srcbe\", 8, 8, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n-  { BPF_F_REGS, \"f-regs\", 8, 8, 7, 8, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_OFFSET16, \"f-offset16\", 16, 16, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_IMM32, \"f-imm32\", 32, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_IMM64_A, \"f-imm64-a\", 32, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_IMM64_B, \"f-imm64-b\", 64, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_IMM64_C, \"f-imm64-c\", 96, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n-  { BPF_F_IMM64, \"f-imm64\", 0, 0, 0, 0,{ 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_NIL, \"f-nil\", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_ANYOF, \"f-anyof\", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_OP_CODE, \"f-op-code\", 0, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_OP_SRC, \"f-op-src\", 0, 8, 3, 1, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_OP_CLASS, \"f-op-class\", 0, 8, 2, 3, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_OP_MODE, \"f-op-mode\", 0, 8, 7, 3, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_OP_SIZE, \"f-op-size\", 0, 8, 4, 2, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_DSTLE, \"f-dstle\", 8, 8, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }  },\n+  { BPF_F_SRCLE, \"f-srcle\", 8, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }  },\n+  { BPF_F_DSTBE, \"f-dstbe\", 8, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }  },\n+  { BPF_F_SRCBE, \"f-srcbe\", 8, 8, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }  },\n+  { BPF_F_REGS, \"f-regs\", 8, 8, 7, 8, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_OFFSET16, \"f-offset16\", 16, 16, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_IMM32, \"f-imm32\", 32, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_IMM64_A, \"f-imm64-a\", 32, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_IMM64_B, \"f-imm64-b\", 64, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_IMM64_C, \"f-imm64-c\", 96, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n+  { BPF_F_IMM64, \"f-imm64\", 0, 0, 0, 0,{ 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n   { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } }\n };\n \n@@ -233,47 +239,47 @@ const CGEN_OPERAND bpf_cgen_operand_table[] =\n /* pc: program counter */\n   { \"pc\", BPF_OPERAND_PC, HW_H_PC, 0, 0,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_NIL] } },\n-    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* dstle: destination register */\n   { \"dstle\", BPF_OPERAND_DSTLE, HW_H_GPR, 3, 4,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_DSTLE] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }  },\n /* srcle: source register */\n   { \"srcle\", BPF_OPERAND_SRCLE, HW_H_GPR, 7, 4,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_SRCLE] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }  },\n /* dstbe: destination register */\n   { \"dstbe\", BPF_OPERAND_DSTBE, HW_H_GPR, 7, 4,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_DSTBE] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }  },\n /* srcbe: source register */\n   { \"srcbe\", BPF_OPERAND_SRCBE, HW_H_GPR, 3, 4,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_SRCBE] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }  },\n /* disp16: 16-bit PC-relative address */\n   { \"disp16\", BPF_OPERAND_DISP16, HW_H_SINT, 15, 16,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_OFFSET16] } },\n-    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* disp32: 32-bit PC-relative address */\n   { \"disp32\", BPF_OPERAND_DISP32, HW_H_SINT, 31, 32,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM32] } },\n-    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* imm32: 32-bit immediate */\n   { \"imm32\", BPF_OPERAND_IMM32, HW_H_SINT, 31, 32,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM32] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* offset16: 16-bit offset */\n   { \"offset16\", BPF_OPERAND_OFFSET16, HW_H_SINT, 15, 16,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_OFFSET16] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* imm64: 64-bit immediate */\n   { \"imm64\", BPF_OPERAND_IMM64, HW_H_SINT64, 31, 96,\n     { 3, { (const PTR) &BPF_F_IMM64_MULTI_IFIELD[0] } },\n-    { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* endsize: endianness size immediate: 16, 32 or 64 */\n   { \"endsize\", BPF_OPERAND_ENDSIZE, HW_H_UINT, 31, 32,\n     { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM32] } },\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }  },\n /* sentinel */\n   { 0, 0, 0, 0, 0,\n     { 0, { (const PTR) 0 } },\n@@ -297,1197 +303,1207 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n /* add $dstle,$imm32 */\n   {\n     BPF_INSN_ADDILE, \"addile\", \"add\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* add $dstle,$srcle */\n   {\n     BPF_INSN_ADDRLE, \"addrle\", \"add\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* add32 $dstle,$imm32 */\n   {\n     BPF_INSN_ADD32ILE, \"add32ile\", \"add32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* add32 $dstle,$srcle */\n   {\n     BPF_INSN_ADD32RLE, \"add32rle\", \"add32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* sub $dstle,$imm32 */\n   {\n     BPF_INSN_SUBILE, \"subile\", \"sub\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* sub $dstle,$srcle */\n   {\n     BPF_INSN_SUBRLE, \"subrle\", \"sub\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* sub32 $dstle,$imm32 */\n   {\n     BPF_INSN_SUB32ILE, \"sub32ile\", \"sub32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* sub32 $dstle,$srcle */\n   {\n     BPF_INSN_SUB32RLE, \"sub32rle\", \"sub32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mul $dstle,$imm32 */\n   {\n     BPF_INSN_MULILE, \"mulile\", \"mul\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mul $dstle,$srcle */\n   {\n     BPF_INSN_MULRLE, \"mulrle\", \"mul\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mul32 $dstle,$imm32 */\n   {\n     BPF_INSN_MUL32ILE, \"mul32ile\", \"mul32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mul32 $dstle,$srcle */\n   {\n     BPF_INSN_MUL32RLE, \"mul32rle\", \"mul32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* div $dstle,$imm32 */\n   {\n     BPF_INSN_DIVILE, \"divile\", \"div\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* div $dstle,$srcle */\n   {\n     BPF_INSN_DIVRLE, \"divrle\", \"div\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* div32 $dstle,$imm32 */\n   {\n     BPF_INSN_DIV32ILE, \"div32ile\", \"div32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* div32 $dstle,$srcle */\n   {\n     BPF_INSN_DIV32RLE, \"div32rle\", \"div32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* or $dstle,$imm32 */\n   {\n     BPF_INSN_ORILE, \"orile\", \"or\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* or $dstle,$srcle */\n   {\n     BPF_INSN_ORRLE, \"orrle\", \"or\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* or32 $dstle,$imm32 */\n   {\n     BPF_INSN_OR32ILE, \"or32ile\", \"or32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* or32 $dstle,$srcle */\n   {\n     BPF_INSN_OR32RLE, \"or32rle\", \"or32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* and $dstle,$imm32 */\n   {\n     BPF_INSN_ANDILE, \"andile\", \"and\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* and $dstle,$srcle */\n   {\n     BPF_INSN_ANDRLE, \"andrle\", \"and\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* and32 $dstle,$imm32 */\n   {\n     BPF_INSN_AND32ILE, \"and32ile\", \"and32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* and32 $dstle,$srcle */\n   {\n     BPF_INSN_AND32RLE, \"and32rle\", \"and32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* lsh $dstle,$imm32 */\n   {\n     BPF_INSN_LSHILE, \"lshile\", \"lsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* lsh $dstle,$srcle */\n   {\n     BPF_INSN_LSHRLE, \"lshrle\", \"lsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* lsh32 $dstle,$imm32 */\n   {\n     BPF_INSN_LSH32ILE, \"lsh32ile\", \"lsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* lsh32 $dstle,$srcle */\n   {\n     BPF_INSN_LSH32RLE, \"lsh32rle\", \"lsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* rsh $dstle,$imm32 */\n   {\n     BPF_INSN_RSHILE, \"rshile\", \"rsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* rsh $dstle,$srcle */\n   {\n     BPF_INSN_RSHRLE, \"rshrle\", \"rsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* rsh32 $dstle,$imm32 */\n   {\n     BPF_INSN_RSH32ILE, \"rsh32ile\", \"rsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* rsh32 $dstle,$srcle */\n   {\n     BPF_INSN_RSH32RLE, \"rsh32rle\", \"rsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mod $dstle,$imm32 */\n   {\n     BPF_INSN_MODILE, \"modile\", \"mod\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mod $dstle,$srcle */\n   {\n     BPF_INSN_MODRLE, \"modrle\", \"mod\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mod32 $dstle,$imm32 */\n   {\n     BPF_INSN_MOD32ILE, \"mod32ile\", \"mod32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mod32 $dstle,$srcle */\n   {\n     BPF_INSN_MOD32RLE, \"mod32rle\", \"mod32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* xor $dstle,$imm32 */\n   {\n     BPF_INSN_XORILE, \"xorile\", \"xor\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* xor $dstle,$srcle */\n   {\n     BPF_INSN_XORRLE, \"xorrle\", \"xor\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* xor32 $dstle,$imm32 */\n   {\n     BPF_INSN_XOR32ILE, \"xor32ile\", \"xor32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* xor32 $dstle,$srcle */\n   {\n     BPF_INSN_XOR32RLE, \"xor32rle\", \"xor32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* arsh $dstle,$imm32 */\n   {\n     BPF_INSN_ARSHILE, \"arshile\", \"arsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* arsh $dstle,$srcle */\n   {\n     BPF_INSN_ARSHRLE, \"arshrle\", \"arsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* arsh32 $dstle,$imm32 */\n   {\n     BPF_INSN_ARSH32ILE, \"arsh32ile\", \"arsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* arsh32 $dstle,$srcle */\n   {\n     BPF_INSN_ARSH32RLE, \"arsh32rle\", \"arsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* neg $dstle */\n   {\n     BPF_INSN_NEGLE, \"negle\", \"neg\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* neg32 $dstle */\n   {\n     BPF_INSN_NEG32LE, \"neg32le\", \"neg32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mov $dstle,$imm32 */\n   {\n     BPF_INSN_MOVILE, \"movile\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mov $dstle,$srcle */\n   {\n     BPF_INSN_MOVRLE, \"movrle\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mov32 $dstle,$imm32 */\n   {\n     BPF_INSN_MOV32ILE, \"mov32ile\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* mov32 $dstle,$srcle */\n   {\n     BPF_INSN_MOV32RLE, \"mov32rle\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* add $dstbe,$imm32 */\n   {\n     BPF_INSN_ADDIBE, \"addibe\", \"add\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* add $dstbe,$srcbe */\n   {\n     BPF_INSN_ADDRBE, \"addrbe\", \"add\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* add32 $dstbe,$imm32 */\n   {\n     BPF_INSN_ADD32IBE, \"add32ibe\", \"add32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* add32 $dstbe,$srcbe */\n   {\n     BPF_INSN_ADD32RBE, \"add32rbe\", \"add32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* sub $dstbe,$imm32 */\n   {\n     BPF_INSN_SUBIBE, \"subibe\", \"sub\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* sub $dstbe,$srcbe */\n   {\n     BPF_INSN_SUBRBE, \"subrbe\", \"sub\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* sub32 $dstbe,$imm32 */\n   {\n     BPF_INSN_SUB32IBE, \"sub32ibe\", \"sub32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* sub32 $dstbe,$srcbe */\n   {\n     BPF_INSN_SUB32RBE, \"sub32rbe\", \"sub32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mul $dstbe,$imm32 */\n   {\n     BPF_INSN_MULIBE, \"mulibe\", \"mul\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mul $dstbe,$srcbe */\n   {\n     BPF_INSN_MULRBE, \"mulrbe\", \"mul\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mul32 $dstbe,$imm32 */\n   {\n     BPF_INSN_MUL32IBE, \"mul32ibe\", \"mul32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mul32 $dstbe,$srcbe */\n   {\n     BPF_INSN_MUL32RBE, \"mul32rbe\", \"mul32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* div $dstbe,$imm32 */\n   {\n     BPF_INSN_DIVIBE, \"divibe\", \"div\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* div $dstbe,$srcbe */\n   {\n     BPF_INSN_DIVRBE, \"divrbe\", \"div\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* div32 $dstbe,$imm32 */\n   {\n     BPF_INSN_DIV32IBE, \"div32ibe\", \"div32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* div32 $dstbe,$srcbe */\n   {\n     BPF_INSN_DIV32RBE, \"div32rbe\", \"div32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* or $dstbe,$imm32 */\n   {\n     BPF_INSN_ORIBE, \"oribe\", \"or\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* or $dstbe,$srcbe */\n   {\n     BPF_INSN_ORRBE, \"orrbe\", \"or\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* or32 $dstbe,$imm32 */\n   {\n     BPF_INSN_OR32IBE, \"or32ibe\", \"or32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* or32 $dstbe,$srcbe */\n   {\n     BPF_INSN_OR32RBE, \"or32rbe\", \"or32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* and $dstbe,$imm32 */\n   {\n     BPF_INSN_ANDIBE, \"andibe\", \"and\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* and $dstbe,$srcbe */\n   {\n     BPF_INSN_ANDRBE, \"andrbe\", \"and\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* and32 $dstbe,$imm32 */\n   {\n     BPF_INSN_AND32IBE, \"and32ibe\", \"and32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* and32 $dstbe,$srcbe */\n   {\n     BPF_INSN_AND32RBE, \"and32rbe\", \"and32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* lsh $dstbe,$imm32 */\n   {\n     BPF_INSN_LSHIBE, \"lshibe\", \"lsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* lsh $dstbe,$srcbe */\n   {\n     BPF_INSN_LSHRBE, \"lshrbe\", \"lsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* lsh32 $dstbe,$imm32 */\n   {\n     BPF_INSN_LSH32IBE, \"lsh32ibe\", \"lsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* lsh32 $dstbe,$srcbe */\n   {\n     BPF_INSN_LSH32RBE, \"lsh32rbe\", \"lsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* rsh $dstbe,$imm32 */\n   {\n     BPF_INSN_RSHIBE, \"rshibe\", \"rsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* rsh $dstbe,$srcbe */\n   {\n     BPF_INSN_RSHRBE, \"rshrbe\", \"rsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* rsh32 $dstbe,$imm32 */\n   {\n     BPF_INSN_RSH32IBE, \"rsh32ibe\", \"rsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* rsh32 $dstbe,$srcbe */\n   {\n     BPF_INSN_RSH32RBE, \"rsh32rbe\", \"rsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mod $dstbe,$imm32 */\n   {\n     BPF_INSN_MODIBE, \"modibe\", \"mod\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mod $dstbe,$srcbe */\n   {\n     BPF_INSN_MODRBE, \"modrbe\", \"mod\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mod32 $dstbe,$imm32 */\n   {\n     BPF_INSN_MOD32IBE, \"mod32ibe\", \"mod32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mod32 $dstbe,$srcbe */\n   {\n     BPF_INSN_MOD32RBE, \"mod32rbe\", \"mod32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* xor $dstbe,$imm32 */\n   {\n     BPF_INSN_XORIBE, \"xoribe\", \"xor\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* xor $dstbe,$srcbe */\n   {\n     BPF_INSN_XORRBE, \"xorrbe\", \"xor\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* xor32 $dstbe,$imm32 */\n   {\n     BPF_INSN_XOR32IBE, \"xor32ibe\", \"xor32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* xor32 $dstbe,$srcbe */\n   {\n     BPF_INSN_XOR32RBE, \"xor32rbe\", \"xor32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* arsh $dstbe,$imm32 */\n   {\n     BPF_INSN_ARSHIBE, \"arshibe\", \"arsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* arsh $dstbe,$srcbe */\n   {\n     BPF_INSN_ARSHRBE, \"arshrbe\", \"arsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* arsh32 $dstbe,$imm32 */\n   {\n     BPF_INSN_ARSH32IBE, \"arsh32ibe\", \"arsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* arsh32 $dstbe,$srcbe */\n   {\n     BPF_INSN_ARSH32RBE, \"arsh32rbe\", \"arsh32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* neg $dstbe */\n   {\n     BPF_INSN_NEGBE, \"negbe\", \"neg\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* neg32 $dstbe */\n   {\n     BPF_INSN_NEG32BE, \"neg32be\", \"neg32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mov $dstbe,$imm32 */\n   {\n     BPF_INSN_MOVIBE, \"movibe\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mov $dstbe,$srcbe */\n   {\n     BPF_INSN_MOVRBE, \"movrbe\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mov32 $dstbe,$imm32 */\n   {\n     BPF_INSN_MOV32IBE, \"mov32ibe\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* mov32 $dstbe,$srcbe */\n   {\n     BPF_INSN_MOV32RBE, \"mov32rbe\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* endle $dstle,$endsize */\n   {\n     BPF_INSN_ENDLELE, \"endlele\", \"endle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* endbe $dstle,$endsize */\n   {\n     BPF_INSN_ENDBELE, \"endbele\", \"endbe\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* endle $dstbe,$endsize */\n   {\n     BPF_INSN_ENDLEBE, \"endlebe\", \"endle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* endbe $dstbe,$endsize */\n   {\n     BPF_INSN_ENDBEBE, \"endbebe\", \"endbe\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* lddw $dstle,$imm64 */\n   {\n     BPF_INSN_LDDWLE, \"lddwle\", \"lddw\", 128,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* lddw $dstbe,$imm64 */\n   {\n     BPF_INSN_LDDWBE, \"lddwbe\", \"lddw\", 128,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldabsw $imm32 */\n   {\n     BPF_INSN_LDABSW, \"ldabsw\", \"ldabsw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n /* ldabsh $imm32 */\n   {\n     BPF_INSN_LDABSH, \"ldabsh\", \"ldabsh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n /* ldabsb $imm32 */\n   {\n     BPF_INSN_LDABSB, \"ldabsb\", \"ldabsb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n /* ldabsdw $imm32 */\n   {\n     BPF_INSN_LDABSDW, \"ldabsdw\", \"ldabsdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n /* ldindw $srcle,$imm32 */\n   {\n     BPF_INSN_LDINDWLE, \"ldindwle\", \"ldindw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldindh $srcle,$imm32 */\n   {\n     BPF_INSN_LDINDHLE, \"ldindhle\", \"ldindh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldindb $srcle,$imm32 */\n   {\n     BPF_INSN_LDINDBLE, \"ldindble\", \"ldindb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldinddw $srcle,$imm32 */\n   {\n     BPF_INSN_LDINDDWLE, \"ldinddwle\", \"ldinddw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldindw $srcbe,$imm32 */\n   {\n     BPF_INSN_LDINDWBE, \"ldindwbe\", \"ldindw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldindh $srcbe,$imm32 */\n   {\n     BPF_INSN_LDINDHBE, \"ldindhbe\", \"ldindh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldindb $srcbe,$imm32 */\n   {\n     BPF_INSN_LDINDBBE, \"ldindbbe\", \"ldindb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldinddw $srcbe,$imm32 */\n   {\n     BPF_INSN_LDINDDWBE, \"ldinddwbe\", \"ldinddw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldxw $dstle,[$srcle+$offset16] */\n   {\n     BPF_INSN_LDXWLE, \"ldxwle\", \"ldxw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldxh $dstle,[$srcle+$offset16] */\n   {\n     BPF_INSN_LDXHLE, \"ldxhle\", \"ldxh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldxb $dstle,[$srcle+$offset16] */\n   {\n     BPF_INSN_LDXBLE, \"ldxble\", \"ldxb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldxdw $dstle,[$srcle+$offset16] */\n   {\n     BPF_INSN_LDXDWLE, \"ldxdwle\", \"ldxdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stxw [$dstle+$offset16],$srcle */\n   {\n     BPF_INSN_STXWLE, \"stxwle\", \"stxw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stxh [$dstle+$offset16],$srcle */\n   {\n     BPF_INSN_STXHLE, \"stxhle\", \"stxh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stxb [$dstle+$offset16],$srcle */\n   {\n     BPF_INSN_STXBLE, \"stxble\", \"stxb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stxdw [$dstle+$offset16],$srcle */\n   {\n     BPF_INSN_STXDWLE, \"stxdwle\", \"stxdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* ldxw $dstbe,[$srcbe+$offset16] */\n   {\n     BPF_INSN_LDXWBE, \"ldxwbe\", \"ldxw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldxh $dstbe,[$srcbe+$offset16] */\n   {\n     BPF_INSN_LDXHBE, \"ldxhbe\", \"ldxh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldxb $dstbe,[$srcbe+$offset16] */\n   {\n     BPF_INSN_LDXBBE, \"ldxbbe\", \"ldxb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* ldxdw $dstbe,[$srcbe+$offset16] */\n   {\n     BPF_INSN_LDXDWBE, \"ldxdwbe\", \"ldxdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stxw [$dstbe+$offset16],$srcbe */\n   {\n     BPF_INSN_STXWBE, \"stxwbe\", \"stxw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stxh [$dstbe+$offset16],$srcbe */\n   {\n     BPF_INSN_STXHBE, \"stxhbe\", \"stxh\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stxb [$dstbe+$offset16],$srcbe */\n   {\n     BPF_INSN_STXBBE, \"stxbbe\", \"stxb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stxdw [$dstbe+$offset16],$srcbe */\n   {\n     BPF_INSN_STXDWBE, \"stxdwbe\", \"stxdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stb [$dstle+$offset16],$imm32 */\n   {\n     BPF_INSN_STBLE, \"stble\", \"stb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* sth [$dstle+$offset16],$imm32 */\n   {\n     BPF_INSN_STHLE, \"sthle\", \"sth\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stw [$dstle+$offset16],$imm32 */\n   {\n     BPF_INSN_STWLE, \"stwle\", \"stw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stdw [$dstle+$offset16],$imm32 */\n   {\n     BPF_INSN_STDWLE, \"stdwle\", \"stdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* stb [$dstbe+$offset16],$imm32 */\n   {\n     BPF_INSN_STBBE, \"stbbe\", \"stb\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* sth [$dstbe+$offset16],$imm32 */\n   {\n     BPF_INSN_STHBE, \"sthbe\", \"sth\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stw [$dstbe+$offset16],$imm32 */\n   {\n     BPF_INSN_STWBE, \"stwbe\", \"stw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* stdw [$dstbe+$offset16],$imm32 */\n   {\n     BPF_INSN_STDWBE, \"stdwbe\", \"stdw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jeq $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQILE, \"jeqile\", \"jeq\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jeq $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JEQRLE, \"jeqrle\", \"jeq\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jeq32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQ32ILE, \"jeq32ile\", \"jeq32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jeq32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JEQ32RLE, \"jeq32rle\", \"jeq32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jgt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGTILE, \"jgtile\", \"jgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jgt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGTRLE, \"jgtrle\", \"jgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jgt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGT32ILE, \"jgt32ile\", \"jgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jgt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGT32RLE, \"jgt32rle\", \"jgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jge $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGEILE, \"jgeile\", \"jge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jge $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGERLE, \"jgerle\", \"jge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jge32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGE32ILE, \"jge32ile\", \"jge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jge32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGE32RLE, \"jge32rle\", \"jge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jlt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLTILE, \"jltile\", \"jlt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jlt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLTRLE, \"jltrle\", \"jlt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jlt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLT32ILE, \"jlt32ile\", \"jlt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jlt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLT32RLE, \"jlt32rle\", \"jlt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jle $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLEILE, \"jleile\", \"jle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jle $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLERLE, \"jlerle\", \"jle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jle32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLE32ILE, \"jle32ile\", \"jle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jle32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLE32RLE, \"jle32rle\", \"jle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jset $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSETILE, \"jsetile\", \"jset\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jset $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSETRLE, \"jsetrle\", \"jset\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jset32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSET32ILE, \"jset32ile\", \"jset32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jset32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSET32RLE, \"jset32rle\", \"jset32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jne $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JNEILE, \"jneile\", \"jne\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jne $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JNERLE, \"jnerle\", \"jne\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jne32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JNE32ILE, \"jne32ile\", \"jne32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jne32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JNE32RLE, \"jne32rle\", \"jne32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsgt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGTILE, \"jsgtile\", \"jsgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsgt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGTRLE, \"jsgtrle\", \"jsgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsgt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGT32ILE, \"jsgt32ile\", \"jsgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsgt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGT32RLE, \"jsgt32rle\", \"jsgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsge $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGEILE, \"jsgeile\", \"jsge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsge $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGERLE, \"jsgerle\", \"jsge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsge32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGE32ILE, \"jsge32ile\", \"jsge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsge32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGE32RLE, \"jsge32rle\", \"jsge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jslt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLTILE, \"jsltile\", \"jslt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jslt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLTRLE, \"jsltrle\", \"jslt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jslt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLT32ILE, \"jslt32ile\", \"jslt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jslt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLT32RLE, \"jslt32rle\", \"jslt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsle $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLEILE, \"jsleile\", \"jsle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsle $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLERLE, \"jslerle\", \"jsle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsle32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLE32ILE, \"jsle32ile\", \"jsle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jsle32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLE32RLE, \"jsle32rle\", \"jsle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* jeq $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQIBE, \"jeqibe\", \"jeq\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jeq $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JEQRBE, \"jeqrbe\", \"jeq\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jeq32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQ32IBE, \"jeq32ibe\", \"jeq32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jeq32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JEQ32RBE, \"jeq32rbe\", \"jeq32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jgt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGTIBE, \"jgtibe\", \"jgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jgt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGTRBE, \"jgtrbe\", \"jgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jgt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGT32IBE, \"jgt32ibe\", \"jgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jgt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGT32RBE, \"jgt32rbe\", \"jgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jge $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGEIBE, \"jgeibe\", \"jge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jge $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGERBE, \"jgerbe\", \"jge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jge32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGE32IBE, \"jge32ibe\", \"jge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jge32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGE32RBE, \"jge32rbe\", \"jge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jlt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLTIBE, \"jltibe\", \"jlt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jlt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLTRBE, \"jltrbe\", \"jlt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jlt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLT32IBE, \"jlt32ibe\", \"jlt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jlt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLT32RBE, \"jlt32rbe\", \"jlt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jle $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLEIBE, \"jleibe\", \"jle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jle $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLERBE, \"jlerbe\", \"jle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jle32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLE32IBE, \"jle32ibe\", \"jle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jle32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLE32RBE, \"jle32rbe\", \"jle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jset $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSETIBE, \"jsetibe\", \"jset\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jset $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSETRBE, \"jsetrbe\", \"jset\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jset32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSET32IBE, \"jset32ibe\", \"jset32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jset32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSET32RBE, \"jset32rbe\", \"jset32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jne $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JNEIBE, \"jneibe\", \"jne\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jne $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JNERBE, \"jnerbe\", \"jne\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jne32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JNE32IBE, \"jne32ibe\", \"jne32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jne32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JNE32RBE, \"jne32rbe\", \"jne32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsgt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGTIBE, \"jsgtibe\", \"jsgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsgt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGTRBE, \"jsgtrbe\", \"jsgt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsgt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGT32IBE, \"jsgt32ibe\", \"jsgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsgt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGT32RBE, \"jsgt32rbe\", \"jsgt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsge $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGEIBE, \"jsgeibe\", \"jsge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsge $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGERBE, \"jsgerbe\", \"jsge\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsge32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGE32IBE, \"jsge32ibe\", \"jsge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsge32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGE32RBE, \"jsge32rbe\", \"jsge32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jslt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLTIBE, \"jsltibe\", \"jslt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jslt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLTRBE, \"jsltrbe\", \"jslt\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jslt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLT32IBE, \"jslt32ibe\", \"jslt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jslt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLT32RBE, \"jslt32rbe\", \"jslt32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsle $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLEIBE, \"jsleibe\", \"jsle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsle $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLERBE, \"jslerbe\", \"jsle\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsle32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLE32IBE, \"jsle32ibe\", \"jsle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* jsle32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLE32RBE, \"jsle32rbe\", \"jsle32\", 64,\n-    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* call $disp32 */\n   {\n     BPF_INSN_CALLLE, \"callle\", \"call\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* call $disp32 */\n   {\n     BPF_INSN_CALLBE, \"callbe\", \"call\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n+  },\n+/* call $dstle */\n+  {\n+    BPF_INSN_CALLRLE, \"callrle\", \"call\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x20\" } } } }\n+  },\n+/* call $dstbe */\n+  {\n+    BPF_INSN_CALLRBE, \"callrbe\", \"call\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x10\" } } } }\n   },\n /* ja $disp16 */\n   {\n     BPF_INSN_JA, \"ja\", \"ja\", 64,\n-    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n /* exit */\n   {\n     BPF_INSN_EXIT, \"exit\", \"exit\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n /* xadddw [$dstle+$offset16],$srcle */\n   {\n     BPF_INSN_XADDDWLE, \"xadddwle\", \"xadddw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* xaddw [$dstle+$offset16],$srcle */\n   {\n     BPF_INSN_XADDWLE, \"xaddwle\", \"xaddw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xa0\" } } } }\n   },\n /* xadddw [$dstbe+$offset16],$srcbe */\n   {\n     BPF_INSN_XADDDWBE, \"xadddwbe\", \"xadddw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* xaddw [$dstbe+$offset16],$srcbe */\n   {\n     BPF_INSN_XADDWBE, \"xaddwbe\", \"xaddw\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x50\" } } } }\n   },\n /* brkpt */\n   {\n     BPF_INSN_BRKPT, \"brkpt\", \"brkpt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xf0\" } } } }\n   },\n };\n "
    },
    {
      "sha": "dd24996492b42442ca00195e68d122c43bad3232",
      "filename": "opcodes/bpf-desc.h",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-desc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-desc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-desc.h?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -99,12 +99,13 @@ typedef enum insn_op_size {\n \n /* Enum declaration for machine type selection.  */\n typedef enum mach_attr {\n-  MACH_BASE, MACH_BPF, MACH_MAX\n+  MACH_BASE, MACH_BPF, MACH_XBPF, MACH_MAX\n } MACH_ATTR;\n \n /* Enum declaration for instruction set selection.  */\n typedef enum isa_attr {\n-  ISA_EBPFLE, ISA_EBPFBE, ISA_MAX\n+  ISA_EBPFLE, ISA_EBPFBE, ISA_XBPFLE, ISA_XBPFBE\n+ , ISA_MAX\n } ISA_ATTR;\n \n /* Number of architecture variants.  */"
    },
    {
      "sha": "72d5cd2e0c7d4020de7f2c21ba6adf45eaec8506",
      "filename": "opcodes/bpf-opc.c",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-opc.c?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -1552,6 +1552,18 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', OP (DISP32), 0 } },\n     & ifmt_callle, { 0x85 }\n   },\n+/* call $dstle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), 0 } },\n+    & ifmt_negle, { 0x8d }\n+  },\n+/* call $dstbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), 0 } },\n+    & ifmt_negbe, { 0x8d }\n+  },\n /* ja $disp16 */\n   {\n     { 0, 0, 0, 0 },"
    },
    {
      "sha": "5d5150c68564f319747b86c70439368c2dd5597a",
      "filename": "opcodes/bpf-opc.h",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/bpf-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-opc.h?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -106,8 +106,9 @@ typedef enum cgen_insn_type {\n  , BPF_INSN_JSGERBE, BPF_INSN_JSGE32IBE, BPF_INSN_JSGE32RBE, BPF_INSN_JSLTIBE\n  , BPF_INSN_JSLTRBE, BPF_INSN_JSLT32IBE, BPF_INSN_JSLT32RBE, BPF_INSN_JSLEIBE\n  , BPF_INSN_JSLERBE, BPF_INSN_JSLE32IBE, BPF_INSN_JSLE32RBE, BPF_INSN_CALLLE\n- , BPF_INSN_CALLBE, BPF_INSN_JA, BPF_INSN_EXIT, BPF_INSN_XADDDWLE\n- , BPF_INSN_XADDWLE, BPF_INSN_XADDDWBE, BPF_INSN_XADDWBE, BPF_INSN_BRKPT\n+ , BPF_INSN_CALLBE, BPF_INSN_CALLRLE, BPF_INSN_CALLRBE, BPF_INSN_JA\n+ , BPF_INSN_EXIT, BPF_INSN_XADDDWLE, BPF_INSN_XADDWLE, BPF_INSN_XADDDWBE\n+ , BPF_INSN_XADDWBE, BPF_INSN_BRKPT\n } CGEN_INSN_TYPE;\n \n /* Index of `invalid' insn place holder.  */"
    },
    {
      "sha": "fd566a9979aa129ac1f084ef8194049f51380078",
      "filename": "opcodes/disassemble.c",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/disassemble.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4449c81a85eef44b10532032207e8db5858c00ee/opcodes/disassemble.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/disassemble.c?ref=4449c81a85eef44b10532032207e8db5858c00ee",
      "patch": "@@ -663,11 +663,19 @@ disassemble_init_for_target (struct disassemble_info * info)\n       info->endian_code = BFD_ENDIAN_LITTLE;\n       if (!info->private_data)\n \t{\n-\t  info->private_data = cgen_bitset_create (ISA_EBPFMAX);\n+\t  info->private_data = cgen_bitset_create (ISA_MAX);\n \t  if (info->endian == BFD_ENDIAN_BIG)\n-\t    cgen_bitset_set (info->private_data, ISA_EBPFBE);\n+\t    {\n+\t      cgen_bitset_set (info->private_data, ISA_EBPFBE);\n+\t      if (info->mach == bfd_mach_xbpf)\n+\t\tcgen_bitset_set (info->private_data, ISA_XBPFBE);\n+\t    }\n \t  else\n-\t    cgen_bitset_set (info->private_data, ISA_EBPFLE);\n+\t    {\n+\t      cgen_bitset_set (info->private_data, ISA_EBPFLE);\n+\t      if (info->mach == bfd_mach_xbpf)\n+\t\tcgen_bitset_set (info->private_data, ISA_XBPFLE);\n+\t    }\n \t}\n       break;\n #endif"
    }
  ]
}