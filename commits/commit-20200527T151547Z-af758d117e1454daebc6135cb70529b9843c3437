{
  "sha": "af758d117e1454daebc6135cb70529b9843c3437",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWY3NThkMTE3ZTE0NTRkYWViYzYxMzVjYjcwNTI5Yjk4NDNjMzQzNw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-05-27T15:15:47Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:15:47Z"
    },
    "message": "Remove symtab links from dwarf2_psymtab and dwarf2_per_cu_quick_data\n\nThe dwarf2_psymtab and dwarf2_per_cu_quick_data types contain a pointer\nto a compunit_symtab, which is a pointer to the corresponding full\nsymtab.  The dwarf2_psymtab and dwarf2_per_cu_quick_data objects are\ngoing to become objfile-independent, and possibly shared by multiple\nobjfiles, whereas compunit_symtab will stay objfile-dependent.  This\nbacklink to the compunit_symtab must therefore be removed.\n\nThis patch replaces them with a vector in the dwarf2_per_objfile type,\nthat serves as a mapping from dwarf2_per_cu_data objects to\ncompunit_symtab objects, for this particular objfile.  The vector is\nindexed using the index assigned to the dwarf2_per_cu_data at its\ncreation.\n\nI removed the get_compunit_symtab, as it appears to bring not much value\nover calling dwarf2_per_objfile::get_symtab directly.\n\ngdb/ChangeLog:\n\nYYYY-MM-DD  Tom Tromey  <tom@tromey.com>\nYYYY-MM-DD  Simon Marchi  <simon.marchi@efficios.com>\n\n\t* dwarf2/read.h (struct dwarf2_per_bfd) <num_psymtabs>: New\n\tmethod.\n\t(struct dwarf2_per_objfile) <resize_symtabs, symtab_set_p,\n\tget_symtab, set_symtab>: New methods.\n\t<m_symtabs>: New field.\n\t(struct dwarf2_psymtab): Derive from partial_symtab.\n\t<readin_p, get_compunit_symtab>: Declare methods.\n\t* dwarf2/read.c (dwarf2_per_objfile::symtab_set_p,\n\tdwarf2_per_objfile::get_symtab, dwarf2_per_objfile::set_symtab):\n\tNew methods.\n\t(struct dwarf2_per_cu_quick_data) <compunit_symtab>: Remove.\n\t(dw2_do_instantiate_symtab, dw2_instantiate_symtab)\n\t(dw2_map_expand_apply, dw2_map_symtabs_matching_filename)\n\t(dw2_symtab_iter_next, dw2_print_stats)\n\t(dw2_expand_symtabs_with_fullname)\n\t(dw2_expand_symtabs_matching_one)\n\t(dw_expand_symtabs_matching_file_matcher)\n\t(dw2_find_pc_sect_compunit_symtab, dw2_map_symbol_filenames)\n\t(dw2_debug_names_iterator::next)\n\t(dw2_debug_names_map_matching_symbols)\n\t(fill_in_sig_entry_from_dwo_entry, dwarf2_psymtab::read_symtab)\n\t(process_queue, dwarf2_psymtab::expand_psymtab): Update.\n\t(dwarf2_psymtab::readin_p, dwarf2_psymtab::get_compunit_symtab):\n\tNew methods.\n\t(get_compunit_symtab, process_full_comp_unit)\n\t(process_full_type_unit): Update.\n\t(dwarf2_build_psymtabs, dwarf2_initialize_objfile, add_type_unit): Call\n\nChange-Id: Iec53d96e0b70a57d8b68408febdac3c6c3d4854b",
    "tree": {
      "sha": "3d7dac616c76fc95f03dc3543939476a4fbc4095",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3d7dac616c76fc95f03dc3543939476a4fbc4095"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/af758d117e1454daebc6135cb70529b9843c3437",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af758d117e1454daebc6135cb70529b9843c3437",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/af758d117e1454daebc6135cb70529b9843c3437",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af758d117e1454daebc6135cb70529b9843c3437/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2"
    }
  ],
  "stats": {
    "total": 230,
    "additions": 160,
    "deletions": 70
  },
  "files": [
    {
      "sha": "55ee15a98cde6d2bc3f01a351330d3b0f533fcae",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af758d117e1454daebc6135cb70529b9843c3437/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af758d117e1454daebc6135cb70529b9843c3437/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=af758d117e1454daebc6135cb70529b9843c3437",
      "patch": "@@ -1,3 +1,34 @@\n+2020-05-27  Tom Tromey  <tom@tromey.com>\n+\t    Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/read.h (struct dwarf2_per_bfd) <num_psymtabs>: New\n+\tmethod.\n+\t(struct dwarf2_per_objfile) <resize_symtabs, symtab_set_p,\n+\tget_symtab, set_symtab>: New methods.\n+\t<m_symtabs>: New field.\n+\t(struct dwarf2_psymtab): Derive from partial_symtab.\n+\t<readin_p, get_compunit_symtab>: Declare methods.\n+\t* dwarf2/read.c (dwarf2_per_objfile::symtab_set_p,\n+\tdwarf2_per_objfile::get_symtab, dwarf2_per_objfile::set_symtab):\n+\tNew methods.\n+\t(struct dwarf2_per_cu_quick_data) <compunit_symtab>: Remove.\n+\t(dw2_do_instantiate_symtab, dw2_instantiate_symtab)\n+\t(dw2_map_expand_apply, dw2_map_symtabs_matching_filename)\n+\t(dw2_symtab_iter_next, dw2_print_stats)\n+\t(dw2_expand_symtabs_with_fullname)\n+\t(dw2_expand_symtabs_matching_one)\n+\t(dw_expand_symtabs_matching_file_matcher)\n+\t(dw2_find_pc_sect_compunit_symtab, dw2_map_symbol_filenames)\n+\t(dw2_debug_names_iterator::next)\n+\t(dw2_debug_names_map_matching_symbols)\n+\t(fill_in_sig_entry_from_dwo_entry, dwarf2_psymtab::read_symtab)\n+\t(process_queue, dwarf2_psymtab::expand_psymtab): Update.\n+\t(dwarf2_psymtab::readin_p, dwarf2_psymtab::get_compunit_symtab):\n+\tNew methods.\n+\t(get_compunit_symtab, process_full_comp_unit)\n+\t(process_full_type_unit): Update.\n+\t(dwarf2_build_psymtabs, dwarf2_initialize_objfile, add_type_unit): Call\n+\n 2020-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.h (dwarf2_per_objfile): Rename to dwarf2_per_bfd,"
    },
    {
      "sha": "a7409b5a1ef33f6469b49f3360393a1682774bab",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 94,
      "deletions": 68,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af758d117e1454daebc6135cb70529b9843c3437/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af758d117e1454daebc6135cb70529b9843c3437/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=af758d117e1454daebc6135cb70529b9843c3437",
      "patch": "@@ -1811,6 +1811,38 @@ class free_cached_comp_units\n   dwarf2_per_objfile *m_per_objfile;\n };\n \n+/* See read.h.  */\n+\n+bool\n+dwarf2_per_objfile::symtab_set_p (const dwarf2_per_cu_data *per_cu) const\n+{\n+  gdb_assert (per_cu->index < this->m_symtabs.size ());\n+\n+  return this->m_symtabs[per_cu->index] != nullptr;\n+}\n+\n+/* See read.h.  */\n+\n+compunit_symtab *\n+dwarf2_per_objfile::get_symtab (const dwarf2_per_cu_data *per_cu) const\n+{\n+  gdb_assert (per_cu->index < this->m_symtabs.size ());\n+\n+  return this->m_symtabs[per_cu->index];\n+}\n+\n+/* See read.h.  */\n+\n+void\n+dwarf2_per_objfile::set_symtab (const dwarf2_per_cu_data *per_cu,\n+\t\t\t\tcompunit_symtab *symtab)\n+{\n+  gdb_assert (per_cu->index < this->m_symtabs.size ());\n+  gdb_assert (this->m_symtabs[per_cu->index] == nullptr);\n+\n+  this->m_symtabs[per_cu->index] = symtab;\n+}\n+\n /* Try to locate the sections we need for DWARF 2 debugging\n    information and return true if we have enough to do something.\n    NAMES points to the dwarf2 section names, or is NULL if the standard\n@@ -2198,10 +2230,6 @@ struct dwarf2_per_cu_quick_data\n      NOTE: This points into dwarf2_per_objfile->per_bfd->quick_file_names_table.  */\n   struct quick_file_names *file_names;\n \n-  /* The corresponding symbol table.  This is NULL if symbols for this\n-     CU have not yet been read.  */\n-  struct compunit_symtab *compunit_symtab;\n-\n   /* A temporary mark bit used when iterating over all CUs in\n      expand_symtabs_matching.  */\n   unsigned int mark : 1;\n@@ -2325,9 +2353,7 @@ dw2_do_instantiate_symtab (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n      with the dwarf queue empty.  */\n   dwarf2_queue_guard q_guard (dwarf2_per_objfile);\n \n-  if (dwarf2_per_objfile->per_bfd->using_index\n-      ? per_cu->v.quick->compunit_symtab == NULL\n-      : (per_cu->v.psymtab == NULL || !per_cu->v.psymtab->readin))\n+  if (!dwarf2_per_objfile->symtab_set_p (per_cu))\n     {\n       queue_comp_unit (per_cu, language_minimal);\n       load_cu (per_cu, skip_partial);\n@@ -2362,15 +2388,16 @@ dw2_instantiate_symtab (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n   struct dwarf2_per_objfile *dwarf2_per_objfile = per_cu->dwarf2_per_objfile;\n \n   gdb_assert (dwarf2_per_objfile->per_bfd->using_index);\n-  if (!per_cu->v.quick->compunit_symtab)\n+\n+  if (!dwarf2_per_objfile->symtab_set_p (per_cu))\n     {\n       free_cached_comp_units freer (dwarf2_per_objfile);\n       scoped_restore decrementer = increment_reading_symtab ();\n       dw2_do_instantiate_symtab (per_cu, skip_partial);\n       process_cu_includes (dwarf2_per_objfile);\n     }\n \n-  return per_cu->v.quick->compunit_symtab;\n+  return dwarf2_per_objfile->get_symtab (per_cu);\n }\n \n /* See declaration.  */\n@@ -3274,7 +3301,8 @@ dw2_map_expand_apply (struct objfile *objfile,\n   struct compunit_symtab *last_made = objfile->compunit_symtabs;\n \n   /* Don't visit already-expanded CUs.  */\n-  if (per_cu->v.quick->compunit_symtab)\n+  dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n+  if (per_objfile->symtab_set_p (per_cu))\n     return 0;\n \n   /* This may expand more than one symtab, and we want to iterate over\n@@ -3302,7 +3330,7 @@ dw2_map_symtabs_matching_filename\n   for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       /* We only need to look at symtabs not already expanded.  */\n-      if (per_cu->v.quick->compunit_symtab)\n+      if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n       quick_file_names *file_data = dw2_get_file_names (per_cu);\n@@ -3444,7 +3472,7 @@ dw2_symtab_iter_next (struct dw2_symtab_iterator *iter)\n       dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (cu_index);\n \n       /* Skip if already read in.  */\n-      if (per_cu->v.quick->compunit_symtab)\n+      if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n       /* Check static vs global.  */\n@@ -3559,7 +3587,7 @@ dw2_print_stats (struct objfile *objfile)\n     {\n       dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (i);\n \n-      if (!per_cu->v.quick->compunit_symtab)\n+      if (!dwarf2_per_objfile->symtab_set_p (per_cu))\n \t++count;\n     }\n   printf_filtered (_(\"  Number of read CUs: %d\\n\"), total - count);\n@@ -3642,7 +3670,7 @@ dw2_expand_symtabs_with_fullname (struct objfile *objfile,\n   for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       /* We only need to look at symtabs not already expanded.  */\n-      if (per_cu->v.quick->compunit_symtab)\n+      if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n       quick_file_names *file_data = dw2_get_file_names (per_cu);\n@@ -4503,15 +4531,14 @@ dw2_expand_symtabs_matching_one\n {\n   if (file_matcher == NULL || per_cu->v.quick->mark)\n     {\n-      bool symtab_was_null\n-\t= (per_cu->v.quick->compunit_symtab == NULL);\n+      dwarf2_per_objfile *per_objfile = per_cu->dwarf2_per_objfile;\n+      bool symtab_was_null = !per_objfile->symtab_set_p (per_cu);\n \n-      dw2_instantiate_symtab (per_cu, false);\n+      compunit_symtab *symtab = dw2_instantiate_symtab (per_cu, false);\n+      gdb_assert (symtab != nullptr);\n \n-      if (expansion_notify != NULL\n-\t  && symtab_was_null\n-\t  && per_cu->v.quick->compunit_symtab != NULL)\n-\texpansion_notify (per_cu->v.quick->compunit_symtab);\n+      if (expansion_notify != NULL && symtab_was_null)\n+\texpansion_notify (symtab);\n     }\n }\n \n@@ -4629,7 +4656,7 @@ dw_expand_symtabs_matching_file_matcher\n       per_cu->v.quick->mark = 0;\n \n       /* We only need to look at symtabs not already expanded.  */\n-      if (per_cu->v.quick->compunit_symtab)\n+      if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n       quick_file_names *file_data = dw2_get_file_names (per_cu);\n@@ -4767,7 +4794,8 @@ dw2_find_pc_sect_compunit_symtab (struct objfile *objfile,\n   if (!data)\n     return NULL;\n \n-  if (warn_if_readin && data->v.quick->compunit_symtab)\n+  dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n+  if (warn_if_readin && per_objfile->symtab_set_p (data))\n     warning (_(\"(Internal error: pc %s in read in CU, but not in symtab.)\"),\n \t     paddress (objfile->arch (), pc));\n \n@@ -4800,7 +4828,7 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n \n       for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n \t{\n-\t  if (per_cu->v.quick->compunit_symtab)\n+\t  if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \t    {\n \t      void **slot = htab_find_slot (visited.get (),\n \t\t\t\t\t    per_cu->v.quick->file_names,\n@@ -4813,7 +4841,7 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n       for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n \t{\n \t  /* We only need to look at symtabs not already expanded.  */\n-\t  if (per_cu->v.quick->compunit_symtab)\n+\t  if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \t    continue;\n \n \t  quick_file_names *file_data = dw2_get_file_names (per_cu);\n@@ -5484,7 +5512,7 @@ dw2_debug_names_iterator::next ()\n     }\n \n   /* Skip if already read in.  */\n-  if (per_cu->v.quick->compunit_symtab)\n+  if (dwarf2_per_objfile->symtab_set_p (per_cu))\n     goto again;\n \n   /* Check static vs global.  */\n@@ -5725,11 +5753,11 @@ dw2_debug_names_map_matching_symbols\n      the psymtab code does.  */\n   for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n-      struct compunit_symtab *cust = per_cu->v.quick->compunit_symtab;\n-      if (cust != nullptr)\n+      compunit_symtab *symtab = dwarf2_per_objfile->get_symtab (per_cu);\n+      if (symtab != nullptr)\n \t{\n \t  const struct block *block\n-\t    = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust), block_kind);\n+\t    = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (symtab), block_kind);\n \t  if (!iterate_over_symbols_terminated (block, name,\n \t\t\t\t\t\tdomain, callback))\n \t    break;\n@@ -5879,6 +5907,7 @@ dwarf2_initialize_objfile (struct objfile *objfile, dw_index_kind *index_kind)\n       dwarf2_per_objfile->per_bfd->quick_file_names_table\n \t= create_quick_file_names_table\n \t    (dwarf2_per_objfile->per_bfd->all_comp_units.size ());\n+      dwarf2_per_objfile->resize_symtabs ();\n \n       for (int i = 0; i < (dwarf2_per_objfile->per_bfd->all_comp_units.size ()\n \t\t\t   + dwarf2_per_objfile->per_bfd->all_type_units.size ()); ++i)\n@@ -5899,6 +5928,7 @@ dwarf2_initialize_objfile (struct objfile *objfile, dw_index_kind *index_kind)\n   if (dwarf2_read_debug_names (dwarf2_per_objfile))\n     {\n       *index_kind = dw_index_kind::DEBUG_NAMES;\n+      dwarf2_per_objfile->resize_symtabs ();\n       return true;\n     }\n \n@@ -5907,6 +5937,7 @@ dwarf2_initialize_objfile (struct objfile *objfile, dw_index_kind *index_kind)\n \t\t\t     get_gdb_index_contents_from_section<dwz_file>))\n     {\n       *index_kind = dw_index_kind::GDB_INDEX;\n+      dwarf2_per_objfile->resize_symtabs ();\n       return true;\n     }\n \n@@ -5917,6 +5948,7 @@ dwarf2_initialize_objfile (struct objfile *objfile, dw_index_kind *index_kind)\n     {\n       global_index_cache.hit ();\n       *index_kind = dw_index_kind::GDB_INDEX;\n+      dwarf2_per_objfile->resize_symtabs ();\n       return true;\n     }\n \n@@ -5945,6 +5977,8 @@ dwarf2_build_psymtabs (struct objfile *objfile)\n       dwarf2_build_psymtabs_hard (dwarf2_per_objfile);\n       psymtabs.keep ();\n \n+      dwarf2_per_objfile->resize_symtabs ();\n+\n       /* (maybe) store an index in the cache.  */\n       global_index_cache.store (dwarf2_per_objfile);\n     }\n@@ -6375,6 +6409,8 @@ add_type_unit (struct dwarf2_per_objfile *dwarf2_per_objfile, ULONGEST sig,\n \n   signatured_type *sig_type = dwarf2_per_objfile->per_bfd->allocate_signatured_type ();\n \n+  dwarf2_per_objfile->resize_symtabs ();\n+\n   dwarf2_per_objfile->per_bfd->all_type_units.push_back (sig_type);\n   sig_type->signature = sig;\n   sig_type->per_cu.is_debug_types = 1;\n@@ -6410,7 +6446,7 @@ fill_in_sig_entry_from_dwo_entry (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   if (dwarf2_per_objfile->per_bfd->using_index)\n     {\n       gdb_assert (sig_entry->per_cu.v.quick != NULL);\n-      gdb_assert (sig_entry->per_cu.v.quick->compunit_symtab == NULL);\n+      gdb_assert (!dwarf2_per_objfile->symtab_set_p (&sig_entry->per_cu));\n     }\n   else\n       gdb_assert (sig_entry->per_cu.v.psymtab == NULL);\n@@ -8837,7 +8873,8 @@ dwarf2_psymtab::read_symtab (struct objfile *objfile)\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  gdb_assert (!readin);\n+  gdb_assert (!dwarf2_per_objfile->symtab_set_p (per_cu_data));\n+\n   /* If this psymtab is constructed from a debug-only objfile, the\n      has_section_at_zero flag will not necessarily be correct.  We\n      can get the correct value for this flag by looking at the data\n@@ -8933,9 +8970,7 @@ process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile)\n     {\n       dwarf2_queue_item &item = dwarf2_per_objfile->per_bfd->queue.front ();\n \n-      if ((dwarf2_per_objfile->per_bfd->using_index\n-\t   ? !item.per_cu->v.quick->compunit_symtab\n-\t   : (item.per_cu->v.psymtab && !item.per_cu->v.psymtab->readin))\n+      if (!dwarf2_per_objfile->symtab_set_p (item.per_cu)\n \t  /* Skip dummy CUs.  */\n \t  && item.per_cu->cu != NULL)\n \t{\n@@ -8990,14 +9025,32 @@ process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile)\n void\n dwarf2_psymtab::expand_psymtab (struct objfile *objfile)\n {\n-  gdb_assert (!readin);\n+  gdb_assert (!readin_p (objfile));\n \n   expand_dependencies (objfile);\n \n   dw2_do_instantiate_symtab (per_cu_data, false);\n   gdb_assert (get_compunit_symtab (objfile) != nullptr);\n }\n \n+/* See psympriv.h.  */\n+\n+bool\n+dwarf2_psymtab::readin_p (struct objfile *objfile) const\n+{\n+  dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n+  return per_objfile->symtab_set_p (per_cu_data);\n+}\n+\n+/* See psympriv.h.  */\n+\n+compunit_symtab *\n+dwarf2_psymtab::get_compunit_symtab (struct objfile *objfile) const\n+{\n+  dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n+  return per_objfile->get_symtab (per_cu_data);\n+}\n+\n /* Trivial hash function for die_info: the hash value of a DIE\n    is its offset in .debug_info for this objfile.  */\n \n@@ -9535,17 +9588,6 @@ rust_union_quirks (struct dwarf2_cu *cu)\n   cu->rust_unions.clear ();\n }\n \n-/* Return the symtab for PER_CU.  This works properly regardless of\n-   whether we're using the index or psymtabs.  */\n-\n-static struct compunit_symtab *\n-get_compunit_symtab (struct dwarf2_per_cu_data *per_cu)\n-{\n-  return (per_cu->dwarf2_per_objfile->per_bfd->using_index\n-\t  ? per_cu->v.quick->compunit_symtab\n-\t  : per_cu->v.psymtab->compunit_symtab);\n-}\n-\n /* A helper function for computing the list of all symbol tables\n    included by PER_CU.  */\n \n@@ -9555,19 +9597,17 @@ recursively_compute_inclusions (std::vector<compunit_symtab *> *result,\n \t\t\t\tstruct dwarf2_per_cu_data *per_cu,\n \t\t\t\tstruct compunit_symtab *immediate_parent)\n {\n-  void **slot;\n-  struct compunit_symtab *cust;\n-\n-  slot = htab_find_slot (all_children, per_cu, INSERT);\n+  void **slot = htab_find_slot (all_children, per_cu, INSERT);\n   if (*slot != NULL)\n     {\n       /* This inclusion and its children have been processed.  */\n       return;\n     }\n \n   *slot = per_cu;\n+\n   /* Only add a CU if it has a symbol table.  */\n-  cust = get_compunit_symtab (per_cu);\n+  compunit_symtab *cust = per_cu->dwarf2_per_objfile->get_symtab (per_cu);\n   if (cust != NULL)\n     {\n       /* If this is a type unit only add its symbol table if we haven't\n@@ -9612,7 +9652,7 @@ compute_compunit_symtab_includes (struct dwarf2_per_cu_data *per_cu)\n       int len;\n       std::vector<compunit_symtab *> result_symtabs;\n       htab_t all_children, all_type_symtabs;\n-      struct compunit_symtab *cust = get_compunit_symtab (per_cu);\n+      compunit_symtab *cust = per_cu->dwarf2_per_objfile->get_symtab (per_cu);\n \n       /* If we don't have a symtab, we can just skip this case.  */\n       if (cust == NULL)\n@@ -9749,14 +9789,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n       cust->call_site_htab = cu->call_site_htab;\n     }\n \n-  if (dwarf2_per_objfile->per_bfd->using_index)\n-    per_cu->v.quick->compunit_symtab = cust;\n-  else\n-    {\n-      dwarf2_psymtab *pst = per_cu->v.psymtab;\n-      pst->compunit_symtab = cust;\n-      pst->readin = true;\n-    }\n+  dwarf2_per_objfile->set_symtab (per_cu, cust);\n \n   /* Push it for inclusion processing later.  */\n   dwarf2_per_objfile->per_bfd->just_read_cus.push_back (per_cu);\n@@ -9829,14 +9862,7 @@ process_full_type_unit (struct dwarf2_per_cu_data *per_cu,\n       cust = sig_type->type_unit_group->compunit_symtab;\n     }\n \n-  if (dwarf2_per_objfile->per_bfd->using_index)\n-    per_cu->v.quick->compunit_symtab = cust;\n-  else\n-    {\n-      dwarf2_psymtab *pst = per_cu->v.psymtab;\n-      pst->compunit_symtab = cust;\n-      pst->readin = true;\n-    }\n+  dwarf2_per_objfile->set_symtab (per_cu, cust);\n \n   /* Not needed any more.  */\n   cu->reset_builder ();"
    },
    {
      "sha": "7631938edb0c3e0e7ae506f8b6bdc1503dbf2485",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 35,
      "deletions": 2,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af758d117e1454daebc6135cb70529b9843c3437/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af758d117e1454daebc6135cb70529b9843c3437/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=af758d117e1454daebc6135cb70529b9843c3437",
      "patch": "@@ -123,6 +123,11 @@ struct dwarf2_per_bfd\n      is allocated on the dwarf2_per_bfd obstack.  */\n   signatured_type *allocate_signatured_type ();\n \n+  /* Return the number of partial symtabs allocated with allocate_per_cu\n+     and allocate_signatured_type so far.  */\n+  int num_psymtabs () const\n+  { return m_num_psymtabs; }\n+\n private:\n   /* This function is mapped across the sections and remembers the\n      offset and size of each of the debugging sections we are\n@@ -278,30 +283,58 @@ struct dwarf2_per_objfile\n \t\t\t\tconst struct comp_unit_head *cu_header,\n \t\t\t\tunsigned int *bytes_read_ptr);\n \n+  /* Resize the M_SYMTABS vector to the needed size (the number of partial\n+     symtabs allocated by the per-bfd).  */\n+  void resize_symtabs ()\n+  {\n+    /* The symtabs vector should only grow, not shrink.  */\n+    gdb_assert (per_bfd->num_psymtabs () >= m_symtabs.size ());\n+\n+    m_symtabs.resize (per_bfd->num_psymtabs ());\n+  }\n+\n+  /* Return true if the symtab corresponding to PER_CU has been set,\n+     false otherwise.  */\n+  bool symtab_set_p (const dwarf2_per_cu_data *per_cu) const;\n+\n+  /* Return the compunit_symtab associated to PER_CU, if it has been created.  */\n+  compunit_symtab *get_symtab (const dwarf2_per_cu_data *per_cu) const;\n+\n+  /* Set the compunit_symtab associated to PER_CU.  */\n+  void set_symtab (const dwarf2_per_cu_data *per_cu, compunit_symtab *symtab);\n+\n   /* Back link.  */\n   struct objfile *objfile;\n \n   /* Pointer to the data that is (possibly) shared between this objfile and\n      other objfiles backed by the same BFD.  */\n   struct dwarf2_per_bfd *per_bfd;\n+\n+private:\n+  /* Hold the corresponding compunit_symtab for each CU or TU.  This\n+     is indexed by dwarf2_per_cu_data::index.  A NULL value means\n+     that the CU/TU has not been expanded yet.  */\n+  std::vector<compunit_symtab *> m_symtabs;\n };\n \n /* Get the dwarf2_per_objfile associated to OBJFILE.  */\n \n dwarf2_per_objfile *get_dwarf2_per_objfile (struct objfile *objfile);\n \n /* A partial symtab specialized for DWARF.  */\n-struct dwarf2_psymtab : public standard_psymtab\n+struct dwarf2_psymtab : public partial_symtab\n {\n   dwarf2_psymtab (const char *filename, struct objfile *objfile,\n \t\t  dwarf2_per_cu_data *per_cu)\n-    : standard_psymtab (filename, objfile, 0),\n+    : partial_symtab (filename, objfile, 0),\n       per_cu_data (per_cu)\n   {\n   }\n \n   void read_symtab (struct objfile *) override;\n   void expand_psymtab (struct objfile *) override;\n+  bool readin_p (struct objfile *) const override;\n+  compunit_symtab *get_compunit_symtab (struct objfile *) const override;\n \n   struct dwarf2_per_cu_data *per_cu_data;\n };"
    }
  ]
}