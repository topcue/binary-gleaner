{
  "sha": "5c076da45ce9a24d47046ddb0bac02e158e6bf58",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWMwNzZkYTQ1Y2U5YTI0ZDQ3MDQ2ZGRiMGJhYzAyZTE1OGU2YmY1OA==",
  "commit": {
    "author": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2019-06-03T01:31:22Z"
    },
    "committer": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2019-07-27T20:38:44Z"
    },
    "message": "Improve test gdb.dwarf2/dw2-ranges-func.exp\n\nThe original dw2-ranges-func.exp test caused a function named foo to be\ncreated with two non-contiguous address ranges.  In the C source file,\na function named foo_low was incorporated into the function foo which\nwas also defined in that file.  The DWARF assembler is used to do this\nmanipulation.  The source file had been laid out so that foo_low would\nlikely be placed (by the compiler and linker) at a lower address than\nfoo().\n\nThe case where a range at a higher set of addresses (than foo) was not\nbeing tested.  In a recent discussion on gdb-patches, it became clear\nthat performing such tests are desirable because bugs were discovered\nwhich only became evident when the other range was located at high(er)\naddresses than the range containing the entry point for the function.\n\nThis other (non entry pc) address range is typically used for \"cold\"\ncode which executes less frequently.  Thus, I renamed foo_low to\nfoo_cold and renamed the C source file from dw-ranges-func.c to\ndw-ranges-func-lo.c.  I then made a copy of this file, naming it\ndw-ranges-func-hi.c.  (That was my intent anyway.  According to git,\nI renamed dw-ranges-func.c to dw-ranges-func-hi.c and then modified it.\ndw-ranges-func-lo.c shows up as an entirely new file.)\n\nWithin dw-ranges-func-hi.c, I changed the placement of foo_cold()\nalong with some of the other functions so that foo_cold() would be at\na higher address than foo() while also remaining non-contiguous.  The\ntwo files, dw-ranges-func-lo.c and dw-ranges-func-hi.c, are\nessentially the same except for the placement of some of the functions\ntherein.\n\nThe tests in dw2-ranges-func.exp where then wrapped in a new proc named\ndo_test which was then called in a loop from the outermost level.  The\nloop causes each of the source files to have the same tests run upon\nthem.\n\nI also added a few new tests which test functionality fixed by the other\ncommits to this patch series.  Due to the reorganization of the file,\nit's hard to identify these changes in the patch.  So, here are the\ntests which were added:\n\n    with_test_prefix \"no-cold-names\" {\n\n\t# Due to the calling sequence, this backtrace would normally\n\t# show function foo_cold for frame #1.  However, we don't want\n\t# this to be the case due to placing it in the same block\n\t# (albeit at a different range) as foo.  Thus it is correct to\n\t# see foo for frames #1 and #2.  It is incorrect to see\n\t# foo_cold at frame #1.\n\tgdb_test_sequence \"bt\" \"backtrace from baz\" {\n\t    \"\\[\\r\\n\\]#0 .*? baz \\\\(\\\\) \"\n\t    \"\\[\\r\\n\\]#1 .*? foo \\\\(\\\\) \"\n\t    \"\\[\\r\\n\\]#2 .*? foo \\\\(\\\\) \"\n\t    \"\\[\\r\\n\\]#3 .*? main \\\\(\\\\) \"\n\t}\n\n\t# Doing x/2i foo_cold should show foo_cold as the first symbolic\n\t# address and an offset from foo for the second.  We also check to\n\t# make sure that the offset is not too large - we don't GDB to\n\t# display really large offsets that would (try to) wrap around the\n\t# address space.\n\tset foo_cold_offset 0\n\tset test \"x/2i foo_cold\"\n\tgdb_test_multiple $test $test {\n\t    -re \"   (?:$hex) <foo_cold>.*?\\n   (?:$hex) <foo\\[+-\\](\\[0-9\\]+)>.*${gdb_prompt}\" {\n\t        set foo_cold_offset $expect_out(1,string)\n\t\tpass $test\n\t    }\n\t}\n\tgdb_assert {$foo_cold_offset <= 10000} \"offset to foo_cold is not too large\"\n\n\t# Likewise, verify that second address shown by \"info line\" is at\n\t# and offset from foo instead of foo_cold.\n\tgdb_test \"info line *foo_cold\" \"starts at address $hex <foo_cold> and ends at $hex <foo\\[+-\\].*?>.*\"\n\n    }\n\nWhen run against a GDB without the requisite bug fixes (from this patch\nseries), these 6 failures should be seen:\n\nFAIL: gdb.dwarf2/dw2-ranges-func.exp: lo-cold: no-cold-names: backtrace from baz (pattern 4)\nFAIL: gdb.dwarf2/dw2-ranges-func.exp: lo-cold: no-cold-names: x/2i foo_cold\nFAIL: gdb.dwarf2/dw2-ranges-func.exp: lo-cold: no-cold-names: info line *foo_cold\nFAIL: gdb.dwarf2/dw2-ranges-func.exp: hi-cold: no-cold-names: backtrace from baz (pattern 3)\nFAIL: gdb.dwarf2/dw2-ranges-func.exp: hi-cold: no-cold-names: x/2i foo_cold\nFAIL: gdb.dwarf2/dw2-ranges-func.exp: hi-cold: no-cold-names: info line *foo_cold\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.dwarf2/dw2-ranges-func.c: Rename to...\n\t* gdb.dwarf2/dw2-ranges-func-lo-cold.c: ...this.\n\t* gdb.dwarf2/dw2-ranges-func-lo-cold.c (foo_low): Change name to\n\tfoo_cold.  Revise comments to match.\n\t* gdb.dwarf2/dw2-ranges-func-hi-cold.c: New file.\n\t* gdb.dwarf2/dw2-ranges-func.exp (do_test): New proc. Existing tests\n\twere wrapped into this proc; Call do_test in loop from outermost\n\tlevel.\n\t(foo_low): Rename all occurrences to \"foo_cold\".\n\t(backtrace from baz): New test.\n\t(x2/i foo_cold): New test.\n\t(info line *foo_cold): New test.",
    "tree": {
      "sha": "694665f17b760f6dc12c52b89f30ba223c3eb343",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/694665f17b760f6dc12c52b89f30ba223c3eb343"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5c076da45ce9a24d47046ddb0bac02e158e6bf58",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5c076da45ce9a24d47046ddb0bac02e158e6bf58",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5c076da45ce9a24d47046ddb0bac02e158e6bf58",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5c076da45ce9a24d47046ddb0bac02e158e6bf58/comments",
  "author": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1aff7173105c9540bbbef75727aa200f5c288b2e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1aff7173105c9540bbbef75727aa200f5c288b2e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1aff7173105c9540bbbef75727aa200f5c288b2e"
    }
  ],
  "stats": {
    "total": 834,
    "additions": 495,
    "deletions": 339
  },
  "files": [
    {
      "sha": "bd887c3191ab01aa2b30555ecb2bfbc42451226f",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=5c076da45ce9a24d47046ddb0bac02e158e6bf58",
      "patch": "@@ -1,3 +1,18 @@\n+2019-07-27  Kevin Buettner  <kevinb@redhat.com>\n+\n+\t* gdb.dwarf2/dw2-ranges-func.c: Rename to...\n+\t* gdb.dwarf2/dw2-ranges-func-lo-cold.c: ...this.\n+\t* gdb.dwarf2/dw2-ranges-func-lo-cold.c (foo_low): Change name to\n+\tfoo_cold.  Revise comments to match.\n+\t* gdb.dwarf2/dw2-ranges-func-hi-cold.c: New file.\n+\t* gdb.dwarf2/dw2-ranges-func.exp (do_test): New proc. Existing tests\n+\twere wrapped into this proc; Call do_test in loop from outermost\n+\tlevel.\n+\t(foo_low): Rename all occurrences to \"foo_cold\".\n+\t(backtrace from baz): New test.\n+\t(x2/i foo_cold): New test.\n+\t(info line *foo_cold): New test.\n+\n 2019-07-26  Tom de Vries  <tdevries@suse.de>\n \n \t* gdb.arch/i386-pkru.exp: Fix unterminated string."
    },
    {
      "sha": "06c3a3485aea508ecb44923dfaf79ac90e72d706",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-ranges-func-hi-cold.c",
      "status": "renamed",
      "additions": 24,
      "deletions": 20,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/gdb.dwarf2/dw2-ranges-func-hi-cold.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/gdb.dwarf2/dw2-ranges-func-hi-cold.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-ranges-func-hi-cold.c?ref=5c076da45ce9a24d47046ddb0bac02e158e6bf58",
      "patch": "@@ -16,7 +16,7 @@\n /* The idea here is to, via use of the dwarf assembler, create a function\n    which occupies two non-contiguous address ranges.\n \n-   foo_low and foo will be combined into a single function foo with a\n+   foo_cold and foo will be combined into a single function foo with a\n    function bar in between these two ranges.\n \n    This test case was motivated by a bug in which a function which\n@@ -37,19 +37,19 @@\n \n volatile int e = 0;\n \n-void\n-baz (void)\n-{\n-  asm (\"baz_label: .globl baz_label\");\n-}\t\t\t\t\t\t/* baz end */\n+void bar (void);\n+void foo_cold (void);\n+void baz (void);\n \n void\n-foo_low (void)\n-{\t\t\t\t\t\t/* foo_low prologue */\n-  asm (\"foo_low_label: .globl foo_low_label\");\n-  baz ();\t\t\t\t\t/* foo_low baz call */\n-  asm (\"foo_low_label2: .globl foo_low_label2\");\n-}\t\t\t\t\t\t/* foo_low end */\n+foo (void)\n+{\t\t\t\t\t\t/* foo prologue */\n+  asm (\"foo_label: .globl foo_label\");\n+  bar ();\t\t\t\t\t/* foo bar call */\n+  asm (\"foo_label2: .globl foo_label2\");\n+  if (e) foo_cold ();\t\t\t\t/* foo foo_cold call */\n+  asm (\"foo_label3: .globl foo_label3\");\n+}\t\t\t\t\t\t/* foo end */\n \n void\n bar (void)\n@@ -58,14 +58,18 @@ bar (void)\n }\t\t\t\t\t\t/* bar end */\n \n void\n-foo (void)\n-{\t\t\t\t\t\t/* foo prologue */\n-  asm (\"foo_label: .globl foo_label\");\n-  bar ();\t\t\t\t\t/* foo bar call */\n-  asm (\"foo_label2: .globl foo_label2\");\n-  if (e) foo_low ();\t\t\t\t/* foo foo_low call */\n-  asm (\"foo_label3: .globl foo_label3\");\n-}\t\t\t\t\t\t/* foo end */\n+foo_cold (void)\n+{\t\t\t\t\t\t/* foo_cold prologue */\n+  asm (\"foo_cold_label: .globl foo_cold_label\");\n+  baz ();\t\t\t\t\t/* foo_cold baz call */\n+  asm (\"foo_cold_label2: .globl foo_cold_label2\");\n+}\t\t\t\t\t\t/* foo_cold end */\n+\n+void\n+baz (void)\n+{\n+  asm (\"baz_label: .globl baz_label\");\n+}\t\t\t\t\t\t/* baz end */\n \n int\n main (void)",
      "previous_filename": "gdb/testsuite/gdb.dwarf2/dw2-ranges-func.c"
    },
    {
      "sha": "40966ce6dcf09f1ed237565b9805b4f84df77a36",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-ranges-func-lo-cold.c",
      "status": "added",
      "additions": 82,
      "deletions": 0,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/gdb.dwarf2/dw2-ranges-func-lo-cold.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/gdb.dwarf2/dw2-ranges-func-lo-cold.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-ranges-func-lo-cold.c?ref=5c076da45ce9a24d47046ddb0bac02e158e6bf58",
      "patch": "@@ -0,0 +1,82 @@\n+/* Copyright 2018-2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* The idea here is to, via use of the dwarf assembler, create a function\n+   which occupies two non-contiguous address ranges.\n+\n+   foo_cold and foo will be combined into a single function foo with a\n+   function bar in between these two ranges.\n+\n+   This test case was motivated by a bug in which a function which\n+   occupied two non-contiguous address ranges was calling another\n+   function which resides in between these ranges.  So we end up with\n+   a situation in which the low/start address of our constructed foo\n+   (in this case) will be less than any of the addresses in bar, but\n+   the high/end address of foo will be greater than any of bar's\n+   addresses.\n+\n+   This situation was causing a problem in the caching code of\n+   find_pc_partial_function:  When the low and high addresses of foo\n+   are placed in the cache, the simple check that was used to see if\n+   the cache was applicable would (incorrectly) succeed when presented\n+   with an address in bar.  I.e. an address in bar presented as an\n+   input to find_pc_partial_function could produce the answer \"this\n+   address belongs to foo\".  */\n+\n+volatile int e = 0;\n+\n+void bar (void);\n+void foo_cold (void);\n+void baz (void);\n+\n+void\n+baz (void)\n+{\n+  asm (\"baz_label: .globl baz_label\");\n+}\t\t\t\t\t\t/* baz end */\n+\n+void\n+foo_cold (void)\n+{\t\t\t\t\t\t/* foo_cold prologue */\n+  asm (\"foo_cold_label: .globl foo_cold_label\");\n+  baz ();\t\t\t\t\t/* foo_cold baz call */\n+  asm (\"foo_cold_label2: .globl foo_cold_label2\");\n+}\t\t\t\t\t\t/* foo_cold end */\n+\n+void\n+bar (void)\n+{\n+  asm (\"bar_label: .globl bar_label\");\n+}\t\t\t\t\t\t/* bar end */\n+\n+void\n+foo (void)\n+{\t\t\t\t\t\t/* foo prologue */\n+  asm (\"foo_label: .globl foo_label\");\n+  bar ();\t\t\t\t\t/* foo bar call */\n+  asm (\"foo_label2: .globl foo_label2\");\n+  if (e) foo_cold ();\t\t\t\t/* foo foo_cold call */\n+  asm (\"foo_label3: .globl foo_label3\");\n+}\t\t\t\t\t\t/* foo end */\n+\n+int\n+main (void)\n+{\t\t\t\t\t\t/* main prologue */\n+  asm (\"main_label: .globl main_label\");\n+  foo ();\t\t\t\t\t/* main foo call */\n+  asm (\"main_label2: .globl main_label2\");\n+  return 0;\t\t\t\t\t/* main return */\n+}\t\t\t\t\t\t/* main end */\n+"
    },
    {
      "sha": "fdc488ae9266cabe462d1accfa1b79e793266221",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-ranges-func.exp",
      "status": "modified",
      "additions": 374,
      "deletions": 319,
      "changes": 693,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/gdb.dwarf2/dw2-ranges-func.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5c076da45ce9a24d47046ddb0bac02e158e6bf58/gdb/testsuite/gdb.dwarf2/dw2-ranges-func.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-ranges-func.exp?ref=5c076da45ce9a24d47046ddb0bac02e158e6bf58",
      "patch": "@@ -30,376 +30,431 @@ if !$gcc_compiled {\n     return 0\n }\n \n-standard_testfile dw2-ranges-func.c dw2-ranges-func-dw.S\n-\n-# We need to know the size of integer and address types in order to\n-# write some of the debugging info we'd like to generate.\n-#\n-# For that, we ask GDB by debugging our test program.  Any program\n-# would do, but since we already have it specifically for this\n-# testcase, might as well use that.\n+proc do_test {suffix} {\n+    global gdb_test_file_name\n+    global testfile binfile srcfile srcfile2 gdb_prompt hex\n+\n+    # Don't use standard_testfile; we want different binaries for\n+    # each suffix.\n+    set testfile $gdb_test_file_name-$suffix\n+    set binfile [standard_output_file ${testfile}]\n+    set srcfile $testfile.c\n+    set srcfile2 $testfile-dw2.S\n+\n+    # We need to know the size of integer and address types in order to\n+    # write some of the debugging info we'd like to generate.\n+    #\n+    # For that, we ask GDB by debugging our test program.  Any program\n+    # would do, but since we already have it specifically for this\n+    # testcase, might as well use that.\n \n-if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n-    return -1\n-}\n+    if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n+\treturn -1\n+    }\n \n-set asm_file [standard_output_file $srcfile2]\n-Dwarf::assemble $asm_file {\n-    global srcdir subdir srcfile srcfile2\n-    declare_labels integer_label volatile_label func_ranges_label cu_ranges_label L\n-    set int_size [get_sizeof \"int\" 4]\n-\n-    # Find start address and length for our functions.\n-    lassign [function_range main [list ${srcdir}/${subdir}/$srcfile]] \\\n-\tmain_start main_len\n-    set main_end \"$main_start + $main_len\"\n-    lassign [function_range foo [list ${srcdir}/${subdir}/$srcfile]] \\\n-\tfoo_start foo_len\n-    set foo_end \"$foo_start + $foo_len\"\n-    lassign [function_range foo_low [list ${srcdir}/${subdir}/$srcfile]] \\\n-\tfoo_low_start foo_low_len\n-    set foo_low_end \"$foo_low_start + $foo_low_len\"\n-    lassign [function_range bar [list ${srcdir}/${subdir}/$srcfile]] \\\n-\tbar_start bar_len\n-    set bar_end \"$bar_start + $bar_len\"\n-    lassign [function_range baz [list ${srcdir}/${subdir}/$srcfile]] \\\n-\tbaz_start baz_len\n-    set baz_end \"$baz_start + $baz_len\"\n-\n-    set e_var [gdb_target_symbol e]\n-\n-    cu {} {\n-\tcompile_unit {\n-\t    {language @DW_LANG_C}\n-\t    {name dw-ranges-func.c}\n-\t    {stmt_list $L DW_FORM_sec_offset}\n-\t    {low_pc 0 addr}\n-\t    {ranges ${cu_ranges_label} DW_FORM_sec_offset}\n-\t} {\n-\t    integer_label: DW_TAG_base_type {\n-\t\t{DW_AT_byte_size $int_size DW_FORM_sdata}\n-\t\t{DW_AT_encoding  @DW_ATE_signed}\n-\t\t{DW_AT_name      integer}\n-\t    }\n-\t    volatile_label: DW_TAG_volatile_type {\n-\t\t{type :$integer_label}\n-\t    }\n-\t    DW_TAG_variable {\n-\t\t{name e}\n-\t\t{external 1 flag}\n-\t\t{type :$volatile_label}\n-\t\t{location {addr $e_var} SPECIAL_expr}\n+    set asm_file [standard_output_file $srcfile2]\n+    Dwarf::assemble $asm_file {\n+\tglobal srcdir subdir srcfile srcfile2\n+\tdeclare_labels integer_label volatile_label func_ranges_label cu_ranges_label L\n+\tset int_size [get_sizeof \"int\" 4]\n+\n+\t# Find start address and length for our functions.\n+\tlassign [function_range main [list ${srcdir}/${subdir}/$srcfile]] \\\n+\t    main_start main_len\n+\tset main_end \"$main_start + $main_len\"\n+\tlassign [function_range foo [list ${srcdir}/${subdir}/$srcfile]] \\\n+\t    foo_start foo_len\n+\tset foo_end \"$foo_start + $foo_len\"\n+\tlassign [function_range foo_cold [list ${srcdir}/${subdir}/$srcfile]] \\\n+\t    foo_cold_start foo_cold_len\n+\tset foo_cold_end \"$foo_cold_start + $foo_cold_len\"\n+\tlassign [function_range bar [list ${srcdir}/${subdir}/$srcfile]] \\\n+\t    bar_start bar_len\n+\tset bar_end \"$bar_start + $bar_len\"\n+\tlassign [function_range baz [list ${srcdir}/${subdir}/$srcfile]] \\\n+\t    baz_start baz_len\n+\tset baz_end \"$baz_start + $baz_len\"\n+\n+\tset e_var [gdb_target_symbol e]\n+\n+\tcu {} {\n+\t    compile_unit {\n+\t\t{language @DW_LANG_C}\n+\t\t{name dw-ranges-func2.c}\n+\t\t{stmt_list $L DW_FORM_sec_offset}\n+\t\t{low_pc 0 addr}\n+\t\t{ranges ${cu_ranges_label} DW_FORM_sec_offset}\n+\t    } {\n+\t\tinteger_label: DW_TAG_base_type {\n+\t\t    {DW_AT_byte_size $int_size DW_FORM_sdata}\n+\t\t    {DW_AT_encoding  @DW_ATE_signed}\n+\t\t    {DW_AT_name      integer}\n+\t\t}\n+\t\tvolatile_label: DW_TAG_volatile_type {\n+\t\t    {type :$integer_label}\n+\t\t}\n+\t\tDW_TAG_variable {\n+\t\t    {name e}\n+\t\t    {external 1 flag}\n+\t\t    {type :$volatile_label}\n+\t\t    {location {addr $e_var} SPECIAL_expr}\n+\t\t}\n+\t\tsubprogram {\n+\t\t    {external 1 flag}\n+\t\t    {name main}\n+\t\t    {DW_AT_type :$integer_label}\n+\t\t    {low_pc $main_start addr}\n+\t\t    {high_pc $main_len DW_FORM_data4}\n+\t\t}\n+\t\tsubprogram {\n+\t\t    {external 1 flag}\n+\t\t    {name foo}\n+\t\t    {ranges ${func_ranges_label} DW_FORM_sec_offset}\n+\t\t}\n+\t\tsubprogram {\n+\t\t    {external 1 flag}\n+\t\t    {name bar}\n+\t\t    {low_pc $bar_start addr}\n+\t\t    {high_pc $bar_len DW_FORM_data4}\n+\t\t}\n+\t\tsubprogram {\n+\t\t    {external 1 flag}\n+\t\t    {name baz}\n+\t\t    {low_pc $baz_start addr}\n+\t\t    {high_pc $baz_len DW_FORM_data4}\n+\t\t}\n \t    }\n-\t    subprogram {\n-\t\t{external 1 flag}\n-\t\t{name main}\n-\t\t{DW_AT_type :$integer_label}\n-\t\t{low_pc $main_start addr}\n-\t\t{high_pc $main_len DW_FORM_data4}\n-\t    }\n-\t    subprogram {\n-\t\t{external 1 flag}\n-\t\t{name foo}\n-\t\t{ranges ${func_ranges_label} DW_FORM_sec_offset}\n+\t}\n+\n+\tlines {version 2} L {\n+\t    include_dir \"${srcdir}/${subdir}\"\n+\t    file_name \"$srcfile\" 1\n+\n+\t    # Generate a line table program.  An attempt was made to make it\n+\t    # reasonably accurate as it made debugging the test case easier.\n+\t    program {\n+\t\t{DW_LNE_set_address $main_start}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"main prologue\"] - 1]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address main_label}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"main foo call\"] - [gdb_get_line_number \"main prologue\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address main_label2}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"main return\"] - [gdb_get_line_number \"main foo call\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address $main_end}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"main end\"] - [gdb_get_line_number \"main return\"] + 1]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_end_sequence}\n+\n+\t\t{DW_LNE_set_address $foo_start}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo prologue\"] - 1] }\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address foo_label}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo bar call\"] - [gdb_get_line_number \"foo prologue\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address foo_label2}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo foo_cold call\"] - [gdb_get_line_number \"foo bar call\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address foo_label3}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo end\"] - [gdb_get_line_number \"foo foo_cold call\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address $foo_end}\n+\t\t{DW_LNS_advance_line 1}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_end_sequence}\n+\n+\t\t{DW_LNE_set_address $bar_start}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"bar end\"] - 1]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNS_advance_pc $bar_len}\n+\t\t{DW_LNS_advance_line 1}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_end_sequence}\n+\n+\t\t{DW_LNE_set_address $baz_start}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"baz end\"] - 1]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNS_advance_pc $baz_len}\n+\t\t{DW_LNS_advance_line 1}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_end_sequence}\n+\n+\t\t{DW_LNE_set_address $foo_cold_start}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo_cold prologue\"] - 1]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address foo_cold_label}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo_cold baz call\"] - [gdb_get_line_number \"foo_cold prologue\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address foo_cold_label2}\n+\t\t{DW_LNS_advance_line [expr [gdb_get_line_number \"foo_cold end\"] - [gdb_get_line_number \"foo_cold baz call\"]]}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_set_address $foo_cold_end}\n+\t\t{DW_LNS_advance_line 1}\n+\t\t{DW_LNS_copy}\n+\t\t{DW_LNE_end_sequence}\n \t    }\n-\t    subprogram {\n-\t\t{external 1 flag}\n-\t\t{name bar}\n-\t\t{low_pc $bar_start addr}\n-\t\t{high_pc $bar_len DW_FORM_data4}\n+\t}\n+\n+\t# Generate ranges data.\n+\tranges {is_64 [is_64_target]} {\n+\t    func_ranges_label: sequence {\n+\t\t{range {$foo_start } $foo_end}\n+\t\t{range {$foo_cold_start} $foo_cold_end}\n \t    }\n-\t    subprogram {\n-\t\t{external 1 flag}\n-\t\t{name baz}\n-\t\t{low_pc $baz_start addr}\n-\t\t{high_pc $baz_len DW_FORM_data4}\n+\t    cu_ranges_label: sequence {\n+\t\t{range {$foo_start } $foo_end}\n+\t\t{range {$foo_cold_start} $foo_cold_end}\n+\t\t{range {$main_start} $main_end}\n+\t\t{range {$bar_start} $bar_end}\n+\t\t{range {$baz_start} $baz_end}\n \t    }\n \t}\n     }\n \n-    lines {version 2} L {\n-\tinclude_dir \"${srcdir}/${subdir}\"\n-\tfile_name \"$srcfile\" 1\n-\n-\t# Generate a line table program.  An attempt was made to make it\n-\t# reasonably accurate as it made debugging the test case easier.\n-\tprogram {\n-\t    {DW_LNE_set_address $main_start}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"main prologue\"] - 1]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address main_label}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"main foo call\"] - [gdb_get_line_number \"main prologue\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address main_label2}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"main return\"] - [gdb_get_line_number \"main foo call\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address $main_end}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"main end\"] - [gdb_get_line_number \"main return\"] + 1]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_end_sequence}\n-\n-\t    {DW_LNE_set_address $foo_start}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo prologue\"] - 1] }\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address foo_label}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo bar call\"] - [gdb_get_line_number \"foo prologue\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address foo_label2}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo foo_low call\"] - [gdb_get_line_number \"foo bar call\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address foo_label3}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo end\"] - [gdb_get_line_number \"foo foo_low call\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address $foo_end}\n-\t    {DW_LNS_advance_line 1}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_end_sequence}\n-\n-\t    {DW_LNE_set_address $bar_start}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"bar end\"] - 1]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNS_advance_pc $bar_len}\n-\t    {DW_LNS_advance_line 1}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_end_sequence}\n-\n-\t    {DW_LNE_set_address $baz_start}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"baz end\"] - 1]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNS_advance_pc $baz_len}\n-\t    {DW_LNS_advance_line 1}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_end_sequence}\n-\n-\t    {DW_LNE_set_address $foo_low_start}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo_low prologue\"] - 1]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address foo_low_label}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo_low baz call\"] - [gdb_get_line_number \"foo_low prologue\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address foo_low_label2}\n-\t    {DW_LNS_advance_line [expr [gdb_get_line_number \"foo_low end\"] - [gdb_get_line_number \"foo_low baz call\"]]}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_set_address $foo_low_end}\n-\t    {DW_LNS_advance_line 1}\n-\t    {DW_LNS_copy}\n-\t    {DW_LNE_end_sequence}\n-\t}\n+    if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n+\t      [list $srcfile $asm_file] {nodebug}] } {\n+\treturn -1\n     }\n \n-    # Generate ranges data.\n-    ranges {is_64 [is_64_target]} {\n-\tfunc_ranges_label: sequence {\n-\t    {range {$foo_start } $foo_end}\n-\t    {range {$foo_low_start} $foo_low_end}\n-\t}\n-\tcu_ranges_label: sequence {\n-\t    {range {$foo_start } $foo_end}\n-\t    {range {$foo_low_start} $foo_low_end}\n-\t    {range {$main_start} $main_end}\n-\t    {range {$bar_start} $bar_end}\n-\t    {range {$baz_start} $baz_end}\n-\t}\n+    if ![runto_main] {\n+\treturn -1\n     }\n-}\n \n-if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n-\t  [list $srcfile $asm_file] {nodebug}] } {\n-    return -1\n-}\n+    set main_prologue_line_num [gdb_get_line_number \"main prologue\"]\n+    # Do a sanity check to make sure that line number info is available.\n+    gdb_test \"info line main\" \\\n+\t\"Line ${main_prologue_line_num} of .* starts at address .* and ends at .*\"\n \n-if ![runto_main] {\n-    return -1\n-}\n+    with_test_prefix \"step-test-1\" {\n+\tset bp_foo_bar [gdb_get_line_number \"foo bar call\"]\n \n-set main_prologue_line_num [gdb_get_line_number \"main prologue\"]\n-# Do a sanity check to make sure that line number info is available.\n-gdb_test \"info line main\" \\\n-    \"Line ${main_prologue_line_num} of .* starts at address .* and ends at .*\"\n+\tgdb_test \"break $bp_foo_bar\" \\\n+\t    \"Breakpoint.*at.* file .*$srcfile, line $bp_foo_bar\\\\.\" \\\n+\t    \"break at call to bar\"\n \n-with_test_prefix \"step-test-1\" {\n-    set bp_foo_bar [gdb_get_line_number \"foo bar call\"]\n+\tgdb_test \"continue\" \\\n+\t    \"Continuing\\\\..*Breakpoint \\[0-9\\]+, foo \\\\(\\\\).*$bp_foo_bar\\\\s+bar\\\\s\\\\(\\\\);.*foo bar call.*\" \\\n+\t    \"continue to call of bar\"\n \n-    gdb_test \"break $bp_foo_bar\" \\\n-\t\"Breakpoint.*at.* file .*$srcfile, line $bp_foo_bar\\\\.\" \\\n-\t\"break at call to bar\"\n+\tgdb_test \"step\" \\\n+\t    \"bar \\\\(\\\\).*bar end.*\" \\\n+\t    \"step into bar\"\n \n-    gdb_test \"continue\" \\\n-\t\"Continuing\\\\..*Breakpoint \\[0-9\\]+, foo \\\\(\\\\).*$bp_foo_bar\\\\s+bar\\\\s\\\\(\\\\);.*foo bar call.*\" \\\n-\t\"continue to call of bar\"\n+\tgdb_test \"step\" \\\n+\t    \"foo \\\\(\\\\).*foo foo_cold call.*\" \\\n+\t    \"step out of bar, back into foo\"\n+    }\n \n-    gdb_test \"step\" \\\n-\t\"bar \\\\(\\\\).*bar end.*\" \\\n-\t\"step into bar\"\n+    with_test_prefix \"step-test-2\" {\n+\tclean_restart ${testfile}\n+\tif ![runto_main] {\n+\t    return -1\n+\t}\n \n-    gdb_test \"step\" \\\n-\t\"foo \\\\(\\\\).*foo foo_low call.*\" \\\n-\t\"step out of bar, back into foo\"\n-}\n+\t# Note that the RE used for the following test will fail when the\n+\t# breakpoint has been set on multiple locations. E.g. \"(2 locations)\". \n+\t# This is intentional since that behavior is one of the bugs that\n+\t# this test case tests for.\n+\tgdb_test \"break foo\" \\\n+\t    \"Breakpoint.*at.* file .*$srcfile, line \\\\d+\\\\.\" \\\n+\t    \"break foo\"\n+\n+\t# Continue to foo.  Allow execution to stop either on the prologue\n+\t# or on the call to bar since either behavior is acceptable though\n+\t# the latter is preferred.\n+\tset test \"continue to foo\"\n+\tgdb_test_multiple \"continue\" $test {\n+\t    -re \"Breakpoint \\\\d+, foo \\\\(\\\\).*foo prologue.*${gdb_prompt}\" {\n+\t\tpass $test\n+\t\tgdb_test \"step\" \\\n+\t\t\t \"foo bar call .*\" \\\n+\t\t\t \"step to call of bar after landing on prologue\"\n+\t    }\n+\t    -re \"Breakpoint \\\\d+, foo \\\\(\\\\).*foo bar call.*${gdb_prompt}\" {\n+\t\tpass $test\n+\t    }\n+\t}\n+\n+\tgdb_test \"step\" \\\n+\t    \"bar \\\\(\\\\).*bar end.*\" \\\n+\t    \"step into bar\"\n+\n+\tgdb_test \"step\" \\\n+\t    \"foo \\\\(\\\\).*foo foo_cold call.*\" \\\n+\t    \"step out of bar, back into foo\"\n+    }\n \n-with_test_prefix \"step-test-2\" {\n     clean_restart ${testfile}\n     if ![runto_main] {\n \treturn -1\n     }\n \n-    # Note that the RE used for the following test will fail when the\n-    # breakpoint has been set on multiple locations. E.g. \"(2 locations)\". \n-    # This is intentional since that behavior is one of the bugs that\n-    # this test case tests for.\n-    gdb_test \"break foo\" \\\n-\t\"Breakpoint.*at.* file .*$srcfile, line \\\\d+\\\\.\" \\\n-\t\"break foo\"\n-\n-    # Continue to foo.  Allow execution to stop either on the prologue\n-    # or on the call to bar since either behavior is acceptable though\n-    # the latter is preferred.\n-    set test \"continue to foo\"\n-    gdb_test_multiple \"continue\" $test {\n-\t-re \"Breakpoint \\\\d+, foo \\\\(\\\\).*foo prologue.*${gdb_prompt}\" {\n+    # Disassembly of foo should have multiple address ranges.\n+    gdb_test_sequence \"disassemble foo\" \"\" [list \\\n+\t\"Dump of assembler code for function foo:\" \\\n+\t\"Address range $hex to $hex:\" \\\n+\t\"   $hex <\\\\+0>:\" \\\n+\t\"Address range $hex to $hex:\" \\\n+\t\"   $hex <(.+?)>:\" \\\n+\t\"End of assembler dump\\\\.\" \\\n+    ]\n+\n+    set foo_cold_addr -1\n+    set test \"x/i foo_cold\"\n+    gdb_test_multiple $test $test {\n+\t-re \"   ($hex) <foo.*?>.*${gdb_prompt}\" {\n+\t    set foo_cold_addr $expect_out(1,string)\n \t    pass $test\n-\t    gdb_test \"step\" \\\n-\t\t     \"foo bar call .*\" \\\n-\t\t     \"step to call of bar after landing on prologue\"\n \t}\n-\t-re \"Breakpoint \\\\d+, foo \\\\(\\\\).*foo bar call.*${gdb_prompt}\" {\n+    }\n+\n+    set foo_addr -1\n+    set test \"x/i foo\"\n+    gdb_test_multiple $test $test {\n+\t-re \"   ($hex) <foo.*?>.*${gdb_prompt}\" {\n+\t    set foo_addr $expect_out(1,string)\n \t    pass $test\n \t}\n     }\n \n-    gdb_test \"step\" \\\n-\t\"bar \\\\(\\\\).*bar end.*\" \\\n-\t\"step into bar\"\n-\n-    gdb_test \"step\" \\\n-\t\"foo \\\\(\\\\).*foo foo_low call.*\" \\\n-\t\"step out of bar, back into foo\"\n-}\n+    gdb_assert {$foo_cold_addr != $foo_addr} \"foo and foo_cold are at different addresses\"\n \n-clean_restart ${testfile}\n-if ![runto_main] {\n-    return -1\n-}\n+    # This more permissive RE for \"break foo\" will allow a breakpoint on\n+    # multiple locations to PASS.  */\n+    gdb_test \"break foo\" \\\n+\t\"Breakpoint.*at.*\" \\\n+\t\"break foo\"\n \n-# Disassembly of foo should have multiple address ranges.\n-gdb_test_sequence \"disassemble foo\" \"\" [list \\\n-    \"Dump of assembler code for function foo:\" \\\n-    \"Address range $hex to $hex:\" \\\n-    \"   $hex <\\\\+0>:\" \\\n-    \"Address range $hex to $hex:\" \\\n-    \"   $hex <(.+?)>:\" \\\n-    \"End of assembler dump\\\\.\" \\\n-]\n-\n-set foo_low_addr -1\n-set test \"x/i foo_low\"\n-gdb_test_multiple $test $test {\n-    -re \"   ($hex) <foo.*?>.*${gdb_prompt}\" {\n-\tset foo_low_addr $expect_out(1,string)\n-\tpass $test\n-    }\n-}\n+    gdb_test \"break baz\" \\\n+\t\"Breakpoint.*at.* file .*$srcfile, line \\\\d+\\\\.\"\n \n-set foo_addr -1\n-set test \"x/i foo\"\n-gdb_test_multiple $test $test {\n-    -re \"   ($hex) <foo.*?>.*${gdb_prompt}\" {\n-\tset foo_addr $expect_out(1,string)\n-\tpass $test\n-    }\n-}\n+    gdb_test \"continue\" \\\n+\t\"Breakpoint \\\\d+, foo \\\\(\\\\).*\" \\\n+\t\"continue to foo\"\n \n-gdb_assert {$foo_low_addr != $foo_addr} \"foo and foo_low are at different addresses\"\n+    gdb_test_no_output \"set variable e=1\"\n \n-# This more permissive RE for \"break foo\" will allow a breakpoint on\n-# multiple locations to PASS.  */\n-gdb_test \"break foo\" \\\n-    \"Breakpoint.*at.*\" \\\n-    \"break foo\"\n+    # If GDB incorrectly places the foo breakpoint on multiple locations,\n+    # then GDB will (incorrectly) stop in foo_cold instead of in baz.\n+    gdb_test \"continue\" \\\n+\t\"Breakpoint \\\\d+, (?:$hex in )?baz \\\\(\\\\).*\" \\\n+\t\"continue to baz\"\n+\n+    with_test_prefix \"no-cold-names\" {\n+\n+\t# Due to the calling sequence, this backtrace would normally\n+\t# show function foo_cold for frame #1.  However, we don't want\n+\t# this to be the case due to placing it in the same block\n+\t# (albeit at a different range) as foo.  Thus it is correct to\n+\t# see foo for frames #1 and #2.  It is incorrect to see\n+\t# foo_cold at frame #1.\n+\tgdb_test_sequence \"bt\" \"backtrace from baz\" {\n+\t    \"\\[\\r\\n\\]#0 .*? baz \\\\(\\\\) \"\n+\t    \"\\[\\r\\n\\]#1 .*? foo \\\\(\\\\) \"\n+\t    \"\\[\\r\\n\\]#2 .*? foo \\\\(\\\\) \"\n+\t    \"\\[\\r\\n\\]#3 .*? main \\\\(\\\\) \"\n+\t}\n \n-gdb_test \"break baz\" \\\n-    \"Breakpoint.*at.* file .*$srcfile, line \\\\d+\\\\.\"\n+\t# Doing x/2i foo_cold should show foo_cold as the first symbolic\n+\t# address and an offset from foo for the second.  We also check to\n+\t# make sure that the offset is not too large - we don't GDB to\n+\t# display really large offsets that would (try to) wrap around the\n+\t# address space.\n+\tset foo_cold_offset 0\n+\tset test \"x/2i foo_cold\"\n+\tgdb_test_multiple $test $test {\n+\t    -re \"   (?:$hex) <foo_cold>.*?\\n   (?:$hex) <foo\\[+-\\](\\[0-9\\]+)>.*${gdb_prompt}\" {\n+\t        set foo_cold_offset $expect_out(1,string)\n+\t\tpass $test\n+\t    }\n+\t}\n+\tgdb_assert {$foo_cold_offset <= 10000} \"offset to foo_cold is not too large\"\n \n-gdb_test \"continue\" \\\n-    \"Breakpoint \\\\d+, foo \\\\(\\\\).*\" \\\n-    \"continue to foo\"\n+\t# Likewise, verify that second address shown by \"info line\" is at\n+\t# and offset from foo instead of foo_cold.\n+\tgdb_test \"info line *foo_cold\" \"starts at address $hex <foo_cold> and ends at $hex <foo\\[+-\\].*?>.*\"\n \n-gdb_test_no_output \"set variable e=1\"\n+    }\n \n-# If GDB incorrectly places the foo breakpoint on multiple locations,\n-# then GDB will (incorrectly) stop in foo_low instead of in baz.\n-gdb_test \"continue\" \\\n-    \"Breakpoint \\\\d+, (?:$hex in )?baz \\\\(\\\\).*\" \\\n-    \"continue to baz\"\n+    with_test_prefix \"step-test-3\" {\n+\tclean_restart ${testfile}\n+\tif ![runto_main] {\n+\t    return -1\n+\t}\n \n-with_test_prefix \"step-test-3\" {\n-    clean_restart ${testfile}\n-    if ![runto_main] {\n-\treturn -1\n-    }\n+\tgdb_test \"step\" \\\n+\t\t \"foo \\\\(\\\\).*bar \\\\(\\\\);.*foo bar call.*\" \\\n+\t\t \"step into foo from main\"\n \n-    gdb_test \"step\" \\\n-\t     \"foo \\\\(\\\\).*bar \\\\(\\\\);.*foo bar call.*\" \\\n-\t     \"step into foo from main\"\n-\n-    gdb_test \"step\" \\\n-\t     \"bar \\\\(\\\\).*\\}.* bar end.*\" \\\n-\t     \"step into bar from foo\"\n-\n-    gdb_test \"step\" \\\n-\t     \"foo(_label2)? \\\\(\\\\).*foo_low \\\\(\\\\);.*foo foo_low call.*\" \\\n-\t     \"step out of bar to foo\"\n-\n-    # The tests in the \"enable_foo_low_stepping\" section, below, work\n-    # with some versions of gcc, though it's not clear that they\n-    # should.  This test case causes foo_low, originally a separate\n-    # function invoked via a subroutine call, to be considered as part\n-    # of foo via use of DW_AT_ranges.  Real code that I've looked at\n-    # uses a branch instruction to cause code in the \"cold\" range to\n-    # be executed. \n-    #\n-    # For the moment though, these tests have been left in place, but\n-    # disabled, in case we decide that making such a subroutine call\n-    # is a reasonable thing to do that should also be supported by\n-    # GDB.\n+\tgdb_test \"step\" \\\n+\t\t \"bar \\\\(\\\\).*\\}.* bar end.*\" \\\n+\t\t \"step into bar from foo\"\n \n-    set enable_foo_low_stepping false\n+\tgdb_test \"step\" \\\n+\t\t \"foo(_label2)? \\\\(\\\\).*foo_cold \\\\(\\\\);.*foo foo_cold call.*\" \\\n+\t\t \"step out of bar to foo\"\n+\n+\t# The tests in the \"enable_foo_cold_stepping\" section, below, work\n+\t# with some versions of gcc, though it's not clear that they\n+\t# should.  This test case causes foo_cold, originally a separate\n+\t# function invoked via a subroutine call, to be considered as part\n+\t# of foo via use of DW_AT_ranges.  Real code that I've looked at\n+\t# uses a branch instruction to cause code in the \"cold\" range to\n+\t# be executed. \n+\t#\n+\t# For the moment though, these tests have been left in place, but\n+\t# disabled, in case we decide that making such a subroutine call\n+\t# is a reasonable thing to do that should also be supported by\n+\t# GDB.\n+\n+\tset enable_foo_cold_stepping false\n+\n+\tif { $enable_foo_cold_stepping } {\n+\t    gdb_test_no_output \"set variable e=1\"\n+\n+\t    set test \"step into foo_cold from foo\"\n+\t    gdb_test_multiple \"step\" $test {\n+\t\t-re \"foo(_low)? \\\\(\\\\).*\\{.*foo_cold prologue.*${gdb_prompt}\" {\n+\t\t    pass $test\n+\t\t    gdb_test \"step\" \\\n+\t\t\t     \"foo \\\\(\\\\).*baz \\\\(\\\\);.*foo_cold baz call.*\" \\\n+\t\t\t     \"step to baz call in foo_cold\"\n+\n+\t\t}\n+\t\t-re \"foo(_low)? \\\\(\\\\).*baz \\\\(\\\\);.*foo_cold baz call.*${gdb_prompt}\" {\n+\t\t    pass $test\n+\t\t}\n+\t    }\n \n-    if { $enable_foo_low_stepping } {\n-\tgdb_test_no_output \"set variable e=1\"\n+\t    gdb_test \"step\" \\\n+\t\t     \"baz \\\\(\\\\).*\\}.*baz end.*\" \\\n+\t\t     \"step into baz from foo_cold\"\n \n-\tset test \"step into foo_low from foo\"\n-\tgdb_test_multiple \"step\" $test {\n-\t    -re \"foo(_low)? \\\\(\\\\).*\\{.*foo_low prologue.*${gdb_prompt}\" {\n-\t\tpass $test\n-\t\tgdb_test \"step\" \\\n-\t\t\t \"foo \\\\(\\\\).*baz \\\\(\\\\);.*foo_low baz call.*\" \\\n-\t\t\t \"step to baz call in foo_low\"\n+\t    gdb_test \"step\" \\\n+\t\t     \"foo(?:_low(?:_label2)?)? \\\\(\\\\).*\\}.*foo_cold end.*\" \\\n+\t\t     \"step out of baz to foo_cold\"\n \n-\t    }\n-\t    -re \"foo(_low)? \\\\(\\\\).*baz \\\\(\\\\);.*foo_low baz call.*${gdb_prompt}\" {\n-\t\tpass $test\n-\t    }\n+\t    gdb_test \"step\" \\\n+\t\t     \"foo(?:_label3)? \\\\(\\\\).*\\}.*foo end.*\" \\\n+\t\t     \"step out of foo_cold to foo\"\n+\t} else {\n+\t    gdb_test \"next\" \\\n+\t\t     \".*foo end.*\" \\\n+\t\t     \"next over foo_cold call\"\n \t}\n \n \tgdb_test \"step\" \\\n-\t\t \"baz \\\\(\\\\).*\\}.*baz end.*\" \\\n-\t\t \"step into baz from foo_low\"\n+\t\t \"main(?:_label2)? \\\\(\\\\).*\" \\\n+\t\t \"step out of foo to main\"\n+    }\n+}\n \n-\tgdb_test \"step\" \\\n-\t\t \"foo(?:_low(?:_label2)?)? \\\\(\\\\).*\\}.*foo_low end.*\" \\\n-\t\t \"step out of baz to foo_low\"\n+# foreach_with_prefix could be used here, but the log file output is somewhat\n+# less verbose when using an explicit \"with_test_prefix\".\n \n-\tgdb_test \"step\" \\\n-\t\t \"foo(?:_label3)? \\\\(\\\\).*\\}.*foo end.*\" \\\n-\t\t \"step out of foo_low to foo\"\n-    } else {\n-\tgdb_test \"next\" \\\n-\t\t \".*foo end.*\" \\\n-\t\t \"next over foo_low call\"\n+foreach test_suffix { \"lo-cold\" \"hi-cold\" } {\n+    with_test_prefix $test_suffix {\n+\tdo_test $test_suffix\n     }\n-\n-    gdb_test \"step\" \\\n-\t     \"main(?:_label2)? \\\\(\\\\).*\" \\\n-\t     \"step out of foo to main\"\n }"
    }
  ]
}