{
  "sha": "362a07001900888b37d54523aa010806bd754e18",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzYyYTA3MDAxOTAwODg4YjM3ZDU0NTIzYWEwMTA4MDZiZDc1NGUxOA==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-15T18:50:10Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:58:23Z"
    },
    "message": "Documentation for the new mtag commands\n\nDocument the new \"memory-tag\" command prefix and all of its subcommands.\n\ngdb/doc/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* gdb.texinfo (Memory Tagging): New subsection and node.\n\t(AArch64 Memory Tagging Extension): New subsection.",
    "tree": {
      "sha": "e292eef16d13f091af40f108bbfdca3ba2d219a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e292eef16d13f091af40f108bbfdca3ba2d219a3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/362a07001900888b37d54523aa010806bd754e18",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/362a07001900888b37d54523aa010806bd754e18",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/362a07001900888b37d54523aa010806bd754e18",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/362a07001900888b37d54523aa010806bd754e18/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "48136e006e324980195e21f70ca4accd7f722ceb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48136e006e324980195e21f70ca4accd7f722ceb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/48136e006e324980195e21f70ca4accd7f722ceb"
    }
  ],
  "stats": {
    "total": 101,
    "additions": 101,
    "deletions": 0
  },
  "files": [
    {
      "sha": "674a2a2f6a65662b02b9f27f2ab1944bd3287c7a",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/362a07001900888b37d54523aa010806bd754e18/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/362a07001900888b37d54523aa010806bd754e18/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=362a07001900888b37d54523aa010806bd754e18",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* gdb.texinfo (Memory Tagging): New subsection and node.\n+\t(AArch64 Memory Tagging Extension): New subsection.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* gdb.texinfo (General Query Packets): Document qMemTags and"
    },
    {
      "sha": "d976325e69574ebea6dddb2d6cfd37f1fa517f90",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 96,
      "deletions": 0,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/362a07001900888b37d54523aa010806bd754e18/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/362a07001900888b37d54523aa010806bd754e18/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=362a07001900888b37d54523aa010806bd754e18",
      "patch": "@@ -10864,6 +10864,66 @@ target supports computing the CRC checksum of a block of memory\n (@pxref{qCRC packet}).\n @end table\n \n+@node Memory Tagging\n+@subsection Memory Tagging\n+\n+Memory tagging is a memory protection technology that uses a pair of tags to\n+validate memory accesses through pointers.  The tags are integer values\n+usually comprised of a few bits, depending on the architecture.\n+\n+There are two types of tags that are used in this setup: logical and\n+allocation.  A logical tag is stored in the pointers themselves, usually at the\n+higher bits of the pointers.  An allocation tag is the tag associated\n+with particular ranges of memory in the physical address space, against which\n+the logical tags from pointers are compared.\n+\n+The pointer tag (logical tag) must match the memory tag (allocation tag)\n+for the memory access to be valid.  If the logical tag does not match the\n+allocation tag, that will raise a memory violation.\n+\n+Allocation tags cover multiple contiguous bytes of physical memory.  This\n+range of bytes is called a memory tag granule and is architecture-specific.\n+For example,  AArch64 has a tag granule of 16 bytes, meaning each allocation\n+tag spans 16 bytes of memory.\n+\n+If the underlying architecture supports memory tagging, like AArch64 MTE\n+or SPARC ADI do,  @value{GDBN} can make use of it to validate pointers\n+against memory allocation tags.\n+\n+A command prefix of @code{memory-tag} gives access to the various memory tagging\n+commands.\n+\n+The @code{memory-tag} commands are the following:\n+\n+@table @code\n+@kindex memory-tag print-logical-tag\n+@item memory-tag print-logical-tag @var{pointer_expression}\n+Print the logical tag stored in @var{pointer_expression}.\n+@kindex memory-tag with-logical-tag\n+@item memory-tag with-logical-tag @var{pointer_expression} @var{tag_bytes}\n+Print the pointer given by @var{pointer_expression}, augmented with a logical\n+tag of @var{tag_bytes}.\n+@kindex memory-tag print-allocation-tag\n+@item memory-tag print-allocation-tag @var{address_expression}\n+Print the allocation tag associated with the memory address given by\n+@var{address_expression}.\n+@kindex memory-tag setatag\n+@item memory-tag setatag @var{starting_address} @var{length} @var{tag_bytes}\n+Set the allocation tag(s) for memory range @r{[}@var{starting_address},\n+@var{starting_address} + @var{length}@r{)} to @var{tag_bytes}.\n+@kindex memory-tag check\n+@item memory-tag check @var{pointer_expression}\n+Check if the logical tag in the pointer given by @var{pointer_expression}\n+matches the allocation tag for the memory referenced by the pointer.\n+\n+This essentially emulates the hardware validation that is done when tagged\n+memory is accessed through a pointer, but does not cause a memory fault as\n+it would during hardware validation.\n+\n+It can be used to inspect potential memory tagging violations in the running\n+process, before any faults get triggered.\n+@end table\n+\n @node Auto Display\n @section Automatic Display\n @cindex automatic display\n@@ -24993,6 +25053,42 @@ When GDB prints a backtrace, any addresses that required unmasking will be\n postfixed with the marker [PAC].  When using the MI, this is printed as part\n of the @code{addr_flags} field.\n \n+@subsubsection AArch64 Memory Tagging Extension.\n+@cindex AArch64 Memory Tagging Extension.\n+\n+When @value{GDBN} is debugging the AArch64 architecture, the program is\n+using the v8.5-A feature Memory Tagging Extension (MTE) and there is support\n+in the kernel for MTE, @value{GDBN} will make memory tagging functionality\n+available for inspection and editing of logical and allocation tags.\n+@xref{Memory Tagging}.\n+\n+To aid debugging, @value{GDBN} will output additional information when SIGSEGV\n+signals are generated as a result of memory tag failures.\n+\n+If the tag violation is synchronous, the following will be shown:\n+\n+@smallexample\n+Program received signal SIGSEGV, Segmentation fault\n+Memory tag violation while accessing address 0x0500fffff7ff8000\n+Allocation tag 0x1\n+Logical tag 0x5.\n+@end smallexample\n+\n+If the tag violation is asynchronous, the fault address is not available.\n+In this case @value{GDBN} will show the following:\n+\n+@smallexample\n+Program received signal SIGSEGV, Segmentation fault\n+Memory tag violation\n+Fault address unavailable.\n+@end smallexample\n+\n+A special register, @code{tag_ctl}, is made available through the\n+@code{org.gnu.gdb.aarch64.mte} feature.  This register exposes some\n+options that can be controlled at runtime and emulates the @code{prctl}\n+option @code{PR_SET_TAGGED_ADDR_CTRL}.  For further information, see the\n+documentation in the Linux kernel.\n+\n @node i386\n @subsection x86 Architecture-specific Issues\n "
    }
  ]
}