{
  "sha": "502e838ed9657ee74cdb4f53798e1468004c9524",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTAyZTgzOGVkOTY1N2VlNzRjZGI0ZjUzNzk4ZTE0NjgwMDRjOTUyNA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-02T19:43:03Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T16:57:31Z"
    },
    "message": "libctf, types: support slices of anything terminating in an int\n\nIt is perfectly valid C to say e.g.\n\ntypedef u64 int;\nstruct foo_t\n  {\n    const volatile u64 wibble:2;\n  };\n\ni.e. bitfields have to be integral types, but they can be cv-qualified\nintegral types or typedefs of same, etc.\n\nThis is easy to fix: do a ctf_type_resolve_unsliced() at creation time\nto ensure the ultimate type is integral, and ctf_type_resolve() at\nlookup time so that if you somehow have e.g. a slice of a typedef of a\nslice of a cv-qualified int, we pull the encoding that the topmost slice\nis based on out of the subsidiary slice (and then modify it), not out of\nthe underlying int.  (This last bit is rather academic right now, since\nall slices override exactly the same properties of the underlying type,\nbut it's still the right thing to do.)\n\nlibctf/\n\t* ctf-create.c (ctf_add_slice): Support slices of any kind that\n\tresolves to an integral type.\n\t* ctf-types.c (ctf_type_encoding): Resolve the type before\n\tfishing its encoding out.",
    "tree": {
      "sha": "6571863adaa1fe7e0b450b7b104ced7a7391abe6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6571863adaa1fe7e0b450b7b104ced7a7391abe6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/502e838ed9657ee74cdb4f53798e1468004c9524",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/502e838ed9657ee74cdb4f53798e1468004c9524",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/502e838ed9657ee74cdb4f53798e1468004c9524",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/502e838ed9657ee74cdb4f53798e1468004c9524/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dd987f004301f6a737fcd431a9ae14d2fc2675bf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd987f004301f6a737fcd431a9ae14d2fc2675bf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dd987f004301f6a737fcd431a9ae14d2fc2675bf"
    }
  ],
  "stats": {
    "total": 25,
    "additions": 22,
    "deletions": 3
  },
  "files": [
    {
      "sha": "78f8f7e3a6c32a789af3371b03f3cdb20eaed6ce",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502e838ed9657ee74cdb4f53798e1468004c9524/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502e838ed9657ee74cdb4f53798e1468004c9524/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=502e838ed9657ee74cdb4f53798e1468004c9524",
      "patch": "@@ -1,3 +1,10 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-create.c (ctf_add_slice): Support slices of any kind that\n+\tresolves to an integral type.\n+\t* ctf-types.c (ctf_type_encoding): Resolve the type before\n+\tfishing its encoding out.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-create.c (ctf_create): Mark dirty."
    },
    {
      "sha": "c13b83d4d3b02d8c45104e31e9291115aa44a692",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502e838ed9657ee74cdb4f53798e1468004c9524/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502e838ed9657ee74cdb4f53798e1468004c9524/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=502e838ed9657ee74cdb4f53798e1468004c9524",
      "patch": "@@ -944,6 +944,7 @@ ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n \t       const ctf_encoding_t *ep)\n {\n   ctf_dtdef_t *dtd;\n+  ctf_id_t resolved_ref = ref;\n   ctf_id_t type;\n   int kind;\n   const ctf_type_t *tp;\n@@ -961,7 +962,13 @@ ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n   if (ref != 0 && ((tp = ctf_lookup_by_id (&tmp, ref)) == NULL))\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  kind = ctf_type_kind_unsliced (tmp, ref);\n+  /* Make sure we ultimately point to an integral type.  We also allow slices to\n+     point to the unimplemented type, for now, because the compiler can emit\n+     such slices, though they're not very much use.  */\n+\n+  resolved_ref = ctf_type_resolve_unsliced (tmp, ref);\n+  kind = ctf_type_kind_unsliced (tmp, resolved_ref);\n+\n   if ((kind != CTF_K_INTEGER) && (kind != CTF_K_FLOAT) &&\n       (kind != CTF_K_ENUM)\n       && (ref != 0))"
    },
    {
      "sha": "f5a1fc0ae1218fcec740b74c96132ba9464ba66f",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/502e838ed9657ee74cdb4f53798e1468004c9524/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/502e838ed9657ee74cdb4f53798e1468004c9524/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=502e838ed9657ee74cdb4f53798e1468004c9524",
      "patch": "@@ -758,9 +758,12 @@ ctf_type_encoding (ctf_file_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n \t  {\n \t    const ctf_slice_t *slice;\n \t    ctf_encoding_t underlying_en;\n+\t    ctf_id_t underlying;\n+\n \t    slice = &dtd->dtd_u.dtu_slice;\n+\t    underlying = ctf_type_resolve (fp, slice->cts_type);\n+\t    data = ctf_type_encoding (fp, underlying, &underlying_en);\n \n-\t    data = ctf_type_encoding (fp, slice->cts_type, &underlying_en);\n \t    ep->cte_format = underlying_en.cte_format;\n \t    ep->cte_offset = slice->cts_offset;\n \t    ep->cte_bits = slice->cts_bits;\n@@ -792,9 +795,11 @@ ctf_type_encoding (ctf_file_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n       {\n \tconst ctf_slice_t *slice;\n \tctf_encoding_t underlying_en;\n+\tctf_id_t underlying;\n \n \tslice = (ctf_slice_t *) ((uintptr_t) tp + increment);\n-\tdata = ctf_type_encoding (fp, slice->cts_type, &underlying_en);\n+\tunderlying = ctf_type_resolve (fp, slice->cts_type);\n+\tdata = ctf_type_encoding (fp, underlying, &underlying_en);\n \n \tep->cte_format = underlying_en.cte_format;\n \tep->cte_offset = slice->cts_offset;"
    }
  ]
}