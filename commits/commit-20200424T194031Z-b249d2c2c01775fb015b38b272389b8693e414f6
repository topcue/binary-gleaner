{
  "sha": "b249d2c2c01775fb015b38b272389b8693e414f6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjI0OWQyYzJjMDE3NzVmYjAxNWIzOGIyNzIzODliODY5M2U0MTRmNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:31Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:31Z"
    },
    "message": "Prefer existing data when evaluating DWARF expression\n\nWhen evaluating a DWARF expression, the dynamic type resolution code\nwill pass in a buffer of bytes via the property_addr_info.  However,\nthe DWARF expression evaluator will then proceed to read memory from\nthe inferior, even when the request could be filled from this buffer.\n\nThis, in turn, is a problem in some cases; and specifically when\ntrying to handle the Ada scenario of extracting a variable-length\nvalue from a packed array.  Here, the ordinary DWARF expression cannot\nbe directly evaluated, because the data may appear at some arbitrary\nbit offset.  So, it is unpacked into a staging area and then the\nexpression is evaluated -- using an address of 0.\n\nThis patch fixes the problem by arranging for the DWARF evaluator, in\nthis case, to prefer passed-in memory when possible.  The type of the\nbuffer in the property_addr_info is changed to an array_view so that\nbounds checking can be done.\n\ngdb/ChangeLog\n2020-04-24  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.c (ada_discrete_type_high_bound, ada_discrete_type_low)\n\t(ada_value_primitive_packed_val): Update.\n\t* ada-valprint.c (ada_value_print_1): Update.\n\t* dwarf2/loc.c (evaluate_for_locexpr_baton): New struct.\n\t(dwarf2_locexpr_baton_eval): Take a property_addr_info rather than\n\tjust an address.  Use evaluate_for_locexpr_baton.\n\t(dwarf2_evaluate_property): Update.\n\t* dwarf2/loc.h (struct property_addr_info) <valaddr>: Now an\n\tarray_view.\n\t* findvar.c (default_read_var_value): Update.\n\t* gdbtypes.c (compute_variant_fields_inner)\n\t(resolve_dynamic_type_internal): Update.\n\t(resolve_dynamic_type): Change type of valaddr parameter.\n\t* gdbtypes.h (resolve_dynamic_type): Update.\n\t* valarith.c (value_subscripted_rvalue): Update.\n\t* value.c (value_from_contents_and_address): Update.",
    "tree": {
      "sha": "5c41219789c65cf9f6f65f46568a432c063f68c4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5c41219789c65cf9f6f65f46568a432c063f68c4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b249d2c2c01775fb015b38b272389b8693e414f6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b249d2c2c01775fb015b38b272389b8693e414f6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b249d2c2c01775fb015b38b272389b8693e414f6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b249d2c2c01775fb015b38b272389b8693e414f6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "61122aa9ed4096c3d85b01d52a0c0f67fb441533",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/61122aa9ed4096c3d85b01d52a0c0f67fb441533",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/61122aa9ed4096c3d85b01d52a0c0f67fb441533"
    }
  ],
  "stats": {
    "total": 138,
    "additions": 104,
    "deletions": 34
  },
  "files": [
    {
      "sha": "305b133b4fb0701b7731f75f0c795bd2db07bf0f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -1,3 +1,22 @@\n+2020-04-24  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.c (ada_discrete_type_high_bound, ada_discrete_type_low)\n+\t(ada_value_primitive_packed_val): Update.\n+\t* ada-valprint.c (ada_value_print_1): Update.\n+\t* dwarf2/loc.c (evaluate_for_locexpr_baton): New struct.\n+\t(dwarf2_locexpr_baton_eval): Take a property_addr_info rather than\n+\tjust an address.  Use evaluate_for_locexpr_baton.\n+\t(dwarf2_evaluate_property): Update.\n+\t* dwarf2/loc.h (struct property_addr_info) <valaddr>: Now an\n+\tarray_view.\n+\t* findvar.c (default_read_var_value): Update.\n+\t* gdbtypes.c (compute_variant_fields_inner)\n+\t(resolve_dynamic_type_internal): Update.\n+\t(resolve_dynamic_type): Change type of valaddr parameter.\n+\t* gdbtypes.h (resolve_dynamic_type): Update.\n+\t* valarith.c (value_subscripted_rvalue): Update.\n+\t* value.c (value_from_contents_and_address): Update.\n+\n 2020-04-24  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2/loc.c (dwarf2_locexpr_baton_eval): Add"
    },
    {
      "sha": "bfbc69084ec1df294897d81dc9129fc2ee4d70e8",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -752,7 +752,7 @@ min_of_type (struct type *t)\n LONGEST\n ada_discrete_type_high_bound (struct type *type)\n {\n-  type = resolve_dynamic_type (type, NULL, 0);\n+  type = resolve_dynamic_type (type, {}, 0);\n   switch (TYPE_CODE (type))\n     {\n     case TYPE_CODE_RANGE:\n@@ -773,7 +773,7 @@ ada_discrete_type_high_bound (struct type *type)\n LONGEST\n ada_discrete_type_low_bound (struct type *type)\n {\n-  type = resolve_dynamic_type (type, NULL, 0);\n+  type = resolve_dynamic_type (type, {}, 0);\n   switch (TYPE_CODE (type))\n     {\n     case TYPE_CODE_RANGE:\n@@ -2508,7 +2508,7 @@ ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,\n \t\t\t        staging.data (), staging.size (),\n \t\t\t\tis_big_endian, has_negatives (type),\n \t\t\t\tis_scalar);\n-      type = resolve_dynamic_type (type, staging.data (), 0);\n+      type = resolve_dynamic_type (type, staging, 0);\n       if (TYPE_LENGTH (type) < (bit_size + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT)\n \t{\n \t  /* This happens when the length of the object is dynamic,"
    },
    {
      "sha": "474b07999104e5e55adb84e1478c954bce002c10",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -1057,7 +1057,9 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n \n   const gdb_byte *valaddr = value_contents_for_printing (val);\n   CORE_ADDR address = value_address (val);\n-  type = ada_check_typedef (resolve_dynamic_type (type, valaddr, address));\n+  gdb::array_view<const gdb_byte> view\n+    = gdb::make_array_view (valaddr, TYPE_LENGTH (type));\n+  type = ada_check_typedef (resolve_dynamic_type (type, view, address));\n   if (type != saved_type)\n     {\n       val = value_copy (val);"
    },
    {
      "sha": "5b690ca9276ed1accd55ec03f97667a1bde7913e",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 58,
      "deletions": 15,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -2384,18 +2384,56 @@ dwarf2_evaluate_loc_desc (struct type *type, struct frame_info *frame,\n \t\t\t\t\tNULL, 0);\n }\n \n-/* Evaluates a dwarf expression and stores the result in VAL, expecting\n-   that the dwarf expression only produces a single CORE_ADDR.  FRAME is the\n-   frame in which the expression is evaluated.  ADDR is a context (location of\n-   a variable) and might be needed to evaluate the location expression.\n-   PUSH_INITIAL_VALUE is true if ADDR should be pushed on the stack\n-   before evaluating the expression;  this is required by certain\n-   forms of DWARF expression.  Returns 1 on success, 0 otherwise.  */\n+/* A specialization of dwarf_evaluate_loc_desc that is used by\n+   dwarf2_locexpr_baton_eval.  This subclass exists to handle the case\n+   where a caller of dwarf2_locexpr_baton_eval passes in some data,\n+   but with the address being 0.  In this situation, we arrange for\n+   memory reads to come from the passed-in buffer.  */\n+\n+struct evaluate_for_locexpr_baton : public dwarf_evaluate_loc_desc\n+{\n+  /* The data that was passed in.  */\n+  gdb::array_view<const gdb_byte> data_view;\n+\n+  CORE_ADDR get_object_address () override\n+  {\n+    if (data_view.data () == nullptr && obj_address == 0)\n+      error (_(\"Location address is not set.\"));\n+    return obj_address;\n+  }\n+\n+  void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t len) override\n+  {\n+    if (len == 0)\n+      return;\n+\n+    /* Prefer the passed-in memory, if it exists.  */\n+    CORE_ADDR offset = addr - obj_address;\n+    if (offset < data_view.size () && offset + len <= data_view.size ())\n+      {\n+\tmemcpy (buf, data_view.data (), len);\n+\treturn;\n+      }\n+\n+    read_memory (addr, buf, len);\n+  }\n+};\n+\n+/* Evaluates a dwarf expression and stores the result in VAL,\n+   expecting that the dwarf expression only produces a single\n+   CORE_ADDR.  FRAME is the frame in which the expression is\n+   evaluated.  ADDR_STACK is a context (location of a variable) and\n+   might be needed to evaluate the location expression.\n+   PUSH_INITIAL_VALUE is true if the address (either from ADDR_STACK,\n+   or the default of 0) should be pushed on the DWARF expression\n+   evaluation stack before evaluating the expression; this is required\n+   by certain forms of DWARF expression.  Returns 1 on success, 0\n+   otherwise.  */\n \n static int\n dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n \t\t\t   struct frame_info *frame,\n-\t\t\t   CORE_ADDR addr,\n+\t\t\t   const struct property_addr_info *addr_stack,\n \t\t\t   CORE_ADDR *valp,\n \t\t\t   bool push_initial_value)\n {\n@@ -2404,11 +2442,17 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n   if (dlbaton == NULL || dlbaton->size == 0)\n     return 0;\n \n-  dwarf_evaluate_loc_desc ctx;\n+  evaluate_for_locexpr_baton ctx;\n \n   ctx.frame = frame;\n   ctx.per_cu = dlbaton->per_cu;\n-  ctx.obj_address = addr;\n+  if (addr_stack == nullptr)\n+    ctx.obj_address = 0;\n+  else\n+    {\n+      ctx.obj_address = addr_stack->addr;\n+      ctx.data_view = addr_stack->valaddr;\n+    }\n \n   objfile = dlbaton->per_cu->objfile ();\n \n@@ -2418,7 +2462,7 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n   ctx.offset = dlbaton->per_cu->text_offset ();\n \n   if (push_initial_value)\n-    ctx.push_address (addr, false);\n+    ctx.push_address (ctx.obj_address, false);\n \n   try\n     {\n@@ -2485,8 +2529,7 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n \t  = (const struct dwarf2_property_baton *) prop->data.baton;\n \tgdb_assert (baton->property_type != NULL);\n \n-\tif (dwarf2_locexpr_baton_eval (&baton->locexpr, frame,\n-\t\t\t\t       addr_stack ? addr_stack->addr : 0,\n+\tif (dwarf2_locexpr_baton_eval (&baton->locexpr, frame, addr_stack,\n \t\t\t\t       value, push_initial_value))\n \t  {\n \t    if (baton->locexpr.is_reference)\n@@ -2569,10 +2612,10 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n \t  }\n \tif (pinfo == NULL)\n \t  error (_(\"cannot find reference address for offset property\"));\n-\tif (pinfo->valaddr != NULL)\n+\tif (pinfo->valaddr.data () != NULL)\n \t  val = value_from_contents\n \t\t  (baton->offset_info.type,\n-\t\t   pinfo->valaddr + baton->offset_info.offset);\n+\t\t   pinfo->valaddr.data () + baton->offset_info.offset);\n \telse\n \t  val = value_at (baton->offset_info.type,\n \t\t\t  pinfo->addr + baton->offset_info.offset);"
    },
    {
      "sha": "9815368d625a5d1101819175ad0ad4d84fd7cacb",
      "filename": "gdb/dwarf2/loc.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/dwarf2/loc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/dwarf2/loc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.h?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -73,7 +73,7 @@ struct property_addr_info\n   struct type *type;\n \n   /* If not NULL, a buffer containing the object's value.  */\n-  const gdb_byte *valaddr;\n+  gdb::array_view<const gdb_byte> valaddr;\n \n   /* The address of that object.  */\n   CORE_ADDR addr;"
    },
    {
      "sha": "ac4f5c3997de89ff96ce7211fd58810dd77b8f4d",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -615,7 +615,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n       if (is_dynamic_type (type))\n \t{\n \t  /* Value is a constant byte-sequence and needs no memory access.  */\n-\t  type = resolve_dynamic_type (type, NULL, /* Unused address.  */ 0);\n+\t  type = resolve_dynamic_type (type, {}, /* Unused address.  */ 0);\n \t}\n       /* Put the constant back in target format. */\n       v = allocate_value (type);\n@@ -647,7 +647,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n       if (is_dynamic_type (type))\n \t{\n \t  /* Value is a constant byte-sequence and needs no memory access.  */\n-\t  type = resolve_dynamic_type (type, NULL, /* Unused address.  */ 0);\n+\t  type = resolve_dynamic_type (type, {}, /* Unused address.  */ 0);\n \t}\n       v = allocate_value (type);\n       memcpy (value_contents_raw (v), SYMBOL_VALUE_BYTES (var),\n@@ -788,7 +788,7 @@ default_read_var_value (struct symbol *var, const struct block *var_block,\n \n     case LOC_OPTIMIZED_OUT:\n       if (is_dynamic_type (type))\n-\ttype = resolve_dynamic_type (type, NULL, /* Unused address.  */ 0);\n+\ttype = resolve_dynamic_type (type, {}, /* Unused address.  */ 0);\n       return allocate_optimized_out_value (type);\n \n     default:"
    },
    {
      "sha": "1bd9d8a55c7845676045f9ee014926801fb5ba2a",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 9,
      "deletions": 6,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -2298,8 +2298,9 @@ compute_variant_fields_inner (struct type *type,\n \terror (_(\"Cannot determine struct field location\"\n \t\t \" (invalid location kind)\"));\n \n-      if (addr_stack->valaddr != NULL)\n-\tdiscr_value = unpack_field_as_long (type, addr_stack->valaddr, idx);\n+      if (addr_stack->valaddr.data () != NULL)\n+\tdiscr_value = unpack_field_as_long (type, addr_stack->valaddr.data (),\n+\t\t\t\t\t    idx);\n       else\n \t{\n \t  CORE_ADDR addr = (addr_stack->addr\n@@ -2516,9 +2517,10 @@ resolve_dynamic_type_internal (struct type *type,\n \t    struct property_addr_info pinfo;\n \n \t    pinfo.type = check_typedef (TYPE_TARGET_TYPE (type));\n-\t    pinfo.valaddr = NULL;\n-\t    if (addr_stack->valaddr != NULL)\n-\t      pinfo.addr = extract_typed_address (addr_stack->valaddr, type);\n+\t    pinfo.valaddr = {};\n+\t    if (addr_stack->valaddr.data () != NULL)\n+\t      pinfo.addr = extract_typed_address (addr_stack->valaddr.data (),\n+\t\t\t\t\t\t  type);\n \t    else\n \t      pinfo.addr = read_memory_typed_address (addr_stack->addr, type);\n \t    pinfo.next = addr_stack;\n@@ -2566,7 +2568,8 @@ resolve_dynamic_type_internal (struct type *type,\n /* See gdbtypes.h  */\n \n struct type *\n-resolve_dynamic_type (struct type *type, const gdb_byte *valaddr,\n+resolve_dynamic_type (struct type *type,\n+\t\t      gdb::array_view<const gdb_byte> valaddr,\n \t\t      CORE_ADDR addr)\n {\n   struct property_addr_info pinfo"
    },
    {
      "sha": "f686e5407ba46a93fe352257a800170d48043e59",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -2140,9 +2140,9 @@ extern void get_signed_type_minmax (struct type *, LONGEST *, LONGEST *);\n    ADDR specifies the location of the variable the type is bound to.\n    If TYPE has no dynamic properties return TYPE; otherwise a new type with\n    static properties is returned.  */\n-extern struct type *resolve_dynamic_type (struct type *type,\n-\t\t\t\t\t  const gdb_byte *valaddr,\n-\t\t\t\t\t  CORE_ADDR addr);\n+extern struct type *resolve_dynamic_type\n+  (struct type *type, gdb::array_view<const gdb_byte> valaddr,\n+   CORE_ADDR addr);\n \n /* * Predicate if the type has dynamic values, which are not resolved yet.  */\n extern int is_dynamic_type (struct type *type);"
    },
    {
      "sha": "504264b1d82fbb992f6381cac70d538b0ae0b40d",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -220,7 +220,7 @@ value_subscripted_rvalue (struct value *array, LONGEST index, LONGEST lowerbound\n       CORE_ADDR address;\n \n       address = value_address (array) + elt_offs;\n-      elt_type = resolve_dynamic_type (elt_type, NULL, address);\n+      elt_type = resolve_dynamic_type (elt_type, {}, address);\n     }\n \n   return value_from_component (array, elt_type, elt_offs);"
    },
    {
      "sha": "7ea39af55517025e3b0a56221e51acaef6c52770",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b249d2c2c01775fb015b38b272389b8693e414f6/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=b249d2c2c01775fb015b38b272389b8693e414f6",
      "patch": "@@ -3477,7 +3477,10 @@ value_from_contents_and_address (struct type *type,\n \t\t\t\t const gdb_byte *valaddr,\n \t\t\t\t CORE_ADDR address)\n {\n-  struct type *resolved_type = resolve_dynamic_type (type, valaddr, address);\n+  gdb::array_view<const gdb_byte> view;\n+  if (valaddr != nullptr)\n+    view = gdb::make_array_view (valaddr, TYPE_LENGTH (type));\n+  struct type *resolved_type = resolve_dynamic_type (type, view, address);\n   struct type *resolved_type_no_typedef = check_typedef (resolved_type);\n   struct value *v;\n "
    }
  ]
}