{
  "sha": "89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODliMDczMzVmZTQyZDZkYTg0YzE5MzUxY2EwYzM0YjExYTNjNGY4ZQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:14:01Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:15:56Z"
    },
    "message": "Add dwarf2_per_objfile to dwarf_expr_context and dwarf2_frame_cache\n\nEvaluating DWARF expressions (such as location expressions) requires\nknowing about the current objfile.  For example, it may call functions\nlike dwarf2_fetch_die_loc_sect_off, which currently obtain the\ndwarf2_per_objfile object it needs from the dwarf2_per_cu_data object.\nHowever, since we are going to remove this\ndwarf2_per_cu_data::dwarf2_per_objfile link, these functions will need\nto obtain the current dwarf2_per_objfile by parmeter.\n\nIf we go up the stack, we see that the DWARF expression contexts\n(dwarf_expr_context and the classes that derive from it) need to store\nthe dwarf2_per_objfile, to be able to pass it to those functions that\nwill need it.\n\nThis patch adds a constructor to all these dwarf_expr_context variants,\naccepting a dwarf2_per_objfile parameter.  This dwarf2_per_objfile\ngenerally comes from a symbol baton created earlier.\n\nFor frame-related expressions, the dwarf2_per_objfile object must be\npassed through the dwarf2_frame_cache object.  This lead to the\ndwarf2_frame_find_fde function returning (by parameter) a\ndwarf2_per_objfile object.  I then realized that this made the existing\n\"out_offset\" parameter redundant.  This offset is\n`objfile->text_section_offset ()`, so it can be recomputed from the\ndwarf2_per_objfile object at any time.  I therefore opted to remove this\noutput parameter, as well as the offset field of dwarf2_frame_cache.\n\n*Note*, there's one spot I'm particularly unsure about.  In\ndwarf_evaluate_loc_desc::push_dwarf_reg_entry_value, we would save and\noverwrite the offset value in the context, along with a bunch of other\nstate.  This is because we might be about to evaluate something in a\ndifferent CU that the current one.  If the two CUs are in the same\nobjfile, then the text_offset is the same, as it's a property of the\nobjfile.  However, if the two CUs are possibly in different objfiles,\nthen it means the text_offsets are different.  It would also mean we\nwould need to save and restore the dwarf2_per_objfile in the context.\nIs that even possible?\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.h (struct dwarf_expr_context)\n\t<dwarf_expr_context>: Add dwarf2_per_objfile parameter.\n\t<offset>: Remove.\n\t<per_objfile>: New member.\n\t* dwarf2/expr.c (dwarf_expr_context::dwarf_expr_context): Add\n\tdwarf2_per_objfile parameter.  Don't set offset, set\n\tper_objfile.\n\t(dwarf_expr_context::execute_stack_op): Use offset from objfile.\n\t* dwarf2/frame.c (dwarf2_frame_find_fde): Return (by parameter)\n\ta dwarf2_per_objfile object instead of an offset.\n\t(class dwarf_expr_executor) <dwarf_expr_executor>: Add\n\tconstructor.\n\t(execute_stack_op): Add dwarf2_per_objfile parameter, pass it\n\tto dwarf2_expr_executor constructor.  Don't set offset.\n\t(dwarf2_fetch_cfa_info): Update.\n\t(struct dwarf2_frame_cache) <text_offset>: Remove.\n\t<per_objfile>: New field.\n\t(dwarf2_frame_cache): Update.\n\t(dwarf2_frame_prev_register): Update.\n\t* dwarf2/loc.c (class dwarf_evaluate_loc_desc)\n\t<dwarf_evaluate_loc_desc>: Add constructor.\n\t(dwarf2_evaluate_loc_desc_full): Update.\n\t(dwarf2_locexpr_baton_eval): Update.\n\t(class symbol_needs_eval_context) <symbol_needs_eval_context>:\n\tAdd constructor.\n\t(dwarf2_loc_desc_get_symbol_read_needs): Update.\n\nChange-Id: I14df060669cc36ad04759f1708c6d7b1fda77727",
    "tree": {
      "sha": "4f7d214a8f9172a131f08f953d3d9b4332be7d54",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4f7d214a8f9172a131f08f953d3d9b4332be7d54"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "293e7e51145506f5f547a777242d7963f946c6ec",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/293e7e51145506f5f547a777242d7963f946c6ec",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/293e7e51145506f5f547a777242d7963f946c6ec"
    }
  ],
  "stats": {
    "total": 151,
    "additions": 98,
    "deletions": 53
  },
  "files": [
    {
      "sha": "6ad1a71f6e0c350269697652c1976468321c02de",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
      "patch": "@@ -1,3 +1,32 @@\n+2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/expr.h (struct dwarf_expr_context)\n+\t<dwarf_expr_context>: Add dwarf2_per_objfile parameter.\n+\t<offset>: Remove.\n+\t<per_objfile>: New member.\n+\t* dwarf2/expr.c (dwarf_expr_context::dwarf_expr_context): Add\n+\tdwarf2_per_objfile parameter.  Don't set offset, set\n+\tper_objfile.\n+\t(dwarf_expr_context::execute_stack_op): Use offset from objfile.\n+\t* dwarf2/frame.c (dwarf2_frame_find_fde): Return (by parameter)\n+\ta dwarf2_per_objfile object instead of an offset.\n+\t(class dwarf_expr_executor) <dwarf_expr_executor>: Add\n+\tconstructor.\n+\t(execute_stack_op): Add dwarf2_per_objfile parameter, pass it\n+\tto dwarf2_expr_executor constructor.  Don't set offset.\n+\t(dwarf2_fetch_cfa_info): Update.\n+\t(struct dwarf2_frame_cache) <text_offset>: Remove.\n+\t<per_objfile>: New field.\n+\t(dwarf2_frame_cache): Update.\n+\t(dwarf2_frame_prev_register): Update.\n+\t* dwarf2/loc.c (class dwarf_evaluate_loc_desc)\n+\t<dwarf_evaluate_loc_desc>: Add constructor.\n+\t(dwarf2_evaluate_loc_desc_full): Update.\n+\t(dwarf2_locexpr_baton_eval): Update.\n+\t(class symbol_needs_eval_context) <symbol_needs_eval_context>:\n+\tAdd constructor.\n+\t(dwarf2_loc_desc_get_symbol_read_needs): Update.\n+\n 2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* dwarf2/read.h (struct dwarf2_per_cu_data) <addr_type,"
    },
    {
      "sha": "91ac4c0d9d2def605c89efbed226a9b3cc0e777d",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
      "patch": "@@ -27,6 +27,7 @@\n #include \"dwarf2.h\"\n #include \"dwarf2/expr.h\"\n #include \"dwarf2/loc.h\"\n+#include \"dwarf2/read.h\"\n #include \"gdbsupport/underlying.h\"\n #include \"gdbarch.h\"\n \n@@ -88,17 +89,17 @@ dwarf_expr_context::address_type () const\n \n /* Create a new context for the expression evaluator.  */\n \n-dwarf_expr_context::dwarf_expr_context ()\n+dwarf_expr_context::dwarf_expr_context (dwarf2_per_objfile *per_objfile)\n : gdbarch (NULL),\n   addr_size (0),\n   ref_addr_size (0),\n-  offset (0),\n   recursion_depth (0),\n   max_recursion_depth (0x100),\n   location (DWARF_VALUE_MEMORY),\n   len (0),\n   data (NULL),\n-  initialized (0)\n+  initialized (0),\n+  per_objfile (per_objfile)\n {\n }\n \n@@ -631,15 +632,15 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t     index, not an address.  We don't support things like\n \t     branching between the address and the TLS op.  */\n \t  if (op_ptr >= op_end || *op_ptr != DW_OP_GNU_push_tls_address)\n-\t    result += this->offset;\n+\t    result += this->per_objfile->objfile->text_section_offset ();\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n \n \tcase DW_OP_addrx:\n \tcase DW_OP_GNU_addr_index:\n \t  op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n \t  result = this->get_addr_index (uoffset);\n-\t  result += this->offset;\n+\t  result += this->per_objfile->objfile->text_section_offset ();\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n \tcase DW_OP_GNU_const_index:"
    },
    {
      "sha": "fd9c2bb6243c21707b5a7d36c2e2dc1a4f4dfabf",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
      "patch": "@@ -25,6 +25,8 @@\n #include \"leb128.h\"\n #include \"gdbtypes.h\"\n \n+struct dwarf2_per_objfile;\n+\n /* The location of a value.  */\n enum dwarf_value_location\n {\n@@ -117,7 +119,7 @@ struct dwarf_stack_value\n    its current state and its callbacks.  */\n struct dwarf_expr_context\n {\n-  dwarf_expr_context ();\n+  dwarf_expr_context (dwarf2_per_objfile *per_objfile);\n   virtual ~dwarf_expr_context () = default;\n \n   void push_address (CORE_ADDR value, bool in_stack_memory);\n@@ -139,10 +141,6 @@ struct dwarf_expr_context\n      context and operations depending on DW_FORM_ref_addr are not allowed.  */\n   int ref_addr_size;\n \n-  /* Offset used to relocate DW_OP_addr, DW_OP_addrx, and\n-     DW_OP_GNU_addr_index arguments.  */\n-  CORE_ADDR offset;\n-\n   /* The current depth of dwarf expression recursion, via DW_OP_call*,\n      DW_OP_fbreg, DW_OP_push_object_address, etc., and the maximum\n      depth we'll tolerate before raising an error.  */\n@@ -185,6 +183,9 @@ struct dwarf_expr_context\n      two cases need to be handled separately.)  */\n   std::vector<dwarf_expr_piece> pieces;\n \n+  /* We evaluate the expression in the context of this objfile.  */\n+  dwarf2_per_objfile *per_objfile;\n+\n   /* Return the value of register number REGNUM (a DWARF register number),\n      read as an address.  */\n   virtual CORE_ADDR read_addr_from_reg (int regnum) = 0;"
    },
    {
      "sha": "a8748e4d7d3fb9b2faa6e5de3daf4b2e52774ca4",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 39,
      "deletions": 28,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
      "patch": "@@ -166,8 +166,8 @@ struct comp_unit\n   auto_obstack obstack;\n };\n \n-static struct dwarf2_fde *dwarf2_frame_find_fde (CORE_ADDR *pc,\n-\t\t\t\t\t\t CORE_ADDR *out_offset);\n+static struct dwarf2_fde *dwarf2_frame_find_fde\n+  (CORE_ADDR *pc, dwarf2_per_objfile **out_per_objfile);\n \n static int dwarf2_frame_adjust_regnum (struct gdbarch *gdbarch, int regnum,\n \t\t\t\t       int eh_frame_p);\n@@ -237,7 +237,11 @@ register %s (#%d) at %s\"),\n \n class dwarf_expr_executor : public dwarf_expr_context\n {\n- public:\n+public:\n+\n+  dwarf_expr_executor (dwarf2_per_objfile *per_objfile)\n+    : dwarf_expr_context (per_objfile)\n+  {}\n \n   struct frame_info *this_frame;\n \n@@ -311,19 +315,18 @@ class dwarf_expr_executor : public dwarf_expr_context\n \n static CORE_ADDR\n execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n-\t\t  CORE_ADDR offset, struct frame_info *this_frame,\n-\t\t  CORE_ADDR initial, int initial_in_stack_memory)\n+\t\t  struct frame_info *this_frame, CORE_ADDR initial,\n+\t\t  int initial_in_stack_memory, dwarf2_per_objfile *per_objfile)\n {\n   CORE_ADDR result;\n \n-  dwarf_expr_executor ctx;\n+  dwarf_expr_executor ctx (per_objfile);\n   scoped_value_mark free_values;\n \n   ctx.this_frame = this_frame;\n   ctx.gdbarch = get_frame_arch (this_frame);\n   ctx.addr_size = addr_size;\n   ctx.ref_addr_size = -1;\n-  ctx.offset = offset;\n \n   ctx.push_address (initial, initial_in_stack_memory);\n   ctx.eval (exp, len);\n@@ -883,29 +886,32 @@ dwarf2_fetch_cfa_info (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t\t       const gdb_byte **cfa_end_out)\n {\n   struct dwarf2_fde *fde;\n-  CORE_ADDR text_offset;\n+  dwarf2_per_objfile *per_objfile;\n   CORE_ADDR pc1 = pc;\n \n   /* Find the correct FDE.  */\n-  fde = dwarf2_frame_find_fde (&pc1, &text_offset);\n+  fde = dwarf2_frame_find_fde (&pc1, &per_objfile);\n   if (fde == NULL)\n     error (_(\"Could not compute CFA; needed to translate this expression\"));\n \n+  gdb_assert (per_objfile != nullptr);\n+\n   dwarf2_frame_state fs (pc1, fde->cie);\n \n   /* Check for \"quirks\" - known bugs in producers.  */\n   dwarf2_frame_find_quirks (&fs, fde);\n \n   /* First decode all the insns in the CIE.  */\n   execute_cfa_program (fde, fde->cie->initial_instructions,\n-\t\t       fde->cie->end, gdbarch, pc, &fs, text_offset);\n+\t\t       fde->cie->end, gdbarch, pc, &fs,\n+\t\t       per_objfile->objfile->text_section_offset ());\n \n   /* Save the initialized register set.  */\n   fs.initial = fs.regs;\n \n   /* Then decode the insns in the FDE up to our target PC.  */\n   execute_cfa_program (fde, fde->instructions, fde->end, gdbarch, pc, &fs,\n-\t\t       text_offset);\n+\t\t       per_objfile->objfile->text_section_offset ());\n \n   /* Calculate the CFA.  */\n   switch (fs.regs.cfa_how)\n@@ -923,7 +929,7 @@ dwarf2_fetch_cfa_info (struct gdbarch *gdbarch, CORE_ADDR pc,\n       }\n \n     case CFA_EXP:\n-      *text_offset_out = text_offset;\n+      *text_offset_out = per_objfile->objfile->text_section_offset ();\n       *cfa_start_out = fs.regs.cfa_exp;\n       *cfa_end_out = fs.regs.cfa_exp + fs.regs.cfa_exp_len;\n       return 0;\n@@ -956,8 +962,8 @@ struct dwarf2_frame_cache\n   /* Target address size in bytes.  */\n   int addr_size;\n \n-  /* The .text offset.  */\n-  CORE_ADDR text_offset;\n+  /* The dwarf2_per_objfile from which this frame description came.  */\n+  dwarf2_per_objfile *per_objfile;\n \n   /* If not NULL then this frame is the bottom frame of a TAILCALL_FRAME\n      sequence.  If NULL then it is a normal case with no TAILCALL_FRAME\n@@ -1003,8 +1009,9 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n   CORE_ADDR pc1 = get_frame_address_in_block (this_frame);\n \n   /* Find the correct FDE.  */\n-  fde = dwarf2_frame_find_fde (&pc1, &cache->text_offset);\n+  fde = dwarf2_frame_find_fde (&pc1, &cache->per_objfile);\n   gdb_assert (fde != NULL);\n+  gdb_assert (cache->per_objfile != nullptr);\n \n   /* Allocate and initialize the frame state.  */\n   struct dwarf2_frame_state fs (pc1, fde->cie);\n@@ -1018,7 +1025,7 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n   execute_cfa_program (fde, fde->cie->initial_instructions,\n \t\t       fde->cie->end, gdbarch,\n \t\t       get_frame_address_in_block (this_frame), &fs,\n-\t\t       cache->text_offset);\n+\t\t       cache->per_objfile->objfile->text_section_offset ());\n \n   /* Save the initialized register set.  */\n   fs.initial = fs.regs;\n@@ -1034,8 +1041,9 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n       && entry_pc < fde->initial_location + fde->address_range)\n     {\n       /* Decode the insns in the FDE up to the entry PC.  */\n-      instr = execute_cfa_program (fde, fde->instructions, fde->end, gdbarch,\n-\t\t\t\t   entry_pc, &fs, cache->text_offset);\n+      instr = execute_cfa_program\n+\t(fde, fde->instructions, fde->end, gdbarch, entry_pc, &fs,\n+\t cache->per_objfile->objfile->text_section_offset ());\n \n       if (fs.regs.cfa_how == CFA_REG_OFFSET\n \t  && (dwarf_reg_to_regnum (gdbarch, fs.regs.cfa_reg)\n@@ -1051,7 +1059,7 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n   /* Then decode the insns in the FDE up to our target PC.  */\n   execute_cfa_program (fde, instr, fde->end, gdbarch,\n \t\t       get_frame_address_in_block (this_frame), &fs,\n-\t\t       cache->text_offset);\n+\t\t       cache->per_objfile->objfile->text_section_offset ());\n \n   try\n     {\n@@ -1069,8 +1077,8 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n \tcase CFA_EXP:\n \t  cache->cfa =\n \t    execute_stack_op (fs.regs.cfa_exp, fs.regs.cfa_exp_len,\n-\t\t\t      cache->addr_size, cache->text_offset,\n-\t\t\t      this_frame, 0, 0);\n+\t\t\t      cache->addr_size, this_frame, 0, 0,\n+\t\t\t      cache->per_objfile);\n \t  break;\n \n \tdefault:\n@@ -1270,8 +1278,9 @@ dwarf2_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n     case DWARF2_FRAME_REG_SAVED_EXP:\n       addr = execute_stack_op (cache->reg[regnum].loc.exp.start,\n \t\t\t       cache->reg[regnum].loc.exp.len,\n-\t\t\t       cache->addr_size, cache->text_offset,\n-\t\t\t       this_frame, cache->cfa, 1);\n+\t\t\t       cache->addr_size,\n+\t\t\t       this_frame, cache->cfa, 1,\n+\t\t\t       cache->per_objfile);\n       return frame_unwind_got_memory (this_frame, regnum, addr);\n \n     case DWARF2_FRAME_REG_SAVED_VAL_OFFSET:\n@@ -1281,8 +1290,9 @@ dwarf2_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n     case DWARF2_FRAME_REG_SAVED_VAL_EXP:\n       addr = execute_stack_op (cache->reg[regnum].loc.exp.start,\n \t\t\t       cache->reg[regnum].loc.exp.len,\n-\t\t\t       cache->addr_size, cache->text_offset,\n-\t\t\t       this_frame, cache->cfa, 1);\n+\t\t\t       cache->addr_size,\n+\t\t\t       this_frame, cache->cfa, 1,\n+\t\t\t       cache->per_objfile);\n       return frame_unwind_got_constant (this_frame, regnum, addr);\n \n     case DWARF2_FRAME_REG_UNSPECIFIED:\n@@ -1650,7 +1660,7 @@ set_comp_unit (struct objfile *objfile, struct comp_unit *unit)\n    initial location associated with it into *PC.  */\n \n static struct dwarf2_fde *\n-dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n+dwarf2_frame_find_fde (CORE_ADDR *pc, dwarf2_per_objfile **out_per_objfile)\n {\n   for (objfile *objfile : current_program_space->objfiles ())\n     {\n@@ -1682,8 +1692,9 @@ dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n       if (it != fde_table->end ())\n         {\n           *pc = (*it)->initial_location + offset;\n-\t  if (out_offset)\n-\t    *out_offset = offset;\n+\t  if (out_per_objfile != nullptr)\n+\t    *out_per_objfile = get_dwarf2_per_objfile (objfile);\n+\n           return *it;\n         }\n     }"
    },
    {
      "sha": "964726e862581e5974405684177c4b3c7b479f6d",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 18,
      "deletions": 15,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/89b07335fe42d6da84c19351ca0c34b11a3c4f8e/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=89b07335fe42d6da84c19351ca0c34b11a3c4f8e",
      "patch": "@@ -617,7 +617,10 @@ sect_variable_value (struct dwarf_expr_context *ctx, sect_offset sect_off,\n \n class dwarf_evaluate_loc_desc : public dwarf_expr_context\n {\n- public:\n+public:\n+  dwarf_evaluate_loc_desc (dwarf2_per_objfile *per_objfile)\n+    : dwarf_expr_context (per_objfile)\n+  {}\n \n   struct frame_info *frame;\n   struct dwarf2_per_cu_data *per_cu;\n@@ -733,8 +736,6 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n     this->gdbarch = per_cu->objfile ()->arch ();\n     scoped_restore save_addr_size = make_scoped_restore (&this->addr_size);\n     this->addr_size = per_cu->addr_size ();\n-    scoped_restore save_offset = make_scoped_restore (&this->offset);\n-    this->offset = per_cu->text_offset ();\n \n     this->eval (data_src, size);\n   }\n@@ -2191,7 +2192,8 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n   if (size == 0)\n     return allocate_optimized_out_value (subobj_type);\n \n-  dwarf_evaluate_loc_desc ctx;\n+  dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n+  dwarf_evaluate_loc_desc ctx (per_objfile);\n   ctx.frame = frame;\n   ctx.per_cu = per_cu;\n   ctx.obj_address = 0;\n@@ -2201,7 +2203,6 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n   ctx.gdbarch = objfile->arch ();\n   ctx.addr_size = per_cu->addr_size ();\n   ctx.ref_addr_size = per_cu->ref_addr_size ();\n-  ctx.offset = per_cu->text_offset ();\n \n   try\n     {\n@@ -2398,6 +2399,10 @@ dwarf2_evaluate_loc_desc (struct type *type, struct frame_info *frame,\n \n struct evaluate_for_locexpr_baton : public dwarf_evaluate_loc_desc\n {\n+  evaluate_for_locexpr_baton (dwarf2_per_objfile *per_objfile)\n+    : dwarf_evaluate_loc_desc (per_objfile)\n+  {}\n+\n   /* The data that was passed in.  */\n   gdb::array_view<const gdb_byte> data_view;\n \n@@ -2443,12 +2448,11 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n \t\t\t   CORE_ADDR *valp,\n \t\t\t   bool push_initial_value)\n {\n-  struct objfile *objfile;\n-\n   if (dlbaton == NULL || dlbaton->size == 0)\n     return 0;\n \n-  evaluate_for_locexpr_baton ctx;\n+  dwarf2_per_objfile *per_objfile = dlbaton->per_objfile;\n+  evaluate_for_locexpr_baton ctx (per_objfile);\n \n   ctx.frame = frame;\n   ctx.per_cu = dlbaton->per_cu;\n@@ -2460,12 +2464,9 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n       ctx.data_view = addr_stack->valaddr;\n     }\n \n-  objfile = dlbaton->per_objfile->objfile;\n-\n-  ctx.gdbarch = objfile->arch ();\n+  ctx.gdbarch = per_objfile->objfile->arch ();\n   ctx.addr_size = dlbaton->per_cu->addr_size ();\n   ctx.ref_addr_size = dlbaton->per_cu->ref_addr_size ();\n-  ctx.offset = dlbaton->per_cu->text_offset ();\n \n   if (push_initial_value)\n     ctx.push_address (ctx.obj_address, false);\n@@ -2675,7 +2676,10 @@ dwarf2_compile_property_to_c (string_file *stream,\n \n class symbol_needs_eval_context : public dwarf_expr_context\n {\n- public:\n+public:\n+  symbol_needs_eval_context (dwarf2_per_objfile *per_objfile)\n+    : dwarf_expr_context (per_objfile)\n+  {}\n \n   enum symbol_needs_kind needs;\n   struct dwarf2_per_cu_data *per_cu;\n@@ -2792,14 +2796,13 @@ dwarf2_loc_desc_get_symbol_read_needs (const gdb_byte *data, size_t size,\n \n   scoped_value_mark free_values;\n \n-  symbol_needs_eval_context ctx;\n+  symbol_needs_eval_context ctx (get_dwarf2_per_objfile (objfile));\n \n   ctx.needs = SYMBOL_NEEDS_NONE;\n   ctx.per_cu = per_cu;\n   ctx.gdbarch = objfile->arch ();\n   ctx.addr_size = per_cu->addr_size ();\n   ctx.ref_addr_size = per_cu->ref_addr_size ();\n-  ctx.offset = per_cu->text_offset ();\n \n   ctx.eval (data, size);\n "
    }
  ]
}