{
  "sha": "6dbf2b734063522b4f3d7403ce7a2b436802b839",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmRiZjJiNzM0MDYzNTIyYjRmM2Q3NDAzY2U3YTJiNDM2ODAyYjgzOQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T10:35:37Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:09:30Z"
    },
    "message": "libctf: labels\n\nThis facility allows you to associate regions of type IDs with *labels*,\na labelled tiling of the type ID space. You can use these to define\nCTF containers with distinct parents for distinct ranges of the ID\nspace, or to assist with parallelization of CTF processing, or for any\nother purpose you can think of.\n\nNotably absent from here (though declared in the API header) is any way\nto define new labels: this will probably be introduced soon, as part of\nthe linker deduplication work.  (One existed in the past, but was deeply\ntied to the Solaris CTF file generator and had to be torn out.)\n\nlibctf/\n\t* ctf-labels.c: New.\ninclude/\n\t* ctf-api.h (ctf_label_f): New.\n\t(ctf_label_set): New.\n\t(ctf_label_get): New.\n\t(ctf_label_topmost): New.\n\t(ctf_label_info): New.\n\t(ctf_label_iter): New.",
    "tree": {
      "sha": "ffd324ef83a909f9bdee848fb2287e87877af5d8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ffd324ef83a909f9bdee848fb2287e87877af5d8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6dbf2b734063522b4f3d7403ce7a2b436802b839",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6dbf2b734063522b4f3d7403ce7a2b436802b839",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6dbf2b734063522b4f3d7403ce7a2b436802b839",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6dbf2b734063522b4f3d7403ce7a2b436802b839/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6c33b742ce19cc2fd226d84f2991572239199a62",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6c33b742ce19cc2fd226d84f2991572239199a62",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6c33b742ce19cc2fd226d84f2991572239199a62"
    }
  ],
  "stats": {
    "total": 160,
    "additions": 160,
    "deletions": 0
  },
  "files": [
    {
      "sha": "3ea7ac8660a8397df1840c8835182bbfd69f7c8d",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6dbf2b734063522b4f3d7403ce7a2b436802b839/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6dbf2b734063522b4f3d7403ce7a2b436802b839/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=6dbf2b734063522b4f3d7403ce7a2b436802b839",
      "patch": "@@ -1,3 +1,12 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_label_f): New.\n+\t(ctf_label_set): New.\n+\t(ctf_label_get): New.\n+\t(ctf_label_topmost): New.\n+\t(ctf_label_info): New.\n+\t(ctf_label_iter): New.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_version): New."
    },
    {
      "sha": "c5ae38e6a43fb4be35f6e99410cdb4f927f6e22a",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6dbf2b734063522b4f3d7403ce7a2b436802b839/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6dbf2b734063522b4f3d7403ce7a2b436802b839/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=6dbf2b734063522b4f3d7403ce7a2b436802b839",
      "patch": "@@ -213,6 +213,8 @@ typedef int ctf_member_f (const char *name, ctf_id_t membtype,\n typedef int ctf_enum_f (const char *name, int val, void *arg);\n typedef int ctf_variable_f (const char *name, ctf_id_t type, void *arg);\n typedef int ctf_type_f (ctf_id_t type, void *arg);\n+typedef int ctf_label_f (const char *name, const ctf_lblinfo_t *info,\n+\t\t\t void *arg);\n typedef int ctf_archive_member_f (ctf_file_t *fp, const char *name, void *arg);\n typedef int ctf_archive_raw_member_f (const char *name, const void *content,\n \t\t\t\t      size_t len, void *arg);\n@@ -299,9 +301,16 @@ extern int ctf_array_info (ctf_file_t *, ctf_id_t, ctf_arinfo_t *);\n extern const char *ctf_enum_name (ctf_file_t *, ctf_id_t, int);\n extern int ctf_enum_value (ctf_file_t *, ctf_id_t, const char *, int *);\n \n+extern void ctf_label_set (ctf_file_t *, const char *);\n+extern const char *ctf_label_get (ctf_file_t *);\n+\n+extern const char *ctf_label_topmost (ctf_file_t *);\n+extern int ctf_label_info (ctf_file_t *, const char *, ctf_lblinfo_t *);\n+\n extern int ctf_member_iter (ctf_file_t *, ctf_id_t, ctf_member_f *, void *);\n extern int ctf_enum_iter (ctf_file_t *, ctf_id_t, ctf_enum_f *, void *);\n extern int ctf_type_iter (ctf_file_t *, ctf_type_f *, void *);\n+extern int ctf_label_iter (ctf_file_t *, ctf_label_f *, void *);\n extern int ctf_variable_iter (ctf_file_t *, ctf_variable_f *, void *);\n extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n \t\t\t     void *);"
    },
    {
      "sha": "e4976c40de2c92d89fc4182b6b6777ea3f18c5ce",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6dbf2b734063522b4f3d7403ce7a2b436802b839/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6dbf2b734063522b4f3d7403ce7a2b436802b839/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=6dbf2b734063522b4f3d7403ce7a2b436802b839",
      "patch": "@@ -1,3 +1,7 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-labels.c: New.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (_libctf_version): New declaration."
    },
    {
      "sha": "9b9fffea4ed351ae8223358406f7afa29ac7dca9",
      "filename": "libctf/ctf-labels.c",
      "status": "added",
      "additions": 138,
      "deletions": 0,
      "changes": 138,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6dbf2b734063522b4f3d7403ce7a2b436802b839/libctf/ctf-labels.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6dbf2b734063522b4f3d7403ce7a2b436802b839/libctf/ctf-labels.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-labels.c?ref=6dbf2b734063522b4f3d7403ce7a2b436802b839",
      "patch": "@@ -0,0 +1,138 @@\n+/* Labelled ranges of type IDs.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+\n+static int\n+extract_label_info (ctf_file_t *fp, const ctf_lblent_t **ctl,\n+\t\t    uint32_t *num_labels)\n+{\n+  const ctf_header_t *h;\n+\n+  h = (const ctf_header_t *) fp->ctf_data.cts_data;\n+\n+  *ctl = (const ctf_lblent_t *) (fp->ctf_buf + h->cth_lbloff);\n+  *num_labels = (h->cth_objtoff - h->cth_lbloff) / sizeof (ctf_lblent_t);\n+\n+  return 0;\n+}\n+\n+/* Returns the topmost label, or NULL if any errors are encountered.  */\n+\n+const char *\n+ctf_label_topmost (ctf_file_t *fp)\n+{\n+  const ctf_lblent_t *ctlp = NULL;\n+  const char *s;\n+  uint32_t num_labels = 0;\n+\n+  if (extract_label_info (fp, &ctlp, &num_labels) == CTF_ERR)\n+    return NULL;\t\t\t\t/* errno is set for us.  */\n+\n+  if (num_labels == 0)\n+    {\n+      (void) ctf_set_errno (fp, ECTF_NOLABELDATA);\n+      return NULL;\n+    }\n+\n+  if ((s = ctf_strraw (fp, (ctlp + num_labels - 1)->ctl_label)) == NULL)\n+    (void) ctf_set_errno (fp, ECTF_CORRUPT);\n+\n+  return s;\n+}\n+\n+/* Iterate over all labels.  We pass the label string and the lblinfo_t struct\n+   to the specified callback function.  */\n+int\n+ctf_label_iter (ctf_file_t *fp, ctf_label_f *func, void *arg)\n+{\n+  const ctf_lblent_t *ctlp = NULL;\n+  uint32_t i;\n+  uint32_t num_labels = 0;\n+  ctf_lblinfo_t linfo;\n+  const char *lname;\n+  int rc;\n+\n+  if (extract_label_info (fp, &ctlp, &num_labels) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if (num_labels == 0)\n+    return (ctf_set_errno (fp, ECTF_NOLABELDATA));\n+\n+  for (i = 0; i < num_labels; i++, ctlp++)\n+    {\n+      if ((lname = ctf_strraw (fp, ctlp->ctl_label)) == NULL)\n+\t{\n+\t  ctf_dprintf (\"failed to decode label %u with \"\n+\t\t       \"type %u\\n\", ctlp->ctl_label, ctlp->ctl_type);\n+\t  return (ctf_set_errno (fp, ECTF_CORRUPT));\n+\t}\n+\n+      linfo.ctb_type = ctlp->ctl_type;\n+      if ((rc = func (lname, &linfo, arg)) != 0)\n+\treturn rc;\n+    }\n+\n+  return 0;\n+}\n+\n+typedef struct linfo_cb_arg\n+{\n+  const char *lca_name;\t\t/* Label we want to retrieve info for.  */\n+  ctf_lblinfo_t *lca_info;\t/* Where to store the info about the label.  */\n+} linfo_cb_arg_t;\n+\n+static int\n+label_info_cb (const char *lname, const ctf_lblinfo_t *linfo, void *arg)\n+{\n+  /* If lname matches the label we are looking for, copy the\n+    lblinfo_t struct for the caller.  */\n+\n+  if (strcmp (lname, ((linfo_cb_arg_t *) arg)->lca_name) == 0)\n+    {\n+      /* * Allow caller not to allocate storage to test if label exists.  */\n+\n+      if (((linfo_cb_arg_t *) arg)->lca_info != NULL)\n+\tmemcpy (((linfo_cb_arg_t *) arg)->lca_info, linfo,\n+\t       sizeof (ctf_lblinfo_t));\n+      return 1;\t\t/* Indicate we found a match.  */\n+    }\n+\n+  return 0;\n+}\n+\n+/* Retrieve information about the label with name \"lname\". */\n+int\n+ctf_label_info (ctf_file_t *fp, const char *lname, ctf_lblinfo_t *linfo)\n+{\n+  linfo_cb_arg_t cb_arg;\n+  int rc;\n+\n+  cb_arg.lca_name = lname;\n+  cb_arg.lca_info = linfo;\n+\n+  if ((rc = ctf_label_iter (fp, label_info_cb, &cb_arg)) == CTF_ERR)\n+    return rc;\n+\n+  if (rc != 1)\n+    return (ctf_set_errno (fp, ECTF_NOLABEL));\n+\n+  return 0;\n+}"
    }
  ]
}