{
  "sha": "d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDhhZWI3N2YwNDBjZWQ3ZDM3YWI4M2YwMzJiMmU0ZGVkMmM4MWNhNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-11-24T16:20:18Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-10T01:28:15Z"
    },
    "message": "Remove ALL_COMPUNITS\n\nThis removes the ALL_COMPUNITS, replacing its uses with two nested\nranged for loops.\n\ngdb/ChangeLog\n2019-01-09  Tom Tromey  <tom@tromey.com>\n\n\t* symtab.c (lookup_objfile_from_block)\n\t(find_pc_sect_compunit_symtab, search_symbols)\n\t(default_collect_symbol_completion_matches_break_on): Use\n\tobjfile_compunits.\n\t* objfiles.h (ALL_COMPUNITS): Remove.\n\t* maint.c (count_symtabs_and_blocks): Use objfile_compunits.\n\t* cp-support.c (add_symbol_overload_list_qualified): Use\n\tobjfile_compunits.\n\t* ada-lang.c (ada_collect_symbol_completion_matches)\n\t(ada_add_global_exceptions): Use objfile_compunits.",
    "tree": {
      "sha": "18324cc1d77dd8bb6cea91bfecd703746b9c71f3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/18324cc1d77dd8bb6cea91bfecd703746b9c71f3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "592553c46959c98bf5981ad245d0fbb97f373d2a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/592553c46959c98bf5981ad245d0fbb97f373d2a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/592553c46959c98bf5981ad245d0fbb97f373d2a"
    }
  ],
  "stats": {
    "total": 413,
    "additions": 220,
    "deletions": 193
  },
  "files": [
    {
      "sha": "70c84979f9fd4e3fe4b3f3386819f378ed7cc3de",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
      "patch": "@@ -1,3 +1,16 @@\n+2019-01-09  Tom Tromey  <tom@tromey.com>\n+\n+\t* symtab.c (lookup_objfile_from_block)\n+\t(find_pc_sect_compunit_symtab, search_symbols)\n+\t(default_collect_symbol_completion_matches_break_on): Use\n+\tobjfile_compunits.\n+\t* objfiles.h (ALL_COMPUNITS): Remove.\n+\t* maint.c (count_symtabs_and_blocks): Use objfile_compunits.\n+\t* cp-support.c (add_symbol_overload_list_qualified): Use\n+\tobjfile_compunits.\n+\t* ada-lang.c (ada_collect_symbol_completion_matches)\n+\t(ada_add_global_exceptions): Use objfile_compunits.\n+\n 2019-01-09  Tom Tromey  <tom@tromey.com>\n \n \t* source.c (select_source_symtab)"
    },
    {
      "sha": "f552f13a418313702fc74630277418533d141cab",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 53,
      "deletions": 47,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
      "patch": "@@ -6465,41 +6465,46 @@ ada_collect_symbol_completion_matches (completion_tracker &tracker,\n   /* Go through the symtabs and check the externs and statics for\n      symbols which match.  */\n \n-  struct objfile *objfile;\n-  ALL_COMPUNITS (objfile, s)\n-  {\n-    QUIT;\n-    b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (s), GLOBAL_BLOCK);\n-    ALL_BLOCK_SYMBOLS (b, iter, sym)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n-      if (completion_skip_symbol (mode, sym))\n-\tcontinue;\n+      for (compunit_symtab *s : objfile_compunits (objfile))\n+\t{\n+\t  QUIT;\n+\t  b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (s), GLOBAL_BLOCK);\n+\t  ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t    {\n+\t      if (completion_skip_symbol (mode, sym))\n+\t\tcontinue;\n \n-      completion_list_add_name (tracker,\n-\t\t\t\tSYMBOL_LANGUAGE (sym),\n-\t\t\t\tSYMBOL_LINKAGE_NAME (sym),\n-\t\t\t\tlookup_name, text, word);\n+\t      completion_list_add_name (tracker,\n+\t\t\t\t\tSYMBOL_LANGUAGE (sym),\n+\t\t\t\t\tSYMBOL_LINKAGE_NAME (sym),\n+\t\t\t\t\tlookup_name, text, word);\n+\t    }\n+\t}\n     }\n-  }\n \n-  ALL_COMPUNITS (objfile, s)\n-  {\n-    QUIT;\n-    b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (s), STATIC_BLOCK);\n-    /* Don't do this block twice.  */\n-    if (b == surrounding_static_block)\n-      continue;\n-    ALL_BLOCK_SYMBOLS (b, iter, sym)\n-    {\n-      if (completion_skip_symbol (mode, sym))\n-\tcontinue;\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *s : objfile_compunits (objfile))\n+\t{\n+\t  QUIT;\n+\t  b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (s), STATIC_BLOCK);\n+\t  /* Don't do this block twice.  */\n+\t  if (b == surrounding_static_block)\n+\t    continue;\n+\t  ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t    {\n+\t      if (completion_skip_symbol (mode, sym))\n+\t\tcontinue;\n \n-      completion_list_add_name (tracker,\n-\t\t\t\tSYMBOL_LANGUAGE (sym),\n-\t\t\t\tSYMBOL_LINKAGE_NAME (sym),\n-\t\t\t\tlookup_name, text, word);\n+\t      completion_list_add_name (tracker,\n+\t\t\t\t\tSYMBOL_LANGUAGE (sym),\n+\t\t\t\t\tSYMBOL_LINKAGE_NAME (sym),\n+\t\t\t\t\tlookup_name, text, word);\n+\t    }\n+\t}\n     }\n-  }\n }\n \n                                 /* Field Access */\n@@ -13548,8 +13553,6 @@ static void\n ada_add_global_exceptions (compiled_regex *preg,\n \t\t\t   std::vector<ada_exc_info> *exceptions)\n {\n-  struct objfile *objfile;\n-\n   /* In Ada, the symbol \"search name\" is a linkage name, whereas the\n      regular expression used to do the matching refers to the natural\n      name.  So match against the decoded name.  */\n@@ -13563,26 +13566,29 @@ ada_add_global_exceptions (compiled_regex *preg,\n \t\t\t   NULL,\n \t\t\t   VARIABLES_DOMAIN);\n \n-  ALL_COMPUNITS (objfile, s)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n-      const struct blockvector *bv = COMPUNIT_BLOCKVECTOR (s);\n-      int i;\n-\n-      for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n+      for (compunit_symtab *s : objfile_compunits (objfile))\n \t{\n-\t  struct block *b = BLOCKVECTOR_BLOCK (bv, i);\n-\t  struct block_iterator iter;\n-\t  struct symbol *sym;\n+\t  const struct blockvector *bv = COMPUNIT_BLOCKVECTOR (s);\n+\t  int i;\n \n-\t  ALL_BLOCK_SYMBOLS (b, iter, sym)\n-\t    if (ada_is_non_standard_exception_sym (sym)\n-\t\t&& name_matches_regex (SYMBOL_NATURAL_NAME (sym), preg))\n-\t      {\n-\t\tstruct ada_exc_info info\n-\t\t  = {SYMBOL_PRINT_NAME (sym), SYMBOL_VALUE_ADDRESS (sym)};\n+\t  for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n+\t    {\n+\t      struct block *b = BLOCKVECTOR_BLOCK (bv, i);\n+\t      struct block_iterator iter;\n+\t      struct symbol *sym;\n \n-\t\texceptions->push_back (info);\n-\t      }\n+\t      ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t\tif (ada_is_non_standard_exception_sym (sym)\n+\t\t    && name_matches_regex (SYMBOL_NATURAL_NAME (sym), preg))\n+\t\t  {\n+\t\t    struct ada_exc_info info\n+\t\t      = {SYMBOL_PRINT_NAME (sym), SYMBOL_VALUE_ADDRESS (sym)};\n+\n+\t\t    exceptions->push_back (info);\n+\t\t  }\n+\t    }\n \t}\n     }\n }"
    },
    {
      "sha": "16d81763419f90ba11de2fb96cfedd79735deecd",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 21,
      "deletions": 16,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
      "patch": "@@ -1395,23 +1395,28 @@ add_symbol_overload_list_qualified (const char *func_name,\n   /* Go through the symtabs and check the externs and statics for\n      symbols which match.  */\n \n-  struct objfile *objfile;\n-  ALL_COMPUNITS (objfile, cust)\n-  {\n-    QUIT;\n-    b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust), GLOBAL_BLOCK);\n-    add_symbol_overload_list_block (func_name, b, overload_list);\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *cust : objfile_compunits (objfile))\n+\t{\n+\t  QUIT;\n+\t  b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust), GLOBAL_BLOCK);\n+\t  add_symbol_overload_list_block (func_name, b, overload_list);\n+\t}\n+    }\n \n-  ALL_COMPUNITS (objfile, cust)\n-  {\n-    QUIT;\n-    b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust), STATIC_BLOCK);\n-    /* Don't do this block twice.  */\n-    if (b == surrounding_static_block)\n-      continue;\n-    add_symbol_overload_list_block (func_name, b, overload_list);\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *cust : objfile_compunits (objfile))\n+\t{\n+\t  QUIT;\n+\t  b = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust), STATIC_BLOCK);\n+\t  /* Don't do this block twice.  */\n+\t  if (b == surrounding_static_block)\n+\t    continue;\n+\t  add_symbol_overload_list_block (func_name, b, overload_list);\n+\t}\n+    }\n }\n \n /* Lookup the rtti type for a class name.  */"
    },
    {
      "sha": "d969e79e4f8a6bcc4da1278bdac6765aaccfeb5d",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
      "patch": "@@ -762,7 +762,6 @@ static void\n count_symtabs_and_blocks (int *nr_symtabs_ptr, int *nr_compunit_symtabs_ptr,\n \t\t\t  int *nr_blocks_ptr)\n {\n-  struct objfile *o;\n   struct symtab *s;\n   int nr_symtabs = 0;\n   int nr_compunit_symtabs = 0;\n@@ -773,12 +772,15 @@ count_symtabs_and_blocks (int *nr_symtabs_ptr, int *nr_compunit_symtabs_ptr,\n      current_program_space may be NULL.  */\n   if (current_program_space != NULL)\n     {\n-      ALL_COMPUNITS (o, cu)\n+      for (objfile *o : all_objfiles (current_program_space))\n \t{\n-\t  ++nr_compunit_symtabs;\n-\t  nr_blocks += BLOCKVECTOR_NBLOCKS (COMPUNIT_BLOCKVECTOR (cu));\n-\t  ALL_COMPUNIT_FILETABS (cu, s)\n-\t    ++nr_symtabs;\n+\t  for (compunit_symtab *cu : objfile_compunits (o))\n+\t    {\n+\t      ++nr_compunit_symtabs;\n+\t      nr_blocks += BLOCKVECTOR_NBLOCKS (COMPUNIT_BLOCKVECTOR (cu));\n+\t      ALL_COMPUNIT_FILETABS (cu, s)\n+\t\t++nr_symtabs;\n+\t    }\n \t}\n     }\n "
    },
    {
      "sha": "ae6a7794911429c04879d7bc901b253bca34761c",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
      "patch": "@@ -718,12 +718,6 @@ class objfile_msymbols\n   ALL_OBJFILES (objfile)\t\t\t\\\n     ALL_OBJFILE_FILETABS (objfile, ps, s)\n \n-/* Traverse all compunits in all objfiles in the current program space.  */\n-\n-#define ALL_COMPUNITS(objfile, cu)\t\\\n-  ALL_OBJFILES (objfile)\t\t\\\n-    for (compunit_symtab *cu : objfile_compunits (objfile))\n-\n #define ALL_OBJFILE_OSECTIONS(objfile, osect)\t\\\n   for (osect = objfile->sections; osect < objfile->sections_end; osect++) \\\n     if (osect->the_bfd_section == NULL)\t\t\t\t\t\\"
    },
    {
      "sha": "e6e001bcd223d65a382074c23297ee174c982840",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 125,
      "deletions": 118,
      "changes": 243,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=d8aeb77f040ced7d37ab83f032b2e4ded2c81ca5",
      "patch": "@@ -2166,22 +2166,23 @@ lookup_local_symbol (const char *name,\n struct objfile *\n lookup_objfile_from_block (const struct block *block)\n {\n-  struct objfile *obj;\n-\n   if (block == NULL)\n     return NULL;\n \n   block = block_global_block (block);\n   /* Look through all blockvectors.  */\n-  ALL_COMPUNITS (obj, cust)\n-    if (block == BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust),\n-\t\t\t\t    GLOBAL_BLOCK))\n-      {\n-\tif (obj->separate_debug_objfile_backlink)\n-\t  obj = obj->separate_debug_objfile_backlink;\n+  for (objfile *obj : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *cust : objfile_compunits (obj))\n+\tif (block == BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust),\n+\t\t\t\t\tGLOBAL_BLOCK))\n+\t  {\n+\t    if (obj->separate_debug_objfile_backlink)\n+\t      obj = obj->separate_debug_objfile_backlink;\n \n-\treturn obj;\n-      }\n+\t    return obj;\n+\t  }\n+    }\n \n   return NULL;\n }\n@@ -2871,7 +2872,6 @@ struct compunit_symtab *\n find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n {\n   struct compunit_symtab *best_cust = NULL;\n-  struct objfile *obj_file;\n   CORE_ADDR distance = 0;\n   struct bound_minimal_symbol msymbol;\n \n@@ -2904,57 +2904,62 @@ find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n      It also happens for objfiles that have their functions reordered.\n      For these, the symtab we are looking for is not necessarily read in.  */\n \n-  ALL_COMPUNITS (obj_file, cust)\n-  {\n-    struct block *b;\n-    const struct blockvector *bv;\n+  for (objfile *obj_file : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *cust : objfile_compunits (obj_file))\n+\t{\n+\t  struct block *b;\n+\t  const struct blockvector *bv;\n \n-    bv = COMPUNIT_BLOCKVECTOR (cust);\n-    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n+\t  bv = COMPUNIT_BLOCKVECTOR (cust);\n+\t  b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n \n-    if (BLOCK_START (b) <= pc\n-\t&& BLOCK_END (b) > pc\n-\t&& (distance == 0\n-\t    || BLOCK_END (b) - BLOCK_START (b) < distance))\n-      {\n-\t/* For an objfile that has its functions reordered,\n-\t   find_pc_psymtab will find the proper partial symbol table\n-\t   and we simply return its corresponding symtab.  */\n-\t/* In order to better support objfiles that contain both\n-\t   stabs and coff debugging info, we continue on if a psymtab\n-\t   can't be found.  */\n-\tif ((obj_file->flags & OBJF_REORDERED) && obj_file->sf)\n-\t  {\n-\t    struct compunit_symtab *result;\n-\n-\t    result\n-\t      = obj_file->sf->qf->find_pc_sect_compunit_symtab (obj_file,\n-\t\t\t\t\t\t\t\tmsymbol,\n-\t\t\t\t\t\t\t\tpc, section,\n-\t\t\t\t\t\t\t\t0);\n-\t    if (result != NULL)\n-\t      return result;\n-\t  }\n-\tif (section != 0)\n-\t  {\n-\t    struct block_iterator iter;\n-\t    struct symbol *sym = NULL;\n+\t  if (BLOCK_START (b) <= pc\n+\t      && BLOCK_END (b) > pc\n+\t      && (distance == 0\n+\t\t  || BLOCK_END (b) - BLOCK_START (b) < distance))\n+\t    {\n+\t      /* For an objfile that has its functions reordered,\n+\t\t find_pc_psymtab will find the proper partial symbol table\n+\t\t and we simply return its corresponding symtab.  */\n+\t      /* In order to better support objfiles that contain both\n+\t\t stabs and coff debugging info, we continue on if a psymtab\n+\t\t can't be found.  */\n+\t      if ((obj_file->flags & OBJF_REORDERED) && obj_file->sf)\n+\t\t{\n+\t\t  struct compunit_symtab *result;\n+\n+\t\t  result\n+\t\t    = obj_file->sf->qf->find_pc_sect_compunit_symtab (obj_file,\n+\t\t\t\t\t\t\t\t      msymbol,\n+\t\t\t\t\t\t\t\t      pc,\n+\t\t\t\t\t\t\t\t      section,\n+\t\t\t\t\t\t\t\t      0);\n+\t\t  if (result != NULL)\n+\t\t    return result;\n+\t\t}\n+\t      if (section != 0)\n+\t\t{\n+\t\t  struct block_iterator iter;\n+\t\t  struct symbol *sym = NULL;\n \n-\t    ALL_BLOCK_SYMBOLS (b, iter, sym)\n-\t      {\n-\t\tfixup_symbol_section (sym, obj_file);\n-\t\tif (matching_obj_sections (SYMBOL_OBJ_SECTION (obj_file, sym),\n-\t\t\t\t\t   section))\n-\t\t  break;\n-\t      }\n-\t    if (sym == NULL)\n-\t      continue;\t\t/* No symbol in this symtab matches\n-\t\t\t\t   section.  */\n-\t  }\n-\tdistance = BLOCK_END (b) - BLOCK_START (b);\n-\tbest_cust = cust;\n-      }\n-  }\n+\t\t  ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t\t    {\n+\t\t      fixup_symbol_section (sym, obj_file);\n+\t\t      if (matching_obj_sections (SYMBOL_OBJ_SECTION (obj_file,\n+\t\t\t\t\t\t\t\t     sym),\n+\t\t\t\t\t\t section))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  if (sym == NULL)\n+\t\t    continue;\t\t/* No symbol in this symtab matches\n+\t\t\t\t\t   section.  */\n+\t\t}\n+\t      distance = BLOCK_END (b) - BLOCK_START (b);\n+\t      best_cust = cust;\n+\t    }\n+\t}\n+    }\n \n   if (best_cust != NULL)\n     return best_cust;\n@@ -4465,7 +4470,7 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t      /* Note: An important side-effect of these\n \t\t\t lookup functions is to expand the symbol\n \t\t\t table if msymbol is found, for the benefit of\n-\t\t\t the next loop on ALL_COMPUNITS.  */\n+\t\t\t the next loop on compunits.  */\n \t\t      if (kind == FUNCTIONS_DOMAIN\n \t\t\t  ? (find_pc_compunit_symtab\n \t\t\t     (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n@@ -4481,60 +4486,60 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t}\n     }\n \n-  {\n-    struct objfile *objfile;\n-    ALL_COMPUNITS (objfile, cust)\n-      {\n-\tbv = COMPUNIT_BLOCKVECTOR (cust);\n-\tfor (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n-\t  {\n-\t    b = BLOCKVECTOR_BLOCK (bv, i);\n-\t    ALL_BLOCK_SYMBOLS (b, iter, sym)\n-\t      {\n-\t\tstruct symtab *real_symtab = symbol_symtab (sym);\n-\n-\t\tQUIT;\n-\n-\t\t/* Check first sole REAL_SYMTAB->FILENAME.  It does\n-\t\t   not need to be a substring of symtab_to_fullname as\n-\t\t   it may contain \"./\" etc.  */\n-\t\tif ((file_matches (real_symtab->filename, files, nfiles, 0)\n-\t\t     || ((basenames_may_differ\n-\t\t\t  || file_matches (lbasename (real_symtab->filename),\n-\t\t\t\t\t   files, nfiles, 1))\n-\t\t\t && file_matches (symtab_to_fullname (real_symtab),\n-\t\t\t\t\t  files, nfiles, 0)))\n-\t\t    && ((!preg.has_value ()\n-\t\t\t || preg->exec (SYMBOL_NATURAL_NAME (sym), 0,\n-\t\t\t\t\tNULL, 0) == 0)\n-\t\t\t&& ((kind == VARIABLES_DOMAIN\n-\t\t\t     && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n-\t\t\t     && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n-\t\t\t     && SYMBOL_CLASS (sym) != LOC_BLOCK\n-\t\t\t     /* LOC_CONST can be used for more than\n-\t\t\t\tjust enums, e.g., c++ static const\n-\t\t\t\tmembers.  We only want to skip enums\n-\t\t\t\there.  */\n-\t\t\t     && !(SYMBOL_CLASS (sym) == LOC_CONST\n-\t\t\t\t  && (TYPE_CODE (SYMBOL_TYPE (sym))\n-\t\t\t\t      == TYPE_CODE_ENUM))\n-\t\t\t     && (!treg.has_value ()\n-\t\t\t\t || treg_matches_sym_type_name (*treg, sym)))\n-\t\t\t    || (kind == FUNCTIONS_DOMAIN\n-\t\t\t\t&& SYMBOL_CLASS (sym) == LOC_BLOCK\n-\t\t\t\t&& (!treg.has_value ()\n-\t\t\t\t    || treg_matches_sym_type_name (*treg,\n-\t\t\t\t\t\t\t\t   sym)))\n-\t\t\t    || (kind == TYPES_DOMAIN\n-\t\t\t\t&& SYMBOL_CLASS (sym) == LOC_TYPEDEF))))\n-\t\t  {\n-\t\t    /* match */\n-\t\t    result.emplace_back (i, sym);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *cust : objfile_compunits (objfile))\n+\t{\n+\t  bv = COMPUNIT_BLOCKVECTOR (cust);\n+\t  for (i = GLOBAL_BLOCK; i <= STATIC_BLOCK; i++)\n+\t    {\n+\t      b = BLOCKVECTOR_BLOCK (bv, i);\n+\t      ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t\t{\n+\t\t  struct symtab *real_symtab = symbol_symtab (sym);\n+\n+\t\t  QUIT;\n+\n+\t\t  /* Check first sole REAL_SYMTAB->FILENAME.  It does\n+\t\t     not need to be a substring of symtab_to_fullname as\n+\t\t     it may contain \"./\" etc.  */\n+\t\t  if ((file_matches (real_symtab->filename, files, nfiles, 0)\n+\t\t       || ((basenames_may_differ\n+\t\t\t    || file_matches (lbasename (real_symtab->filename),\n+\t\t\t\t\t     files, nfiles, 1))\n+\t\t\t   && file_matches (symtab_to_fullname (real_symtab),\n+\t\t\t\t\t    files, nfiles, 0)))\n+\t\t      && ((!preg.has_value ()\n+\t\t\t   || preg->exec (SYMBOL_NATURAL_NAME (sym), 0,\n+\t\t\t\t\t  NULL, 0) == 0)\n+\t\t\t  && ((kind == VARIABLES_DOMAIN\n+\t\t\t       && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n+\t\t\t       && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n+\t\t\t       && SYMBOL_CLASS (sym) != LOC_BLOCK\n+\t\t\t       /* LOC_CONST can be used for more than\n+\t\t\t\t  just enums, e.g., c++ static const\n+\t\t\t\t  members.  We only want to skip enums\n+\t\t\t\t  here.  */\n+\t\t\t       && !(SYMBOL_CLASS (sym) == LOC_CONST\n+\t\t\t\t    && (TYPE_CODE (SYMBOL_TYPE (sym))\n+\t\t\t\t\t== TYPE_CODE_ENUM))\n+\t\t\t       && (!treg.has_value ()\n+\t\t\t\t   || treg_matches_sym_type_name (*treg, sym)))\n+\t\t\t      || (kind == FUNCTIONS_DOMAIN\n+\t\t\t\t  && SYMBOL_CLASS (sym) == LOC_BLOCK\n+\t\t\t\t  && (!treg.has_value ()\n+\t\t\t\t      || treg_matches_sym_type_name (*treg,\n+\t\t\t\t\t\t\t\t     sym)))\n+\t\t\t      || (kind == TYPES_DOMAIN\n+\t\t\t\t  && SYMBOL_CLASS (sym) == LOC_TYPEDEF))))\n+\t\t    {\n+\t\t      /* match */\n+\t\t      result.emplace_back (i, sym);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   if (!result.empty ())\n     sort_search_symbols_remove_dups (&result);\n@@ -5282,10 +5287,12 @@ default_collect_symbol_completion_matches_break_on\n     }\n \n   /* Add completions for all currently loaded symbol tables.  */\n-  struct objfile *objfile;\n-  ALL_COMPUNITS (objfile, cust)\n-    add_symtab_completions (cust, tracker, mode, lookup_name,\n-\t\t\t    sym_text, word, code);\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      for (compunit_symtab *cust : objfile_compunits (objfile))\n+\tadd_symtab_completions (cust, tracker, mode, lookup_name,\n+\t\t\t\tsym_text, word, code);\n+    }\n \n   /* Look through the partial symtabs for all symbols which begin by\n      matching SYM_TEXT.  Expand all CUs that you find to the list.  */"
    }
  ]
}