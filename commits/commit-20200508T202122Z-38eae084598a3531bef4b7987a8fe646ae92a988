{
  "sha": "38eae084598a3531bef4b7987a8fe646ae92a988",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzhlYWUwODQ1OThhMzUzMWJlZjRiNzk4N2E4ZmU2NDZhZTkyYTk4OA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-05-08T20:21:22Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-05-08T20:21:22Z"
    },
    "message": "Remove ALL_EXTENSION_LANGUAGES and ALL_ENABLED_EXTENSION_LANGUAGES\n\nThis removes the ALL_EXTENSION_LANGUAGES and\nALL_ENABLED_EXTENSION_LANGUAGES macros, in favor of ordinary\niterators.  For ALL_ENABLED_EXTENSION_LANGUAGES, I chose to simply\ninline the check, as that seemed simpler than trying to make\nfiltered_iterator work for std::array.  (As an aside, this sort of\nthing will be easier once we can use the ranges library...)\n\ngdb/ChangeLog\n2020-05-08  Tom Tromey  <tom@tromey.com>\n\n\t* extension.c (extension_languages): Now a std::array.\n\t(ALL_EXTENSION_LANGUAGES): Remove.\n\t(get_ext_lang_defn, get_ext_lang_of_file)\n\t(eval_ext_lang_from_control_command): Update.\n\t(finish_ext_lang_initialization)\n\t(auto_load_ext_lang_scripts_for_objfile)\n\t(ext_lang_type_printers::ext_lang_type_printers)\n\t(apply_ext_lang_type_printers)\n\t(ext_lang_type_printers::~ext_lang_type_printers)\n\t(apply_ext_lang_val_pretty_printer, apply_ext_lang_frame_filter)\n\t(preserve_ext_lang_values, get_breakpoint_cond_ext_lang)\n\t(breakpoint_ext_lang_cond_says_stop, check_quit_flag)\n\t(get_matching_xmethod_workers, ext_lang_colorize)\n\t(ext_lang_before_prompt): Update.\n\t(ALL_ENABLED_EXTENSION_LANGUAGES): Remove.",
    "tree": {
      "sha": "46a7e6828f3775e6b0044e091a8cfd58436977a0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/46a7e6828f3775e6b0044e091a8cfd58436977a0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/38eae084598a3531bef4b7987a8fe646ae92a988",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/38eae084598a3531bef4b7987a8fe646ae92a988",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/38eae084598a3531bef4b7987a8fe646ae92a988",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/38eae084598a3531bef4b7987a8fe646ae92a988/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/596dc4adfff347b4d8dc1f7e4eb57b8f2f342281"
    }
  ],
  "stats": {
    "total": 171,
    "additions": 69,
    "deletions": 102
  },
  "files": [
    {
      "sha": "be55c41d67f920dc519e6f1fc68b3049cb525dd0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/38eae084598a3531bef4b7987a8fe646ae92a988/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/38eae084598a3531bef4b7987a8fe646ae92a988/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=38eae084598a3531bef4b7987a8fe646ae92a988",
      "patch": "@@ -1,3 +1,21 @@\n+2020-05-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* extension.c (extension_languages): Now a std::array.\n+\t(ALL_EXTENSION_LANGUAGES): Remove.\n+\t(get_ext_lang_defn, get_ext_lang_of_file)\n+\t(eval_ext_lang_from_control_command): Update.\n+\t(finish_ext_lang_initialization)\n+\t(auto_load_ext_lang_scripts_for_objfile)\n+\t(ext_lang_type_printers::ext_lang_type_printers)\n+\t(apply_ext_lang_type_printers)\n+\t(ext_lang_type_printers::~ext_lang_type_printers)\n+\t(apply_ext_lang_val_pretty_printer, apply_ext_lang_frame_filter)\n+\t(preserve_ext_lang_values, get_breakpoint_cond_ext_lang)\n+\t(breakpoint_ext_lang_cond_says_stop, check_quit_flag)\n+\t(get_matching_xmethod_workers, ext_lang_colorize)\n+\t(ext_lang_before_prompt): Update.\n+\t(ALL_ENABLED_EXTENSION_LANGUAGES): Remove.\n+\n 2020-05-08  Tom Tromey  <tom@tromey.com>\n \n \t* symtab.h (class demangle_result_storage) <set_malloc_ptr>: New"
    },
    {
      "sha": "e4b3b3cbd12b973d72aa0c1766b57f7944248220",
      "filename": "gdb/extension.c",
      "status": "modified",
      "additions": 51,
      "deletions": 102,
      "changes": 153,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/38eae084598a3531bef4b7987a8fe646ae92a988/gdb/extension.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/38eae084598a3531bef4b7987a8fe646ae92a988/gdb/extension.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/extension.c?ref=38eae084598a3531bef4b7987a8fe646ae92a988",
      "patch": "@@ -32,24 +32,7 @@\n #include \"cli/cli-script.h\"\n #include \"python/python.h\"\n #include \"guile/guile.h\"\n-\n-/* Iterate over all external extension languages, regardless of whether the\n-   support has been compiled in or not.\n-   This does not include GDB's own scripting language.  */\n-\n-#define ALL_EXTENSION_LANGUAGES(i, extlang) \\\n-  for (/*int*/ i = 0, extlang = extension_languages[0]; \\\n-       extlang != NULL; \\\n-       extlang = extension_languages[++i])\n-\n-/* Iterate over all external extension languages that are supported.\n-   This does not include GDB's own scripting language.  */\n-\n-#define ALL_ENABLED_EXTENSION_LANGUAGES(i, extlang) \\\n-  for (/*int*/ i = 0, extlang = extension_languages[0]; \\\n-       extlang != NULL; \\\n-       extlang = extension_languages[++i]) \\\n-    if (extlang->ops != NULL)\n+#include <array>\n \n static script_sourcer_func source_gdb_script;\n static objfile_script_sourcer_func source_gdb_objfile_script;\n@@ -99,12 +82,11 @@ const struct extension_language_defn extension_language_gdb =\n    pretty-printed value is the one that is used.  This algorithm is employed\n    throughout.  */\n \n-static const struct extension_language_defn * const extension_languages[] =\n+static const std::array<const extension_language_defn *, 2> extension_languages\n {\n   /* To preserve existing behaviour, python should always appear first.  */\n   &extension_language_python,\n   &extension_language_guile,\n-  NULL\n };\n \n /* Return a pointer to the struct extension_language_defn object of\n@@ -115,15 +97,12 @@ static const struct extension_language_defn * const extension_languages[] =\n const struct extension_language_defn *\n get_ext_lang_defn (enum extension_language lang)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n   gdb_assert (lang != EXT_LANG_NONE);\n \n   if (lang == EXT_LANG_GDB)\n     return &extension_language_gdb;\n \n-  ALL_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       if (extlang->language == lang)\n \treturn extlang;\n@@ -151,13 +130,10 @@ has_extension (const char *file, const char *extension)\n const struct extension_language_defn *\n get_ext_lang_of_file (const char *file)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n   if (has_extension (file, extension_language_gdb.suffix))\n     return &extension_language_gdb;\n \n-  ALL_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       if (has_extension (file, extlang->suffix))\n \treturn extlang;\n@@ -331,12 +307,10 @@ ext_lang_auto_load_enabled (const struct extension_language_defn *extlang)\n void\n finish_ext_lang_initialization (void)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->ops->finish_initialization != NULL)\n+      if (extlang->ops != nullptr\n+\t  && extlang->ops->finish_initialization != NULL)\n \textlang->ops->finish_initialization (extlang);\n     }\n }\n@@ -355,10 +329,7 @@ finish_ext_lang_initialization (void)\n void\n eval_ext_lang_from_control_command (struct command_line *cmd)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       if (extlang->cli_control_type == cmd->control_type)\n \t{\n@@ -385,16 +356,14 @@ eval_ext_lang_from_control_command (struct command_line *cmd)\n void\n auto_load_ext_lang_scripts_for_objfile (struct objfile *objfile)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  extlang = &extension_language_gdb;\n-  if (ext_lang_auto_load_enabled (extlang))\n-    auto_load_objfile_script (objfile, extlang);\n+  const struct extension_language_defn *gdb = &extension_language_gdb;\n+  if (ext_lang_auto_load_enabled (gdb))\n+    auto_load_objfile_script (objfile, gdb);\n \n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (ext_lang_auto_load_enabled (extlang))\n+      if (extlang->ops != nullptr\n+\t  && ext_lang_auto_load_enabled (extlang))\n \tauto_load_objfile_script (objfile, extlang);\n     }\n }\n@@ -410,12 +379,10 @@ auto_load_ext_lang_scripts_for_objfile (struct objfile *objfile)\n \n ext_lang_type_printers::ext_lang_type_printers ()\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->ops->start_type_printers != NULL)\n+      if (extlang->ops != nullptr\n+\t  && extlang->ops->start_type_printers != NULL)\n \textlang->ops->start_type_printers (extlang, this);\n     }\n }\n@@ -429,15 +396,13 @@ char *\n apply_ext_lang_type_printers (struct ext_lang_type_printers *printers,\n \t\t\t      struct type *type)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       char *result = NULL;\n       enum ext_lang_rc rc;\n \n-      if (extlang->ops->apply_type_printers == NULL)\n+      if (extlang->ops == nullptr\n+\t  || extlang->ops->apply_type_printers == NULL)\n \tcontinue;\n       rc = extlang->ops->apply_type_printers (extlang, printers, type,\n \t\t\t\t\t      &result);\n@@ -460,12 +425,10 @@ apply_ext_lang_type_printers (struct ext_lang_type_printers *printers,\n \n ext_lang_type_printers::~ext_lang_type_printers ()\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->ops->free_type_printers != NULL)\n+      if (extlang->ops != nullptr\n+\t  && extlang->ops->free_type_printers != NULL)\n \textlang->ops->free_type_printers (extlang, this);\n     }\n }\n@@ -490,14 +453,12 @@ apply_ext_lang_val_pretty_printer (struct value *val,\n \t\t\t\t   const struct value_print_options *options,\n \t\t\t\t   const struct language_defn *language)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       enum ext_lang_rc rc;\n \n-      if (extlang->ops->apply_val_pretty_printer == NULL)\n+      if (extlang->ops == nullptr\n+\t  || extlang->ops->apply_val_pretty_printer == NULL)\n \tcontinue;\n       rc = extlang->ops->apply_val_pretty_printer (extlang, val, stream,\n \t\t\t\t\t\t   recurse, options, language);\n@@ -544,14 +505,12 @@ apply_ext_lang_frame_filter (struct frame_info *frame,\n \t\t\t     struct ui_out *out,\n \t\t\t     int frame_low, int frame_high)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       enum ext_lang_bt_status status;\n \n-      if (extlang->ops->apply_frame_filter == NULL)\n+      if (extlang->ops == nullptr\n+\t  || extlang->ops->apply_frame_filter == NULL)\n \tcontinue;\n       status = extlang->ops->apply_frame_filter (extlang, frame, flags,\n \t\t\t\t\t       args_type, out,\n@@ -577,12 +536,10 @@ apply_ext_lang_frame_filter (struct frame_info *frame,\n void\n preserve_ext_lang_values (struct objfile *objfile, htab_t copied_types)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->ops->preserve_values != NULL)\n+      if (extlang->ops != nullptr\n+\t  && extlang->ops->preserve_values != NULL)\n \textlang->ops->preserve_values (extlang, objfile, copied_types);\n     }\n }\n@@ -600,12 +557,10 @@ const struct extension_language_defn *\n get_breakpoint_cond_ext_lang (struct breakpoint *b,\n \t\t\t      enum extension_language skip_lang)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->language != skip_lang\n+      if (extlang->ops != nullptr\n+\t  && extlang->language != skip_lang\n \t  && extlang->ops->breakpoint_has_cond != NULL\n \t  && extlang->ops->breakpoint_has_cond (extlang, b))\n \treturn extlang;\n@@ -620,18 +575,17 @@ get_breakpoint_cond_ext_lang (struct breakpoint *b,\n int\n breakpoint_ext_lang_cond_says_stop (struct breakpoint *b)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n   enum ext_lang_bp_stop stop = EXT_LANG_BP_STOP_UNSET;\n \n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       /* There is a rule that a breakpoint can have at most one of any of a\n \t CLI or extension language condition.  However, Python hacks in \"finish\n \t breakpoints\" on top of the \"stop\" check, so we have to call this for\n \t every language, even if we could first determine whether a \"stop\"\n \t method exists.  */\n-      if (extlang->ops->breakpoint_cond_says_stop != NULL)\n+      if (extlang->ops != nullptr\n+\t  && extlang->ops->breakpoint_cond_says_stop != NULL)\n \t{\n \t  enum ext_lang_bp_stop this_stop\n \t    = extlang->ops->breakpoint_cond_says_stop (extlang, b);\n@@ -813,12 +767,12 @@ set_quit_flag (void)\n int\n check_quit_flag (void)\n {\n-  int i, result = 0;\n-  const struct extension_language_defn *extlang;\n+  int result = 0;\n \n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->ops->check_quit_flag != NULL)\n+      if (extlang->ops != nullptr\n+\t  && extlang->ops->check_quit_flag != NULL)\n \tif (extlang->ops->check_quit_flag (extlang) != 0)\n \t  result = 1;\n     }\n@@ -843,16 +797,14 @@ void\n get_matching_xmethod_workers (struct type *type, const char *method_name,\n \t\t\t      std::vector<xmethod_worker_up> *workers)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       enum ext_lang_rc rc;\n \n       /* If an extension language does not support xmethods, ignore\n \t it.  */\n-      if (extlang->ops->get_matching_xmethod_workers == NULL)\n+      if (extlang->ops == nullptr\n+\t  || extlang->ops->get_matching_xmethod_workers == NULL)\n \tcontinue;\n \n       rc = extlang->ops->get_matching_xmethod_workers (extlang,\n@@ -901,13 +853,12 @@ xmethod_worker::get_result_type (value *object, gdb::array_view<value *> args)\n gdb::optional<std::string>\n ext_lang_colorize (const std::string &filename, const std::string &contents)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n   gdb::optional<std::string> result;\n \n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n-      if (extlang->ops->colorize == nullptr)\n+      if (extlang->ops == nullptr\n+\t  || extlang->ops->colorize == nullptr)\n \tcontinue;\n       result = extlang->ops->colorize (filename, contents);\n       if (result.has_value ())\n@@ -925,14 +876,12 @@ ext_lang_colorize (const std::string &filename, const std::string &contents)\n static void\n ext_lang_before_prompt (const char *current_gdb_prompt)\n {\n-  int i;\n-  const struct extension_language_defn *extlang;\n-\n-  ALL_ENABLED_EXTENSION_LANGUAGES (i, extlang)\n+  for (const struct extension_language_defn *extlang : extension_languages)\n     {\n       enum ext_lang_rc rc;\n \n-      if (extlang->ops->before_prompt == NULL)\n+      if (extlang->ops == nullptr\n+\t  || extlang->ops->before_prompt == NULL)\n \tcontinue;\n       rc = extlang->ops->before_prompt (extlang, current_gdb_prompt);\n       switch (rc)"
    }
  ]
}