{
  "sha": "54af62279c15ebc54ae2c72a3479193c2c2a19eb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTRhZjYyMjc5YzE1ZWJjNTRhZTJjNzJhMzQ3OTE5M2MyYzJhMTllYg==",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-07-01T04:49:33Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-07-02T00:47:09Z"
    },
    "message": "sim: m32r: reformat linux traps code\n\nDo this as a sep commit to try and make the history easier to review.",
    "tree": {
      "sha": "950e5dd15ee3fb45d2f9d3298b1605c782d8d989",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/950e5dd15ee3fb45d2f9d3298b1605c782d8d989"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/54af62279c15ebc54ae2c72a3479193c2c2a19eb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/54af62279c15ebc54ae2c72a3479193c2c2a19eb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/54af62279c15ebc54ae2c72a3479193c2c2a19eb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/54af62279c15ebc54ae2c72a3479193c2c2a19eb/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fe41f7211abb7d50c172588fa0d5e45feb067590",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe41f7211abb7d50c172588fa0d5e45feb067590",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fe41f7211abb7d50c172588fa0d5e45feb067590"
    }
  ],
  "stats": {
    "total": 2134,
    "additions": 1067,
    "deletions": 1067
  },
  "files": [
    {
      "sha": "f308b58e5108b05443868483af3312e98b61aa70",
      "filename": "sim/m32r/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/54af62279c15ebc54ae2c72a3479193c2c2a19eb/sim/m32r/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/54af62279c15ebc54ae2c72a3479193c2c2a19eb/sim/m32r/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/ChangeLog?ref=54af62279c15ebc54ae2c72a3479193c2c2a19eb",
      "patch": "@@ -1,3 +1,7 @@\n+2021-07-01  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* traps.c (m32r_trap): Reformat indentation to GNU style.\n+\n 2021-07-01  Mike Frysinger  <vapier@gentoo.org>\n \n \t* Makefile.in (TRAPS_OBJ, SIM_EXTRA_CFLAGS): Delete."
    },
    {
      "sha": "b9912f95106e0218d3c82e011188bde807bdf73d",
      "filename": "sim/m32r/traps.c",
      "status": "modified",
      "additions": 1063,
      "deletions": 1067,
      "changes": 2130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/54af62279c15ebc54ae2c72a3479193c2c2a19eb/sim/m32r/traps.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/54af62279c15ebc54ae2c72a3479193c2c2a19eb/sim/m32r/traps.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/traps.c?ref=54af62279c15ebc54ae2c72a3479193c2c2a19eb",
      "patch": "@@ -206,8 +206,8 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n     case TRAP_LINUX_SYSCALL:\n       {\n \tCB_SYSCALL s;\n-        unsigned int func, arg1, arg2, arg3, arg4, arg5, arg6, arg7;\n-        int result, result2, errcode;\n+\tunsigned int func, arg1, arg2, arg3, arg4, arg5, arg6, arg7;\n+\tint result, result2, errcode;\n \n \tif (STATE_ENVIRONMENT (sd) != USER_ENVIRONMENT)\n \t  goto case_default;\n@@ -221,1088 +221,1084 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n \targ6 = m32rbf_h_gr_get (current_cpu, 5);\n \targ7 = m32rbf_h_gr_get (current_cpu, 6);\n \n-        CB_SYSCALL_INIT (&s);\n-        s.func = func;\n-        s.arg1 = arg1;\n-        s.arg2 = arg2;\n-        s.arg3 = arg3;\n-        s.arg4 = arg4;\n-        s.arg5 = arg5;\n-        s.arg6 = arg6;\n-        s.arg7 = arg7;\n-\n-        s.p1 = (PTR) sd;\n-        s.p2 = (PTR) current_cpu;\n-        s.read_mem = sim_syscall_read_mem;\n-        s.write_mem = sim_syscall_write_mem;\n-\n-        result = 0;\n-        result2 = 0;\n-        errcode = 0;\n-\n-        switch (func)\n-          {\n-          case TARGET_LINUX_SYS_exit:\n+\tCB_SYSCALL_INIT (&s);\n+\ts.func = func;\n+\ts.arg1 = arg1;\n+\ts.arg2 = arg2;\n+\ts.arg3 = arg3;\n+\ts.arg4 = arg4;\n+\ts.arg5 = arg5;\n+\ts.arg6 = arg6;\n+\ts.arg7 = arg7;\n+\n+\ts.p1 = (PTR) sd;\n+\ts.p2 = (PTR) current_cpu;\n+\ts.read_mem = sim_syscall_read_mem;\n+\ts.write_mem = sim_syscall_write_mem;\n+\n+\tresult = 0;\n+\tresult2 = 0;\n+\terrcode = 0;\n+\n+\tswitch (func)\n+\t  {\n+\t  case TARGET_LINUX_SYS_exit:\n \t    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, arg1);\n-            break;\n-\n-          case TARGET_LINUX_SYS_read:\n-            result = read(arg1, t2h_addr(cb, &s, arg2), arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_write:\n-            result = write(arg1, t2h_addr(cb, &s, arg2), arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_open:\n-            result = open((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_close:\n-            result = close(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_creat:\n-            result = creat((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_link:\n-            result = link((char *) t2h_addr(cb, &s, arg1),\n-                          (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_unlink:\n-            result = unlink((char *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_chdir:\n-            result = chdir((char *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_time:\n-            {\n-              time_t t;\n-\n-              if (arg1 == 0)\n-                {\n-                  result = (int) time(NULL);\n-                  errcode = errno;\n-                }\n-              else\n-                {\n-                  result = (int) time(&t);\n-                  errcode = errno;\n-\n-                  if (result != 0)\n-                    break;\n-\n-                  t = H2T_4 (t);\n-                  if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t)) != sizeof(t))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mknod:\n-            result = mknod((char *) t2h_addr(cb, &s, arg1),\n-                           (mode_t) arg2, (dev_t) arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_chmod:\n-            result = chmod((char *) t2h_addr(cb, &s, arg1), (mode_t) arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_lchown32:\n-          case TARGET_LINUX_SYS_lchown:\n-            result = lchown((char *) t2h_addr(cb, &s, arg1),\n-                            (uid_t) arg2, (gid_t) arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_lseek:\n-            result = (int) lseek(arg1, (off_t) arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getpid:\n-            result = getpid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getuid32:\n-          case TARGET_LINUX_SYS_getuid:\n-            result = getuid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_utime:\n-            {\n-              struct utimbuf buf;\n-\n-              if (arg2 == 0)\n-                {\n-                  result = utime((char *) t2h_addr(cb, &s, arg1), NULL);\n-                  errcode = errno;\n-                }\n-              else\n-                {\n-                  buf = *((struct utimbuf *) t2h_addr(cb, &s, arg2));\n-                  translate_endian_t2h (&buf, sizeof(buf));\n-                  result = utime((char *) t2h_addr(cb, &s, arg1), &buf);\n-                  errcode = errno;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_access:\n-            result = access((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_ftime:\n-            {\n-              struct timeb t;\n-\n-              result = ftime(&t);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              t.time = H2T_4 (t.time);\n-              t.millitm = H2T_2 (t.millitm);\n-              t.timezone = H2T_2 (t.timezone);\n-              t.dstflag = H2T_2 (t.dstflag);\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t))\n-                  != sizeof(t))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-\n-          case TARGET_LINUX_SYS_sync:\n-            sync();\n-            result = 0;\n-            break;\n-\n-          case TARGET_LINUX_SYS_rename:\n-            result = rename((char *) t2h_addr(cb, &s, arg1),\n-                            (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_mkdir:\n-            result = mkdir((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_rmdir:\n-            result = rmdir((char *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_dup:\n-            result = dup(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_brk:\n-            result = brk((void *) arg1);\n-            errcode = errno;\n-            //result = arg1;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getgid32:\n-          case TARGET_LINUX_SYS_getgid:\n-            result = getgid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_geteuid32:\n-          case TARGET_LINUX_SYS_geteuid:\n-            result = geteuid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getegid32:\n-          case TARGET_LINUX_SYS_getegid:\n-            result = getegid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_ioctl:\n-            result = ioctl(arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fcntl:\n-            result = fcntl(arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_dup2:\n-            result = dup2(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getppid:\n-            result = getppid();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getpgrp:\n-            result = getpgrp();\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getrlimit:\n-            {\n-              struct rlimit rlim;\n-\n-              result = getrlimit(arg1, &rlim);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&rlim, sizeof(rlim));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &rlim, sizeof(rlim))\n-                  != sizeof(rlim))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getrusage:\n-            {\n-              struct rusage usage;\n-\n-              result = getrusage(arg1, &usage);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&usage, sizeof(usage));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &usage, sizeof(usage))\n-                  != sizeof(usage))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_gettimeofday:\n-            {\n-              struct timeval tv;\n-              struct timezone tz;\n-              \n-              result = gettimeofday(&tv, &tz);\n-              errcode = errno;\n-              \n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&tv, sizeof(tv));\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &tv, sizeof(tv))\n-                  != sizeof(tv))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-\n-              translate_endian_h2t (&tz, sizeof(tz));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &tz, sizeof(tz))\n-                  != sizeof(tz))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getgroups32:\n-          case TARGET_LINUX_SYS_getgroups:\n-            {\n-              gid_t *list;\n-\n-              if (arg1 > 0)\n-                list = (gid_t *) malloc(arg1 * sizeof(gid_t));\n-\n-              result = getgroups(arg1, list);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (list, arg1 * sizeof(gid_t));\n-              if (arg1 > 0)\n-                if ((s.write_mem) (cb, &s, arg2, (char *) list, arg1 * sizeof(gid_t))\n-                    != arg1 * sizeof(gid_t))\n-                  {\n-                    result = -1;\n-                     errcode = EINVAL;\n-                  }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_select:\n-            {\n-              int n;\n-              fd_set readfds;\n-              fd_set *treadfdsp;\n-              fd_set *hreadfdsp;\n-              fd_set writefds;\n-              fd_set *twritefdsp;\n-              fd_set *hwritefdsp;\n-              fd_set exceptfds;\n-              fd_set *texceptfdsp;\n-              fd_set *hexceptfdsp;\n-              struct timeval *ttimeoutp;\n-              struct timeval timeout;\n-              \n-              n = arg1;\n-\n-              treadfdsp = (fd_set *) arg2;\n-              if (treadfdsp != NULL)\n-                {\n-                  readfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) treadfdsp));\n-                  translate_endian_t2h (&readfds, sizeof(readfds));\n-                  hreadfdsp = &readfds;\n-                }\n-              else\n-                hreadfdsp = NULL;\n-              \n-              twritefdsp  = (fd_set *) arg3;\n-              if (twritefdsp != NULL)\n-                {\n-                  writefds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) twritefdsp));\n-                  translate_endian_t2h (&writefds, sizeof(writefds));\n-                  hwritefdsp = &writefds;\n-                }\n-              else\n-                hwritefdsp = NULL;\n-              \n-              texceptfdsp = (fd_set *) arg4;\n-              if (texceptfdsp != NULL)\n-                {\n-                  exceptfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) texceptfdsp));\n-                  translate_endian_t2h (&exceptfds, sizeof(exceptfds));\n-                  hexceptfdsp = &exceptfds;\n-                }\n-              else\n-                hexceptfdsp = NULL;\n-              \n-              ttimeoutp = (struct timeval *) arg5;\n-              timeout = *((struct timeval *) t2h_addr(cb, &s, (unsigned int) ttimeoutp));\n-              translate_endian_t2h (&timeout, sizeof(timeout));\n-\n-              result = select(n, hreadfdsp, hwritefdsp, hexceptfdsp, &timeout);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              if (treadfdsp != NULL)\n-                {\n-                  translate_endian_h2t (&readfds, sizeof(readfds));\n-                  if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,\n-                       (char *) &readfds, sizeof(readfds)) != sizeof(readfds))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-\n-              if (twritefdsp != NULL)\n-                {\n-                  translate_endian_h2t (&writefds, sizeof(writefds));\n-                  if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,\n-                       (char *) &writefds, sizeof(writefds)) != sizeof(writefds))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-\n-              if (texceptfdsp != NULL)\n-                {\n-                  translate_endian_h2t (&exceptfds, sizeof(exceptfds));\n-                  if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,\n-                       (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-\n-              translate_endian_h2t (&timeout, sizeof(timeout));\n-              if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,\n-                   (char *) &timeout, sizeof(timeout)) != sizeof(timeout))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_symlink:\n-            result = symlink((char *) t2h_addr(cb, &s, arg1),\n-                             (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_readlink:\n-            result = readlink((char *) t2h_addr(cb, &s, arg1),\n-                              (char *) t2h_addr(cb, &s, arg2),\n-                              arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_readdir:\n-            result = (int) readdir((DIR *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_read:\n+\t    result = read (arg1, t2h_addr (cb, &s, arg2), arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_write:\n+\t    result = write (arg1, t2h_addr (cb, &s, arg2), arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_open:\n+\t    result = open ((char *) t2h_addr (cb, &s, arg1), arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_close:\n+\t    result = close (arg1);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_creat:\n+\t    result = creat ((char *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_link:\n+\t    result = link ((char *) t2h_addr (cb, &s, arg1),\n+\t\t\t   (char *) t2h_addr (cb, &s, arg2));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_unlink:\n+\t    result = unlink ((char *) t2h_addr (cb, &s, arg1));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_chdir:\n+\t    result = chdir ((char *) t2h_addr (cb, &s, arg1));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_time:\n+\t    {\n+\t      time_t t;\n+\n+\t      if (arg1 == 0)\n+\t\t{\n+\t\t  result = (int) time (NULL);\n+\t\t  errcode = errno;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  result = (int) time (&t);\n+\t\t  errcode = errno;\n+\n+\t\t  if (result != 0)\n+\t\t    break;\n+\n+\t\t  t = H2T_4 (t);\n+\t\t  if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t)) != sizeof(t))\n+\t\t    {\n+\t\t      result = -1;\n+\t\t      errcode = EINVAL;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_mknod:\n+\t    result = mknod ((char *) t2h_addr (cb, &s, arg1),\n+\t\t\t    (mode_t) arg2, (dev_t) arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_chmod:\n+\t    result = chmod ((char *) t2h_addr (cb, &s, arg1), (mode_t) arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_lchown32:\n+\t  case TARGET_LINUX_SYS_lchown:\n+\t    result = lchown ((char *) t2h_addr (cb, &s, arg1),\n+\t\t\t     (uid_t) arg2, (gid_t) arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_lseek:\n+\t    result = (int) lseek (arg1, (off_t) arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getpid:\n+\t    result = getpid ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getuid32:\n+\t  case TARGET_LINUX_SYS_getuid:\n+\t    result = getuid ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_utime:\n+\t    {\n+\t      struct utimbuf buf;\n+\n+\t      if (arg2 == 0)\n+\t\t{\n+\t\t  result = utime ((char *) t2h_addr (cb, &s, arg1), NULL);\n+\t\t  errcode = errno;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  buf = *((struct utimbuf *) t2h_addr (cb, &s, arg2));\n+\t\t  translate_endian_t2h (&buf, sizeof(buf));\n+\t\t  result = utime ((char *) t2h_addr (cb, &s, arg1), &buf);\n+\t\t  errcode = errno;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_access:\n+\t    result = access ((char *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_ftime:\n+\t    {\n+\t      struct timeb t;\n+\n+\t      result = ftime (&t);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      t.time = H2T_4 (t.time);\n+\t      t.millitm = H2T_2 (t.millitm);\n+\t      t.timezone = H2T_2 (t.timezone);\n+\t      t.dstflag = H2T_2 (t.dstflag);\n+\t      if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t))\n+\t\t  != sizeof(t))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\n+\t  case TARGET_LINUX_SYS_sync:\n+\t    sync ();\n+\t    result = 0;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_rename:\n+\t    result = rename ((char *) t2h_addr (cb, &s, arg1),\n+\t\t\t     (char *) t2h_addr (cb, &s, arg2));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_mkdir:\n+\t    result = mkdir ((char *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_rmdir:\n+\t    result = rmdir ((char *) t2h_addr (cb, &s, arg1));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_dup:\n+\t    result = dup (arg1);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_brk:\n+\t    result = brk ((void *) arg1);\n+\t    errcode = errno;\n+\t    //result = arg1;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getgid32:\n+\t  case TARGET_LINUX_SYS_getgid:\n+\t    result = getgid ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_geteuid32:\n+\t  case TARGET_LINUX_SYS_geteuid:\n+\t    result = geteuid ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getegid32:\n+\t  case TARGET_LINUX_SYS_getegid:\n+\t    result = getegid ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_ioctl:\n+\t    result = ioctl (arg1, arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fcntl:\n+\t    result = fcntl (arg1, arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_dup2:\n+\t    result = dup2 (arg1, arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getppid:\n+\t    result = getppid ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getpgrp:\n+\t    result = getpgrp ();\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getrlimit:\n+\t    {\n+\t      struct rlimit rlim;\n+\n+\t      result = getrlimit (arg1, &rlim);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&rlim, sizeof(rlim));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &rlim, sizeof(rlim))\n+\t\t  != sizeof(rlim))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getrusage:\n+\t    {\n+\t      struct rusage usage;\n+\n+\t      result = getrusage (arg1, &usage);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&usage, sizeof(usage));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &usage, sizeof(usage))\n+\t\t  != sizeof(usage))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_gettimeofday:\n+\t    {\n+\t      struct timeval tv;\n+\t      struct timezone tz;\n+\n+\t      result = gettimeofday (&tv, &tz);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&tv, sizeof(tv));\n+\t      if ((s.write_mem) (cb, &s, arg1, (char *) &tv, sizeof(tv))\n+\t\t  != sizeof(tv))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\n+\t      translate_endian_h2t (&tz, sizeof(tz));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &tz, sizeof(tz))\n+\t\t  != sizeof(tz))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getgroups32:\n+\t  case TARGET_LINUX_SYS_getgroups:\n+\t    {\n+\t      gid_t *list;\n+\n+\t      if (arg1 > 0)\n+\t\tlist = (gid_t *) malloc (arg1 * sizeof(gid_t));\n+\n+\t      result = getgroups (arg1, list);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (list, arg1 * sizeof(gid_t));\n+\t      if (arg1 > 0)\n+\t\tif ((s.write_mem) (cb, &s, arg2, (char *) list, arg1 * sizeof(gid_t))\n+\t\t    != arg1 * sizeof(gid_t))\n+\t\t  {\n+\t\t    result = -1;\n+\t\t     errcode = EINVAL;\n+\t\t  }\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_select:\n+\t    {\n+\t      int n;\n+\t      fd_set readfds;\n+\t      fd_set *treadfdsp;\n+\t      fd_set *hreadfdsp;\n+\t      fd_set writefds;\n+\t      fd_set *twritefdsp;\n+\t      fd_set *hwritefdsp;\n+\t      fd_set exceptfds;\n+\t      fd_set *texceptfdsp;\n+\t      fd_set *hexceptfdsp;\n+\t      struct timeval *ttimeoutp;\n+\t      struct timeval timeout;\n+\n+\t      n = arg1;\n+\n+\t      treadfdsp = (fd_set *) arg2;\n+\t      if (treadfdsp != NULL)\n+\t\t{\n+\t\t  readfds = *((fd_set *) t2h_addr (cb, &s, (unsigned int) treadfdsp));\n+\t\t  translate_endian_t2h (&readfds, sizeof(readfds));\n+\t\t  hreadfdsp = &readfds;\n+\t\t}\n+\t      else\n+\t\threadfdsp = NULL;\n+\n+\t      twritefdsp  = (fd_set *) arg3;\n+\t      if (twritefdsp != NULL)\n+\t\t{\n+\t\t  writefds = *((fd_set *) t2h_addr (cb, &s, (unsigned int) twritefdsp));\n+\t\t  translate_endian_t2h (&writefds, sizeof(writefds));\n+\t\t  hwritefdsp = &writefds;\n+\t\t}\n+\t      else\n+\t\thwritefdsp = NULL;\n+\n+\t      texceptfdsp = (fd_set *) arg4;\n+\t      if (texceptfdsp != NULL)\n+\t\t{\n+\t\t  exceptfds = *((fd_set *) t2h_addr (cb, &s, (unsigned int) texceptfdsp));\n+\t\t  translate_endian_t2h (&exceptfds, sizeof(exceptfds));\n+\t\t  hexceptfdsp = &exceptfds;\n+\t\t}\n+\t      else\n+\t\thexceptfdsp = NULL;\n+\n+\t      ttimeoutp = (struct timeval *) arg5;\n+\t      timeout = *((struct timeval *) t2h_addr (cb, &s, (unsigned int) ttimeoutp));\n+\t      translate_endian_t2h (&timeout, sizeof(timeout));\n+\n+\t      result = select (n, hreadfdsp, hwritefdsp, hexceptfdsp, &timeout);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      if (treadfdsp != NULL)\n+\t\t{\n+\t\t  translate_endian_h2t (&readfds, sizeof(readfds));\n+\t\t  if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,\n+\t\t       (char *) &readfds, sizeof(readfds)) != sizeof(readfds))\n+\t\t    {\n+\t\t      result = -1;\n+\t\t      errcode = EINVAL;\n+\t\t    }\n+\t\t}\n+\n+\t      if (twritefdsp != NULL)\n+\t\t{\n+\t\t  translate_endian_h2t (&writefds, sizeof(writefds));\n+\t\t  if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,\n+\t\t       (char *) &writefds, sizeof(writefds)) != sizeof(writefds))\n+\t\t    {\n+\t\t      result = -1;\n+\t\t      errcode = EINVAL;\n+\t\t    }\n+\t\t}\n+\n+\t      if (texceptfdsp != NULL)\n+\t\t{\n+\t\t  translate_endian_h2t (&exceptfds, sizeof(exceptfds));\n+\t\t  if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,\n+\t\t       (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))\n+\t\t    {\n+\t\t      result = -1;\n+\t\t      errcode = EINVAL;\n+\t\t    }\n+\t\t}\n+\n+\t      translate_endian_h2t (&timeout, sizeof(timeout));\n+\t      if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,\n+\t\t   (char *) &timeout, sizeof(timeout)) != sizeof(timeout))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_symlink:\n+\t    result = symlink ((char *) t2h_addr (cb, &s, arg1),\n+\t\t\t      (char *) t2h_addr (cb, &s, arg2));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_readlink:\n+\t    result = readlink ((char *) t2h_addr (cb, &s, arg1),\n+\t\t\t       (char *) t2h_addr (cb, &s, arg2),\n+\t\t\t       arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_readdir:\n+\t    result = (int) readdir ((DIR *) t2h_addr (cb, &s, arg1));\n+\t    errcode = errno;\n+\t    break;\n \n #if 0\n-          case TARGET_LINUX_SYS_mmap:\n-            {\n-              result = (int) mmap((void *) t2h_addr(cb, &s, arg1),\n-                                  arg2, arg3, arg4, arg5, arg6);\n-              errcode = errno;\n-\n-              if (errno == 0)\n-                {\n-                  sim_core_attach (sd, NULL,\n-                                   0, access_read_write_exec, 0,\n-                                   result, arg2, 0, NULL, NULL);\n-                }\n-            }\n-            break;\n+\t  case TARGET_LINUX_SYS_mmap:\n+\t    {\n+\t      result = (int) mmap ((void *) t2h_addr (cb, &s, arg1),\n+\t\t\t\t   arg2, arg3, arg4, arg5, arg6);\n+\t      errcode = errno;\n+\n+\t      if (errno == 0)\n+\t\t{\n+\t\t  sim_core_attach (sd, NULL,\n+\t\t\t\t   0, access_read_write_exec, 0,\n+\t\t\t\t   result, arg2, 0, NULL, NULL);\n+\t\t}\n+\t    }\n+\t    break;\n #endif\n-          case TARGET_LINUX_SYS_mmap2:\n-            {\n-              void *addr;\n-              size_t len;\n-              int prot, flags, fildes;\n-              off_t off;\n-              \n-              addr   = (void *)  t2h_addr(cb, &s, arg1);\n-              len    = arg2;\n-              prot   = arg3;\n-              flags  = arg4;\n-              fildes = arg5;\n-              off    = arg6 << 12;\n-\n-\t      result = (int) mmap(addr, len, prot, flags, fildes, off);\n-              errcode = errno;\n-              if (result != -1)\n-                {\n-                  char c;\n+\t  case TARGET_LINUX_SYS_mmap2:\n+\t    {\n+\t      void *addr;\n+\t      size_t len;\n+\t      int prot, flags, fildes;\n+\t      off_t off;\n+\n+\t      addr   = (void *) t2h_addr (cb, &s, arg1);\n+\t      len    = arg2;\n+\t      prot   = arg3;\n+\t      flags  = arg4;\n+\t      fildes = arg5;\n+\t      off    = arg6 << 12;\n+\n+\t      result = (int) mmap (addr, len, prot, flags, fildes, off);\n+\t      errcode = errno;\n+\t      if (result != -1)\n+\t\t{\n+\t\t  char c;\n \t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n-                    sim_core_attach (sd, NULL,\n-                                     0, access_read_write_exec, 0,\n-                                     result, len, 0, NULL, NULL);\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mmap:\n-            {\n-              void *addr;\n-              size_t len;\n-              int prot, flags, fildes;\n-              off_t off;\n-              \n-              addr   = *((void **)  t2h_addr(cb, &s, arg1));\n-              len    = *((size_t *) t2h_addr(cb, &s, arg1 + 4));\n-              prot   = *((int *)    t2h_addr(cb, &s, arg1 + 8));\n-              flags  = *((int *)    t2h_addr(cb, &s, arg1 + 12));\n-              fildes = *((int *)    t2h_addr(cb, &s, arg1 + 16));\n-              off    = *((off_t *)  t2h_addr(cb, &s, arg1 + 20));\n-\n-              addr   = (void *) T2H_4 ((unsigned int) addr);\n-              len    = T2H_4 (len);\n-              prot   = T2H_4 (prot);\n-              flags  = T2H_4 (flags);\n-              fildes = T2H_4 (fildes);\n-              off    = T2H_4 (off);\n-\n-              //addr   = (void *) t2h_addr(cb, &s, (unsigned int) addr);\n-              result = (int) mmap(addr, len, prot, flags, fildes, off);\n-              errcode = errno;\n-\n-              //if (errno == 0)\n-              if (result != -1)\n-                {\n-                  char c;\n+\t\t    sim_core_attach (sd, NULL,\n+\t\t\t\t     0, access_read_write_exec, 0,\n+\t\t\t\t     result, len, 0, NULL, NULL);\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_mmap:\n+\t    {\n+\t      void *addr;\n+\t      size_t len;\n+\t      int prot, flags, fildes;\n+\t      off_t off;\n+\n+\t      addr   = *((void **)  t2h_addr (cb, &s, arg1));\n+\t      len    = *((size_t *) t2h_addr (cb, &s, arg1 + 4));\n+\t      prot   = *((int *)    t2h_addr (cb, &s, arg1 + 8));\n+\t      flags  = *((int *)    t2h_addr (cb, &s, arg1 + 12));\n+\t      fildes = *((int *)    t2h_addr (cb, &s, arg1 + 16));\n+\t      off    = *((off_t *)  t2h_addr (cb, &s, arg1 + 20));\n+\n+\t      addr   = (void *) T2H_4 ((unsigned int) addr);\n+\t      len    = T2H_4 (len);\n+\t      prot   = T2H_4 (prot);\n+\t      flags  = T2H_4 (flags);\n+\t      fildes = T2H_4 (fildes);\n+\t      off    = T2H_4 (off);\n+\n+\t      //addr   = (void *) t2h_addr (cb, &s, (unsigned int) addr);\n+\t      result = (int) mmap (addr, len, prot, flags, fildes, off);\n+\t      errcode = errno;\n+\n+\t      //if (errno == 0)\n+\t      if (result != -1)\n+\t\t{\n+\t\t  char c;\n \t\t  if (sim_core_read_buffer (sd, NULL, read_map, &c, result, 1) == 0)\n-                    sim_core_attach (sd, NULL,\n-                                     0, access_read_write_exec, 0,\n-                                     result, len, 0, NULL, NULL);\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_munmap:\n-            {\n-            result = munmap((void *)arg1, arg2);\n-            errcode = errno;\n-            if (result != -1)\n-              {\n-                sim_core_detach (sd, NULL, 0, arg2, result);\n-              }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_truncate:\n-            result = truncate((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_ftruncate:\n-            result = ftruncate(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fchmod:\n-            result = fchmod(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fchown32:\n-          case TARGET_LINUX_SYS_fchown:\n-            result = fchown(arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_statfs:\n-            {\n-              struct statfs statbuf;\n-\n-              result = statfs((char *) t2h_addr(cb, &s, arg1), &statbuf);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&statbuf, sizeof(statbuf));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n-                  != sizeof(statbuf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_fstatfs:\n-            {\n-              struct statfs statbuf;\n-\n-              result = fstatfs(arg1, &statbuf);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&statbuf, sizeof(statbuf));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n-                  != sizeof(statbuf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_syslog:\n-            result = syslog(arg1, (char *) t2h_addr(cb, &s, arg2));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_setitimer:\n-            {\n-              struct itimerval value, ovalue;\n-\n-              value = *((struct itimerval *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&value, sizeof(value));\n-\n-              if (arg2 == 0)\n-                {\n-                  result = setitimer(arg1, &value, NULL);\n-                  errcode = errno;\n-                }\n-              else\n-                {\n-                  result = setitimer(arg1, &value, &ovalue);\n-                  errcode = errno;\n-\n-                  if (result != 0)\n-                    break;\n-\n-                  translate_endian_h2t (&ovalue, sizeof(ovalue));\n-                  if ((s.write_mem) (cb, &s, arg3, (char *) &ovalue, sizeof(ovalue))\n-                      != sizeof(ovalue))\n-                    {\n-                      result = -1;\n-                      errcode = EINVAL;\n-                    }\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getitimer:\n-            {\n-              struct itimerval value;\n-\n-              result = getitimer(arg1, &value);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&value, sizeof(value));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &value, sizeof(value))\n-                  != sizeof(value))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_stat:\n-            {\n-              char *buf;\n-              int buflen;\n-              struct stat statbuf;\n-\n-              result = stat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n-              errcode = errno;\n-              if (result < 0)\n-                break;\n-\n-              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n-              buf = xmalloc (buflen);\n-              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n-                {\n-                  /* The translation failed.  This is due to an internal\n-                     host program error, not the target's fault.  */\n-                  free (buf);\n-                  result = -1;\n-                  errcode = ENOSYS;\n-                  break;\n-                }\n-              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n-                {\n-                  free (buf);\n-                  result = -1;\n-                  errcode = EINVAL;\n-                  break;\n-                }\n-              free (buf);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_lstat:\n-            {\n-              char *buf;\n-              int buflen;\n-              struct stat statbuf;\n-\n-              result = lstat((char *) t2h_addr(cb, &s, arg1), &statbuf);\n-              errcode = errno;\n-              if (result < 0)\n-                break;\n-\n-              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n-              buf = xmalloc (buflen);\n-              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n-                {\n-                  /* The translation failed.  This is due to an internal\n-                     host program error, not the target's fault.  */\n-                  free (buf);\n-                  result = -1;\n-                  errcode = ENOSYS;\n-                  break;\n-                }\n-              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n-                {\n-                  free (buf);\n-                  result = -1;\n-                  errcode = EINVAL;\n-                  break;\n-                }\n-              free (buf);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_fstat:\n-            {\n-              char *buf;\n-              int buflen;\n-              struct stat statbuf;\n-\n-              result = fstat(arg1, &statbuf);\n-              errcode = errno;\n-              if (result < 0)\n-                break;\n-\n-              buflen = cb_host_to_target_stat (cb, NULL, NULL);\n-              buf = xmalloc (buflen);\n-              if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n-                {\n-                  /* The translation failed.  This is due to an internal\n-                     host program error, not the target's fault.  */\n-                  free (buf);\n-                  result = -1;\n-                  errcode = ENOSYS;\n-                  break;\n-                }\n-              if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n-                {\n-                  free (buf);\n-                  result = -1;\n-                  errcode = EINVAL;\n-                  break;\n-                }\n-              free (buf);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_sysinfo:\n-            {\n-              struct sysinfo info;\n-\n-              result = sysinfo(&info);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              info.uptime    = H2T_4 (info.uptime);\n-              info.loads[0]  = H2T_4 (info.loads[0]);\n-              info.loads[1]  = H2T_4 (info.loads[1]);\n-              info.loads[2]  = H2T_4 (info.loads[2]);\n-              info.totalram  = H2T_4 (info.totalram);\n-              info.freeram   = H2T_4 (info.freeram);\n-              info.sharedram = H2T_4 (info.sharedram);\n-              info.bufferram = H2T_4 (info.bufferram);\n-              info.totalswap = H2T_4 (info.totalswap);\n-              info.freeswap  = H2T_4 (info.freeswap);\n-              info.procs     = H2T_2 (info.procs);\n+\t\t    sim_core_attach (sd, NULL,\n+\t\t\t\t     0, access_read_write_exec, 0,\n+\t\t\t\t     result, len, 0, NULL, NULL);\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_munmap:\n+\t    result = munmap ((void *)arg1, arg2);\n+\t    errcode = errno;\n+\t    if (result != -1)\n+\t      sim_core_detach (sd, NULL, 0, arg2, result);\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_truncate:\n+\t    result = truncate ((char *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_ftruncate:\n+\t    result = ftruncate (arg1, arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fchmod:\n+\t    result = fchmod (arg1, arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fchown32:\n+\t  case TARGET_LINUX_SYS_fchown:\n+\t    result = fchown (arg1, arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_statfs:\n+\t    {\n+\t      struct statfs statbuf;\n+\n+\t      result = statfs ((char *) t2h_addr (cb, &s, arg1), &statbuf);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&statbuf, sizeof(statbuf));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n+\t\t  != sizeof(statbuf))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fstatfs:\n+\t    {\n+\t      struct statfs statbuf;\n+\n+\t      result = fstatfs (arg1, &statbuf);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&statbuf, sizeof(statbuf));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n+\t\t  != sizeof(statbuf))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_syslog:\n+\t    result = syslog (arg1, (char *) t2h_addr (cb, &s, arg2));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_setitimer:\n+\t    {\n+\t      struct itimerval value, ovalue;\n+\n+\t      value = *((struct itimerval *) t2h_addr (cb, &s, arg2));\n+\t      translate_endian_t2h (&value, sizeof(value));\n+\n+\t      if (arg2 == 0)\n+\t\t{\n+\t\t  result = setitimer (arg1, &value, NULL);\n+\t\t  errcode = errno;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  result = setitimer (arg1, &value, &ovalue);\n+\t\t  errcode = errno;\n+\n+\t\t  if (result != 0)\n+\t\t    break;\n+\n+\t\t  translate_endian_h2t (&ovalue, sizeof(ovalue));\n+\t\t  if ((s.write_mem) (cb, &s, arg3, (char *) &ovalue, sizeof(ovalue))\n+\t\t      != sizeof(ovalue))\n+\t\t    {\n+\t\t      result = -1;\n+\t\t      errcode = EINVAL;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getitimer:\n+\t    {\n+\t      struct itimerval value;\n+\n+\t      result = getitimer (arg1, &value);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&value, sizeof(value));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &value, sizeof(value))\n+\t\t  != sizeof(value))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_stat:\n+\t    {\n+\t      char *buf;\n+\t      int buflen;\n+\t      struct stat statbuf;\n+\n+\t      result = stat ((char *) t2h_addr (cb, &s, arg1), &statbuf);\n+\t      errcode = errno;\n+\t      if (result < 0)\n+\t\tbreak;\n+\n+\t      buflen = cb_host_to_target_stat (cb, NULL, NULL);\n+\t      buf = xmalloc (buflen);\n+\t      if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n+\t\t{\n+\t\t  /* The translation failed.  This is due to an internal\n+\t\t     host program error, not the target's fault.  */\n+\t\t  free (buf);\n+\t\t  result = -1;\n+\t\t  errcode = ENOSYS;\n+\t\t  break;\n+\t\t}\n+\t      if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n+\t\t{\n+\t\t  free (buf);\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t  break;\n+\t\t}\n+\t      free (buf);\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_lstat:\n+\t    {\n+\t      char *buf;\n+\t      int buflen;\n+\t      struct stat statbuf;\n+\n+\t      result = lstat ((char *) t2h_addr (cb, &s, arg1), &statbuf);\n+\t      errcode = errno;\n+\t      if (result < 0)\n+\t\tbreak;\n+\n+\t      buflen = cb_host_to_target_stat (cb, NULL, NULL);\n+\t      buf = xmalloc (buflen);\n+\t      if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n+\t\t{\n+\t\t  /* The translation failed.  This is due to an internal\n+\t\t     host program error, not the target's fault.  */\n+\t\t  free (buf);\n+\t\t  result = -1;\n+\t\t  errcode = ENOSYS;\n+\t\t  break;\n+\t\t}\n+\t      if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n+\t\t{\n+\t\t  free (buf);\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t  break;\n+\t\t}\n+\t      free (buf);\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fstat:\n+\t    {\n+\t      char *buf;\n+\t      int buflen;\n+\t      struct stat statbuf;\n+\n+\t      result = fstat (arg1, &statbuf);\n+\t      errcode = errno;\n+\t      if (result < 0)\n+\t\tbreak;\n+\n+\t      buflen = cb_host_to_target_stat (cb, NULL, NULL);\n+\t      buf = xmalloc (buflen);\n+\t      if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)\n+\t\t{\n+\t\t  /* The translation failed.  This is due to an internal\n+\t\t     host program error, not the target's fault.  */\n+\t\t  free (buf);\n+\t\t  result = -1;\n+\t\t  errcode = ENOSYS;\n+\t\t  break;\n+\t\t}\n+\t      if ((s.write_mem) (cb, &s, arg2, buf, buflen) != buflen)\n+\t\t{\n+\t\t  free (buf);\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t  break;\n+\t\t}\n+\t      free (buf);\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_sysinfo:\n+\t    {\n+\t      struct sysinfo info;\n+\n+\t      result = sysinfo (&info);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      info.uptime    = H2T_4 (info.uptime);\n+\t      info.loads[0]  = H2T_4 (info.loads[0]);\n+\t      info.loads[1]  = H2T_4 (info.loads[1]);\n+\t      info.loads[2]  = H2T_4 (info.loads[2]);\n+\t      info.totalram  = H2T_4 (info.totalram);\n+\t      info.freeram   = H2T_4 (info.freeram);\n+\t      info.sharedram = H2T_4 (info.sharedram);\n+\t      info.bufferram = H2T_4 (info.bufferram);\n+\t      info.totalswap = H2T_4 (info.totalswap);\n+\t      info.freeswap  = H2T_4 (info.freeswap);\n+\t      info.procs     = H2T_2 (info.procs);\n #if LINUX_VERSION_CODE >= 0x20400\n-              info.totalhigh = H2T_4 (info.totalhigh);\n-              info.freehigh  = H2T_4 (info.freehigh);\n-              info.mem_unit  = H2T_4 (info.mem_unit);\n+\t      info.totalhigh = H2T_4 (info.totalhigh);\n+\t      info.freehigh  = H2T_4 (info.freehigh);\n+\t      info.mem_unit  = H2T_4 (info.mem_unit);\n #endif\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &info, sizeof(info))\n-                  != sizeof(info))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n+\t      if ((s.write_mem) (cb, &s, arg1, (char *) &info, sizeof(info))\n+\t\t  != sizeof(info))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n \n #if 0\n-          case TARGET_LINUX_SYS_ipc:\n-            {\n-              result = ipc(arg1, arg2, arg3, arg4,\n-                           (void *) t2h_addr(cb, &s, arg5), arg6);\n-              errcode = errno;\n-            }\n-            break;\n+\t  case TARGET_LINUX_SYS_ipc:\n+\t    {\n+\t      result = ipc (arg1, arg2, arg3, arg4,\n+\t\t\t    (void *) t2h_addr (cb, &s, arg5), arg6);\n+\t      errcode = errno;\n+\t    }\n+\t    break;\n #endif\n \n-          case TARGET_LINUX_SYS_fsync:\n-            result = fsync(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_uname:\n-            /* utsname contains only arrays of char, so it is not necessary\n-               to translate endian. */\n-            result = uname((struct utsname *) t2h_addr(cb, &s, arg1));\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_adjtimex:\n-            {\n-              struct timex buf;\n-\n-              result = adjtimex(&buf);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&buf, sizeof(buf));\n-              if ((s.write_mem) (cb, &s, arg1, (char *) &buf, sizeof(buf))\n-                  != sizeof(buf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mprotect:\n-            result = mprotect((void *) arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_fchdir:\n-            result = fchdir(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_setfsuid32:\n-          case TARGET_LINUX_SYS_setfsuid:\n-            result = setfsuid(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_setfsgid32:\n-          case TARGET_LINUX_SYS_setfsgid:\n-            result = setfsgid(arg1);\n-            errcode = errno;\n-            break;\n+\t  case TARGET_LINUX_SYS_fsync:\n+\t    result = fsync (arg1);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_uname:\n+\t    /* utsname contains only arrays of char, so it is not necessary\n+\t       to translate endian. */\n+\t    result = uname ((struct utsname *) t2h_addr (cb, &s, arg1));\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_adjtimex:\n+\t    {\n+\t      struct timex buf;\n+\n+\t      result = adjtimex (&buf);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&buf, sizeof(buf));\n+\t      if ((s.write_mem) (cb, &s, arg1, (char *) &buf, sizeof(buf))\n+\t\t  != sizeof(buf))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_mprotect:\n+\t    result = mprotect ((void *) arg1, arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fchdir:\n+\t    result = fchdir (arg1);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_setfsuid32:\n+\t  case TARGET_LINUX_SYS_setfsuid:\n+\t    result = setfsuid (arg1);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_setfsgid32:\n+\t  case TARGET_LINUX_SYS_setfsgid:\n+\t    result = setfsgid (arg1);\n+\t    errcode = errno;\n+\t    break;\n \n #if 0\n-          case TARGET_LINUX_SYS__llseek:\n-            {\n-              loff_t buf;\n-\n-              result = _llseek(arg1, arg2, arg3, &buf, arg5);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&buf, sizeof(buf));\n-              if ((s.write_mem) (cb, &s, t2h_addr(cb, &s, arg4),\n-                                 (char *) &buf, sizeof(buf)) != sizeof(buf))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getdents:\n-            {\n-              struct dirent dir;\n-\n-              result = getdents(arg1, &dir, arg3);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              dir.d_ino = H2T_4 (dir.d_ino);\n-              dir.d_off = H2T_4 (dir.d_off);\n-              dir.d_reclen = H2T_2 (dir.d_reclen);\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &dir, sizeof(dir))\n-                  != sizeof(dir))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n+\t  case TARGET_LINUX_SYS__llseek:\n+\t    {\n+\t      loff_t buf;\n+\n+\t      result = _llseek (arg1, arg2, arg3, &buf, arg5);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&buf, sizeof(buf));\n+\t      if ((s.write_mem) (cb, &s, t2h_addr (cb, &s, arg4),\n+\t\t\t\t (char *) &buf, sizeof(buf)) != sizeof(buf))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getdents:\n+\t    {\n+\t      struct dirent dir;\n+\n+\t      result = getdents (arg1, &dir, arg3);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      dir.d_ino = H2T_4 (dir.d_ino);\n+\t      dir.d_off = H2T_4 (dir.d_off);\n+\t      dir.d_reclen = H2T_2 (dir.d_reclen);\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &dir, sizeof(dir))\n+\t\t  != sizeof(dir))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n #endif\n \n-          case TARGET_LINUX_SYS_flock:\n-            result = flock(arg1, arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_msync:\n-            result = msync((void *) arg1, arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_readv:\n-            {\n-              struct iovec vector;\n-\n-              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&vector, sizeof(vector));\n-\n-              result = readv(arg1, &vector, arg3);\n-              errcode = errno;\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_writev:\n-            {\n-              struct iovec vector;\n-\n-              vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&vector, sizeof(vector));\n-\n-              result = writev(arg1, &vector, arg3);\n-              errcode = errno;\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_fdatasync:\n-            result = fdatasync(arg1);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_mlock:\n-            result = mlock((void *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_munlock:\n-            result = munlock((void *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_nanosleep:\n-            {\n-              struct timespec req, rem;\n-\n-              req = *((struct timespec *) t2h_addr(cb, &s, arg2));\n-              translate_endian_t2h (&req, sizeof(req));\n-\n-              result = nanosleep(&req, &rem);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              translate_endian_h2t (&rem, sizeof(rem));\n-              if ((s.write_mem) (cb, &s, arg2, (char *) &rem, sizeof(rem))\n-                  != sizeof(rem))\n-                {\n-                  result = -1;\n-                  errcode = EINVAL;\n-                }\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_mremap: /* FIXME */\n-            result = (int) mremap((void *) t2h_addr(cb, &s, arg1), arg2, arg3, arg4); \n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getresuid32:\n-          case TARGET_LINUX_SYS_getresuid:\n-            {\n-              uid_t ruid, euid, suid;\n-\n-              result = getresuid(&ruid, &euid, &suid);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (ruid);\n-              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (euid);\n-              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (suid);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_poll:\n-            {\n-              struct pollfd ufds;\n-\n-              ufds = *((struct pollfd *) t2h_addr(cb, &s, arg1));\n-              ufds.fd = T2H_4 (ufds.fd);\n-              ufds.events = T2H_2 (ufds.events);\n-              ufds.revents = T2H_2 (ufds.revents);\n-\n-              result = poll(&ufds, arg2, arg3);\n-              errcode = errno;\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_getresgid32:\n-          case TARGET_LINUX_SYS_getresgid:\n-            {\n-              uid_t rgid, egid, sgid;\n-\n-              result = getresgid(&rgid, &egid, &sgid);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (rgid);\n-              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (egid);\n-              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (sgid);\n-            }\n-            break;\n-\n-          case TARGET_LINUX_SYS_pread:\n-            result =  pread(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_pwrite:\n-            result =  pwrite(arg1, (void *) t2h_addr(cb, &s, arg2), arg3, arg4); \n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_chown32:\n-          case TARGET_LINUX_SYS_chown:\n-            result = chown((char *) t2h_addr(cb, &s, arg1), arg2, arg3);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_getcwd:\n-            result = (int) getcwd((char *) t2h_addr(cb, &s, arg1), arg2);\n-            errcode = errno;\n-            break;\n-\n-          case TARGET_LINUX_SYS_sendfile:\n-            {\n-              off_t offset;\n-\n-              offset = *((off_t *) t2h_addr(cb, &s, arg3));\n-              offset = T2H_4 (offset);\n-\n-              result = sendfile(arg1, arg2, &offset, arg3);\n-              errcode = errno;\n-\n-              if (result != 0)\n-                break;\n-\n-              *((off_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (offset);\n-            }\n-            break;\n-\n-          default:\n-            result = -1;\n-            errcode = ENOSYS;\n-            break;\n-          }\n-        \n-        if (result == -1)\n+\t  case TARGET_LINUX_SYS_flock:\n+\t    result = flock (arg1, arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_msync:\n+\t    result = msync ((void *) arg1, arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_readv:\n+\t    {\n+\t      struct iovec vector;\n+\n+\t      vector = *((struct iovec *) t2h_addr (cb, &s, arg2));\n+\t      translate_endian_t2h (&vector, sizeof(vector));\n+\n+\t      result = readv (arg1, &vector, arg3);\n+\t      errcode = errno;\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_writev:\n+\t    {\n+\t      struct iovec vector;\n+\n+\t      vector = *((struct iovec *) t2h_addr (cb, &s, arg2));\n+\t      translate_endian_t2h (&vector, sizeof(vector));\n+\n+\t      result = writev (arg1, &vector, arg3);\n+\t      errcode = errno;\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_fdatasync:\n+\t    result = fdatasync (arg1);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_mlock:\n+\t    result = mlock ((void *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_munlock:\n+\t    result = munlock ((void *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_nanosleep:\n+\t    {\n+\t      struct timespec req, rem;\n+\n+\t      req = *((struct timespec *) t2h_addr (cb, &s, arg2));\n+\t      translate_endian_t2h (&req, sizeof(req));\n+\n+\t      result = nanosleep (&req, &rem);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      translate_endian_h2t (&rem, sizeof(rem));\n+\t      if ((s.write_mem) (cb, &s, arg2, (char *) &rem, sizeof(rem))\n+\t\t  != sizeof(rem))\n+\t\t{\n+\t\t  result = -1;\n+\t\t  errcode = EINVAL;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_mremap: /* FIXME */\n+\t    result = (int) mremap ((void *) t2h_addr (cb, &s, arg1), arg2, arg3, arg4);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getresuid32:\n+\t  case TARGET_LINUX_SYS_getresuid:\n+\t    {\n+\t      uid_t ruid, euid, suid;\n+\n+\t      result = getresuid (&ruid, &euid, &suid);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      *((uid_t *) t2h_addr (cb, &s, arg1)) = H2T_4 (ruid);\n+\t      *((uid_t *) t2h_addr (cb, &s, arg2)) = H2T_4 (euid);\n+\t      *((uid_t *) t2h_addr (cb, &s, arg3)) = H2T_4 (suid);\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_poll:\n+\t    {\n+\t      struct pollfd ufds;\n+\n+\t      ufds = *((struct pollfd *) t2h_addr (cb, &s, arg1));\n+\t      ufds.fd = T2H_4 (ufds.fd);\n+\t      ufds.events = T2H_2 (ufds.events);\n+\t      ufds.revents = T2H_2 (ufds.revents);\n+\n+\t      result = poll (&ufds, arg2, arg3);\n+\t      errcode = errno;\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getresgid32:\n+\t  case TARGET_LINUX_SYS_getresgid:\n+\t    {\n+\t      uid_t rgid, egid, sgid;\n+\n+\t      result = getresgid (&rgid, &egid, &sgid);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      *((uid_t *) t2h_addr (cb, &s, arg1)) = H2T_4 (rgid);\n+\t      *((uid_t *) t2h_addr (cb, &s, arg2)) = H2T_4 (egid);\n+\t      *((uid_t *) t2h_addr (cb, &s, arg3)) = H2T_4 (sgid);\n+\t    }\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_pread:\n+\t    result =  pread (arg1, (void *) t2h_addr (cb, &s, arg2), arg3, arg4);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_pwrite:\n+\t    result =  pwrite (arg1, (void *) t2h_addr (cb, &s, arg2), arg3, arg4);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_chown32:\n+\t  case TARGET_LINUX_SYS_chown:\n+\t    result = chown ((char *) t2h_addr (cb, &s, arg1), arg2, arg3);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_getcwd:\n+\t    result = (int) getcwd ((char *) t2h_addr (cb, &s, arg1), arg2);\n+\t    errcode = errno;\n+\t    break;\n+\n+\t  case TARGET_LINUX_SYS_sendfile:\n+\t    {\n+\t      off_t offset;\n+\n+\t      offset = *((off_t *) t2h_addr (cb, &s, arg3));\n+\t      offset = T2H_4 (offset);\n+\n+\t      result = sendfile (arg1, arg2, &offset, arg3);\n+\t      errcode = errno;\n+\n+\t      if (result != 0)\n+\t\tbreak;\n+\n+\t      *((off_t *) t2h_addr (cb, &s, arg3)) = H2T_4 (offset);\n+\t    }\n+\t    break;\n+\n+\t  default:\n+\t    result = -1;\n+\t    errcode = ENOSYS;\n+\t    break;\n+\t  }\n+\n+\tif (result == -1)\n \t  m32rbf_h_gr_set (current_cpu, 0, -errcode);\n-        else\n+\telse\n \t  m32rbf_h_gr_set (current_cpu, 0, result);\n \tbreak;\n       }"
    }
  ]
}