{
  "sha": "08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDhiZGVmYjU4Yjc4NjIxZjUwYjMwZjY0MTcwZTJjZGMzMWMxYjJjZg==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-06-14T19:57:04Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-13T00:46:52Z"
    },
    "message": "gdb: make inferior_list use intrusive_list\n\nChange inferior_list, the global list of inferiors, to use\nintrusive_list.  I think most other changes are somewhat obvious\nfallouts from this change.\n\nThere is a small change in behavior in scoped_mock_context.  Before this\npatch, constructing a scoped_mock_context would replace the whole\ninferior list with only the new mock inferior.  Tests using two\nscoped_mock_contexts therefore needed to manually link the two inferiors\ntogether, as the second scoped_mock_context would bump the first mock\ninferior from the thread list.  With this patch, a scoped_mock_context\nadds its mock inferior to the inferior list on construction, and removes\nit on destruction.  This means that tests run with mock inferiors in the\ninferior list in addition to any pre-existing inferiors (there is always\nat least one).  There is no possible pid clash problem, since each\nscoped mock inferior uses its own process target, and pids are per\nprocess target.\n\nCo-Authored-By: Simon Marchi <simon.marchi@efficios.com>\nChange-Id: I7eb6a8f867d4dcf8b8cd2dcffd118f7270756018",
    "tree": {
      "sha": "05c3de69ddd7f935e415b7f9c88af0ef798daa91",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/05c3de69ddd7f935e415b7f9c88af0ef798daa91"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b"
    }
  ],
  "stats": {
    "total": 219,
    "additions": 103,
    "deletions": 116
  },
  "files": [
    {
      "sha": "80a72216f96ea6939edb8740a4acee09a5c092b7",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -1444,8 +1444,6 @@ ada_tasks_normal_stop_observer (struct bpstats *unused_args, int unused_args2)\n static void\n ada_tasks_new_objfile_observer (struct objfile *objfile)\n {\n-  struct inferior *inf;\n-\n   /* Invalidate the relevant data in our program-space data.  */\n \n   if (objfile == NULL)\n@@ -1468,7 +1466,7 @@ ada_tasks_new_objfile_observer (struct objfile *objfile)\n      If all objfiles are being cleared (OBJFILE is NULL), then\n      clear the caches for all inferiors.  */\n \n-  for (inf = inferior_list; inf != NULL; inf = inf->next)\n+  for (inferior *inf : all_inferiors ())\n     if (objfile == NULL || inf->pspace == objfile->pspace)\n       ada_tasks_invalidate_inferior_data (inf);\n }"
    },
    {
      "sha": "1701465eaf83144bee42e34f338ca238d89f10fe",
      "filename": "gdb/inferior-iter.h",
      "status": "modified",
      "additions": 15,
      "deletions": 10,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/inferior-iter.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/inferior-iter.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior-iter.h?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -36,18 +36,21 @@ class all_inferiors_iterator\n   typedef int difference_type;\n \n   /* Create an iterator pointing at HEAD.  */\n-  all_inferiors_iterator (process_stratum_target *proc_target, inferior *head)\n-    : m_proc_target (proc_target)\n+  all_inferiors_iterator (process_stratum_target *proc_target,\n+\t\t\t  const intrusive_list<inferior> &list)\n+    : m_proc_target (proc_target), m_inf_iter (list.begin ())\n   {\n+    intrusive_list<inferior>::iterator end;\n+\n     /* Advance M_INF to the first inferior's position.  */\n-    for (m_inf = head; m_inf != NULL; m_inf = m_inf->next)\n+    for (; m_inf_iter != end; ++m_inf_iter)\n       if (m_inf_matches ())\n \treturn;\n   }\n \n   /* Create a one-past-end iterator.  */\n   all_inferiors_iterator ()\n-    : m_proc_target (nullptr), m_inf (nullptr)\n+    : m_proc_target (nullptr)\n   {}\n \n   all_inferiors_iterator &operator++ ()\n@@ -57,37 +60,39 @@ class all_inferiors_iterator\n   }\n \n   inferior *operator* () const\n-  { return m_inf; }\n+  { return &*m_inf_iter; }\n \n   bool operator!= (const all_inferiors_iterator &other) const\n-  { return m_inf != other.m_inf; }\n+  { return m_inf_iter != other.m_inf_iter; }\n \n private:\n   /* Advance to next inferior, skipping filtered inferiors.  */\n   void advance ()\n   {\n+    intrusive_list<inferior>::iterator end;\n+\n     /* The loop below is written in the natural way as-if we'd always\n        start at the beginning of the inferior list.  This\n        fast-forwards the algorithm to the actual current position.  */\n     goto start;\n \n-    while (m_inf != NULL)\n+    while (m_inf_iter != end)\n       {\n \tif (m_inf_matches ())\n \t  return;\n       start:\n-\tm_inf = m_inf->next;\n+\t++m_inf_iter;\n       }\n   }\n \n   bool m_inf_matches ()\n   {\n     return (m_proc_target == nullptr\n-\t    || m_proc_target == m_inf->process_target ());\n+\t    || m_proc_target == m_inf_iter->process_target ());\n   }\n \n   process_stratum_target *m_proc_target;\n-  inferior *m_inf;\n+  intrusive_list<inferior>::iterator m_inf_iter;\n };\n \n /* A range adapter that makes it possible to iterate over all"
    },
    {
      "sha": "9681aaf2cdb48249fb0aa2fd7b4476b2ed6aa302",
      "filename": "gdb/inferior.c",
      "status": "modified",
      "additions": 12,
      "deletions": 51,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -41,7 +41,7 @@\n \n DEFINE_REGISTRY (inferior, REGISTRY_ACCESS_FIELD)\n \n-struct inferior *inferior_list = NULL;\n+intrusive_list<inferior> inferior_list;\n static int highest_inferior_num;\n \n /* See inferior.h.  */\n@@ -126,16 +126,7 @@ add_inferior_silent (int pid)\n {\n   inferior *inf = new inferior (pid);\n \n-  if (inferior_list == NULL)\n-    inferior_list = inf;\n-  else\n-    {\n-      inferior *last;\n-\n-      for (last = inferior_list; last->next != NULL; last = last->next)\n-\t;\n-      last->next = inf;\n-    }\n+  inferior_list.push_back (*inf);\n \n   gdb::observers::inferior_added.notify (inf);\n \n@@ -177,25 +168,12 @@ inferior::clear_thread_list (bool silent)\n }\n \n void\n-delete_inferior (struct inferior *todel)\n+delete_inferior (struct inferior *inf)\n {\n-  struct inferior *inf, *infprev;\n-\n-  infprev = NULL;\n-\n-  for (inf = inferior_list; inf; infprev = inf, inf = inf->next)\n-    if (inf == todel)\n-      break;\n-\n-  if (!inf)\n-    return;\n-\n   inf->clear_thread_list (true);\n \n-  if (infprev)\n-    infprev->next = inf->next;\n-  else\n-    inferior_list = inf->next;\n+  auto it = inferior_list.iterator_to (*inf);\n+  inferior_list.erase (it);\n \n   gdb::observers::inferior_removed.notify (inf);\n \n@@ -210,17 +188,8 @@ delete_inferior (struct inferior *todel)\n    exit of its threads.  */\n \n static void\n-exit_inferior_1 (struct inferior *inftoex, int silent)\n+exit_inferior_1 (struct inferior *inf, int silent)\n {\n-  struct inferior *inf;\n-\n-  for (inf = inferior_list; inf; inf = inf->next)\n-    if (inf == inftoex)\n-      break;\n-\n-  if (!inf)\n-    return;\n-\n   inf->clear_thread_list (silent);\n \n   gdb::observers::inferior_exit.notify (inf);\n@@ -388,22 +357,14 @@ have_live_inferiors (void)\n void\n prune_inferiors (void)\n {\n-  inferior *ss;\n-\n-  ss = inferior_list;\n-  while (ss)\n+  for (inferior *inf : all_inferiors_safe ())\n     {\n-      if (!ss->deletable ()\n-\t  || !ss->removable\n-\t  || ss->pid != 0)\n-\t{\n-\t  ss = ss->next;\n-\t  continue;\n-\t}\n+      if (!inf->deletable ()\n+\t  || !inf->removable\n+\t  || inf->pid != 0)\n+\tcontinue;\n \n-      inferior *ss_next = ss->next;\n-      delete_inferior (ss);\n-      ss = ss_next;\n+      delete_inferior (inf);\n     }\n }\n "
    },
    {
      "sha": "830dec3ebbaa58dc0a7cfbb92ce92847189b9aef",
      "filename": "gdb/inferior.h",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.h?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -55,6 +55,7 @@ struct thread_info;\n #include \"gdbsupport/refcounted-object.h\"\n #include \"gdbsupport/forward-scope-exit.h\"\n #include \"gdbsupport/gdb_unique_ptr.h\"\n+#include \"gdbsupport/intrusive_list.h\"\n \n #include \"gdbsupport/common-inferior.h\"\n #include \"gdbthread.h\"\n@@ -339,7 +340,8 @@ extern void switch_to_inferior_no_thread (inferior *inf);\n    listed exactly once in the inferior list, so placing an inferior in\n    the inferior list is an implicit, not counted strong reference.  */\n \n-class inferior : public refcounted_object\n+class inferior : public refcounted_object,\n+\t\t public intrusive_list_node<inferior>\n {\n public:\n   explicit inferior (int pid);\n@@ -387,9 +389,6 @@ class inferior : public refcounted_object\n   bool has_execution ()\n   { return target_has_execution (this); }\n \n-  /* Pointer to next inferior in singly-linked list of inferiors.  */\n-  struct inferior *next = NULL;\n-\n   /* This inferior's thread list, sorted by creation order.  */\n   intrusive_list<thread_info> thread_list;\n \n@@ -653,7 +652,7 @@ class scoped_restore_current_inferior\n \n /* Traverse all inferiors.  */\n \n-extern struct inferior *inferior_list;\n+extern intrusive_list<inferior> inferior_list;\n \n /* Pull in the internals of the inferiors ranges and iterators.  Must\n    be done after struct inferior is defined.  */"
    },
    {
      "sha": "300d62736701c4d14f256fd6d89f9350cc42809a",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 19,
      "deletions": 11,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -3730,18 +3730,28 @@ do_target_wait (execution_control_state *ecs, target_wait_flags options)\n      reported the stop to the user, polling for events.  */\n   scoped_restore_current_thread restore_thread;\n \n-  int inf_num = selected->num;\n-  for (inferior *inf = selected; inf != NULL; inf = inf->next)\n-    if (inferior_matches (inf))\n-      if (do_wait (inf))\n+  intrusive_list_iterator<inferior> start\n+    = inferior_list.iterator_to (*selected);\n+\n+  for (intrusive_list_iterator<inferior> it = start;\n+       it != inferior_list.end ();\n+       ++it)\n+    {\n+      inferior *inf = &*it;\n+\n+      if (inferior_matches (inf) && do_wait (inf))\n \treturn true;\n+    }\n \n-  for (inferior *inf = inferior_list;\n-       inf != NULL && inf->num < inf_num;\n-       inf = inf->next)\n-    if (inferior_matches (inf))\n-      if (do_wait (inf))\n+  for (intrusive_list_iterator<inferior> it = inferior_list.begin ();\n+       it != start;\n+       ++it)\n+    {\n+      inferior *inf = &*it;\n+\n+      if (inferior_matches (inf) && do_wait (inf))\n \treturn true;\n+    }\n \n   ecs->ws.kind = TARGET_WAITKIND_IGNORE;\n   return false;\n@@ -9452,7 +9462,6 @@ infrun_thread_ptid_changed ()\n \n     scoped_mock_context<test_target_ops> target1 (arch);\n     scoped_mock_context<test_target_ops> target2 (arch);\n-    target2.mock_inferior.next = &target1.mock_inferior;\n \n     ptid_t old_ptid (111, 222);\n     ptid_t new_ptid (111, 333);\n@@ -9477,7 +9486,6 @@ infrun_thread_ptid_changed ()\n \n     scoped_mock_context<test_target_ops> target1 (arch);\n     scoped_mock_context<test_target_ops> target2 (arch);\n-    target2.mock_inferior.next = &target1.mock_inferior;\n \n     ptid_t old_ptid (111, 222);\n     ptid_t new_ptid (111, 333);"
    },
    {
      "sha": "7080bf8ee2707f0aacd3a7db6d620703e18b6ab4",
      "filename": "gdb/progspace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/progspace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/progspace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -404,7 +404,6 @@ void\n update_address_spaces (void)\n {\n   int shared_aspace = gdbarch_has_shared_address_space (target_gdbarch ());\n-  struct inferior *inf;\n \n   init_address_spaces ();\n \n@@ -423,7 +422,7 @@ update_address_spaces (void)\n \tpspace->aspace = new_address_space ();\n       }\n \n-  for (inf = inferior_list; inf; inf = inf->next)\n+  for (inferior *inf : all_inferiors ())\n     if (gdbarch_has_global_solist (target_gdbarch ()))\n       inf->aspace = maybe_new_address_space ();\n     else"
    },
    {
      "sha": "21fa25d31553eea62fbb6bb5c41931c480f325ca",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -2038,7 +2038,6 @@ regcache_thread_ptid_changed ()\n   /* Prepare two targets with one thread each, with the same ptid.  */\n   scoped_mock_context<test_target_ops> target1 (arch);\n   scoped_mock_context<test_target_ops> target2 (arch);\n-  target2.mock_inferior.next = &target1.mock_inferior;\n \n   ptid_t old_ptid (111, 222);\n   ptid_t new_ptid (111, 333);"
    },
    {
      "sha": "ba3b81ed12a5bbadc4668646de5a08d132238bf0",
      "filename": "gdb/scoped-mock-context.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/scoped-mock-context.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/scoped-mock-context.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/scoped-mock-context.h?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -44,13 +44,12 @@ struct scoped_mock_context\n \n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n-  /* Add the mock inferior to the inferior list so that look ups by\n-     target+ptid can find it.  */\n-  scoped_restore_tmpl<inferior *> restore_inferior_list\n-    {&inferior_list, &mock_inferior};\n-\n   explicit scoped_mock_context (gdbarch *gdbarch)\n   {\n+    /* Add the mock inferior to the inferior list so that look ups by\n+       target+ptid can find it.  */\n+    inferior_list.push_back (mock_inferior);\n+\n     mock_inferior.thread_list.push_back (mock_thread);\n     mock_inferior.gdbarch = gdbarch;\n     mock_inferior.aspace = mock_pspace.aspace;\n@@ -70,6 +69,7 @@ struct scoped_mock_context\n \n   ~scoped_mock_context ()\n   {\n+    inferior_list.erase (inferior_list.iterator_to (mock_inferior));\n     pop_all_targets_at_and_above (process_stratum);\n   }\n };"
    },
    {
      "sha": "31b7a36eaada1b69b4739bd4611c23ae56748c3d",
      "filename": "gdb/thread-iter.c",
      "status": "modified",
      "additions": 41,
      "deletions": 27,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/thread-iter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/thread-iter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-iter.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -26,15 +26,18 @@\n all_threads_iterator::all_threads_iterator (begin_t)\n {\n   /* Advance M_INF/M_THR to the first thread's position.  */\n-  for (m_inf = inferior_list; m_inf != NULL; m_inf = m_inf->next)\n+\n+  for (inferior &inf : inferior_list)\n     {\n-      auto thr_iter = m_inf->thread_list.begin ();\n-      if (thr_iter != m_inf->thread_list.end ())\n+      auto thr_iter = inf.thread_list.begin ();\n+      if (thr_iter != inf.thread_list.end ())\n \t{\n+\t  m_inf = &inf;\n \t  m_thr = &*thr_iter;\n \t  return;\n \t}\n     }\n+  m_inf = nullptr;\n   m_thr = nullptr;\n }\n \n@@ -43,15 +46,17 @@ all_threads_iterator::all_threads_iterator (begin_t)\n void\n all_threads_iterator::advance ()\n {\n+  intrusive_list<inferior>::iterator inf_iter (m_inf);\n   intrusive_list<thread_info>::iterator thr_iter (m_thr);\n \n   /* The loop below is written in the natural way as-if we'd always\n      start at the beginning of the inferior list.  This fast forwards\n      the algorithm to the actual current position.  */\n   goto start;\n \n-  for (; m_inf != NULL; m_inf = m_inf->next)\n+  for (; inf_iter != inferior_list.end (); ++inf_iter)\n     {\n+      m_inf = &*inf_iter;\n       thr_iter = m_inf->thread_list.begin ();\n       while (thr_iter != m_inf->thread_list.end ())\n \t{\n@@ -86,16 +91,21 @@ all_matching_threads_iterator::all_matching_threads_iterator\n   gdb_assert ((filter_target == nullptr && filter_ptid == minus_one_ptid)\n \t      || filter_target->stratum () == process_stratum);\n \n-  for (m_inf = inferior_list; m_inf != NULL; m_inf = m_inf->next)\n-    if (m_inf_matches ())\n-      for (auto thr_iter = m_inf->thread_list.begin ();\n-\t   thr_iter != m_inf->thread_list.end ();\n-\t   ++thr_iter)\n-\tif (thr_iter->ptid.matches (m_filter_ptid))\n+  for (inferior &inf : inferior_list)\n+    {\n+      m_inf = &inf;\n+      if (m_inf_matches ())\n+\tfor (auto thr_iter = m_inf->thread_list.begin ();\n+\t     thr_iter != m_inf->thread_list.end ();\n+\t     ++thr_iter)\n \t  {\n-\t    m_thr = &*thr_iter;\n-\t    return;\n+\t    if (thr_iter->ptid.matches (m_filter_ptid))\n+\t      {\n+\t\tm_thr = &*thr_iter;\n+\t\treturn;\n+\t      }\n \t  }\n+    }\n \n   m_thr = nullptr;\n }\n@@ -105,28 +115,32 @@ all_matching_threads_iterator::all_matching_threads_iterator\n void\n all_matching_threads_iterator::advance ()\n {\n+  intrusive_list<inferior>::iterator inf_iter (m_inf);\n   intrusive_list<thread_info>::iterator thr_iter (m_thr);\n \n   /* The loop below is written in the natural way as-if we'd always\n      start at the beginning of the inferior list.  This fast forwards\n      the algorithm to the actual current position.  */\n   goto start;\n \n-  for (; m_inf != NULL; m_inf = m_inf->next)\n-    if (m_inf_matches ())\n-      {\n-\tthr_iter = m_inf->thread_list.begin ();\n-\twhile (thr_iter != m_inf->thread_list.end ())\n-\t  {\n-\t    if (thr_iter->ptid.matches (m_filter_ptid))\n-\t      {\n-\t\tm_thr = &*thr_iter;\n-\t\treturn;\n-\t      }\n-\t  start:\n-\t    ++thr_iter;\n-\t  }\n-      }\n+  for (; inf_iter != inferior_list.end (); ++inf_iter)\n+    {\n+      m_inf = &*inf_iter;\n+      if (m_inf_matches ())\n+\t{\n+\t  thr_iter = m_inf->thread_list.begin ();\n+\t  while (thr_iter != m_inf->thread_list.end ())\n+\t    {\n+\t      if (thr_iter->ptid.matches (m_filter_ptid))\n+\t\t{\n+\t\t  m_thr = &*thr_iter;\n+\t\t  return;\n+\t\t}\n+\t    start:\n+\t      ++thr_iter;\n+\t    }\n+\t}\n+    }\n \n   m_thr = nullptr;\n }"
    },
    {
      "sha": "506e93cf4016593d8973c43877691b437104794d",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08bdefb58b78621f50b30f64170e2cdc31c1b2cf/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=08bdefb58b78621f50b30f64170e2cdc31c1b2cf",
      "patch": "@@ -1395,7 +1395,11 @@ show_thread_that_caused_stop (void)\n int\n show_inferior_qualified_tids (void)\n {\n-  return (inferior_list->next != NULL || inferior_list->num != 1);\n+  auto inf = inferior_list.begin ();\n+  if (inf->num != 1)\n+    return true;\n+  ++inf;\n+  return inf != inferior_list.end ();\n }\n \n /* See gdbthread.h.  */"
    }
  ]
}