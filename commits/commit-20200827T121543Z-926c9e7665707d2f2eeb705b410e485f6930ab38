{
  "sha": "926c9e7665707d2f2eeb705b410e485f6930ab38",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTI2YzllNzY2NTcwN2QyZjJlZWI3MDViNDEwZTQ4NWY2OTMwYWIzOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-27T15:45:15Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-08-27T12:15:43Z"
    },
    "message": "libctf, binutils, include, ld: gettextize and improve error handling\n\nThis commit follows on from the earlier commit \"libctf, ld, binutils:\nadd textual error/warning reporting for libctf\" and converts every error\nin libctf that was reported using ctf_dprintf to use ctf_err_warn\ninstead, gettextizing them in the process, using N_() where necessary to\navoid doing gettext calls unless an error message is actually generated,\nand rephrasing some error messages for ease of translation.\n\nThis requires a slight change in the ctf_errwarning_next API: this API\nis public but has not been in a release yet, so can still change freely.\nThe problem is that many errors are emitted at open time (whether\nopening of a CTF dict, or opening of a CTF archive): the former of these\nthrows away its incompletely-initialized ctf_file_t rather than return\nit, and the latter has no ctf_file_t at all. So errors and warnings\nemitted at open time cannot be stored in the ctf_file_t, and have to go\nelsewhere.\n\nWe put them in a static local in ctf-subr.c (which is not very\nthread-safe: a later commit will improve things here): ctf_err_warn with\na NULL fp adds to this list, and the public interface\nctf_errwarning_next with a NULL fp retrieves from it.\n\nWe need a slight exception from the usual iterator rules in this case:\nwith a NULL fp, there is nowhere to store the ECTF_NEXT_END \"error\"\nwhich signifies the end of iteration, so we add a new err parameter to\nctf_errwarning_next which is used to report such iteration-related\nerrors.  (If an fp is provided -- i.e., if not reporting open errors --\nthis is optional, but even if it's optional it's still an API change.\nThis is actually useful from a usability POV as well, since\nctf_errwarning_next is usually called when there's been an error, so\noverwriting the error code with ECTF_NEXT_END is not very helpful!\nSo, unusually, ctf_errwarning_next now uses the passed fp for its\nerror code *only* if no errp pointer is passed in, and leaves it\nuntouched otherwise.)\n\nld, objdump and readelf are adapted to call ctf_errwarning_next with a\nNULL fp to report open errors where appropriate.\n\nThe ctf_err_warn API also has to change, gaining a new error-number\nparameter which is used to add the error message corresponding to that\nerror number into the debug stream when LIBCTF_DEBUG is enabled:\nchanging this API is easy at this point since we are already touching\nall existing calls to gettextize them.  We need this because the debug\nstream should contain the errno's message, but the error reported in the\nerror/warning stream should *not*, because the caller will probably\nreport it themselves at failure time regardless, and reporting it in\nevery error message that leads up to it leads to a ridiculous chattering\non failure, which is likely to end up as ridiculous chattering on stderr\n(trimmed a bit):\n\nCTF error: `ld/testsuite/ld-ctf/A.c (0): lookup failure for type 3: flags 1: The parent CTF dictionary is unavailable'\nCTF error: `ld/testsuite/ld-ctf/A.c (0): struct/union member type hashing error during type hashing for type 80000001, kind 6: The parent CTF dictionary is unavailable'\nCTF error: `deduplicating link variable emission failed for ld/testsuite/ld-ctf/A.c: The parent CTF dictionary is unavailable'\nld/.libs/lt-ld-new: warning: CTF linking failed; output will have no CTF section: `The parent CTF dictionary is unavailable'\n\nWe only need to be told that the parent CTF dictionary is unavailable\n*once*, not over and over again!\n\nerrmsgs are still emitted on warning generation, because warnings do not\nusually lead to a failure propagated up to the caller and reported\nthere.\n\nDebug-stream messages are not translated.  If translation is turned on,\nthere will be a mixture of English and translated messages in the debug\nstream, but rather that than burden the translators with debug-only\noutput.\n\nbinutils/ChangeLog\n2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* objdump.c (dump_ctf_archive_member): Move error-\n\treporting...\n\t(dump_ctf_errs): ... into this separate function.\n\t(dump_ctf): Call it on open errors.\n\t* readelf.c (dump_ctf_archive_member): Move error-\n\treporting...\n\t(dump_ctf_errs): ... into this separate function.  Support\n\tcalls with NULL fp. Adjust for new err parameter to\n\tctf_errwarning_next.\n\t(dump_section_as_ctf): Call it on open errors.\n\ninclude/ChangeLog\n2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h (ctf_errwarning_next): New err parameter.\n\nld/ChangeLog\n2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ldlang.c (lang_ctf_errs_warnings): Support calls with NULL fp.\n\tAdjust for new err parameter to ctf_errwarning_next.  Only\n\tcheck for assertion failures when fp is non-NULL.\n\t(ldlang_open_ctf): Call it on open errors.\n\t* testsuite/ld-ctf/ctf.exp: Always use the C locale to avoid\n\tbreaking the diags tests.\n\nlibctf/ChangeLog\n2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-subr.c (open_errors): New list.\n\t(ctf_err_warn): Calls with NULL fp append to open_errors.  Add err\n\tparameter, and use it to decorate the debug stream with errmsgs.\n\t(ctf_err_warn_to_open): Splice errors from a CTF dict into the\n\topen_errors.\n\t(ctf_errwarning_next): Calls with NULL fp report from open_errors.\n\tNew err param to report iteration errors (including end-of-iteration)\n\twhen fp is NULL.\n\t(ctf_assert_fail_internal): Adjust ctf_err_warn call for new err\n\tparameter: gettextize.\n\t* ctf-impl.h (ctfo_get_vbytes): Add ctf_file_t parameter.\n\t(LCTF_VBYTES): Adjust.\n\t(ctf_err_warn_to_open): New.\n\t(ctf_err_warn): Adjust.\n\t(ctf_bundle): Used in only one place: move...\n\t* ctf-create.c: ... here.\n\t(enumcmp): Use ctf_err_warn, not ctf_dprintf, passing the err number\n\tdown as needed.  Don't emit the errmsg.  Gettextize.\n\t(membcmp): Likewise.\n\t(ctf_add_type_internal): Likewise.\n\t(ctf_write_mem): Likewise.\n\t(ctf_compress_write): Likewise.  Report errors writing the header or\n\tbody.\n\t(ctf_write): Likewise.\n\t* ctf-archive.c (ctf_arc_write_fd): Use ctf_err_warn, not\n\tctf_dprintf, and gettextize, as above.\n\t(ctf_arc_write): Likewise.\n\t(ctf_arc_bufopen): Likewise.\n\t(ctf_arc_open_internal): Likewise.\n\t* ctf-labels.c (ctf_label_iter): Likewise.\n\t* ctf-open-bfd.c (ctf_bfdclose): Likewise.\n\t(ctf_bfdopen): Likewise.\n\t(ctf_bfdopen_ctfsect): Likewise.\n\t(ctf_fdopen): Likewise.\n\t* ctf-string.c (ctf_str_write_strtab): Likewise.\n\t* ctf-types.c (ctf_type_resolve): Likewise.\n\t* ctf-open.c (get_vbytes_common): Likewise. Pass down the ctf dict.\n\t(get_vbytes_v1): Pass down the ctf dict.\n\t(get_vbytes_v2): Likewise.\n\t(flip_ctf): Likewise.\n\t(flip_types): Likewise. Use ctf_err_warn, not ctf_dprintf, and\n\tgettextize, as above.\n\t(upgrade_types_v1): Adjust calls.\n\t(init_types): Use ctf_err_warn, not ctf_dprintf, as above.\n\t(ctf_bufopen_internal): Likewise. Adjust calls. Transplant errors\n\temitted into individual dicts into the open errors if this turns\n\tout to be a failed open in the end.\n\t* ctf-dump.c (ctf_dump_format_type): Adjust ctf_err_warn for new err\n\targument.  Gettextize.  Don't emit the errmsg.\n\t(ctf_dump_funcs): Likewise.  Collapse err label into its only case.\n\t(ctf_dump_type): Likewise.\n\t* ctf-link.c (ctf_create_per_cu): Adjust ctf_err_warn for new err\n\targument.  Gettextize.  Don't emit the errmsg.\n\t(ctf_link_one_type): Likewise.\n\t(ctf_link_lazy_open): Likewise.\n\t(ctf_link_one_input_archive): Likewise.\n\t(ctf_link_deduplicating_count_inputs): Likewise.\n\t(ctf_link_deduplicating_open_inputs): Likewise.\n\t(ctf_link_deduplicating_close_inputs): Likewise.\n\t(ctf_link_deduplicating): Likewise.\n\t(ctf_link): Likewise.\n\t(ctf_link_deduplicating_per_cu): Likewise. Add some missed\n\tctf_set_errnos to obscure error cases.\n\t* ctf-dedup.c (ctf_dedup_rhash_type): Adjust ctf_err_warn for new\n\terr argument.  Gettextize.  Don't emit the errmsg.\n\t(ctf_dedup_populate_mappings): Likewise.\n\t(ctf_dedup_detect_name_ambiguity): Likewise.\n\t(ctf_dedup_init): Likewise.\n\t(ctf_dedup_multiple_input_dicts): Likewise.\n\t(ctf_dedup_conflictify_unshared): Likewise.\n\t(ctf_dedup): Likewise.\n\t(ctf_dedup_rwalk_one_output_mapping): Likewise.\n\t(ctf_dedup_id_to_target): Likewise.\n\t(ctf_dedup_emit_type): Likewise.\n\t(ctf_dedup_emit_struct_members): Likewise.\n\t(ctf_dedup_populate_type_mapping): Likewise.\n\t(ctf_dedup_populate_type_mappings): Likewise.\n\t(ctf_dedup_emit): Likewise.\n\t(ctf_dedup_hash_type): Likewise. Fix a bit of messed-up error\n\tstatus setting.\n\t(ctf_dedup_rwalk_one_output_mapping): Likewise. Don't hide\n\tunknown-type-kind messages (which signify file corruption).",
    "tree": {
      "sha": "8a0a3a001ca33b62ea9b8edd7b91cbfa12953233",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8a0a3a001ca33b62ea9b8edd7b91cbfa12953233"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/926c9e7665707d2f2eeb705b410e485f6930ab38",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/926c9e7665707d2f2eeb705b410e485f6930ab38",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/926c9e7665707d2f2eeb705b410e485f6930ab38",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/926c9e7665707d2f2eeb705b410e485f6930ab38/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "987cf30ad80c7c13f713aa8e4ca3e1dbf08e9d63",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/987cf30ad80c7c13f713aa8e4ca3e1dbf08e9d63",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/987cf30ad80c7c13f713aa8e4ca3e1dbf08e9d63"
    }
  ],
  "stats": {
    "total": 1076,
    "additions": 658,
    "deletions": 418
  },
  "files": [
    {
      "sha": "05423bd8b143ea2a64fcbd3ee799b68aa5cbb644",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -1,3 +1,16 @@\n+2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* objdump.c (dump_ctf_archive_member): Move error-\n+\treporting...\n+\t(dump_ctf_errs): ... into this separate function.\n+\t(dump_ctf): Call it on open errors.\n+\t* readelf.c (dump_ctf_archive_member): Move error-\n+\treporting...\n+\t(dump_ctf_errs): ... into this separate function.  Support\n+\tcalls with NULL fp. Adjust for new err parameter to\n+\tctf_errwarning_next.\n+\t(dump_section_as_ctf): Call it on open errors.\n+\n 2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* Makefile.am (readelf_LDADD): Move $(LIBINTL) after $(LIBCTF_NOBFD)."
    },
    {
      "sha": "c18489614168e89ed4dcfc151805bf17af789dba",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 27,
      "deletions": 15,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -4071,6 +4071,29 @@ make_ctfsect (const char *name, bfd_byte *data,\n   return ctfsect;\n }\n \n+/* Dump CTF errors/warnings.  */\n+static void\n+dump_ctf_errs (ctf_file_t *fp)\n+{\n+  ctf_next_t *it = NULL;\n+  char *errtext;\n+  int is_warning;\n+  int err;\n+\n+  /* Dump accumulated errors and warnings.  */\n+  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != NULL)\n+    {\n+      non_fatal (_(\"%s: `%s'\"), is_warning ? _(\"warning\"): _(\"error\"),\n+\t\t errtext);\n+      free (errtext);\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      non_fatal (_(\"CTF error: cannot get CTF errors: `%s'\"),\n+\t\t ctf_errmsg (err));\n+    }\n+}\n+\n /* Dump one CTF archive member.  */\n \n static int\n@@ -4081,9 +4104,6 @@ dump_ctf_archive_member (ctf_file_t *ctf, const char *name, void *arg)\n \t\t\t  \"Function objects\", \"Variables\", \"Types\", \"Strings\",\n \t\t\t  \"\"};\n   const char **thing;\n-  ctf_next_t *it = NULL;\n-  char *errtext;\n-  int is_warning;\n   size_t i;\n \n   /* Only print out the name of non-default-named archive members.\n@@ -4121,18 +4141,7 @@ dump_ctf_archive_member (ctf_file_t *ctf, const char *name, void *arg)\n \t}\n     }\n \n-  /* Dump accumulated errors and warnings.  */\n-  while ((errtext = ctf_errwarning_next (ctf, &it, &is_warning)) != NULL)\n-    {\n-      non_fatal (_(\"%s: `%s'\"), is_warning ? _(\"warning\"): _(\"error\"),\n-\t\t errtext);\n-      free (errtext);\n-    }\n-  if (ctf_errno (ctf) != ECTF_NEXT_END)\n-    {\n-      non_fatal (_(\"CTF error: cannot get CTF errors: `%s'\"),\n-\t\t ctf_errmsg (ctf_errno (ctf)));\n-    }\n+  dump_ctf_errs (ctf);\n \n   return 0;\n }\n@@ -4162,6 +4171,7 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n   ctfsect = make_ctfsect (sect_name, ctfdata, ctfsize);\n   if ((ctfa = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)\n     {\n+      dump_ctf_errs (NULL);\n       non_fatal (_(\"CTF open failure: %s\"), ctf_errmsg (err));\n       bfd_fatal (bfd_get_filename (abfd));\n     }\n@@ -4171,6 +4181,7 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n       ctfsect = make_ctfsect (parent_name, parentdata, parentsize);\n       if ((parenta = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)\n \t{\n+\t  dump_ctf_errs (NULL);\n \t  non_fatal (_(\"CTF open failure: %s\"), ctf_errmsg (err));\n \t  bfd_fatal (bfd_get_filename (abfd));\n \t}\n@@ -4185,6 +4196,7 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n      put CTFs and their parents in archives together.)  */\n   if ((parent = ctf_arc_open_by_name (lookparent, NULL, &err)) == NULL)\n     {\n+      dump_ctf_errs (NULL);\n       non_fatal (_(\"CTF open failure: %s\"), ctf_errmsg (err));\n       bfd_fatal (bfd_get_filename (abfd));\n     }"
    },
    {
      "sha": "c5796e83e1dfefa1a7a24279ce5bf8e09663ffcf",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 24,
      "deletions": 15,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -14237,6 +14237,26 @@ dump_ctf_indent_lines (ctf_sect_names_t sect ATTRIBUTE_UNUSED,\n   return new_s;\n }\n \n+/* Dump CTF errors/warnings.  */\n+static void\n+dump_ctf_errs (ctf_file_t *fp)\n+{\n+  ctf_next_t *it = NULL;\n+  char *errtext;\n+  int is_warning;\n+  int err;\n+\n+  /* Dump accumulated errors and warnings.  */\n+  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != NULL)\n+    {\n+      error (_(\"%s: `%s'\"), is_warning ? _(\"warning\"): _(\"error\"),\n+\t     errtext);\n+      free (errtext);\n+    }\n+  if (err != ECTF_NEXT_END)\n+    error (_(\"CTF error: cannot get CTF errors: `%s'\"), ctf_errmsg (err));\n+}\n+\n /* Dump one CTF archive member.  */\n \n static int\n@@ -14247,9 +14267,6 @@ dump_ctf_archive_member (ctf_file_t *ctf, const char *name, void *arg)\n \t\t\t  \"Function objects\", \"Variables\", \"Types\", \"Strings\",\n \t\t\t  \"\"};\n   const char **thing;\n-  ctf_next_t *it = NULL;\n-  char *errtext;\n-  int is_warning;\n   size_t i;\n   int err = 0;\n \n@@ -14290,18 +14307,7 @@ dump_ctf_archive_member (ctf_file_t *ctf, const char *name, void *arg)\n     }\n \n  out:\n-  /* Dump accumulated errors and warnings.  */\n-  while ((errtext = ctf_errwarning_next (ctf, &it, &is_warning)) != NULL)\n-    {\n-      error (_(\"%s: `%s'\\n\"), is_warning ? _(\"warning\"): _(\"error\"),\n-\t     errtext);\n-      free (errtext);\n-    }\n-  if (ctf_errno (ctf) != ECTF_NEXT_END)\n-    {\n-      error (_(\"CTF error: cannot get CTF errors: `%s'\\n\"),\n-\t     ctf_errmsg (ctf_errno (ctf)));\n-    }\n+  dump_ctf_errs (ctf);\n   return err;\n }\n \n@@ -14388,6 +14394,7 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n \n   if ((ctfa = ctf_arc_bufopen (&ctfsect, symsectp, strsectp, &err)) == NULL)\n     {\n+      dump_ctf_errs (NULL);\n       error (_(\"CTF open failure: %s\\n\"), ctf_errmsg (err));\n       goto fail;\n     }\n@@ -14397,6 +14404,7 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n       if ((parenta = ctf_arc_bufopen (&parentsect, symsectp, strsectp,\n \t\t\t\t      &err)) == NULL)\n \t{\n+\t  dump_ctf_errs (NULL);\n \t  error (_(\"CTF open failure: %s\\n\"), ctf_errmsg (err));\n \t  goto fail;\n \t}\n@@ -14410,6 +14418,7 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n      put CTFs and their parents in archives together.)  */\n   if ((parent = ctf_arc_open_by_name (lookparent, NULL, &err)) == NULL)\n     {\n+      dump_ctf_errs (NULL);\n       error (_(\"CTF open failure: %s\\n\"), ctf_errmsg (err));\n       goto fail;\n     }"
    },
    {
      "sha": "c53e4058c2fc665368ff1e201e55ac68f3b546d5",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -1,3 +1,7 @@\n+2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_errwarning_next): New err parameter.\n+\n 2020-08-26  Nick Clifton  <nickc@redhat.com>\n \n \tPR 26405"
    },
    {
      "sha": "3a8e942f0d812214a5e771e532d6fc7661a8aa4b",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -411,7 +411,7 @@ extern char *ctf_dump (ctf_file_t *, ctf_dump_state_t **state,\n    the error/warning list, in order of emission.  Errors and warnings are popped\n    after return: the caller must free the returned error-text pointer.  */\n extern char *ctf_errwarning_next (ctf_file_t *, ctf_next_t **,\n-\t\t\t\t  int *is_warning);\n+\t\t\t\t  int *is_warning, int *errp);\n \n extern ctf_id_t ctf_add_array (ctf_file_t *, uint32_t,\n \t\t\t       const ctf_arinfo_t *);"
    },
    {
      "sha": "4589432b81c43fe79b9625ef61ab76ae8a125623",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -1,3 +1,12 @@\n+2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ldlang.c (lang_ctf_errs_warnings): Support calls with NULL fp.\n+\tAdjust for new err parameter to ctf_errwarning_next.  Only\n+\tcheck for assertion failures when fp is non-NULL.\n+\t(ldlang_open_ctf): Call it on open errors.\n+\t* testsuite/ld-ctf/ctf.exp: Always use the C locale to avoid\n+\tbreaking the diags tests.\n+\n 2020-08-27  Jeremy Drake  <sourceware-bugzilla@jdrake.com>\n \n \tPR 19011"
    },
    {
      "sha": "dc6f1b4039901ab0481c3ee4f70a6ef7620135d9",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 36,
      "deletions": 27,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -3671,6 +3671,34 @@ open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)\n }\n \n #ifdef ENABLE_LIBCTF\n+/* Emit CTF errors and warnings.  fp can be NULL to report errors/warnings\n+   that happened specifically at CTF open time.  */\n+static void\n+lang_ctf_errs_warnings (ctf_file_t *fp)\n+{\n+  ctf_next_t *i = NULL;\n+  char *text;\n+  int is_warning;\n+  int err;\n+\n+  while ((text = ctf_errwarning_next (fp, &i, &is_warning, &err)) != NULL)\n+    {\n+      einfo (_(\"%s: `%s'\\n\"), is_warning ? _(\"CTF warning\"): _(\"CTF error\"),\n+\t     text);\n+      free (text);\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      einfo (_(\"CTF error: cannot get CTF errors: `%s'\\n\"),\n+\t     ctf_errmsg (err));\n+    }\n+\n+  /* `err' returns errors from the error/warning iterator in particular.\n+     These never assert.  But if we have an fp, that could have recorded\n+     an assertion failure: assert if it has done so.  */\n+  ASSERT (!fp || ctf_errno (fp) != ECTF_INTERNAL);\n+}\n+\n /* Open the CTF sections in the input files with libctf: if any were opened,\n    create a fake input file that we'll write the merged CTF data to later\n    on.  */\n@@ -3693,9 +3721,12 @@ ldlang_open_ctf (void)\n       if ((file->the_ctf = ctf_bfdopen (file->the_bfd, &err)) == NULL)\n \t{\n \t  if (err != ECTF_NOCTFDATA)\n-\t    einfo (_(\"%P: warning: CTF section in %pB not loaded; \"\n-\t\t     \"its types will be discarded: `%s'\\n\"), file->the_bfd,\n+\t    {\n+\t      lang_ctf_errs_warnings (NULL);\n+\t      einfo (_(\"%P: warning: CTF section in %pB not loaded; \"\n+\t\t       \"its types will be discarded: `%s'\\n\"), file->the_bfd,\n \t\t     ctf_errmsg (err));\n+\t    }\n \t  continue;\n \t}\n \n@@ -3728,29 +3759,6 @@ ldlang_open_ctf (void)\n     ctf_close (errfile->the_ctf);\n }\n \n-/* Emit CTF errors and warnings.  */\n-static void\n-lang_ctf_errs_warnings (ctf_file_t *fp)\n-{\n-  ctf_next_t *i = NULL;\n-  char *text;\n-  int is_warning;\n-\n-  while ((text = ctf_errwarning_next (fp, &i, &is_warning)) != NULL)\n-    {\n-      einfo (_(\"%s: `%s'\\n\"), is_warning ? _(\"CTF warning\"): _(\"CTF error\"),\n-\t     text);\n-      free (text);\n-    }\n-  if (ctf_errno (fp) != ECTF_NEXT_END)\n-    {\n-      einfo (_(\"CTF error: cannot get CTF errors: `%s'\\n\"),\n-\t     ctf_errmsg (ctf_errno (fp)));\n-    }\n-\n-  ASSERT (ctf_errno (fp) != ECTF_INTERNAL);\n-}\n-\n /* Merge together CTF sections.  After this, only the symtab-dependent\n    function and data object sections need adjustment.  */\n \n@@ -3804,6 +3812,7 @@ lang_merge_ctf (void)\n \n   if (ctf_link (ctf_output, flags) < 0)\n     {\n+      lang_ctf_errs_warnings (ctf_output);\n       einfo (_(\"%P: warning: CTF linking failed; \"\n \t       \"output will have no CTF section: `%s'\\n\"),\n \t     ctf_errmsg (ctf_errno (ctf_output)));\n@@ -3813,6 +3822,7 @@ lang_merge_ctf (void)\n \t  output_sect->flags |= SEC_EXCLUDE;\n \t}\n     }\n+  /* Output any lingering errors that didn't come from ctf_link.  */\n   lang_ctf_errs_warnings (ctf_output);\n }\n \n@@ -3860,6 +3870,7 @@ lang_write_ctf (int late)\n       output_sect->size = output_size;\n       output_sect->flags |= SEC_IN_MEMORY | SEC_KEEP;\n \n+      lang_ctf_errs_warnings (ctf_output);\n       if (!output_sect->contents)\n \t{\n \t  einfo (_(\"%P: warning: CTF section emission failed; \"\n@@ -3868,8 +3879,6 @@ lang_write_ctf (int late)\n \t  output_sect->size = 0;\n \t  output_sect->flags |= SEC_EXCLUDE;\n \t}\n-\n-      lang_ctf_errs_warnings (ctf_output);\n     }\n \n   /* This also closes every CTF input file used in the link.  */"
    },
    {
      "sha": "6893365f30ff326b2d73a242e84e53b5048afd46",
      "filename": "ld/testsuite/ld-ctf/ctf.exp",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/ld/testsuite/ld-ctf/ctf.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/ld/testsuite/ld-ctf/ctf.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-ctf/ctf.exp?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -28,6 +28,11 @@ if ![is_elf_format] {\n     return 0\n }\n \n+if {[info exists env(LC_ALL)]} {\n+    set old_lc_all $env(LC_ALL)\n+}\n+set env(LC_ALL) \"C\"\n+\n set ctf_test_list [lsort [glob -nocomplain $srcdir/$subdir/*.d]]\n \n foreach ctf_test $ctf_test_list {\n@@ -39,3 +44,9 @@ foreach ctf_test $ctf_test_list {\n     verbose [file rootname $ctf_test]\n     run_dump_test [file rootname $ctf_test] { { cc \"-gt -fPIC\" } }\n }\n+\n+if {[info exists old_lc_all]} {\n+    set env(LC_ALL) $old_lc_all\n+} else {\n+    unset env(LC_ALL)\n+}"
    },
    {
      "sha": "e193436eddd06f3b2372d98fcfc409409bc3a443",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 85,
      "deletions": 0,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -1,3 +1,88 @@\n+2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-subr.c (open_errors): New list.\n+\t(ctf_err_warn): Calls with NULL fp append to open_errors.  Add err\n+\tparameter, and use it to decorate the debug stream with errmsgs.\n+\t(ctf_err_warn_to_open): Splice errors from a CTF dict into the\n+\topen_errors.\n+\t(ctf_errwarning_next): Calls with NULL fp report from open_errors.\n+\tNew err param to report iteration errors (including end-of-iteration)\n+\twhen fp is NULL.\n+\t(ctf_assert_fail_internal): Adjust ctf_err_warn call for new err\n+\tparameter: gettextize.\n+\t* ctf-impl.h (ctfo_get_vbytes): Add ctf_file_t parameter.\n+\t(LCTF_VBYTES): Adjust.\n+\t(ctf_err_warn_to_open): New.\n+\t(ctf_err_warn): Adjust.\n+\t(ctf_bundle): Used in only one place: move...\n+\t* ctf-create.c: ... here.\n+\t(enumcmp): Use ctf_err_warn, not ctf_dprintf, passing the err number\n+\tdown as needed.  Don't emit the errmsg.  Gettextize.\n+\t(membcmp): Likewise.\n+\t(ctf_add_type_internal): Likewise.\n+\t(ctf_write_mem): Likewise.\n+\t(ctf_compress_write): Likewise.  Report errors writing the header or\n+\tbody.\n+\t(ctf_write): Likewise.\n+\t* ctf-archive.c (ctf_arc_write_fd): Use ctf_err_warn, not\n+\tctf_dprintf, and gettextize, as above.\n+\t(ctf_arc_write): Likewise.\n+\t(ctf_arc_bufopen): Likewise.\n+\t(ctf_arc_open_internal): Likewise.\n+\t* ctf-labels.c (ctf_label_iter): Likewise.\n+\t* ctf-open-bfd.c (ctf_bfdclose): Likewise.\n+\t(ctf_bfdopen): Likewise.\n+\t(ctf_bfdopen_ctfsect): Likewise.\n+\t(ctf_fdopen): Likewise.\n+\t* ctf-string.c (ctf_str_write_strtab): Likewise.\n+\t* ctf-types.c (ctf_type_resolve): Likewise.\n+\t* ctf-open.c (get_vbytes_common): Likewise. Pass down the ctf dict.\n+\t(get_vbytes_v1): Pass down the ctf dict.\n+\t(get_vbytes_v2): Likewise.\n+\t(flip_ctf): Likewise.\n+\t(flip_types): Likewise. Use ctf_err_warn, not ctf_dprintf, and\n+\tgettextize, as above.\n+\t(upgrade_types_v1): Adjust calls.\n+\t(init_types): Use ctf_err_warn, not ctf_dprintf, as above.\n+\t(ctf_bufopen_internal): Likewise. Adjust calls. Transplant errors\n+\temitted into individual dicts into the open errors if this turns\n+\tout to be a failed open in the end.\n+\t* ctf-dump.c (ctf_dump_format_type): Adjust ctf_err_warn for new err\n+\targument.  Gettextize.  Don't emit the errmsg.\n+\t(ctf_dump_funcs): Likewise.  Collapse err label into its only case.\n+\t(ctf_dump_type): Likewise.\n+\t* ctf-link.c (ctf_create_per_cu): Adjust ctf_err_warn for new err\n+\targument.  Gettextize.  Don't emit the errmsg.\n+\t(ctf_link_one_type): Likewise.\n+\t(ctf_link_lazy_open): Likewise.\n+\t(ctf_link_one_input_archive): Likewise.\n+\t(ctf_link_deduplicating_count_inputs): Likewise.\n+\t(ctf_link_deduplicating_open_inputs): Likewise.\n+\t(ctf_link_deduplicating_close_inputs): Likewise.\n+\t(ctf_link_deduplicating): Likewise.\n+\t(ctf_link): Likewise.\n+\t(ctf_link_deduplicating_per_cu): Likewise. Add some missed\n+\tctf_set_errnos to obscure error cases.\n+\t* ctf-dedup.c (ctf_dedup_rhash_type): Adjust ctf_err_warn for new\n+\terr argument.  Gettextize.  Don't emit the errmsg.\n+\t(ctf_dedup_populate_mappings): Likewise.\n+\t(ctf_dedup_detect_name_ambiguity): Likewise.\n+\t(ctf_dedup_init): Likewise.\n+\t(ctf_dedup_multiple_input_dicts): Likewise.\n+\t(ctf_dedup_conflictify_unshared): Likewise.\n+\t(ctf_dedup): Likewise.\n+\t(ctf_dedup_rwalk_one_output_mapping): Likewise.\n+\t(ctf_dedup_id_to_target): Likewise.\n+\t(ctf_dedup_emit_type): Likewise.\n+\t(ctf_dedup_emit_struct_members): Likewise.\n+\t(ctf_dedup_populate_type_mapping): Likewise.\n+\t(ctf_dedup_populate_type_mappings): Likewise.\n+\t(ctf_dedup_emit): Likewise.\n+\t(ctf_dedup_hash_type): Likewise. Fix a bit of messed-up error\n+\tstatus setting.\n+\t(ctf_dedup_rwalk_one_output_mapping): Likewise. Don't hide\n+\tunknown-type-kind messages (which signify file corruption).\n+\n 2020-08-27  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* configure.ac: Adjust package name to simply 'libctf': arbitrarily"
    },
    {
      "sha": "799c3fbf26c5539c69bdad3f66ac933cb4699f4b",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 33,
      "deletions": 30,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -82,19 +82,19 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n   ctf_startoffs = headersz;\n   if (lseek (fd, ctf_startoffs - 1, SEEK_SET) < 0)\n     {\n-      errmsg = \"ctf_arc_write(): cannot extend file while writing: %s\\n\";\n+      errmsg = N_(\"ctf_arc_write(): cannot extend file while writing\");\n       goto err;\n     }\n \n   if (write (fd, &dummy, 1) < 0)\n     {\n-      errmsg = \"ctf_arc_write(): cannot extend file while writing: %s\\n\";\n+      errmsg = N_(\"ctf_arc_write(): cannot extend file while writing\");\n       goto err;\n     }\n \n   if ((archdr = arc_mmap_header (fd, headersz)) == NULL)\n     {\n-      errmsg = \"ctf_arc_write(): Cannot mmap(): %s\\n\";\n+      errmsg = N_(\"ctf_arc_write(): cannot mmap\");\n       goto err;\n     }\n \n@@ -128,7 +128,7 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n   nametbl = malloc (namesz);\n   if (nametbl == NULL)\n     {\n-      errmsg = \"Error writing named CTF to archive: %s\\n\";\n+      errmsg = N_(\"ctf_arc_write(): error writing named CTF to archive\");\n       goto err_unmap;\n     }\n \n@@ -144,13 +144,13 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n       off = arc_write_one_ctf (ctf_files[i], fd, threshold);\n       if ((off < 0) && (off > -ECTF_BASE))\n \t{\n-\t  errmsg = \"ctf_arc_write(): Cannot determine file \"\n-\t    \"position while writing to archive: %s\";\n+\t  errmsg = N_(\"ctf_arc_write(): cannot determine file \"\n+\t\t      \"position while writing to archive\");\n \t  goto err_free;\n \t}\n       if (off < 0)\n \t{\n-\t  errmsg = \"ctf_arc_write(): Cannot write CTF file to archive: %s\\n\";\n+\t  errmsg = N_(\"ctf_arc_write(): cannot write CTF file to archive\");\n \t  errno = off * -1;\n \t  goto err_free;\n \t}\n@@ -171,8 +171,8 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n \n   if ((nameoffs = lseek (fd, 0, SEEK_CUR)) < 0)\n     {\n-      errmsg = \"ctf_arc_write(): Cannot get current file position \"\n-\t\"in archive: %s\\n\";\n+      errmsg = N_(\"ctf_arc_write(): cannot get current file position \"\n+\t\t  \"in archive\");\n       goto err_free;\n     }\n   archdr->ctfa_names = htole64 (nameoffs);\n@@ -182,7 +182,7 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n       ssize_t len;\n       if ((len = write (fd, np, namesz)) < 0)\n \t{\n-\t  errmsg = \"ctf_arc_write(): Cannot write name table to archive: %s\\n\";\n+\t  errmsg = N_(\"ctf_arc_write(): cannot write name table to archive\");\n \t  goto err_free;\n \t}\n       namesz -= len;\n@@ -201,8 +201,11 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n err_unmap:\n   arc_mmap_unmap (archdr, headersz, NULL);\n err:\n-  ctf_dprintf (errmsg, errno < ECTF_BASE ? strerror (errno) :\n-\t       ctf_errmsg (errno));\n+  /* We report errors into the first file in the archive, if any: if this is a\n+     zero-file archive, put it in the open-errors stream for lack of anywhere\n+     else for it to go.  */\n+  ctf_err_warn (ctf_file_cnt > 0 ? ctf_files[0] : NULL, 0, errno, \"%s\",\n+\t\tgettext (errmsg));\n   return errno;\n }\n \n@@ -213,16 +216,16 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n \n    Returns 0 on success, or an errno, or an ECTF_* value.  */\n int\n-ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n+ctf_arc_write (const char *file, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n \t       const char **names, size_t threshold)\n {\n   int err;\n   int fd;\n \n   if ((fd = open (file, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0666)) < 0)\n     {\n-      ctf_dprintf (\"ctf_arc_write(): cannot create %s: %s\\n\", file,\n-\t\t   strerror (errno));\n+      ctf_err_warn (ctf_file_cnt > 0 ? ctf_files[0] : NULL, 0, errno,\n+\t\t    _(\"ctf_arc_write(): cannot create %s\"), file);\n       return errno;\n     }\n \n@@ -231,8 +234,8 @@ ctf_arc_write (const char *file, ctf_file_t ** ctf_files, size_t ctf_file_cnt,\n     goto err_close;\n \n   if ((err = close (fd)) < 0)\n-    ctf_dprintf (\"ctf_arc_write(): Cannot close after writing to archive: \"\n-\t\t \"%s\\n\", strerror (errno));\n+    ctf_err_warn (ctf_file_cnt > 0 ? ctf_files[0] : NULL, 0, errno,\n+\t\t  _(\"ctf_arc_write(): cannot close after writing to archive\"));\n   goto err;\n \n  err_close:\n@@ -404,8 +407,7 @@ ctf_arc_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       is_archive = 0;\n       if ((fp = ctf_bufopen (ctfsect, symsect, strsect, errp)) == NULL)\n \t{\n-\t  ctf_dprintf (\"ctf_arc_bufopen(): cannot open CTF: %s\\n\",\n-\t\t       ctf_errmsg (*errp));\n+\t  ctf_err_warn (NULL, 0, *errp, _(\"ctf_arc_bufopen(): cannot open CTF\"));\n \t  return NULL;\n \t}\n     }\n@@ -426,24 +428,24 @@ ctf_arc_open_internal (const char *filename, int *errp)\n   libctf_init_debug();\n   if ((fd = open (filename, O_RDONLY)) < 0)\n     {\n-      errmsg = \"ctf_arc_open(): cannot open %s: %s\\n\";\n+      errmsg = N_(\"ctf_arc_open(): cannot open %s\");\n       goto err;\n     }\n   if (fstat (fd, &s) < 0)\n     {\n-      errmsg = \"ctf_arc_open(): cannot stat %s: %s\\n\";\n+      errmsg = N_(\"ctf_arc_open(): cannot stat %s\");\n       goto err_close;\n     }\n \n   if ((arc = arc_mmap_file (fd, s.st_size)) == NULL)\n     {\n-      errmsg = \"ctf_arc_open(): Cannot read in %s: %s\\n\";\n+      errmsg = N_(\"ctf_arc_open(): cannot read in %s\");\n       goto err_close;\n     }\n \n   if (le64toh (arc->ctfa_magic) != CTFA_MAGIC)\n     {\n-      errmsg = \"ctf_arc_open(): Invalid magic number\";\n+      errmsg = N_(\"ctf_arc_open(): %s: invalid magic number\");\n       errno = ECTF_FMT;\n       goto err_unmap;\n     }\n@@ -462,8 +464,7 @@ ctf_arc_open_internal (const char *filename, int *errp)\n err:\n   if (errp)\n     *errp = errno;\n-  ctf_dprintf (errmsg, filename, errno < ECTF_BASE ? strerror (errno) :\n-\t       ctf_errmsg (errno));\n+  ctf_err_warn (NULL, 0, errno, gettext (errmsg), filename);\n   return NULL;\n }\n \n@@ -872,7 +873,8 @@ static int arc_mmap_writeout (int fd _libctf_unused_, void *header,\n     if (msync (header, headersz, MS_ASYNC) < 0)\n     {\n       if (errmsg)\n-\t*errmsg = \"arc_mmap_writeout(): Cannot sync after writing to %s: %s\\n\";\n+\t*errmsg = N_(\"arc_mmap_writeout(): cannot sync after writing \"\n+\t\t     \"to %s: %s\");\n       return -1;\n     }\n     return 0;\n@@ -884,7 +886,8 @@ static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg)\n   if (munmap (header, headersz) < 0)\n     {\n       if (errmsg)\n-\t*errmsg = \"arc_mmap_munmap(): Cannot unmap after writing to %s: %s\\n\";\n+\t*errmsg = N_(\"arc_mmap_munmap(): cannot unmap after writing \"\n+\t\t     \"to %s: %s\");\n       return -1;\n     }\n     return 0;\n@@ -928,8 +931,8 @@ static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n   if ((lseek (fd, 0, SEEK_SET)) < 0)\n     {\n       if (errmsg)\n-\t*errmsg = \"arc_mmap_writeout(): Cannot seek while writing header to \"\n-\t  \"%s: %s\\n\";\n+\t*errmsg = N_(\"arc_mmap_writeout(): cannot seek while writing header to \"\n+\t\t     \"%s: %s\");\n       return -1;\n     }\n \n@@ -938,7 +941,7 @@ static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n       if ((len = write (fd, data, count)) < 0)\n \t{\n \t  if (errmsg)\n-\t    *errmsg = \"arc_mmap_writeout(): Cannot write header to %s: %s\\n\";\n+\t    *errmsg = N_(\"arc_mmap_writeout(): cannot write header to %s: %s\");\n \t  return len;\n \t}\n       if (len == EINTR)"
    },
    {
      "sha": "e236606a249a1a1b05497379a2be9c59a358ceb3",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 60,
      "deletions": 30,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -1596,6 +1596,13 @@ ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n   return 0;\n }\n \n+typedef struct ctf_bundle\n+{\n+  ctf_file_t *ctb_file;\t\t/* CTF container handle.  */\n+  ctf_id_t ctb_type;\t\t/* CTF type identifier.  */\n+  ctf_dtdef_t *ctb_dtd;\t\t/* CTF dynamic type definition (if any).  */\n+} ctf_bundle_t;\n+\n static int\n enumcmp (const char *name, int value, void *arg)\n {\n@@ -1604,14 +1611,15 @@ enumcmp (const char *name, int value, void *arg)\n \n   if (ctf_enum_value (ctb->ctb_file, ctb->ctb_type, name, &bvalue) < 0)\n     {\n-      ctf_dprintf (\"Conflict due to member %s iteration error: %s.\\n\", name,\n-\t\t   ctf_errmsg (ctf_errno (ctb->ctb_file)));\n+      ctf_err_warn (ctb->ctb_file, 0, 0,\n+\t\t    _(\"conflict due to enum %s iteration error\"), name);\n       return 1;\n     }\n   if (value != bvalue)\n     {\n-      ctf_dprintf (\"Conflict due to value change: %i versus %i\\n\",\n-\t\t   value, bvalue);\n+      ctf_err_warn (ctb->ctb_file, 1, ECTF_CONFLICT,\n+\t\t    _(\"conflict due to enum value change: %i versus %i\"),\n+\t\t    value, bvalue);\n       return 1;\n     }\n   return 0;\n@@ -1640,14 +1648,17 @@ membcmp (const char *name, ctf_id_t type _libctf_unused_, unsigned long offset,\n \n   if (ctf_member_info (ctb->ctb_file, ctb->ctb_type, name, &ctm) < 0)\n     {\n-      ctf_dprintf (\"Conflict due to member %s iteration error: %s.\\n\", name,\n-\t\t   ctf_errmsg (ctf_errno (ctb->ctb_file)));\n+      ctf_err_warn (ctb->ctb_file, 0, 0,\n+\t\t    _(\"conflict due to struct member %s iteration error\"),\n+\t\t    name);\n       return 1;\n     }\n   if (ctm.ctm_offset != offset)\n     {\n-      ctf_dprintf (\"Conflict due to member %s offset change: \"\n-\t\t   \"%lx versus %lx\\n\", name, ctm.ctm_offset, offset);\n+      ctf_err_warn (ctb->ctb_file, 1, ECTF_CONFLICT,\n+\t\t    _(\"conflict due to struct member %s offset change: \"\n+\t\t      \"%lx versus %lx\"),\n+\t\t    name, ctm.ctm_offset, offset);\n       return 1;\n     }\n   return 0;\n@@ -1791,8 +1802,10 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \t  || (kind != CTF_K_ENUM && kind != CTF_K_STRUCT\n \t      && kind != CTF_K_UNION))\n \t{\n-\t  ctf_dprintf (\"Conflict for type %s: kinds differ, new: %i; \"\n-\t\t       \"old (ID %lx): %i\\n\", name, kind, dst_type, dst_kind);\n+\t  ctf_err_warn (dst_fp, 1, ECTF_CONFLICT,\n+\t\t\t_(\"ctf_add_file(): conflict for type %s: \"\n+\t\t\t  \"kinds differ, new: %i; old (ID %lx): %i\"),\n+\t\t\tname, kind, dst_type, dst_kind);\n \t  return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n \t}\n     }\n@@ -1937,12 +1950,13 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \n \t  if (memcmp (&src_ar, &dst_ar, sizeof (ctf_arinfo_t)))\n \t    {\n-\t      ctf_dprintf (\"Conflict for type %s against ID %lx: \"\n-\t\t\t   \"array info differs, old %lx/%lx/%x; \"\n-\t\t\t   \"new: %lx/%lx/%x\\n\", name, dst_type,\n-\t\t\t   src_ar.ctr_contents, src_ar.ctr_index,\n-\t\t\t   src_ar.ctr_nelems, dst_ar.ctr_contents,\n-\t\t\t   dst_ar.ctr_index, dst_ar.ctr_nelems);\n+\t      ctf_err_warn (dst_fp, 1, ECTF_CONFLICT,\n+\t\t\t    _(\"conflict for type %s against ID %lx: array info \"\n+\t\t\t      \"differs, old %lx/%lx/%x; new: %lx/%lx/%x\"),\n+\t\t\t    name, dst_type, src_ar.ctr_contents,\n+\t\t\t    src_ar.ctr_index, src_ar.ctr_nelems,\n+\t\t\t    dst_ar.ctr_contents, dst_ar.ctr_index,\n+\t\t\t    dst_ar.ctr_nelems);\n \t      return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n \t    }\n \t}\n@@ -1986,18 +2000,19 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \t    if (ctf_type_size (src_fp, src_type) !=\n \t\tctf_type_size (dst_fp, dst_type))\n \t      {\n-\t\tctf_dprintf (\"Conflict for type %s against ID %lx: \"\n-\t\t\t     \"union size differs, old %li, new %li\\n\",\n-\t\t\t     name, dst_type,\n-\t\t\t     (long) ctf_type_size (src_fp, src_type),\n-\t\t\t     (long) ctf_type_size (dst_fp, dst_type));\n+\t\tctf_err_warn (dst_fp, 1, ECTF_CONFLICT,\n+\t\t\t      _(\"conflict for type %s against ID %lx: union \"\n+\t\t\t\t\"size differs, old %li, new %li\"), name,\n+\t\t\t      dst_type, (long) ctf_type_size (src_fp, src_type),\n+\t\t\t      (long) ctf_type_size (dst_fp, dst_type));\n \t\treturn (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n \t      }\n \n \t    if (ctf_member_iter (src_fp, src_type, membcmp, &dst))\n \t      {\n-\t\tctf_dprintf (\"Conflict for type %s against ID %lx: \"\n-\t\t\t     \"members differ, see above\\n\", name, dst_type);\n+\t\tctf_err_warn (dst_fp, 1, ECTF_CONFLICT,\n+\t\t\t      _(\"conflict for type %s against ID %lx: members \"\n+\t\t\t\t\"differ, see above\"), name, dst_type);\n \t\treturn (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n \t      }\n \n@@ -2076,8 +2091,9 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \t  if (ctf_enum_iter (src_fp, src_type, enumcmp, &dst)\n \t      || ctf_enum_iter (dst_fp, dst_type, enumcmp, &src))\n \t    {\n-\t      ctf_dprintf (\"Conflict for enum %s against ID %lx: \"\n-\t\t\t   \"members differ, see above\\n\", name, dst_type);\n+\t      ctf_err_warn (dst_fp, 1, ECTF_CONFLICT,\n+\t\t\t    _(\"conflict for enum %s against ID %lx: members \"\n+\t\t\t      \"differ, see above\"), name, dst_type);\n \t      return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n \t    }\n \t}\n@@ -2200,13 +2216,17 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n   compress_len = compressBound (fp->ctf_size);\n \n   if ((buf = malloc (compress_len)) == NULL)\n-    return (ctf_set_errno (fp, ECTF_ZALLOC));\n+    {\n+      ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: cannot allocate %li bytes\"),\n+\t\t    (unsigned long) compress_len);\n+      return (ctf_set_errno (fp, ECTF_ZALLOC));\n+    }\n \n   if ((rc = compress (buf, (uLongf *) &compress_len,\n \t\t      fp->ctf_buf, fp->ctf_size)) != Z_OK)\n     {\n-      ctf_dprintf (\"zlib deflate err: %s\\n\", zError (rc));\n       err = ctf_set_errno (fp, ECTF_COMPRESS);\n+      ctf_err_warn (fp, 0, 0, _(\"zlib deflate err: %s\"), zError (rc));\n       goto ret;\n     }\n \n@@ -2215,6 +2235,7 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n       if ((len = write (fd, hp, header_len)) < 0)\n \t{\n \t  err = ctf_set_errno (fp, errno);\n+\t  ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: error writing header\"));\n \t  goto ret;\n \t}\n       header_len -= len;\n@@ -2227,6 +2248,7 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n       if ((len = write (fd, bp, compress_len)) < 0)\n \t{\n \t  err = ctf_set_errno (fp, errno);\n+\t  ctf_err_warn (fp, 0, 0, _(\"ctf_compress_write: error writing\"));\n \t  goto ret;\n \t}\n       compress_len -= len;\n@@ -2260,6 +2282,8 @@ ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n \t\t     + sizeof (struct ctf_header))) == NULL)\n     {\n       ctf_set_errno (fp, ENOMEM);\n+      ctf_err_warn (fp, 0, 0, _(\"ctf_write_mem: cannot allocate %li bytes\"),\n+\t\t    (unsigned long) (compress_len + sizeof (struct ctf_header)));\n       return NULL;\n     }\n \n@@ -2280,8 +2304,8 @@ ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n       if ((rc = compress (bp, (uLongf *) &compress_len,\n \t\t\t  fp->ctf_buf, fp->ctf_size)) != Z_OK)\n \t{\n-\t  ctf_dprintf (\"zlib deflate err: %s\\n\", zError (rc));\n \t  ctf_set_errno (fp, ECTF_COMPRESS);\n+\t  ctf_err_warn (fp, 0, 0, _(\"zlib deflate err: %s\"), zError (rc));\n \t  free (buf);\n \t  return NULL;\n \t}\n@@ -2306,7 +2330,10 @@ ctf_write (ctf_file_t *fp, int fd)\n   while (resid != 0)\n     {\n       if ((len = write (fd, buf, resid)) <= 0)\n-\treturn (ctf_set_errno (fp, errno));\n+\t{\n+\t  ctf_err_warn (fp, 0, errno, _(\"ctf_write: error writing header\"));\n+\t  return (ctf_set_errno (fp, errno));\n+\t}\n       resid -= len;\n       buf += len;\n     }\n@@ -2316,7 +2343,10 @@ ctf_write (ctf_file_t *fp, int fd)\n   while (resid != 0)\n     {\n       if ((len = write (fd, buf, resid)) <= 0)\n-\treturn (ctf_set_errno (fp, errno));\n+\t{\n+\t  ctf_err_warn (fp, 0, errno, _(\"ctf_write: error writing\"));\n+\t  return (ctf_set_errno (fp, errno));\n+\t}\n       resid -= len;\n       buf += len;\n     }"
    },
    {
      "sha": "b58b815b84d38203a94394f9abf7accf58cb08e2",
      "filename": "libctf/ctf-dedup.c",
      "status": "modified",
      "additions": 144,
      "deletions": 146,
      "changes": 290,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-dedup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-dedup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dedup.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -581,7 +581,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n #define ADD_CITER(citers, hval)\t\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      whaterr = \"updating citers\";\t\t\t\t\t\\\n+      whaterr = N_(\"error updating citers\");\t\t\t\t\\\n       if (!citers)\t\t\t\t\t\t\t\\\n \tif ((citers = ctf_dynset_create (htab_hash_string,\t\t\\\n \t\t\t\t\t  ctf_dynset_eq_string,\t\t\\\n@@ -610,14 +610,13 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \n       if ((hval = intern (fp, strdup (hashbuf))) == NULL)\n \t{\n-\t  ctf_err_warn (fp, 0, \"%s (%i): out of memory during forwarding-stub \"\n-\t\t\t\"hashing for type with GID %p; errno: %s\",\n-\t\t\tctf_link_input_name (input), input_num, type_id,\n-\t\t\tstrerror (errno));\n+\t  ctf_err_warn (fp, 0, 0, _(\"%s (%i): out of memory during forwarding-\"\n+\t\t\t\t    \"stub hashing for type with GID %p\"),\n+\t\t\tctf_link_input_name (input), input_num, type_id);\n \t  return NULL;\t\t\t\t/* errno is set for us.  */\n \t}\n \n-      /* In share--duplicated link mode, make sure the origin of this type is\n+      /* In share-duplicated link mode, make sure the origin of this type is\n \t recorded, even if this is a type in a parent dict which will not be\n \t directly traversed.  */\n       if (d->cd_link_flags & CTF_LINK_SHARE_DUPLICATED\n@@ -680,7 +679,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t\t\t    depth);\n \tif (ctf_type_encoding (input, type, &ep) < 0)\n \t  {\n-\t    whaterr = \"encoding\";\n+\t    whaterr = N_(\"error getting encoding\");\n \t    goto err;\n \t  }\n \tctf_dedup_sha1_add (&hash, &ep, sizeof (ctf_encoding_t), \"encoding\",\n@@ -699,7 +698,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t\t\t\t       child_type, flags, depth,\n \t\t\t\t       populate_fun)) == NULL)\n \t{\n-\t  whaterr = \"referenced type hashing\";\n+\t  whaterr = N_(\"error doing referenced type hashing\");\n \t  goto err;\n \t}\n       ctf_dedup_sha1_add (&hash, hval, strlen (hval) + 1, \"referenced type\",\n@@ -728,7 +727,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t\t\t\t\t child_type, flags, depth,\n \t\t\t\t\t populate_fun)) == NULL)\n \t  {\n-\t    whaterr = \"slice-referenced type hashing\";\n+\t    whaterr = N_(\"error doing slice-referenced type hashing\");\n \t    goto err;\n \t  }\n \tctf_dedup_sha1_add (&hash, hval, strlen (hval) + 1, \"sliced type\",\n@@ -753,15 +752,15 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \n \tif (ctf_array_info (input, type, &ar) < 0)\n \t  {\n-\t    whaterr = \"array info\";\n+\t    whaterr = N_(\"error getting array info\");\n \t    goto err;\n \t  }\n \n \tif ((hval = ctf_dedup_hash_type (fp, input, inputs, parents, input_num,\n \t\t\t\t\t ar.ctr_contents, flags, depth,\n \t\t\t\t\t populate_fun)) == NULL)\n \t  {\n-\t    whaterr = \"array contents type hashing\";\n+\t    whaterr = N_(\"error doing array contents type hashing\");\n \t    goto err;\n \t  }\n \tctf_dedup_sha1_add (&hash, hval, strlen (hval) + 1, \"array contents\",\n@@ -772,7 +771,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t\t\t\t\t ar.ctr_index, flags, depth,\n \t\t\t\t\t populate_fun)) == NULL)\n \t  {\n-\t    whaterr = \"array index type hashing\";\n+\t    whaterr = N_(\"error doing array index type hashing\");\n \t    goto err;\n \t  }\n \tctf_dedup_sha1_add (&hash, hval, strlen (hval) + 1, \"array index\",\n@@ -791,15 +790,15 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \n \tif (ctf_func_type_info (input, type, &fi) < 0)\n \t  {\n-\t    whaterr = \"func type info\";\n+\t    whaterr = N_(\"error getting func type info\");\n \t    goto err;\n \t  }\n \n \tif ((hval = ctf_dedup_hash_type (fp, input, inputs, parents, input_num,\n \t\t\t\t\t fi.ctc_return, flags, depth,\n \t\t\t\t\t populate_fun)) == NULL)\n \t  {\n-\t    whaterr = \"func return type\";\n+\t    whaterr = N_(\"error getting func return type\");\n \t    goto err;\n \t  }\n \tctf_dedup_sha1_add (&hash, hval, strlen (hval) + 1, \"func return\",\n@@ -812,14 +811,14 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \n \tif ((args = calloc (fi.ctc_argc, sizeof (ctf_id_t))) == NULL)\n \t  {\n-\t    whaterr = \"memory allocation\";\n+\t    whaterr = N_(\"error doing memory allocation\");\n \t    goto err;\n \t  }\n \n \tif (ctf_func_type_args (input, type, fi.ctc_argc, args) < 0)\n \t  {\n \t    free (args);\n-\t    whaterr = \"func arg type\";\n+\t    whaterr = N_(\"error getting func arg type\");\n \t    goto err;\n \t  }\n \tfor (j = 0; j < fi.ctc_argc; j++)\n@@ -829,7 +828,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t\t\t\t\t     populate_fun)) == NULL)\n \t      {\n \t\tfree (args);\n-\t\twhaterr = \"func arg type hashing\";\n+\t\twhaterr = N_(\"error doing func arg type hashing\");\n \t\tgoto err;\n \t      }\n \t    ctf_dedup_sha1_add (&hash, hval, strlen (hval) + 1, \"func arg type\",\n@@ -854,7 +853,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t  }\n \tif (ctf_errno (input) != ECTF_NEXT_END)\n \t  {\n-\t    whaterr = \"enum member iteration\";\n+\t    whaterr = N_(\"error doing enum member iteration\");\n \t    goto err;\n \t  }\n \tbreak;\n@@ -887,7 +886,7 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t\t\t\t\t     input_num, membtype, flags, depth,\n \t\t\t\t\t     populate_fun)) == NULL)\n \t      {\n-\t\twhaterr = \"struct/union member type hashing\";\n+\t\twhaterr = N_(\"error doing struct/union member type hashing\");\n \t\tgoto iterr;\n \t      }\n \n@@ -899,26 +898,26 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n \t  }\n \tif (ctf_errno (input) != ECTF_NEXT_END)\n \t  {\n-\t    whaterr = \"struct/union member iteration\";\n+\t    whaterr = N_(\"error doing struct/union member iteration\");\n \t    goto err;\n \t  }\n \tbreak;\n       }\n     default:\n-      whaterr = \"unknown type kind\";\n+      whaterr = N_(\"error: unknown type kind\");\n       goto err;\n     }\n   ctf_sha1_fini (&hash, hashbuf);\n \n   if ((hval = intern (fp, strdup (hashbuf))) == NULL)\n     {\n-      whaterr = \"hash internment\";\n+      whaterr = N_(\"cannot intern hash\");\n       goto oom;\n     }\n \n   /* Populate the citers for this type's subtypes, now the hash for the type\n      itself is known.  */\n-  whaterr = \"citer tracking\";\n+  whaterr = N_(\"error tracking citers\");\n \n   if (citer)\n     {\n@@ -957,17 +956,15 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n   ctf_next_destroy (i);\n  err:\n   ctf_sha1_fini (&hash, NULL);\n-  ctf_err_warn (fp, 0, \"%s (%i): %s error during type hashing for \"\n-\t\t\"type %lx, kind %i: CTF error: %s; errno: %s\",\n-\t\tctf_link_input_name (input), input_num, whaterr, type,\n-\t\tkind, ctf_errmsg (ctf_errno (fp)), strerror (errno));\n+  ctf_err_warn (fp, 0, 0, _(\"%s (%i): %s: during type hashing for type %lx, \"\n+\t\t\t    \"kind %i\"), ctf_link_input_name (input),\n+\t\tinput_num, gettext (whaterr), type, kind);\n   return NULL;\n  oom:\n   ctf_set_errno (fp, errno);\n-  ctf_err_warn (fp, 0, \"%s (%i): %s error during type hashing for \"\n-\t\t\"type %lx, kind %i: CTF error: %s; errno: %s\",\n-\t\tctf_link_input_name (input), input_num, whaterr, type,\n-\t\tkind, ctf_errmsg (ctf_errno (fp)), strerror (errno));\n+  ctf_err_warn (fp, 0, 0, _(\"%s (%i): %s: during type hashing for type %lx, \"\n+\t\t\t    \"kind %i\"), ctf_link_input_name (input),\n+\t\tinput_num, gettext (whaterr), type, kind);\n   return NULL;\n }\n \n@@ -1034,8 +1031,10 @@ ctf_dedup_hash_type (ctf_file_t *fp, ctf_file_t *input,\n \n   if ((tp = ctf_lookup_by_id (&input, type)) == NULL)\n     {\n-      ctf_err_warn (fp, 0, \"%s (%i): lookup failure for type %lx: flags %x\",\n-\t\t    ctf_link_input_name (input), input_num, type, flags);\n+      ctf_set_errno (fp, ctf_errno (input));\n+      ctf_err_warn (fp, 0, 0, _(\"%s (%i): lookup failure for type %lx: \"\n+\t\t\t\t\"flags %x\"), ctf_link_input_name (input),\n+\t\t    input_num, type, flags);\n       return NULL;\t\t/* errno is set for us.  */\n     }\n \n@@ -1106,14 +1105,14 @@ ctf_dedup_hash_type (ctf_file_t *fp, ctf_file_t *input,\n \n       if (ctf_dynhash_cinsert (d->cd_type_hashes, type_id, hval) < 0)\n \t{\n-\t  whaterr = \"hash caching\";\n+\t  whaterr = N_(\"error hash caching\");\n \t  goto oom;\n \t}\n \n       if (populate_fun (fp, input, inputs, input_num, type, type_id,\n \t\t\tdecorated, hval) < 0)\n \t{\n-\t  whaterr = \"population function\";\n+\t  whaterr = N_(\"error calling population function\");\n \t  goto err;\t\t\t\t/* errno is set for us. */\n \t}\n     }\n@@ -1127,11 +1126,10 @@ ctf_dedup_hash_type (ctf_file_t *fp, ctf_file_t *input,\n  oom:\n   ctf_set_errno (fp, errno);\n  err:\n-  ctf_err_warn (fp, 0, \"%s (%i): %s error during type hashing, type %lx, \"\n-\t\t\"kind %i: CTF errno: %s; errno: %s\",\n-\t\tctf_link_input_name (input), input_num, whaterr, type,\n-\t\tkind, ctf_errmsg (ctf_errno (fp)),\n-\t\tstrerror (errno));\n+  ctf_err_warn (fp, 0, 0, _(\"%s (%i): %s: during type hashing, \"\n+\t\t\t    \"type %lx, kind %i\"),\n+\t\tctf_link_input_name (input), input_num,\n+\t\tgettext (whaterr), type, kind);\n   return NULL;\n }\n \n@@ -1218,7 +1216,7 @@ ctf_dedup_populate_mappings (ctf_file_t *fp, ctf_file_t *input _libctf_unused_,\n \t  ctf_id_t bar = CTF_DEDUP_GID_TO_TYPE (one_id);\n \t  if (ctf_type_kind_unsliced (foo, bar) != orig_kind)\n \t    {\n-\t      ctf_err_warn (fp, 1, \"added wrong kind to output mapping \"\n+\t      ctf_err_warn (fp, 1, 0, \"added wrong kind to output mapping \"\n \t\t\t    \"for hash %s named %s: %p/%lx from %s is \"\n \t\t\t    \"kind %i, but newly-added %p/%lx from %s is \"\n \t\t\t    \"kind %i\", hval,\n@@ -1410,7 +1408,7 @@ ctf_dedup_detect_name_ambiguity (ctf_file_t *fp, ctf_file_t **inputs)\n   void *k;\n   void *v;\n   int err;\n-  const char *erm;\n+  const char *whaterr;\n \n   /* Go through cd_name_counts for all CTF namespaces in turn.  */\n \n@@ -1474,7 +1472,7 @@ ctf_dedup_detect_name_ambiguity (ctf_file_t *fp, ctf_file_t **inputs)\n \t\t}\n \t      if (err != ECTF_NEXT_END)\n \t\t{\n-\t\t  erm = \"marking conflicting structs/unions\";\n+\t\t  whaterr = N_(\"error marking conflicting structs/unions\");\n \t\t  goto iterr;\n \t\t}\n \t    }\n@@ -1511,7 +1509,7 @@ ctf_dedup_detect_name_ambiguity (ctf_file_t *fp, ctf_file_t **inputs)\n \t    }\n \t  if (err != ECTF_NEXT_END)\n \t    {\n-\t      erm = \"finding commonest conflicting type\";\n+\t      whaterr = N_(\"error finding commonest conflicting type\");\n \t      goto iterr;\n \t    }\n \n@@ -1526,32 +1524,32 @@ ctf_dedup_detect_name_ambiguity (ctf_file_t *fp, ctf_file_t **inputs)\n \t\t\t   hval, (const char *) k);\n \t      if (ctf_dedup_mark_conflicting_hash (fp, hval) < 0)\n \t\t{\n-\t\t  erm = \"marking hashes as conflicting\";\n+\t\t  whaterr = N_(\"error marking hashes as conflicting\");\n \t\t  goto err;\n \t\t}\n \t    }\n \t  if (err != ECTF_NEXT_END)\n \t    {\n-\t      erm = \"marking uncommon conflicting types\";\n+\t      whaterr = N_(\"marking uncommon conflicting types\");\n \t      goto iterr;\n \t    }\n \t}\n     }\n   if (err != ECTF_NEXT_END)\n     {\n-      erm = \"scanning for ambiguous names\";\n+      whaterr = N_(\"scanning for ambiguous names\");\n       goto iterr;\n     }\n \n   return 0;\n \n  err:\n   ctf_next_destroy (i);\n-  ctf_err_warn (fp, 0, \"%s: %s\", erm, ctf_errmsg (ctf_errno (fp)));\n-  return -1;\n+  ctf_err_warn (fp, 0, 0, \"%s\", gettext (whaterr));\n+  return -1;\t\t\t\t\t/* errno is set for us.  */\n \n  iterr:\n-  ctf_err_warn (fp, 0, \"iteration failed %s: %s\", erm, ctf_errmsg (err));\n+  ctf_err_warn (fp, 0, err, _(\"iteration failed: %s\"), gettext (whaterr));\n   return ctf_set_errno (fp, err);\n \n  assert_err:\n@@ -1642,8 +1640,8 @@ ctf_dedup_init (ctf_file_t *fp)\n   return 0;\n \n  oom:\n-  ctf_err_warn (fp, 0, \"ctf_dedup_init: cannot initialize: \"\n-\t\t\"out of memory.\");\n+  ctf_err_warn (fp, 0, ENOMEM, _(\"ctf_dedup_init: cannot initialize: \"\n+\t\t\t\t \"out of memory\"));\n   return ctf_set_errno (fp, ENOMEM);\n }\n \n@@ -1740,10 +1738,9 @@ ctf_dedup_multiple_input_dicts (ctf_file_t *output, ctf_file_t **inputs,\n     }\n   if ((err != ECTF_NEXT_END) && (err != 0))\n     {\n-      ctf_err_warn (output, 0, \"propagating conflictedness: %s\",\n-\t\t    ctf_errmsg (err));\n-      ctf_set_errno (output, err);\n-      return -1;\n+      ctf_err_warn (output, 0, err, _(\"iteration error \"\n+\t\t\t\t      \"propagating conflictedness\"));\n+      return ctf_set_errno (output, err);\n     }\n \n   if (multiple)\n@@ -1836,11 +1833,9 @@ ctf_dedup_conflictify_unshared (ctf_file_t *output, ctf_file_t **inputs)\n   err = ctf_errno (output);\n   ctf_next_destroy (i);\n  iterr:\n-  ctf_set_errno (output, err);\n   ctf_dynset_destroy (to_mark);\n-  ctf_err_warn (output, 0, \"conflictifying unshared types: %s\",\n-\t\tctf_errmsg (ctf_errno (output)));\n-  return -1;\n+  ctf_err_warn (output, 0, err, _(\"conflictifying unshared types\"));\n+  return ctf_set_errno (output, err);\n }\n \n /* The core deduplicator.  Populate cd_output_mapping in the output ctf_dedup\n@@ -1899,9 +1894,10 @@ ctf_dedup (ctf_file_t *output, ctf_file_t **inputs, uint32_t ninputs,\n \t}\n       if (ctf_errno (inputs[i]) != ECTF_NEXT_END)\n \t{\n-\t  ctf_err_warn (output, 0, \"iteration failure computing type \"\n-\t\t\t\"hashes: %s\", ctf_errmsg (ctf_errno (inputs[i])));\n-\t  return ctf_set_errno (output, ctf_errno (inputs[i]));\n+\t  ctf_set_errno (output, ctf_errno (inputs[i]));\n+\t  ctf_err_warn (output, 0, 0, _(\"iteration failure \"\n+\t\t\t\t\t\"computing type hashes\"));\n+\t  return -1;\n \t}\n     }\n \n@@ -2013,7 +2009,7 @@ ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n     hashval = ctf_dynhash_lookup (d->cd_type_hashes, type_id);\t\t\\\n     if (!ctf_assert (output, hashval))\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\twhaterr = \"looking up ID in type hashes\";\t\t\t\\\n+\twhaterr = N_(\"error looking up ID in type hashes\");\t\t\\\n \tgoto errlabel;\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     ctf_dprintf (\"ID %i/%lx has hash %s\\n\", cited_type_input_num, type,\t\\\n@@ -2048,7 +2044,7 @@ ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n     case CTF_K_POINTER:\n     case CTF_K_SLICE:\n       CTF_TYPE_WALK (ctf_type_reference (fp, type), err,\n-\t\t     \"Referenced type walk\");\n+\t\t     N_(\"error during referenced type walk\"));\n       break;\n \n     case CTF_K_ARRAY:\n@@ -2057,12 +2053,14 @@ ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n \n \tif (ctf_array_info (fp, type, &ar) < 0)\n \t  {\n-\t    whaterr = \"array info lookup\";\n+\t    whaterr = N_(\"error during array info lookup\");\n \t    goto err_msg;\n \t  }\n \n-\tCTF_TYPE_WALK (ar.ctr_contents, err, \"Array contents type walk\");\n-\tCTF_TYPE_WALK (ar.ctr_index, err, \"Array index type walk\");\n+\tCTF_TYPE_WALK (ar.ctr_contents, err,\n+\t\t       N_(\"error during array contents type walk\"));\n+\tCTF_TYPE_WALK (ar.ctr_index, err,\n+\t\t       N_(\"error during array index type walk\"));\n \tbreak;\n       }\n \n@@ -2074,27 +2072,29 @@ ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n \n \tif (ctf_func_type_info (fp, type, &fi) < 0)\n \t  {\n-\t    whaterr = \"func type info lookup\";\n+\t    whaterr = N_(\"error during func type info lookup\");\n \t    goto err_msg;\n \t  }\n \n-\tCTF_TYPE_WALK (fi.ctc_return, err, \"Func return type walk\");\n+\tCTF_TYPE_WALK (fi.ctc_return, err,\n+\t\t       N_(\"error during func return type walk\"));\n \n \tif ((args = calloc (fi.ctc_argc, sizeof (ctf_id_t))) == NULL)\n \t  {\n-\t    whaterr = \"memory allocation\";\n+\t    whaterr = N_(\"error doing memory allocation\");\n \t    goto err_msg;\n \t  }\n \n \tif (ctf_func_type_args (fp, type, fi.ctc_argc, args) < 0)\n \t  {\n-\t    whaterr = \"func arg type lookup\";\n+\t    whaterr = N_(\"error doing func arg type lookup\");\n \t    free (args);\n \t    goto err_msg;\n \t  }\n \n \tfor (j = 0; j < fi.ctc_argc; j++)\n-\t  CTF_TYPE_WALK (args[j], err_free_args, \"Func arg type walk\");\n+\t  CTF_TYPE_WALK (args[j], err_free_args,\n+\t\t\t N_(\"error during Func arg type walk\"));\n \tfree (args);\n \tbreak;\n \n@@ -2108,17 +2108,17 @@ ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n \t emitted later, in a separate pass.  */\n \tbreak;\n     default:\n-      whaterr = \"unknown type kind\";\n-      goto err;\n+      whaterr = N_(\"CTF dict corruption: unknown type kind\");\n+      goto err_msg;\n     }\n \n   return visit_fun (hval, output, inputs, ninputs, parents, visited, fp, type,\n \t\t    type_id, depth, arg);\n \n  err_msg:\n   ctf_set_errno (output, ctf_errno (fp));\n-  ctf_err_warn (fp, 0, \"%s during type walking in %s at ID %lx: %s\", whaterr,\n-\t       ctf_link_input_name (fp), type, ctf_errmsg (ctf_errno (fp)));\n+  ctf_err_warn (output, 0, 0, _(\"%s in input file %s at type ID %lx\"),\n+\t\tgettext (whaterr), ctf_link_input_name (fp), type);\n  err:\n   return -1;\n }\n@@ -2157,8 +2157,8 @@ ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n   type_ids = ctf_dynhash_lookup (d->cd_output_mapping, hval);\n   if (!type_ids)\n     {\n-      ctf_err_warn (output, 0, \"looked up type kind by nonexistent \"\n-\t\t    \"hash %s.\", hval);\n+      ctf_err_warn (output, 0, ECTF_INTERNAL,\n+\t\t    _(\"looked up type kind by nonexistent hash %s\"), hval);\n       return ctf_set_errno (output, ECTF_INTERNAL);\n     }\n \n@@ -2175,8 +2175,8 @@ ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n       visited = 0;\n       if (ctf_dynset_cinsert (already_visited, hval) < 0)\n \t{\n-\t  ctf_err_warn (output, 0, \"out of memory tracking already-visited \"\n-\t\t\t\"types.\");\n+\t  ctf_err_warn (output, 0, ENOMEM,\n+\t\t\t_(\"out of memory tracking already-visited types\"));\n \t  return ctf_set_errno (output, ENOMEM);\n \t}\n     }\n@@ -2213,8 +2213,7 @@ ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n     }\n   if (err != ECTF_NEXT_END)\n     {\n-      ctf_err_warn (output, 0, \"walking many types with one hash: %s\",\n-\t\t    ctf_errmsg (err));\n+      ctf_err_warn (output, 0, err, _(\"cannot walk conflicted type\"));\n       return ctf_set_errno (output, err);\n     }\n \n@@ -2336,8 +2335,7 @@ ctf_dedup_walk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n     }\n   if (err != ECTF_NEXT_END)\n     {\n-      ctf_err_warn (output, 0, \"recursing over output mapping: %s\",\n-\t\t    ctf_errmsg (err));\n+      ctf_err_warn (output, 0, err, _(\"cannot recurse over output mapping\"));\n       ctf_set_errno (output, err);\n       goto err;\n     }\n@@ -2490,8 +2488,8 @@ ctf_dedup_id_to_target (ctf_file_t *output, ctf_file_t *target,\n       break;\n     case -1:\n       ctf_set_errno (err_fp, ctf_errno (output));\n-      ctf_err_warn (err_fp, 0, \"adding synthetic forward for type %i/%lx: \"\n-\t\t    \"%s\", input_num, id, ctf_errmsg (ctf_errno (err_fp)));\n+      ctf_err_warn (err_fp, 0, 0, _(\"cannot add synthetic forward for type \"\n+\t\t\t\t    \"%i/%lx\"), input_num, id);\n       return -1;\n     default:\n       return emitted_forward;\n@@ -2518,10 +2516,10 @@ ctf_dedup_id_to_target (ctf_file_t *output, ctf_file_t *target,\n \tcase 0: /* No forward needed.  */\n \t  break;\n \tcase -1:\n-\t  ctf_set_errno (err_fp, ctf_errno (output));\n-\t  ctf_err_warn (err_fp, 0, \"adding synthetic forward for type %i/%lx: \"\n-\t\t\t\"%s\", input_num, id, ctf_errmsg (ctf_errno (err_fp)));\n-\t  return -1;\n+\t  ctf_err_warn (err_fp, 0, ctf_errno (output),\n+\t\t\t_(\"cannot add synthetic forward for type %i/%lx\"),\n+\t\t\tinput_num, id);\n+\t  return ctf_set_errno (err_fp, ctf_errno (output));\n \tdefault:\n \t  return emitted_forward;\n \t}\n@@ -2570,7 +2568,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n   ctf_id_t ref;\n   ctf_id_t maybe_dup = 0;\n   ctf_encoding_t ep;\n-  const char *erm;\n+  const char *errtype;\n   int emission_hashed = 0;\n \n   /* We don't want to re-emit something we've already emitted.  */\n@@ -2600,10 +2598,10 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n \n \t  if ((target = ctf_create (&err)) == NULL)\n \t    {\n-\t      ctf_err_warn (output, 0, \"cannot create per-CU CTF archive \"\n-\t\t\t    \"for CU %s: %s\", ctf_link_input_name (input),\n-\t\t\t    ctf_errmsg (err)); ctf_set_errno (output, err);\n-\t      return -1;\n+\t      ctf_err_warn (output, 0, err,\n+\t\t\t    _(\"cannot create per-CU CTF archive for CU %s\"),\n+\t\t\t    ctf_link_input_name (input));\n+\t      return ctf_set_errno (output, err);\n \t    }\n \n \t  ctf_import_unref (target, output);\n@@ -2621,11 +2619,10 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n   real_input = input;\n   if ((tp = ctf_lookup_by_id (&real_input, type)) == NULL)\n     {\n-      ctf_err_warn (output, 0, \"%s: lookup failure for type %lx: %s\",\n-\t\t    ctf_link_input_name (real_input), type,\n-\t\t    ctf_errmsg (ctf_errno (input)));\n-      ctf_set_errno (output, ctf_errno (input));\n-      return -1;\t\t/* errno is set for us.  */\n+      ctf_err_warn (output, 0, ctf_errno (input),\n+\t\t    _(\"%s: lookup failure for type %lx\"),\n+\t\t    ctf_link_input_name (real_input), type);\n+      return ctf_set_errno (output, ctf_errno (input));\n     }\n \n   name = ctf_strraw (real_input, tp->ctt_name);\n@@ -2667,7 +2664,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n       /* This will do nothing if the type to which this forwards already exists,\n \t and will be replaced with such a type if it appears later.  */\n \n-      erm = \"forward\";\n+      errtype = _(\"forward\");\n       if ((new_type = ctf_add_forward (target, isroot, name,\n \t\t\t\t       ctf_type_kind_forwarded (input, type)))\n \t  == CTF_ERR)\n@@ -2676,7 +2673,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n \n     case CTF_K_FLOAT:\n     case CTF_K_INTEGER:\n-      erm = \"float/int\";\n+      errtype = _(\"float/int\");\n       if (ctf_type_encoding (input, type, &ep) < 0)\n \tgoto err_input;\t\t\t\t/* errno is set for us.  */\n       if ((new_type = ctf_add_encoded (target, isroot, name, &ep, kind))\n@@ -2687,18 +2684,19 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n     case CTF_K_ENUM:\n       {\n \tint val;\n-\term = \"enum\";\n+\terrtype = _(\"enum\");\n \tif ((new_type = ctf_add_enum (target, isroot, name)) == CTF_ERR)\n \t  goto err_input;\t\t\t\t/* errno is set for us.  */\n \n \twhile ((name = ctf_enum_next (input, type, &i, &val)) != NULL)\n \t  {\n \t    if (ctf_add_enumerator (target, new_type, name, val) < 0)\n \t      {\n-\t\tctf_err_warn (target, 0, \"%s (%i): cannot add enumeration \"\n-\t\t\t      \"value %s from input type %lx: %s\",\n+\t\tctf_err_warn (target, 0, ctf_errno (target),\n+\t\t\t      _(\"%s (%i): cannot add enumeration value %s \"\n+\t\t\t\t\"from input type %lx\"),\n \t\t\t      ctf_link_input_name (input), input_num, name,\n-\t\t\t      type, ctf_errmsg (ctf_errno (target)));\n+\t\t\t      type);\n \t\tctf_next_destroy (i);\n \t\treturn ctf_set_errno (output, ctf_errno (target));\n \t      }\n@@ -2709,7 +2707,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n       }\n \n     case CTF_K_TYPEDEF:\n-      erm = \"typedef\";\n+      errtype = _(\"typedef\");\n \n       ref = ctf_type_reference (input, type);\n       if ((ref = ctf_dedup_id_to_target (output, target, inputs, ninputs,\n@@ -2725,7 +2723,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n     case CTF_K_CONST:\n     case CTF_K_RESTRICT:\n     case CTF_K_POINTER:\n-      erm = \"pointer or cvr-qual\";\n+      errtype = _(\"pointer or cvr-qual\");\n \n       ref = ctf_type_reference (input, type);\n       if ((ref = ctf_dedup_id_to_target (output, target, inputs, ninputs,\n@@ -2738,7 +2736,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n       break;\n \n     case CTF_K_SLICE:\n-      erm = \"slice\";\n+      errtype = _(\"slice\");\n \n       if (ctf_type_encoding (input, type, &ep) < 0)\n \tgoto err_input;\t\t\t\t/* errno is set for us.  */\n@@ -2757,7 +2755,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n       {\n \tctf_arinfo_t ar;\n \n-\term = \"array info\";\n+\terrtype = _(\"array info\");\n \tif (ctf_array_info (input, type, &ar) < 0)\n \t  goto err_input;\n \n@@ -2783,7 +2781,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n \tctf_id_t *args;\n \tuint32_t j;\n \n-\term = \"function\";\n+\terrtype = _(\"function\");\n \tif (ctf_func_type_info (input, type, &fi) < 0)\n \t  goto err_input;\n \n@@ -2799,7 +2797,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n \t    goto err_input;\n \t  }\n \n-\term = \"function args\";\n+\terrtype = _(\"function args\");\n \tif (ctf_func_type_args (input, type, fi.ctc_argc, args) < 0)\n \t  {\n \t    free (args);\n@@ -2832,7 +2830,7 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n \tvoid *out_id;\n \t/* Insert the structure itself, so other types can refer to it.  */\n \n-\term = \"structure/union\";\n+\terrtype = _(\"structure/union\");\n \tif (kind == CTF_K_STRUCT)\n \t  new_type = ctf_add_struct_sized (target, isroot, name, size);\n \telse\n@@ -2850,18 +2848,19 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n \tbreak;\n       }\n     default:\n-      ctf_err_warn (output, 0, \"%s: unknown type kind for input type %lx\",\n+      ctf_err_warn (output, 0, ECTF_CORRUPT, _(\"%s: unknown type kind for \"\n+\t\t\t\t\t       \"input type %lx\"),\n \t\t    ctf_link_input_name (input), type);\n-      return -1;\n+      return ctf_set_errno (output, ECTF_CORRUPT);\n     }\n \n   if (!emission_hashed\n       && new_type != 0\n       && ctf_dynhash_cinsert (target->ctf_dedup.cd_output_emission_hashes,\n \t\t\t      hval, (void *) (uintptr_t) new_type) < 0)\n     {\n-      ctf_err_warn (output, 0, \"out of memory tracking deduplicated \"\n-\t\t    \"global type IDs\");\n+      ctf_err_warn (output, 0, ENOMEM, _(\"out of memory tracking deduplicated \"\n+\t\t\t\t\t \"global type IDs\"));\n \treturn ctf_set_errno (output, ENOMEM);\n     }\n \n@@ -2873,22 +2872,23 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n   return 0;\n \n  oom_hash:\n-  ctf_err_warn (output, 0, \"out of memory creating emission-tracking hashes\");\n+  ctf_err_warn (output, 0, ENOMEM, _(\"out of memory creating emission-tracking \"\n+\t\t\t\t     \"hashes\"));\n   return ctf_set_errno (output, ENOMEM);\n \n  err_input:\n-  ctf_err_warn (output, 0, \"%s (%i): while emitting deduplicated %s, error \"\n-\t\t\"getting input type %lx: %s\", ctf_link_input_name (input),\n-\t\tinput_num,erm, type, ctf_errmsg (ctf_errno (input)));\n-  ctf_set_errno (output, ctf_errno (input));\n-  return -1;\n+  ctf_err_warn (output, 0, ctf_errno (input),\n+\t\t_(\"%s (%i): while emitting deduplicated %s, error getting \"\n+\t\t  \"input type %lx\"), ctf_link_input_name (input),\n+\t\tinput_num, errtype, type);\n+  return ctf_set_errno (output, ctf_errno (input));\n  err_target:\n-  ctf_err_warn (output, 0, \"%s (%i): while emitting deduplicated %s, error \"\n-\t\t\"emitting target type from input type %lx: %s\",\n-\t\tctf_link_input_name (input), input_num, erm, type,\n-\t\tctf_errmsg (ctf_errno (target)));\n-  ctf_set_errno (output, ctf_errno (target));\n-  return -1;\n+  ctf_err_warn (output, 0, ctf_errno (target),\n+\t\t_(\"%s (%i): while emitting deduplicated %s, error emitting \"\n+\t\t  \"target type from input type %lx\"),\n+\t\tctf_link_input_name (input), input_num,\n+\t\terrtype, type);\n+  return ctf_set_errno (output, ctf_errno (target));\n }\n \n /* Traverse the cd_emission_struct_members and emit the members of all\n@@ -2978,16 +2978,14 @@ ctf_dedup_emit_struct_members (ctf_file_t *output, ctf_file_t **inputs,\n   return 0;\n  err_target:\n   ctf_next_destroy (i);\n-  ctf_err_warn (output, 0, \"%s (%i): error emitting members for structure \"\n-\t\t\"type %lx: %s\", ctf_link_input_name (input_fp), input_num,\n-\t\terr_type, ctf_errmsg (ctf_errno (err_fp)));\n-  ctf_set_errno (output, ctf_errno (err_fp));\n-  return -1;\n+  ctf_err_warn (output, 0, ctf_errno (err_fp),\n+\t\t_(\"%s (%i): error emitting members for structure type %lx\"),\n+\t\tctf_link_input_name (input_fp), input_num, err_type);\n+  return ctf_set_errno (output, ctf_errno (err_fp));\n  iterr:\n-  ctf_err_warn (output, 0, \"iteration failure emitting structure members: %s\",\n-\t\tctf_errmsg (err));\n-  ctf_set_errno (output, err);\n-  return -1;\n+  ctf_err_warn (output, 0, err, _(\"iteration failure emitting \"\n+\t\t\t\t  \"structure members\"));\n+  return ctf_set_errno (output, err);\n }\n \n /* Populate the type mapping used by the types in one FP (which must be an input\n@@ -3052,8 +3050,7 @@ ctf_dedup_populate_type_mapping (ctf_file_t *shared, ctf_file_t *fp,\n   return 0;\n \n  err:\n-  ctf_err_warn (shared, 0, \"iteration error populating the type mapping: %s\",\n-\t\tctf_errmsg (err));\n+  ctf_err_warn (shared, 0, err, _(\"iteration error populating the type mapping\"));\n   return ctf_set_errno (shared, err);\n }\n \n@@ -3067,17 +3064,17 @@ ctf_dedup_populate_type_mappings (ctf_file_t *output, ctf_file_t **inputs,\n \n   if (ctf_dedup_populate_type_mapping (output, output, inputs) < 0)\n     {\n-      ctf_err_warn (output, 0, \"cannot populate type mappings for shared \"\n-\t\t    \"CTF dict: %s\", ctf_errmsg (ctf_errno (output)));\n+      ctf_err_warn (output, 0, 0, _(\"cannot populate type mappings for shared \"\n+\t\t\t\t    \"CTF dict\"));\n       return -1;\t\t\t\t/* errno is set for us.  */\n     }\n \n   for (i = 0; i < ninputs; i++)\n     {\n       if (ctf_dedup_populate_type_mapping (output, inputs[i], inputs) < 0)\n \t{\n-\t  ctf_err_warn (output, 0, \"cannot populate type mappings for per-CU \"\n-\t\t\t\"CTF dict: %s\", ctf_errmsg (ctf_errno (inputs[i])));\n+\t  ctf_err_warn (output, 0, ctf_errno (inputs[i]),\n+\t\t\t_(\"cannot populate type mappings for per-CU CTF dict\"));\n \t  return ctf_set_errno (output, ctf_errno (inputs[i]));\n \t}\n     }\n@@ -3129,7 +3126,8 @@ ctf_dedup_emit (ctf_file_t *output, ctf_file_t **inputs, uint32_t ninputs,\n \n   if ((outputs = calloc (num_outputs, sizeof (ctf_file_t *))) == NULL)\n     {\n-      ctf_err_warn (output, 0, \"out of memory allocating link outputs array\");\n+      ctf_err_warn (output, 0, ENOMEM,\n+\t\t    _(\"out of memory allocating link outputs array\"));\n       ctf_set_errno (output, ENOMEM);\n       return NULL;\n     }"
    },
    {
      "sha": "ba358a21b07a24dc8122738b9349faf719c840ad",
      "filename": "libctf/ctf-dump.c",
      "status": "modified",
      "additions": 9,
      "deletions": 18,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dump.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -174,8 +174,7 @@ ctf_dump_format_type (ctf_file_t *fp, ctf_id_t id, int flag)\n  oom:\n   ctf_set_errno (fp, errno);\n  err:\n-  ctf_err_warn (fp, 1, \"Cannot format name dumping type 0x%lx: %s\", id,\n-\t\tctf_errmsg (ctf_errno (fp)));\n+  ctf_err_warn (fp, 1, 0, _(\"cannot format name dumping type 0x%lx\"), id);\n   free (buf);\n   free (str);\n   free (bit);\n@@ -405,7 +404,6 @@ ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n     {\n       char *str;\n       char *bit = NULL;\n-      const char *err;\n       const char *sym_name;\n       ctf_funcinfo_t fi;\n       ctf_id_t type;\n@@ -427,8 +425,11 @@ ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n       /* Return type and all args.  */\n       if ((bit = ctf_type_aname (state->cds_fp, type)) == NULL)\n \t{\n-\t  err = \"look up return type\";\n-\t  goto err;\n+\t  ctf_err_warn (fp, 1, ctf_errno (state->cds_fp),\n+\t\t\t_(\"cannot look up return type dumping function type \"\n+\t\t\t  \"for symbol 0x%li\"), (unsigned long) i);\n+\t  free (bit);\n+\t  return -1;\t\t\t/* errno is set for us.  */\n \t}\n \n       /* Replace in the returned string, dropping in the function name.  */\n@@ -469,13 +470,6 @@ ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n       ctf_dump_append (state, str);\n       continue;\n \n-    err:\n-      ctf_err_warn (fp, 1, \"Cannot %s dumping function type for \"\n-\t\t    \"symbol 0x%li: %s\", err, (unsigned long) i,\n-\t\t    ctf_errmsg (ctf_errno (state->cds_fp)));\n-      free (bit);\n-      return -1;\t\t/* errno is set for us.  */\n-\n     oom:\n       free (bit);\n       return (ctf_set_errno (fp, errno));\n@@ -597,13 +591,12 @@ static int\n ctf_dump_type (ctf_id_t id, int flag, void *arg)\n {\n   char *str;\n-  const char *err;\n   ctf_dump_state_t *state = arg;\n   ctf_dump_membstate_t membstate = { &str, state->cds_fp };\n   size_t len;\n \n   if ((str = ctf_dump_format_type (state->cds_fp, id, flag)) == NULL)\n-    goto err_nomsg;\t\t/* Error already logged for us.  */\n+    goto err;\n \n   str = str_append (str, \"\\n\");\n   if ((ctf_type_visit (state->cds_fp, id, ctf_dump_member, &membstate)) < 0)\n@@ -613,7 +606,8 @@ ctf_dump_type (ctf_id_t id, int flag, void *arg)\n \t  ctf_dump_append (state, str);\n \t  return 0;\n \t}\n-      err = \"visit members\";\n+      ctf_err_warn (state->cds_fp, 1, ctf_errno (state->cds_fp),\n+\t\t    _(\"cannot visit members dumping type 0x%lx\"), id);\n       goto err;\n     }\n \n@@ -626,9 +620,6 @@ ctf_dump_type (ctf_id_t id, int flag, void *arg)\n   return 0;\n \n  err:\n-  ctf_err_warn (state->cds_fp, 1, \"Cannot %s dumping type 0x%lx: %s\",\n-\t\terr, id, ctf_errmsg (ctf_errno (state->cds_fp)));\n- err_nomsg:\n   free (str);\n   return 0;\t\t\t\t/* Swallow the error.  */\n }"
    },
    {
      "sha": "ecd0ef211883b3d0bc2d3a96bd076ae9a9bd8588",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 6,
      "deletions": 11,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -130,7 +130,7 @@ typedef struct ctf_fileops\n   uint32_t (*ctfo_get_vlen) (uint32_t);\n   ssize_t (*ctfo_get_ctt_size) (const ctf_file_t *, const ctf_type_t *,\n \t\t\t\tssize_t *, ssize_t *);\n-  ssize_t (*ctfo_get_vbytes) (unsigned short, ssize_t, size_t);\n+  ssize_t (*ctfo_get_vbytes) (ctf_file_t *, unsigned short, ssize_t, size_t);\n } ctf_fileops_t;\n \n typedef struct ctf_list\n@@ -199,13 +199,6 @@ typedef struct ctf_dvdef\n   unsigned long dvd_snapshots;\t/* Snapshot count when inserted.  */\n } ctf_dvdef_t;\n \n-typedef struct ctf_bundle\n-{\n-  ctf_file_t *ctb_file;\t\t/* CTF container handle.  */\n-  ctf_id_t ctb_type;\t\t/* CTF type identifier.  */\n-  ctf_dtdef_t *ctb_dtd;\t\t/* CTF dynamic type definition (if any).  */\n-} ctf_bundle_t;\n-\n typedef struct ctf_err_warning\n {\n   ctf_list_t cew_list;\t\t/* List forward/back pointers.  */\n@@ -546,7 +539,7 @@ struct ctf_next\n #define LCTF_INFO_ISROOT(fp, info)\t((fp)->ctf_fileops->ctfo_get_root(info))\n #define LCTF_INFO_VLEN(fp, info)\t((fp)->ctf_fileops->ctfo_get_vlen(info))\n #define LCTF_VBYTES(fp, kind, size, vlen) \\\n-  ((fp)->ctf_fileops->ctfo_get_vbytes(kind, size, vlen))\n+  ((fp)->ctf_fileops->ctfo_get_vbytes(fp, kind, size, vlen))\n \n #define LCTF_CHILD\t0x0001\t/* CTF container is a child */\n #define LCTF_RDWR\t0x0002\t/* CTF container is writable */\n@@ -718,8 +711,10 @@ _libctf_printflike_ (1, 2)\n extern void ctf_dprintf (const char *, ...);\n extern void libctf_init_debug (void);\n \n-_libctf_printflike_ (3, 4)\n-extern void ctf_err_warn (ctf_file_t *, int is_warning, const char *, ...);\n+_libctf_printflike_ (4, 5)\n+extern void ctf_err_warn (ctf_file_t *, int is_warning, int err,\n+\t\t\t  const char *, ...);\n+extern void ctf_err_warn_to_open (ctf_file_t *);\n extern void ctf_assert_fail_internal (ctf_file_t *, const char *,\n \t\t\t\t      size_t, const char *);\n extern const char *ctf_link_input_name (ctf_file_t *);"
    },
    {
      "sha": "014a9933e64d43cff315a8db39b8b3ffafaeb4ac",
      "filename": "libctf/ctf-labels.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-labels.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-labels.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-labels.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -80,8 +80,10 @@ ctf_label_iter (ctf_file_t *fp, ctf_label_f *func, void *arg)\n     {\n       if ((lname = ctf_strraw (fp, ctlp->ctl_label)) == NULL)\n \t{\n-\t  ctf_dprintf (\"failed to decode label %u with \"\n-\t\t       \"type %u\\n\", ctlp->ctl_label, ctlp->ctl_type);\n+\t  /* Not marked for translation: label code not used yet.  */\n+\t  ctf_err_warn (fp, 0, ECTF_CORRUPT,\n+\t\t\t\"failed to decode label %u with type %u\",\n+\t\t\tctlp->ctl_label, ctlp->ctl_type);\n \t  return (ctf_set_errno (fp, ECTF_CORRUPT));\n \t}\n "
    },
    {
      "sha": "1cda324e65e10f308ea7d483a6b45999a42d31d1",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 68,
      "deletions": 65,
      "changes": 133,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -314,9 +314,9 @@ ctf_create_per_cu (ctf_file_t *fp, const char *filename, const char *cuname)\n \n       if ((cu_fp = ctf_create (&err)) == NULL)\n \t{\n-\t  ctf_err_warn (fp, 0, \"Cannot create per-CU CTF archive for \"\n-\t\t\t\"CU %s from input file %s: %s\", cuname, filename,\n-\t\t\tctf_errmsg (err));\n+\t  ctf_err_warn (fp, 0, err, _(\"cannot create per-CU CTF archive for \"\n+\t\t\t\t      \"CU %s from input file %s\"),\n+\t\t\tcuname, filename);\n \t  ctf_set_errno (fp, err);\n \t  return NULL;\n \t}\n@@ -477,7 +477,8 @@ ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n \n   if (arg->in_fp->ctf_link_flags != CTF_LINK_SHARE_UNCONFLICTED)\n     {\n-      ctf_err_warn (arg->out_fp, 0, \"Share-duplicated mode not yet implemented\");\n+      ctf_err_warn (arg->out_fp, 0, ECTF_NOTYET,\n+\t\t    _(\"share-duplicated mode not yet implemented\"));\n       return ctf_set_errno (arg->out_fp, ECTF_NOTYET);\n     }\n \n@@ -495,9 +496,10 @@ ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n       if (err != ECTF_CONFLICT)\n \t{\n \t  if (err != ECTF_NONREPRESENTABLE)\n-\t    ctf_err_warn (arg->out_fp, 1, \"Cannot link type %lx from input file %s, \"\n-\t\t\t  \"CU %s into output link: %s\", type, arg->cu_name,\n-\t\t\t arg->in_file_name, ctf_errmsg (err));\n+\t    ctf_err_warn (arg->out_fp, 1, 0,\n+\t\t\t  _(\"cannot link type %lx from input file %s, CU %s \"\n+\t\t\t    \"into output link\"), type, arg->cu_name,\n+\t\t\t  arg->in_file_name);\n \t  /* We must ignore this problem or we end up losing future types, then\n \t     trying to link the variables in, then exploding.  Better to link as\n \t     much as possible.  */\n@@ -515,10 +517,11 @@ ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n \n   err = ctf_errno (per_cu_out_fp);\n   if (err != ECTF_NONREPRESENTABLE)\n-    ctf_err_warn (arg->out_fp, 1, \"Cannot link type %lx from input file %s, CU %s \"\n-\t\t \"into output per-CU CTF archive member %s: %s: skipped\", type,\n-\t\t ctf_link_input_name (arg->in_fp), arg->in_file_name,\n-\t\t ctf_link_input_name (per_cu_out_fp), ctf_errmsg (err));\n+    ctf_err_warn (arg->out_fp, 1, 0,\n+\t\t  _(\"cannot link type %lx from input file %s, CU %s \"\n+\t\t    \"into output per-CU CTF archive member %s: %s: skipped\"),\n+\t\t  type, ctf_link_input_name (arg->in_fp), arg->in_file_name,\n+\t\t  ctf_link_input_name (per_cu_out_fp), ctf_errmsg (err));\n   if (err == ECTF_CONFLICT)\n       /* Conflicts are possible at this stage only if a non-ld user has combined\n \t multiple TUs into a single output dictionary.  Even in this case we do not\n@@ -633,8 +636,9 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n \n       if (dst_type == 0)\n \t{\n-\t  ctf_err_warn (arg->out_fp, 1, \"Type %lx for variable %s in input \"\n-\t\t\t\"file %s not found: skipped\", type, name,\n+\t  ctf_err_warn (arg->out_fp, 1, 0,\n+\t\t\t_(\"type %lx for variable %s in input file %s \"\n+\t\t\t  \"not found: skipped\"), type, name,\n \t\t\targ->in_file_name);\n \t  /* Do not terminate the link: just skip the variable.  */\n \t  return 0;\n@@ -727,8 +731,8 @@ ctf_link_lazy_open (ctf_file_t *fp, ctf_link_input_t *input)\n #if defined (PIC) || !NOBFD\n   input->clin_arc = ctf_open (input->clin_filename, NULL, &err);\n #else\n-  ctf_err_warn (fp, 0, \"Cannot open %s lazily: %s\", input->clin_filename,\n-\t\tctf_errmsg (ECTF_NEEDSBFD));\n+  ctf_err_warn (fp, 0, ECTF_NEEDSBFD, _(\"cannot open %s lazily\"),\n+\t\tinput->clin_filename);\n   ctf_set_errno (fp, ECTF_NEEDSBFD);\n   return -1;\n #endif\n@@ -741,8 +745,8 @@ ctf_link_lazy_open (ctf_file_t *fp, ctf_link_input_t *input)\n       if (err == ECTF_NOCTFDATA)\n \treturn 0;\n \n-      ctf_err_warn (fp, 0, \"Opening CTF %s failed: %s\",\n-\t\t    input->clin_filename, ctf_errmsg (err));\n+      ctf_err_warn (fp, 0, err, _(\"opening CTF %s failed\"),\n+\t\t    input->clin_filename);\n       ctf_set_errno (fp, err);\n       return -1;\n     }\n@@ -789,9 +793,10 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n \t\t\t\t\t\t &err)) == NULL)\n     if (err != ECTF_ARNNAME)\n       {\n-\tctf_err_warn (arg->out_fp, 0, \"Cannot open main archive member in \"\n-\t\t      \"input file %s in the link: skipping: %s\",\n-\t\t      arg->in_file_name, ctf_errmsg (err));\n+\tctf_err_warn (arg->out_fp, 1, 0,\n+\t\t      _(\"cannot open main archive member in input file %s \"\n+\t\t\t\"in the link: skipping: %s\"), arg->in_file_name,\n+\t\t      ctf_errmsg (err));\n \tgoto out;\n       }\n \n@@ -804,9 +809,9 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n   arg->done_parent = 1;\n   if (ctf_archive_iter (input->clin_arc, ctf_link_one_input_archive_member,\n \t\t\targ) < 0)\n-    ctf_err_warn (arg->out_fp, 0, \"Cannot traverse archive in input file %s: \"\n-\t\t  \"link cannot continue: %s\", arg->in_file_name,\n-\t\t  ctf_errmsg (ctf_errno (arg->out_fp)));\n+    ctf_err_warn (arg->out_fp, 0, 0, _(\"cannot traverse archive in input file \"\n+\t\t\t\t       \"%s: link cannot continue\"),\n+\t\t  arg->in_file_name);\n   else\n     {\n       /* The only error indication to the caller is the errno: so ensure that it\n@@ -911,8 +916,8 @@ ctf_link_deduplicating_count_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n     }\n   if (err != ECTF_NEXT_END)\n     {\n-      ctf_err_warn (fp, 0, \"Iteration error counting deduplicating CTF link \"\n-\t\t    \"inputs: %s\", ctf_errmsg (err));\n+      ctf_err_warn (fp, 0, err, _(\"iteration error counting deduplicating \"\n+\t\t\t\t  \"CTF link inputs\"));\n       ctf_set_errno (fp, err);\n       return -1;\n     }\n@@ -1073,8 +1078,8 @@ ctf_link_deduplicating_open_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n  err:\n   free (dedup_inputs);\n   free (parents_);\n-  ctf_err_warn (fp, 0, \"Error in deduplicating CTF link input allocation: %s\",\n-\t\tctf_errmsg (ctf_errno (fp)));\n+  ctf_err_warn (fp, 0, 0, _(\"error in deduplicating CTF link \"\n+\t\t\t    \"input allocation\"));\n   return NULL;\n }\n \n@@ -1108,8 +1113,8 @@ ctf_link_deduplicating_close_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n \t}\n       if (err != ECTF_NEXT_END)\n \t{\n-\t  ctf_err_warn (fp, 0, \"Iteration error in deduplicating link input \"\n-\t\t\t\"freeing: %s\", ctf_errmsg (err));\n+\t  ctf_err_warn (fp, 0, err, _(\"iteration error in deduplicating link \"\n+\t\t\t\t      \"input freeing\"));\n \t  ctf_set_errno (fp, err);\n \t}\n     }\n@@ -1186,8 +1191,9 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \n       if (labs ((long int) ninputs) > 0xfffffffe)\n \t{\n-\t  ctf_err_warn (fp, 0, \"Too many inputs in deduplicating link: %li\",\n-\t\t\t(long int) ninputs);\n+\t  ctf_err_warn (fp, 0, EFBIG, _(\"too many inputs in deduplicating \"\n+\t\t\t\t\t\"link: %li\"), (long int) ninputs);\n+\t  ctf_set_errno (fp, EFBIG);\n \t  goto err_open_inputs;\n \t}\n \n@@ -1209,9 +1215,9 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \t\t\t\t\t\t  &ai, NULL, 0, &err);\n \t  if (!only_input->clin_fp)\n \t    {\n-\t      ctf_err_warn (fp, 0, \"Cannot open archive %s in CU-mapped CTF \"\n-\t\t\t    \"link: %s\", only_input->clin_filename,\n-\t\t\t    ctf_errmsg (err));\n+\t      ctf_err_warn (fp, 0, err, _(\"cannot open archive %s in \"\n+\t\t\t\t\t  \"CU-mapped CTF link\"),\n+\t\t\t    only_input->clin_filename);\n \t      ctf_set_errno (fp, err);\n \t      goto err_open_inputs;\n \t    }\n@@ -1231,8 +1237,8 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \t\t\t\t\t     only_input->clin_fp,\n \t\t\t\t\t     out_name) < 0)\n \t\t{\n-\t\t  ctf_err_warn (fp, 0, \"Cannot add intermediate files \"\n-\t\t\t\t\"to link: %s\", ctf_errmsg (ctf_errno (fp)));\n+\t\t  ctf_err_warn (fp, 0, 0, _(\"cannot add intermediate files \"\n+\t\t\t\t\t    \"to link\"));\n \t\t  goto err_open_inputs;\n \t\t}\n \t      only_input->clin_arc = NULL;\n@@ -1255,8 +1261,9 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \n       if ((out = ctf_create (&err)) == NULL)\n \t{\n-\t  ctf_err_warn (fp, 0, \"Cannot create per-CU CTF archive for %s: %s\",\n-\t\t       out_name, ctf_errmsg (err));\n+\t  ctf_err_warn (fp, 0, err, _(\"cannot create per-CU CTF archive \"\n+\t\t\t\t      \"for %s\"),\n+\t\t\tout_name);\n \t  ctf_set_errno (fp, err);\n \t  goto err_inputs;\n \t}\n@@ -1272,17 +1279,18 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \n       if (ctf_dedup (out, inputs, ninputs, parents, 1) < 0)\n \t{\n-\t  ctf_err_warn (fp, 0, \"CU-mapped deduplication failed for %s: %s\",\n-\t\t       out_name, ctf_errmsg (ctf_errno (out)));\n+\t  ctf_set_errno (fp, ctf_errno (out));\n+\t  ctf_err_warn (fp, 0, 0, _(\"CU-mapped deduplication failed for %s\"),\n+\t\t\tout_name);\n \t  goto err_inputs;\n \t}\n \n       if ((outputs = ctf_dedup_emit (out, inputs, ninputs, parents,\n \t\t\t\t     &noutputs, 1)) == NULL)\n \t{\n-\t  ctf_err_warn (fp, 0, \"CU-mapped deduplicating link type emission \"\n-\t\t\t\"failed for %s: %s\", out_name,\n-\t\t\tctf_errmsg (ctf_errno (out)));\n+\t  ctf_set_errno (fp, ctf_errno (out));\n+\t  ctf_err_warn (fp, 0, 0, _(\"CU-mapped deduplicating link type emission \"\n+\t\t\t\t     \"failed for %s\"), out_name);\n \t  goto err_inputs;\n \t}\n       if (!ctf_assert (fp, noutputs == 1))\n@@ -1291,9 +1299,9 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n       if (!(fp->ctf_link_flags & CTF_LINK_OMIT_VARIABLES_SECTION)\n \t  && ctf_link_deduplicating_variables (out, inputs, ninputs, 1) < 0)\n \t{\n-\t  ctf_err_warn (fp, 0, \"CU-mapped deduplicating link variable \"\n-\t\t\t\"emission failed for %s: %s\", out_name,\n-\t\t\tctf_errmsg (ctf_errno (out)));\n+\t  ctf_set_errno (fp, ctf_errno (out));\n+\t  ctf_err_warn (fp, 0, 0, _(\"CU-mapped deduplicating link variable \"\n+\t\t\t\t    \"emission failed for %s\"), out_name);\n \t  goto err_inputs_outputs;\n \t}\n \n@@ -1324,8 +1332,7 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n       if (ctf_link_add_ctf_internal (fp, in_arc, NULL,\n \t\t\t\t     ctf_cuname (outputs[0])) < 0)\n \t{\n-\t  ctf_err_warn (fp, 0, \"Cannot add intermediate files to link: %s\",\n-\t\t\tctf_errmsg (ctf_errno (fp)));\n+\t  ctf_err_warn (fp, 0, 0, _(\"cannot add intermediate files to link\"));\n \t  goto err_outputs;\n \t}\n \n@@ -1355,8 +1362,8 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n     }\n   if (err != ECTF_NEXT_END)\n     {\n-      ctf_err_warn (fp, 0, \"Iteration error in CU-mapped deduplicating \"\n-\t\t    \"link: %s\", ctf_errmsg (err));\n+      ctf_err_warn (fp, 0, err, _(\"iteration error in CU-mapped deduplicating \"\n+\t\t\t\t  \"link\"));\n       return ctf_set_errno (fp, err);\n     }\n \n@@ -1375,8 +1382,7 @@ ctf_link_deduplicating (ctf_file_t *fp)\n \n   if (ctf_dedup_atoms_init (fp) < 0)\n     {\n-      ctf_err_warn (fp, 0, \"%s allocating CTF dedup atoms table\",\n-\t\t    ctf_errmsg (ctf_errno (fp)));\n+      ctf_err_warn (fp, 0, 0, _(\"allocating CTF dedup atoms table\"));\n       return;\t\t\t\t\t/* Errno is set for us.  */\n     }\n \n@@ -1396,17 +1402,16 @@ ctf_link_deduplicating (ctf_file_t *fp)\n \n   if (ctf_dedup (fp, inputs, ninputs, parents, 0) < 0)\n     {\n-      ctf_err_warn (fp, 0, \"Deduplication failed for %s: %s\",\n-\t\t    ctf_link_input_name (fp), ctf_errmsg (ctf_errno (fp)));\n+      ctf_err_warn (fp, 0, 0, _(\"deduplication failed for %s\"),\n+\t\t    ctf_link_input_name (fp));\n       goto err;\n     }\n \n   if ((outputs = ctf_dedup_emit (fp, inputs, ninputs, parents, &noutputs,\n \t\t\t\t 0)) == NULL)\n     {\n-      ctf_err_warn (fp, 0, \"Deduplicating link type emission failed \"\n-\t\t    \"for %s: %s\", ctf_link_input_name (fp),\n-\t\t    ctf_errmsg (ctf_errno (fp)));\n+      ctf_err_warn (fp, 0, 0, _(\"deduplicating link type emission failed \"\n+\t\t\t\t\"for %s\"), ctf_link_input_name (fp));\n       goto err;\n     }\n \n@@ -1433,8 +1438,8 @@ ctf_link_deduplicating (ctf_file_t *fp)\n       continue;\n \n     oom_one_output:\n-      ctf_err_warn (fp, 0, \"Out of memory allocating link outputs\");\n       ctf_set_errno (fp, ENOMEM);\n+      ctf_err_warn (fp, 0, 0, _(\"out of memory allocating link outputs\"));\n       free (dynname);\n \n       for (; i < noutputs; i++)\n@@ -1445,9 +1450,8 @@ ctf_link_deduplicating (ctf_file_t *fp)\n   if (!(fp->ctf_link_flags & CTF_LINK_OMIT_VARIABLES_SECTION)\n       && ctf_link_deduplicating_variables (fp, inputs, ninputs, 0) < 0)\n     {\n-      ctf_err_warn (fp, 0, \"Deduplicating link variable emission failed for \"\n-\t\t    \"%s: %s\", ctf_link_input_name (fp),\n-\t\t    ctf_errmsg (ctf_errno (fp)));\n+      ctf_err_warn (fp, 0, 0, _(\"deduplicating link variable emission failed for \"\n+\t\t\t\t\"%s\"), ctf_link_input_name (fp));\n       for (i = 1; i < noutputs; i++)\n \tctf_file_close (outputs[i]);\n       goto err;\n@@ -1517,8 +1521,7 @@ ctf_link (ctf_file_t *fp, int flags)\n \t}\n       if (err != ECTF_NEXT_END)\n \t{\n-\t  ctf_err_warn (fp, 1, \"Iteration error creating empty CUs: %s\",\n-\t\t\tctf_errmsg (err));\n+\t  ctf_err_warn (fp, 1, err, _(\"iteration error creating empty CUs\"));\n \t  ctf_set_errno (fp, err);\n \t  return -1;\n \t}\n@@ -1823,7 +1826,7 @@ ctf_link_write (ctf_file_t *fp, size_t *size, size_t threshold)\n \tfree (arg.dynames[i]);\n       free (arg.dynames);\n     }\n-  ctf_err_warn (fp, 0, \"Cannot write archive in link: %s failure: %s\", errloc,\n-\t\tctf_errmsg (ctf_errno (fp)));\n+  ctf_err_warn (fp, 0, 0, _(\"cannot write archive in link: %s failure\"),\n+\t\terrloc);\n   return NULL;\n }"
    },
    {
      "sha": "5541c9dd4dcbae868a5b9b8d65886c609e9556e4",
      "filename": "libctf/ctf-open-bfd.c",
      "status": "modified",
      "additions": 17,
      "deletions": 14,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-open-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-open-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open-bfd.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -40,7 +40,8 @@ ctf_bfdclose (struct ctf_archive_internal *arci)\n {\n   if (arci->ctfi_abfd != NULL)\n     if (!bfd_close_all_done (arci->ctfi_abfd))\n-      ctf_dprintf (\"Cannot close BFD: %s\\n\", bfd_errmsg (bfd_get_error()));\n+      ctf_err_warn (NULL, 0, 0, _(\"cannot close BFD: %s\"),\n+\t\t    bfd_errmsg (bfd_get_error ()));\n }\n \n /* Open a CTF file given the specified BFD.  */\n@@ -62,8 +63,9 @@ ctf_bfdopen (struct bfd *abfd, int *errp)\n \n   if (!bfd_malloc_and_get_section (abfd, ctf_asect, &contents))\n     {\n-      ctf_dprintf (\"ctf_bfdopen(): cannot malloc CTF section: %s\\n\",\n-\t\t   bfd_errmsg (bfd_get_error()));\n+      ctf_err_warn (NULL, 0, 0, _(\"ctf_bfdopen(): cannot malloc \"\n+\t\t\t\t  \"CTF section: %s\"),\n+\t\t    bfd_errmsg (bfd_get_error ()));\n       return (ctf_set_open_errno (errp, ECTF_FMT));\n     }\n \n@@ -112,7 +114,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n       symcount = symhdr->sh_size / symhdr->sh_entsize;\n       if ((symtab = malloc (symhdr->sh_size)) == NULL)\n \t{\n-\t  bfderrstr = \"Cannot malloc symbol table\";\n+\t  bfderrstr = N_(\"cannot malloc symbol table\");\n \t  goto err;\n \t}\n \n@@ -121,7 +123,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n       free (isymbuf);\n       if (isymbuf == NULL)\n \t{\n-\t  bfderrstr = \"Cannot read symbol table\";\n+\t  bfderrstr = N_(\"cannot read symbol table\");\n \t  goto err_free_sym;\n \t}\n \n@@ -135,7 +137,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n \t    {\n \t      if ((strtab = bfd_elf_get_str_section (abfd, symhdr->sh_link)) == NULL)\n \t\t{\n-\t\t  bfderrstr = \"Cannot read string table\";\n+\t\t  bfderrstr = N_(\"cannot read string table\");\n \t\t  goto err_free_sym;\n \t\t}\n \t    }\n@@ -199,7 +201,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n err: _libctf_unused_;\n   if (bfderrstr)\n     {\n-      ctf_dprintf (\"ctf_bfdopen(): %s: %s\\n\", bfderrstr,\n+      ctf_err_warn (NULL, 0, 0, \"ctf_bfdopen(): %s: %s\", gettext (bfderrstr),\n \t\t   bfd_errmsg (bfd_get_error()));\n       ctf_set_open_errno (errp, ECTF_FMT);\n     }\n@@ -283,18 +285,18 @@ ctf_fdopen (int fd, const char *filename, const char *target, int *errp)\n \n   if ((abfd = bfd_fdopenr (filename, target, nfd)) == NULL)\n     {\n-      ctf_dprintf (\"Cannot open BFD from %s: %s\\n\",\n-\t\t   filename ? filename : \"(unknown file)\",\n-\t\t   bfd_errmsg (bfd_get_error()));\n+      ctf_err_warn (NULL, 0, 0, _(\"cannot open BFD from %s: %s\"),\n+\t\t    filename ? filename : _(\"(unknown file)\"),\n+\t\t    bfd_errmsg (bfd_get_error ()));\n       return (ctf_set_open_errno (errp, ECTF_FMT));\n     }\n   bfd_set_cacheable (abfd, 1);\n \n   if (!bfd_check_format (abfd, bfd_object))\n     {\n-      ctf_dprintf (\"BFD format problem in %s: %s\\n\",\n-\t\t   filename ? filename : \"(unknown file)\",\n-\t\t   bfd_errmsg (bfd_get_error()));\n+      ctf_err_warn (NULL, 0, 0, _(\"BFD format problem in %s: %s\"),\n+\t\t    filename ? filename : _(\"(unknown file)\"),\n+\t\t    bfd_errmsg (bfd_get_error ()));\n       if (bfd_get_error() == bfd_error_file_ambiguously_recognized)\n \treturn (ctf_set_open_errno (errp, ECTF_BFD_AMBIGUOUS));\n       else\n@@ -304,7 +306,8 @@ ctf_fdopen (int fd, const char *filename, const char *target, int *errp)\n   if ((arci = ctf_bfdopen (abfd, errp)) == NULL)\n     {\n       if (!bfd_close_all_done (abfd))\n-\tctf_dprintf (\"Cannot close BFD: %s\\n\", bfd_errmsg (bfd_get_error()));\n+\tctf_err_warn (NULL, 0, 0, _(\"cannot close BFD: %s\"),\n+\t\t      bfd_errmsg (bfd_get_error ()));\n       return NULL;\t\t\t/* errno is set for us.  */\n     }\n   arci->ctfi_bfd_close = ctf_bfdclose;"
    },
    {
      "sha": "8c30182616707243a049e719a7e84f0268f87b10",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 32,
      "deletions": 27,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -141,8 +141,8 @@ get_ctt_size_v2 (const ctf_file_t *fp, const ctf_type_t *tp,\n }\n \n static ssize_t\n-get_vbytes_common (unsigned short kind, ssize_t size _libctf_unused_,\n-\t\t   size_t vlen)\n+get_vbytes_common (ctf_file_t *fp, unsigned short kind,\n+\t\t   ssize_t size _libctf_unused_, size_t vlen)\n {\n   switch (kind)\n     {\n@@ -162,13 +162,14 @@ get_vbytes_common (unsigned short kind, ssize_t size _libctf_unused_,\n     case CTF_K_RESTRICT:\n       return 0;\n     default:\n-      ctf_dprintf (\"detected invalid CTF kind -- %x\\n\", kind);\n-      return ECTF_CORRUPT;\n+      ctf_set_errno (fp, ECTF_CORRUPT);\n+      ctf_err_warn (fp, 0, 0, _(\"detected invalid CTF kind: %x\"), kind);\n+      return -1;\n     }\n }\n \n static ssize_t\n-get_vbytes_v1 (unsigned short kind, ssize_t size, size_t vlen)\n+get_vbytes_v1 (ctf_file_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n {\n   switch (kind)\n     {\n@@ -184,11 +185,11 @@ get_vbytes_v1 (unsigned short kind, ssize_t size, size_t vlen)\n \treturn (sizeof (ctf_lmember_v1_t) * vlen);\n     }\n \n-  return (get_vbytes_common (kind, size, vlen));\n+  return (get_vbytes_common (fp, kind, size, vlen));\n }\n \n static ssize_t\n-get_vbytes_v2 (unsigned short kind, ssize_t size, size_t vlen)\n+get_vbytes_v2 (ctf_file_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n {\n   switch (kind)\n     {\n@@ -204,7 +205,7 @@ get_vbytes_v2 (unsigned short kind, ssize_t size, size_t vlen)\n \treturn (sizeof (ctf_lmember_t) * vlen);\n     }\n \n-  return (get_vbytes_common (kind, size, vlen));\n+  return (get_vbytes_common (fp, kind, size, vlen));\n }\n \n static const ctf_fileops_t ctf_fileops[] = {\n@@ -428,11 +429,11 @@ upgrade_types_v1 (ctf_file_t *fp, ctf_header_t *cth)\n       unsigned long vlen = CTF_V1_INFO_VLEN (tp->ctt_info);\n \n       size = get_ctt_size_v1 (fp, (const ctf_type_t *) tp, NULL, &increment);\n-      vbytes = get_vbytes_v1 (kind, size, vlen);\n+      vbytes = get_vbytes_v1 (fp, kind, size, vlen);\n \n       get_ctt_size_v2_unconverted (fp, (const ctf_type_t *) tp, NULL,\n \t\t\t\t   &v2increment);\n-      v2bytes = get_vbytes_v2 (kind, size, vlen);\n+      v2bytes = get_vbytes_v2 (fp, kind, size, vlen);\n \n       if ((vbytes < 0) || (size < 0))\n \treturn ECTF_CORRUPT;\n@@ -485,7 +486,7 @@ upgrade_types_v1 (ctf_file_t *fp, ctf_header_t *cth)\n       void *vdata, *v2data;\n \n       size = get_ctt_size_v1 (fp, (const ctf_type_t *) tp, NULL, &increment);\n-      vbytes = get_vbytes_v1 (kind, size, vlen);\n+      vbytes = get_vbytes_v1 (fp, kind, size, vlen);\n \n       t2p->ctt_name = tp->ctt_name;\n       t2p->ctt_info = CTF_TYPE_INFO (kind, isroot, vlen);\n@@ -519,7 +520,7 @@ upgrade_types_v1 (ctf_file_t *fp, ctf_header_t *cth)\n \t}\n \n       v2size = get_ctt_size_v2 (fp, t2p, NULL, &v2increment);\n-      v2bytes = get_vbytes_v2 (kind, v2size, vlen);\n+      v2bytes = get_vbytes_v2 (fp, kind, v2size, vlen);\n \n       /* Catch out-of-sync get_ctt_size_*().  The count goes wrong if\n \t these are not identical (and having them different makes no\n@@ -767,6 +768,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \n       (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n       name = ctf_strptr (fp, tp->ctt_name);\n+      /* Cannot fail: shielded by call in loop above.  */\n       vbytes = LCTF_VBYTES (fp, kind, size, vlen);\n \n       switch (kind)\n@@ -905,8 +907,8 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t    return err;\n \t  break;\n \tdefault:\n-\t  ctf_dprintf (\"unhandled CTF kind in endianness conversion -- %x\\n\",\n-\t\t       kind);\n+\t  ctf_err_warn (fp, 0, ECTF_CORRUPT,\n+\t\t\t_(\"init_types(): unhandled CTF kind: %x\"), kind);\n \t  return ECTF_CORRUPT;\n \t}\n \n@@ -1043,7 +1045,7 @@ flip_vars (void *start, size_t len)\n    ctf_stype followed by variable data.  */\n \n static int\n-flip_types (void *start, size_t len)\n+flip_types (ctf_file_t *fp, void *start, size_t len)\n {\n   ctf_type_t *t = start;\n \n@@ -1056,7 +1058,7 @@ flip_types (void *start, size_t len)\n       uint32_t kind = CTF_V2_INFO_KIND (t->ctt_info);\n       size_t size = t->ctt_size;\n       uint32_t vlen = CTF_V2_INFO_VLEN (t->ctt_info);\n-      size_t vbytes = get_vbytes_v2 (kind, size, vlen);\n+      size_t vbytes = get_vbytes_v2 (fp, kind, size, vlen);\n \n       if (_libctf_unlikely_ (size == CTF_LSIZE_SENT))\n \t{\n@@ -1181,8 +1183,9 @@ flip_types (void *start, size_t len)\n \t    break;\n \t  }\n \tdefault:\n-\t  ctf_dprintf (\"unhandled CTF kind in endianness conversion -- %x\\n\",\n-\t\t       kind);\n+\t  ctf_err_warn (fp, 0, ECTF_CORRUPT,\n+\t\t\t_(\"unhandled CTF kind in endianness conversion: %x\"),\n+\t\t\tkind);\n \t  return ECTF_CORRUPT;\n \t}\n \n@@ -1200,15 +1203,15 @@ flip_types (void *start, size_t len)\n    data, this is no real loss.  */\n \n static int\n-flip_ctf (ctf_header_t *cth, unsigned char *buf)\n+flip_ctf (ctf_file_t *fp, ctf_header_t *cth, unsigned char *buf)\n {\n   flip_lbls (buf + cth->cth_lbloff, cth->cth_objtoff - cth->cth_lbloff);\n   flip_objts (buf + cth->cth_objtoff, cth->cth_funcoff - cth->cth_objtoff);\n   flip_objts (buf + cth->cth_funcoff, cth->cth_objtidxoff - cth->cth_funcoff);\n   flip_objts (buf + cth->cth_objtidxoff, cth->cth_funcidxoff - cth->cth_objtidxoff);\n   flip_objts (buf + cth->cth_funcidxoff, cth->cth_varoff - cth->cth_funcidxoff);\n   flip_vars (buf + cth->cth_varoff, cth->cth_typeoff - cth->cth_varoff);\n-  return flip_types (buf + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n+  return flip_types (fp, buf + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n }\n \n /* Set up the ctl hashes in a ctf_file_t.  Called by both writable and\n@@ -1376,8 +1379,8 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t info.  We do not support dynamically upgrading such entries (none\n \t should exist in any case, since dwarf2ctf does not create them).  */\n \n-      ctf_dprintf (\"ctf_bufopen: CTF version %d symsect not \"\n-\t\t   \"supported\\n\", pp->ctp_version);\n+      ctf_err_warn (NULL, 0, 0, _(\"ctf_bufopen: CTF version %d symsect not \"\n+\t\t\t\t  \"supported\"), pp->ctp_version);\n       return (ctf_set_open_errno (errp, ECTF_NOTSUP));\n     }\n \n@@ -1470,16 +1473,17 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n       if ((rc = uncompress (fp->ctf_base, &dstlen, src, srclen)) != Z_OK)\n \t{\n-\t  ctf_dprintf (\"zlib inflate err: %s\\n\", zError (rc));\n+\t  ctf_err_warn (NULL, 0, ECTF_DECOMPRESS, _(\"zlib inflate err: %s\"),\n+\t\t\tzError (rc));\n \t  err = ECTF_DECOMPRESS;\n \t  goto bad;\n \t}\n \n       if ((size_t) dstlen != fp->ctf_size)\n \t{\n-\t  ctf_dprintf (\"zlib inflate short -- got %lu of %lu \"\n-\t\t       \"bytes\\n\", (unsigned long) dstlen,\n-\t\t       (unsigned long) fp->ctf_size);\n+\t  ctf_err_warn (NULL, 0, ECTF_CORRUPT,\n+\t\t\t_(\"zlib inflate short: got %lu of %lu bytes\"),\n+\t\t\t(unsigned long) dstlen, (unsigned long) fp->ctf_size);\n \t  err = ECTF_CORRUPT;\n \t  goto bad;\n \t}\n@@ -1559,7 +1563,7 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n   fp->ctf_syn_ext_strtab = syn_strtab;\n \n   if (foreign_endian &&\n-      (err = flip_ctf (hp, fp->ctf_buf)) != 0)\n+      (err = flip_ctf (fp, hp, fp->ctf_buf)) != 0)\n     {\n       /* We can be certain that flip_ctf() will have endian-flipped everything\n \t other than the types table when we return.  In particular the header\n@@ -1619,6 +1623,7 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n bad:\n   ctf_set_open_errno (errp, err);\n+  ctf_err_warn_to_open (fp);\n   ctf_file_close (fp);\n   return NULL;\n }"
    },
    {
      "sha": "837f66433c9774f3addf6eefcf732aeb89752df2",
      "filename": "libctf/ctf-string.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -427,7 +427,7 @@ ctf_str_write_strtab (ctf_file_t *fp)\n   nullstr = ctf_dynhash_lookup (fp->ctf_str_atoms, \"\");\n   if (!nullstr)\n     {\n-      ctf_dprintf (\"Internal error: null string not found in strtab.\\n\");\n+      ctf_err_warn (fp, 0, ECTF_INTERNAL, _(\"null string not found in strtab\"));\n       strtab.cts_strs = NULL;\n       return strtab;\n     }"
    },
    {
      "sha": "431b6d849f895b69f2d293a46ee1a92c7e68ca3c",
      "filename": "libctf/ctf-subr.c",
      "status": "modified",
      "additions": 72,
      "deletions": 15,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-subr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-subr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-subr.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -193,10 +193,16 @@ void ctf_dprintf (const char *format, ...)\n     }\n }\n \n-/* Errors and warnings.  */\n-_libctf_printflike_ (3, 4)\n+/* This needs more attention to thread-safety later on.  */\n+static ctf_list_t open_errors;\n+\n+/* Errors and warnings.  Report the warning or error to the list in FP (or the\n+   open errors list if NULL): if ERR is nonzero it is the errno to report to the\n+   debug stream instead of that recorded on fp.  */\n+_libctf_printflike_ (4, 5)\n extern void\n-ctf_err_warn (ctf_file_t *fp, int is_warning, const char *format, ...)\n+ctf_err_warn (ctf_file_t *fp, int is_warning, int err,\n+\t      const char *format, ...)\n {\n   va_list alist;\n   ctf_err_warning_t *cew;\n@@ -219,26 +225,68 @@ ctf_err_warn (ctf_file_t *fp, int is_warning, const char *format, ...)\n     }\n   va_end (alist);\n \n-  ctf_dprintf (\"%s: %s\\n\", is_warning ? \"error\" : \"warning\", cew->cew_text);\n+  /* Include the error code only if there is one, and if this is not a warning.\n+     (Warnings may not have a meaningful error code, since the warning may not\n+     lead to unwinding up to the user.)  */\n+  if (!is_warning && (err != 0 || (fp && ctf_errno (fp) != 0)))\n+    ctf_dprintf (\"%s: %s (%s)\\n\", is_warning ? _(\"error\") : _(\"warning\"),\n+\t\t cew->cew_text, err != 0 ? ctf_errmsg (err)\n+\t\t : ctf_errmsg (ctf_errno (fp)));\n+  else\n+    ctf_dprintf (\"%s: %s\\n\", is_warning ? _(\"error\") : _(\"warning\"),\n+\t\t cew->cew_text);\n+\n+  if (fp != NULL)\n+    ctf_list_append (&fp->ctf_errs_warnings, cew);\n+  else\n+    ctf_list_append (&open_errors, cew);\n+}\n \n-  ctf_list_append (&fp->ctf_errs_warnings, cew);\n+/* Move all the errors/warnings from an fp into the open_errors.  */\n+void\n+ctf_err_warn_to_open (ctf_file_t *fp)\n+{\n+  ctf_list_splice (&open_errors, &fp->ctf_errs_warnings);\n }\n \n /* Error-warning reporting: an 'iterator' that returns errors and warnings from\n    the error/warning list, in order of emission.  Errors and warnings are popped\n-   after return: the caller must free the returned error-text pointer.  */\n+   after return: the caller must free the returned error-text pointer.\n+\n+   An fp of NULL returns CTF-open-time errors from the open_errors variable\n+   above.\n+\n+   The treatment of errors from this function itself is somewhat unusual: it\n+   will often be called on an error path, so we don't want to overwrite the\n+   ctf_errno unless we have no choice.  So, like ctf_bufopen et al, this\n+   function takes an errp pointer where errors are reported.  The pointer is\n+   optional: if not set, errors are reported via the fp (if non-NULL).  Calls\n+   with neither fp nor errp set are mildly problematic because there is no clear\n+   way to report end-of-iteration: you just have to assume that a NULL return\n+   means the end, and not an iterator error.  */\n+\n char *\n-ctf_errwarning_next (ctf_file_t *fp, ctf_next_t **it, int *is_warning)\n+ctf_errwarning_next (ctf_file_t *fp, ctf_next_t **it, int *is_warning,\n+\t\t     int *errp)\n {\n   ctf_next_t *i = *it;\n   char *ret;\n+  ctf_list_t *errlist;\n   ctf_err_warning_t *cew;\n \n+  if (fp)\n+    errlist = &fp->ctf_errs_warnings;\n+  else\n+    errlist = &open_errors;\n+\n   if (!i)\n     {\n       if ((i = ctf_next_create ()) == NULL)\n \t{\n-\t  ctf_set_errno (fp, ENOMEM);\n+\t  if (errp)\n+\t    *errp = ENOMEM;\n+\t  else if (fp)\n+\t    ctf_set_errno (fp, ENOMEM);\n \t  return NULL;\n \t}\n \n@@ -249,30 +297,39 @@ ctf_errwarning_next (ctf_file_t *fp, ctf_next_t **it, int *is_warning)\n \n   if ((void (*) (void)) ctf_errwarning_next != i->ctn_iter_fun)\n     {\n-      ctf_set_errno (fp, ECTF_NEXT_WRONGFUN);\n+      if (errp)\n+\t*errp = ECTF_NEXT_WRONGFUN;\n+      else if (fp)\n+\tctf_set_errno (fp, ECTF_NEXT_WRONGFUN);\n       return NULL;\n     }\n \n   if (fp != i->cu.ctn_fp)\n     {\n-      ctf_set_errno (fp, ECTF_NEXT_WRONGFP);\n+      if (errp)\n+\t*errp = ECTF_NEXT_WRONGFP;\n+      else if (fp)\n+\tctf_set_errno (fp, ECTF_NEXT_WRONGFP);\n       return NULL;\n     }\n \n-  cew = ctf_list_next (&fp->ctf_errs_warnings);\n+  cew = ctf_list_next (errlist);\n \n   if (!cew)\n     {\n       ctf_next_destroy (i);\n       *it = NULL;\n-      ctf_set_errno (fp, ECTF_NEXT_END);\n+      if (errp)\n+\t*errp = ECTF_NEXT_END;\n+      else if (fp)\n+\tctf_set_errno (fp, ECTF_NEXT_END);\n       return NULL;\n     }\n \n   if (is_warning)\n     *is_warning = cew->cew_is_warning;\n   ret = cew->cew_text;\n-  ctf_list_delete (&fp->ctf_errs_warnings, cew);\n+  ctf_list_delete (errlist, cew);\n   free (cew);\n   return ret;\n }\n@@ -281,7 +338,7 @@ void\n ctf_assert_fail_internal (ctf_file_t *fp, const char *file, size_t line,\n \t\t\t  const char *exprstr)\n {\n-  ctf_err_warn (fp, 0, \"%s: %lu: libctf assertion failed: %s\", file,\n-\t\t(long unsigned int) line, exprstr);\n+  ctf_err_warn (fp, 0, ECTF_INTERNAL, _(\"%s: %lu: libctf assertion failed: %s\"),\n+\t\tfile, (long unsigned int) line, exprstr);\n   ctf_set_errno (fp, ECTF_INTERNAL);\n }"
    },
    {
      "sha": "c9fed1558dd188e79c240c52cfc6392211fc227f",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/926c9e7665707d2f2eeb705b410e485f6930ab38/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=926c9e7665707d2f2eeb705b410e485f6930ab38",
      "patch": "@@ -606,7 +606,8 @@ ctf_type_resolve (ctf_file_t *fp, ctf_id_t type)\n \t  if (tp->ctt_type == type || tp->ctt_type == otype\n \t      || tp->ctt_type == prev)\n \t    {\n-\t      ctf_dprintf (\"type %ld cycle detected\\n\", otype);\n+\t      ctf_err_warn (ofp, 0, ECTF_CORRUPT, _(\"type %lx cycle detected\"),\n+\t\t\t    otype);\n \t      return (ctf_set_errno (ofp, ECTF_CORRUPT));\n \t    }\n \t  prev = type;"
    }
  ]
}