{
  "sha": "5af6f000d88622107e7382d337af2884fd211da2",
  "node_id": "C_kwDOANOeidoAKDVhZjZmMDAwZDg4NjIyMTA3ZTczODJkMzM3YWYyODg0ZmQyMTFkYTI",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2022-01-03T05:14:46Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2022-01-12T14:04:51Z"
    },
    "message": "x86: Add DT_RELR support\n\nDT_RELR is implemented with linker relaxation:\n\n1. During linker relaxation, we scan input relocations with the same\nlogic in relocate_section to determine if a relative relocation should\nbe generated and save the relative relocation candidate information for\nsizing the DT_RELR section later after all symbols addresses can be\ndetermined.  For these relative relocations which can't be placed in\nthe DT_RELR section, they will be placed in the rela.dyn/rel.dyn\nsection.\n2. When DT_RELR is enabled, _bfd_elf_map_sections_to_segments calls a\nbackend function to size the DT_RELR section which will compute the\nDT_RELR section size and tell ldelf_map_segments to layout sections\nagain when the DT_RELR section size has been increased.\n3. After regular symbol processing is finished, bfd_elf_final_link calls\na backend function to finish the DT_RELR section.\n\n\t* elf32-i386.c (elf_i386_relocate_section): Don't generate\n\trelative relocation when DT_RELR is enabled.\n\t(elf_i386_finish_dynamic_symbol): Likewise.\n\t* elf64-x86-64.c (elf_x86_64_relocate_section): Don't generate\n\trelative relocation when DT_RELR is enabled.\n\t(elf_x86_64_finish_dynamic_symbol): Likewise.\n\t* elfxx-x86.c (_bfd_x86_elf_link_hash_table_create): Initialize\n\trelative_r_type, relative_r_name, elf_append_reloc,\n\telf_write_addend and elf_write_addend_in_got.\n\t(elf_x86_relative_reloc_record_add): New function.\n\t(_bfd_x86_elf_link_relax_section): Likewise.\n\t(elf64_dt_relr_bitmap_add): Likewise.\n\t(elf32_dt_relr_bitmap_add): Likewise.\n\t(_bfd_elf32_write_addend): Likewise.\n\t(_bfd_elf64_write_addend): Likewise.\n\t(elf_x86_size_or_finish_relative_reloc): Likewise.\n\t(elf_x86_compute_dl_relr_bitmap): Likewise.\n\t(elf_x86_write_dl_relr_bitmap): Likewise.\n\t(elf_x86_relative_reloc_compare ): Likewise.\n\t(_bfd_elf_x86_size_relative_relocs): Likewise.\n\t(_bfd_elf_x86_finish_relative_relocs): Likewise.\n\t(_bfd_x86_elf_size_dynamic_sections): Skip the .relr.dyn section.\n\t(_bfd_x86_elf_finish_dynamic_sections): Convert 3 spare dynamic\n\ttags to DT_RELR, DT_RELRSZ and for compact relative relocation.\n\t* elfxx-x86.h (X86_64_GOT_TYPE_P): New.\n\t(I386_GOT_TYPE_P): Likewise.\n\t(X86_GOT_TYPE_P): Likewise.\n\t(X86_64_RELATIVE_RELOC_TYPE_P): Likewise.\n\t(I386_RELATIVE_RELOC_TYPE_P): Likewise.\n\t(X86_RELATIVE_RELOC_TYPE_P): Likewise.\n\t(X86_LOCAL_GOT_RELATIVE_RELOC_P): Likewise.\n\t(I386_PCREL_TYPE_P): Likewise.\n\t(X86_64_PCREL_TYPE_P): Likewise.\n\t(X86_64_NEED_DYNAMIC_RELOC_TYPE_P): Rewrite.\n\t(I386_NEED_DYNAMIC_RELOC_TYPE_P): Likewise.\n\t(GENERATE_DYNAMIC_RELOCATION_P): Also check rel_from_abs.\n\t(elf_x86_link_hash_entry): Add got_relative_reloc_done.\n\t(elf_x86_relative_reloc_record): New.\n\t(elf_x86_relative_reloc_data): Likewise.\n\t(elf_dt_relr_bitmap): Likewise.\n\t(elf_x86_link_hash_table): Add dt_relr_bitmap, relative_reloc,\n\tunaligned_relative_reloc, relative_r_type, relative_r_name,\n\telf_append_reloc, elf_write_addend, elf_write_addend_in_got and\n\trelative_reloc_done.\n\t(elf_x86_relative_reloc_done): New.\n\t(relative_reloc_packed): Likewise.\n\t(_bfd_x86_elf_link_relax_section): Likewise.\n\t(_bfd_elf_x86_size_relative_relocs): Likewise.\n\t(_bfd_elf_x86_finish_relative_relocs): Likewise.\n\t(_bfd_elf32_write_addend): Likewise.\n\t(_bfd_elf64_write_addend): Likewise.\n\t(bfd_elf32_bfd_relax_section): Likewise.\n\t(bfd_elf64_bfd_relax_section): Likewise.\n\t(elf_backend_size_relative_relocs): Likewise.\n\t(elf_backend_finish_relative_relocs): Likewise.\n\t(elf_x86_allocate_local_got_info): Also allocate\n\trelative_reloc_done.",
    "tree": {
      "sha": "febc80d4b1e88ca1d383dfda5c4e72e7f6685e19",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/febc80d4b1e88ca1d383dfda5c4e72e7f6685e19"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5af6f000d88622107e7382d337af2884fd211da2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5af6f000d88622107e7382d337af2884fd211da2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5af6f000d88622107e7382d337af2884fd211da2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5af6f000d88622107e7382d337af2884fd211da2/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f2e37a5c7f8c8f761d2d86f2a69efe07503dc640",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f2e37a5c7f8c8f761d2d86f2a69efe07503dc640",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f2e37a5c7f8c8f761d2d86f2a69efe07503dc640"
    }
  ],
  "stats": {
    "total": 1252,
    "additions": 1195,
    "deletions": 57
  },
  "files": [
    {
      "sha": "25977cc56bd6b73aa75205f11943ca08592ad631",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 46,
      "deletions": 22,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5af6f000d88622107e7382d337af2884fd211da2/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5af6f000d88622107e7382d337af2884fd211da2/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=5af6f000d88622107e7382d337af2884fd211da2",
      "patch": "@@ -2473,8 +2473,10 @@ elf_i386_relocate_section (bfd *output_bfd,\n \t\t      bfd_put_32 (output_bfd, relocation,\n \t\t\t\t  htab->elf.sgot->contents + off);\n \t\t      h->got.offset |= 1;\n-\n-\t\t      if (GENERATE_RELATIVE_RELOC_P (info, h))\n+\t\t      /* NB: Don't generate relative relocation here if\n+\t\t\t it has been generated by DT_RELR.  */\n+\t\t      if (!info->enable_dt_relr\n+\t\t\t  && GENERATE_RELATIVE_RELOC_P (info, h))\n \t\t\t{\n \t\t\t  /* PR ld/21402: If this symbol isn't dynamic\n \t\t\t     in PIC, generate R_386_RELATIVE here.  */\n@@ -2504,7 +2506,9 @@ elf_i386_relocate_section (bfd *output_bfd,\n \t\t\t      htab->elf.sgot->contents + off);\n \t\t  local_got_offsets[r_symndx] |= 1;\n \n-\t\t  if (bfd_link_pic (info))\n+\t\t  /* NB: Don't generate relative relocation here if it\n+\t\t     has been generated by DT_RELR.  */\n+\t\t  if (!info->enable_dt_relr && bfd_link_pic (info))\n \t\t    relative_reloc = true;\n \t\t}\n \t    }\n@@ -2707,6 +2711,7 @@ elf_i386_relocate_section (bfd *output_bfd,\n \t    {\n \t      Elf_Internal_Rela outrel;\n \t      bool skip, relocate;\n+\t      bool generate_dynamic_reloc = true;\n \t      asection *sreloc;\n \n \t      /* When generating a shared object, these relocations\n@@ -2734,23 +2739,33 @@ elf_i386_relocate_section (bfd *output_bfd,\n \t\t{\n \t\t  /* This symbol is local, or marked to become local.  */\n \t\t  relocate = true;\n-\t\t  outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n+\t\t  /* NB: Don't generate relative relocation here if it\n+\t\t     has been generated by DT_RELR.  */\n+\t\t  if (info->enable_dt_relr)\n+\t\t    generate_dynamic_reloc = false;\n+\t\t  else\n+\t\t    {\n+\t\t      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n \n-\t\t  if (htab->params->report_relative_reloc)\n-\t\t    _bfd_x86_elf_link_report_relative_reloc\n-\t\t      (info, input_section, h, sym, \"R_386_RELATIVE\",\n-\t\t       &outrel);\n+\t\t      if (htab->params->report_relative_reloc)\n+\t\t\t_bfd_x86_elf_link_report_relative_reloc\n+\t\t\t  (info, input_section, h, sym, \"R_386_RELATIVE\",\n+\t\t\t   &outrel);\n+\t\t    }\n \t\t}\n \n-\t      sreloc = elf_section_data (input_section)->sreloc;\n-\n-\t      if (sreloc == NULL || sreloc->contents == NULL)\n+\t      if (generate_dynamic_reloc)\n \t\t{\n-\t\t  r = bfd_reloc_notsupported;\n-\t\t  goto check_relocation_error;\n-\t\t}\n+\t\t  sreloc = elf_section_data (input_section)->sreloc;\n \n-\t      elf_append_rel (output_bfd, sreloc, &outrel);\n+\t\t  if (sreloc == NULL || sreloc->contents == NULL)\n+\t\t    {\n+\t\t      r = bfd_reloc_notsupported;\n+\t\t      goto check_relocation_error;\n+\t\t    }\n+\n+\t\t  elf_append_rel (output_bfd, sreloc, &outrel);\n+\t\t}\n \n \t      /* If this reloc is against an external symbol, we do\n \t\t not want to fiddle with the addend.  Otherwise, we\n@@ -3776,6 +3791,7 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,\n       Elf_Internal_Rela rel;\n       asection *relgot = htab->elf.srelgot;\n       const char *relative_reloc_name = NULL;\n+      bool generate_dynamic_reloc = true;\n \n       /* This symbol has an entry in the global offset table.  Set it\n \t up.  */\n@@ -3858,8 +3874,13 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,\n \t       && SYMBOL_REFERENCES_LOCAL_P (info, h))\n \t{\n \t  BFD_ASSERT((h->got.offset & 1) != 0);\n-\t  rel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n-\t  relative_reloc_name = \"R_386_RELATIVE\";\n+\t  if (info->enable_dt_relr)\n+\t    generate_dynamic_reloc = false;\n+\t  else\n+\t    {\n+\t      rel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n+\t      relative_reloc_name = \"R_386_RELATIVE\";\n+\t    }\n \t}\n       else\n \t{\n@@ -3870,12 +3891,15 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,\n \t  rel.r_info = ELF32_R_INFO (h->dynindx, R_386_GLOB_DAT);\n \t}\n \n-      if (relative_reloc_name != NULL\n-\t  && htab->params->report_relative_reloc)\n-\t_bfd_x86_elf_link_report_relative_reloc\n-\t  (info, relgot, h, sym, relative_reloc_name, &rel);\n+      if (generate_dynamic_reloc)\n+\t{\n+\t  if (relative_reloc_name != NULL\n+\t      && htab->params->report_relative_reloc)\n+\t    _bfd_x86_elf_link_report_relative_reloc\n+\t      (info, relgot, h, sym, relative_reloc_name, &rel);\n \n-      elf_append_rel (output_bfd, relgot, &rel);\n+\t  elf_append_rel (output_bfd, relgot, &rel);\n+\t}\n     }\n \n   if (h->needs_copy)"
    },
    {
      "sha": "02ca55200bb2320549aaa4dd1eb03d555cadc8fc",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 55,
      "deletions": 28,
      "changes": 83,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5af6f000d88622107e7382d337af2884fd211da2/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5af6f000d88622107e7382d337af2884fd211da2/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=5af6f000d88622107e7382d337af2884fd211da2",
      "patch": "@@ -2867,7 +2867,10 @@ elf_x86_64_relocate_section (bfd *output_bfd,\n \t\t\t as -1 | 1 still is -1.  */\n \t\t      h->got.offset |= 1;\n \n-\t\t      if (GENERATE_RELATIVE_RELOC_P (info, h))\n+\t\t      /* NB: Don't generate relative relocation here if\n+\t\t\t it has been generated by DT_RELR.  */\n+\t\t      if (!info->enable_dt_relr\n+\t\t\t  && GENERATE_RELATIVE_RELOC_P (info, h))\n \t\t\t{\n \t\t\t  /* If this symbol isn't dynamic in PIC,\n \t\t\t     generate R_X86_64_RELATIVE here.  */\n@@ -2899,8 +2902,11 @@ elf_x86_64_relocate_section (bfd *output_bfd,\n \n \t\t  /* NB: GOTPCREL relocations against local absolute\n \t\t     symbol store relocation value in the GOT slot\n-\t\t     without relative relocation.  */\n-\t\t  if (bfd_link_pic (info)\n+\t\t     without relative relocation.  Don't generate\n+\t\t     relative relocation here if it has been generated\n+\t\t     by DT_RELR.  */\n+\t\t  if (!info->enable_dt_relr\n+\t\t      && bfd_link_pic (info)\n \t\t      && !(sym->st_shndx == SHN_ABS\n \t\t\t   && (r_type == R_X86_64_GOTPCREL\n \t\t\t       || r_type == R_X86_64_GOTPCRELX\n@@ -3215,6 +3221,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,\n \t    {\n \t      Elf_Internal_Rela outrel;\n \t      bool skip, relocate;\n+\t      bool generate_dynamic_reloc = true;\n \t      asection *sreloc;\n \t      const char *relative_reloc_name = NULL;\n \n@@ -3253,9 +3260,17 @@ elf_x86_64_relocate_section (bfd *output_bfd,\n \t\t\t  && htab->params->no_reloc_overflow_check))\n \t\t    {\n \t\t      relocate = true;\n-\t\t      outrel.r_info = htab->r_info (0, R_X86_64_RELATIVE);\n-\t\t      outrel.r_addend = relocation + rel->r_addend;\n-\t\t      relative_reloc_name = \"R_X86_64_RELATIVE\";\n+\t\t      /* NB: Don't generate relative relocation here if\n+\t\t\t it has been generated by DT_RELR.  */\n+\t\t      if (info->enable_dt_relr)\n+\t\t\tgenerate_dynamic_reloc = false;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  outrel.r_info =\n+\t\t\t    htab->r_info (0, R_X86_64_RELATIVE);\n+\t\t\t  outrel.r_addend = relocation + rel->r_addend;\n+\t\t\t  relative_reloc_name = \"R_X86_64_RELATIVE\";\n+\t\t\t}\n \t\t    }\n \t\t  else if (r_type == R_X86_64_64\n \t\t\t   && !ABI_64_P (output_bfd))\n@@ -3323,21 +3338,24 @@ elf_x86_64_relocate_section (bfd *output_bfd,\n \t\t    }\n \t\t}\n \n-\t      sreloc = elf_section_data (input_section)->sreloc;\n-\n-\t      if (sreloc == NULL || sreloc->contents == NULL)\n+\t      if (generate_dynamic_reloc)\n \t\t{\n-\t\t  r = bfd_reloc_notsupported;\n-\t\t  goto check_relocation_error;\n-\t\t}\n+\t\t  sreloc = elf_section_data (input_section)->sreloc;\n \n-\t      if (relative_reloc_name\n-\t\t  && htab->params->report_relative_reloc)\n-\t\t_bfd_x86_elf_link_report_relative_reloc\n-\t\t  (info, input_section, h, sym, relative_reloc_name,\n-\t\t   &outrel);\n+\t\t  if (sreloc == NULL || sreloc->contents == NULL)\n+\t\t    {\n+\t\t      r = bfd_reloc_notsupported;\n+\t\t      goto check_relocation_error;\n+\t\t    }\n \n-\t      elf_append_rela (output_bfd, sreloc, &outrel);\n+\t\t  if (relative_reloc_name\n+\t\t      && htab->params->report_relative_reloc)\n+\t\t    _bfd_x86_elf_link_report_relative_reloc\n+\t\t      (info, input_section, h, sym,\n+\t\t       relative_reloc_name, &outrel);\n+\n+\t\t  elf_append_rela (output_bfd, sreloc, &outrel);\n+\t\t}\n \n \t      /* If this reloc is against an external symbol, we do\n \t\t not want to fiddle with the addend.  Otherwise, we\n@@ -4424,6 +4442,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,\n       Elf_Internal_Rela rela;\n       asection *relgot = htab->elf.srelgot;\n       const char *relative_reloc_name = NULL;\n+      bool generate_dynamic_reloc = true;\n \n       /* This symbol has an entry in the global offset table.  Set it\n \t up.  */\n@@ -4506,11 +4525,16 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,\n \t  if (!SYMBOL_DEFINED_NON_SHARED_P (h))\n \t    return false;\n \t  BFD_ASSERT((h->got.offset & 1) != 0);\n-\t  rela.r_info = htab->r_info (0, R_X86_64_RELATIVE);\n-\t  rela.r_addend = (h->root.u.def.value\n-\t\t\t   + h->root.u.def.section->output_section->vma\n-\t\t\t   + h->root.u.def.section->output_offset);\n-\t  relative_reloc_name = \"R_X86_64_RELATIVE\";\n+\t  if (info->enable_dt_relr)\n+\t    generate_dynamic_reloc = false;\n+\t  else\n+\t    {\n+\t      rela.r_info = htab->r_info (0, R_X86_64_RELATIVE);\n+\t      rela.r_addend = (h->root.u.def.value\n+\t\t\t       + h->root.u.def.section->output_section->vma\n+\t\t\t       + h->root.u.def.section->output_offset);\n+\t      relative_reloc_name = \"R_X86_64_RELATIVE\";\n+\t    }\n \t}\n       else\n \t{\n@@ -4522,12 +4546,15 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,\n \t  rela.r_addend = 0;\n \t}\n \n-      if (relative_reloc_name != NULL\n-\t  && htab->params->report_relative_reloc)\n-\t_bfd_x86_elf_link_report_relative_reloc\n-\t  (info, relgot, h, sym, relative_reloc_name, &rela);\n+      if (generate_dynamic_reloc)\n+\t{\n+\t  if (relative_reloc_name != NULL\n+\t      && htab->params->report_relative_reloc)\n+\t    _bfd_x86_elf_link_report_relative_reloc\n+\t      (info, relgot, h, sym, relative_reloc_name, &rela);\n \n-      elf_append_rela (output_bfd, relgot, &rela);\n+\t  elf_append_rela (output_bfd, relgot, &rela);\n+\t}\n     }\n \n   if (h->needs_copy)"
    },
    {
      "sha": "119929bb093854596314648d8ab2393b66726907",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 954,
      "deletions": 0,
      "changes": 954,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5af6f000d88622107e7382d337af2884fd211da2/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5af6f000d88622107e7382d337af2884fd211da2/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=5af6f000d88622107e7382d337af2884fd211da2",
      "patch": "@@ -726,13 +726,18 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)\n       ret->got_entry_size = 8;\n       ret->pcrel_plt = true;\n       ret->tls_get_addr = \"__tls_get_addr\";\n+      ret->relative_r_type = R_X86_64_RELATIVE;\n+      ret->relative_r_name = \"R_X86_64_RELATIVE\";\n+      ret->elf_append_reloc = elf_append_rela;\n+      ret->elf_write_addend_in_got = _bfd_elf64_write_addend;\n     }\n   if (ABI_64_P (abfd))\n     {\n       ret->sizeof_reloc = sizeof (Elf64_External_Rela);\n       ret->pointer_r_type = R_X86_64_64;\n       ret->dynamic_interpreter = ELF64_DYNAMIC_INTERPRETER;\n       ret->dynamic_interpreter_size = sizeof ELF64_DYNAMIC_INTERPRETER;\n+      ret->elf_write_addend = _bfd_elf64_write_addend;\n     }\n   else\n     {\n@@ -743,6 +748,7 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)\n \t  ret->dynamic_interpreter = ELFX32_DYNAMIC_INTERPRETER;\n \t  ret->dynamic_interpreter_size\n \t    = sizeof ELFX32_DYNAMIC_INTERPRETER;\n+\t  ret->elf_write_addend = _bfd_elf32_write_addend;\n \t}\n       else\n \t{\n@@ -751,6 +757,11 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)\n \t  ret->got_entry_size = 4;\n \t  ret->pcrel_plt = false;\n \t  ret->pointer_r_type = R_386_32;\n+\t  ret->relative_r_type = R_386_RELATIVE;\n+\t  ret->relative_r_name = \"R_386_RELATIVE\";\n+\t  ret->elf_append_reloc = elf_append_rel;\n+\t  ret->elf_write_addend = _bfd_elf32_write_addend;\n+\t  ret->elf_write_addend_in_got = _bfd_elf32_write_addend;\n \t  ret->dynamic_interpreter = ELF32_DYNAMIC_INTERPRETER;\n \t  ret->dynamic_interpreter_size\n \t    = sizeof ELF32_DYNAMIC_INTERPRETER;\n@@ -977,6 +988,919 @@ _bfd_x86_elf_check_relocs (bfd *abfd,\n   return true;\n }\n \n+/* Add an entry to the relative reloc record.  */\n+\n+static bool\n+elf_x86_relative_reloc_record_add\n+  (struct bfd_link_info *info,\n+   struct elf_x86_relative_reloc_data *relative_reloc,\n+   Elf_Internal_Rela *rel, asection *sec,\n+   asection *sym_sec, struct elf_link_hash_entry *h,\n+   Elf_Internal_Sym *sym, bfd_vma offset)\n+{\n+  bfd_size_type newidx;\n+\n+  if (relative_reloc->data == NULL)\n+    {\n+      relative_reloc->data = bfd_malloc\n+\t(sizeof (struct elf_x86_relative_reloc_record));\n+      relative_reloc->count = 0;\n+      relative_reloc->size = 1;\n+    }\n+\n+  newidx = relative_reloc->count++;\n+\n+  if (relative_reloc->count > relative_reloc->size)\n+    {\n+      relative_reloc->size <<= 1;\n+      relative_reloc->data = bfd_realloc\n+\t(relative_reloc->data,\n+\t (relative_reloc->size\n+\t  * sizeof (struct elf_x86_relative_reloc_record)));\n+    }\n+\n+  if (relative_reloc->data == NULL)\n+    {\n+      info->callbacks->einfo\n+\t/* xgettext:c-format */\n+\t(_(\"%F%P: %pB: failed to allocate relative reloc record\\n\"),\n+\t info->output_bfd);\n+      return false;\n+    }\n+\n+  relative_reloc->data[newidx].rel = *rel;\n+  relative_reloc->data[newidx].sec = sec;\n+  if (h != NULL)\n+    {\n+      /* Set SYM to NULL to indicate a global symbol.  */\n+      relative_reloc->data[newidx].sym = NULL;\n+      relative_reloc->data[newidx].u.h = h;\n+    }\n+  else\n+    {\n+      relative_reloc->data[newidx].sym = sym;\n+      relative_reloc->data[newidx].u.sym_sec = sym_sec;\n+    }\n+  relative_reloc->data[newidx].offset = offset;\n+  relative_reloc->data[newidx].address = 0;\n+  return true;\n+}\n+\n+/* After input sections have been mapped to output sections and\n+   addresses of output sections are set initiallly, scan input\n+   relocations with the same logic in relocate_section to determine\n+   if a relative relocation should be generated.  Save the relative\n+   relocation candidate information for sizing the DT_RELR section\n+   later after all symbols addresses can be determined.  */\n+\n+bool\n+_bfd_x86_elf_link_relax_section (bfd *abfd ATTRIBUTE_UNUSED,\n+\t\t\t\t asection *input_section,\n+\t\t\t\t struct bfd_link_info *info,\n+\t\t\t\t bool *again)\n+{\n+  Elf_Internal_Shdr *symtab_hdr;\n+  Elf_Internal_Rela *internal_relocs;\n+  Elf_Internal_Rela *irel, *irelend;\n+  Elf_Internal_Sym *isymbuf = NULL;\n+  struct elf_link_hash_entry **sym_hashes;\n+  const struct elf_backend_data *bed;\n+  struct elf_x86_link_hash_table *htab;\n+  bfd_vma *local_got_offsets;\n+  bool is_x86_64;\n+  bool unaligned_section;\n+\n+  if (bfd_link_relocatable (info))\n+    return true;\n+\n+  /* Assume we're not going to change any sizes, and we'll only need\n+     one pass.  */\n+  *again = false;\n+\n+  bed = get_elf_backend_data (abfd);\n+  htab = elf_x86_hash_table (info, bed->target_id);\n+  if (htab == NULL)\n+    return true;\n+\n+  /* Nothing to do if there are no relocations or relative relocations\n+     have been packed.  */\n+  if (input_section == htab->elf.srelrdyn\n+      || input_section->relative_reloc_packed\n+      || ((input_section->flags & (SEC_RELOC | SEC_ALLOC))\n+\t  != (SEC_RELOC | SEC_ALLOC))\n+      || (input_section->flags & SEC_DEBUGGING) != 0\n+      || input_section->reloc_count == 0)\n+    return true;\n+\n+  /* Skip if the section isn't aligned.  */\n+  unaligned_section = input_section->alignment_power == 0;\n+\n+  is_x86_64 = bed->target_id == X86_64_ELF_DATA;\n+\n+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n+  sym_hashes = elf_sym_hashes (abfd);\n+  local_got_offsets = elf_local_got_offsets (abfd);\n+\n+  /* Load the relocations for this section.  */\n+  internal_relocs =\n+    _bfd_elf_link_read_relocs (abfd, input_section, NULL,\n+\t\t\t       (Elf_Internal_Rela *) NULL,\n+\t\t\t       info->keep_memory);\n+  if (internal_relocs == NULL)\n+    return false;\n+\n+  irelend = internal_relocs + input_section->reloc_count;\n+  for (irel = internal_relocs; irel < irelend; irel++)\n+    {\n+      unsigned int r_type;\n+      unsigned int r_symndx;\n+      Elf_Internal_Sym *isym;\n+      struct elf_link_hash_entry *h;\n+      struct elf_x86_link_hash_entry *eh;\n+      bfd_vma offset;\n+      bool resolved_to_zero;\n+      bool need_copy_reloc_in_pie;\n+      bool pc32_reloc;\n+      asection *sec;\n+      /* Offset must be a multiple of 2.  */\n+      bool unaligned_offset = (irel->r_offset & 1) != 0;\n+      /* True if there is a relative relocation against a dynamic\n+\t symbol.  */\n+      bool dynamic_relative_reloc_p;\n+\n+      /* Get the value of the symbol referred to by the reloc.  */\n+      r_symndx = htab->r_sym (irel->r_info);\n+\n+      r_type = ELF32_R_TYPE (irel->r_info);\n+      /* Clear the R_X86_64_converted_reloc_bit bit.  */\n+      r_type &= ~R_X86_64_converted_reloc_bit;\n+\n+      sec = NULL;\n+      h = NULL;\n+      dynamic_relative_reloc_p = false;\n+\n+      if (r_symndx < symtab_hdr->sh_info)\n+\t{\n+\t  /* Read this BFD's local symbols.  */\n+\t  if (isymbuf == NULL)\n+\t    {\n+\t      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;\n+\t      if (isymbuf == NULL)\n+\t\tisymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,\n+\t\t\t\t\t\tsymtab_hdr->sh_info, 0,\n+\t\t\t\t\t\tNULL, NULL, NULL);\n+\t      if (isymbuf == NULL)\n+\t\tgoto error_return;\n+\t    }\n+\n+\t  isym = isymbuf + r_symndx;\n+\t  switch (isym->st_shndx)\n+\t    {\n+\t    case SHN_ABS:\n+\t      sec = bfd_abs_section_ptr;\n+\t      break;\n+\t    case SHN_COMMON:\n+\t      sec = bfd_com_section_ptr;\n+\t      break;\n+\t    case SHN_X86_64_LCOMMON:\n+\t      if (!is_x86_64)\n+\t\tabort ();\n+\t      sec = &_bfd_elf_large_com_section;\n+\t      break;\n+\t    default:\n+\t      sec = bfd_section_from_elf_index (abfd, isym->st_shndx);\n+\t      break;\n+\t    }\n+\n+\t  /* Skip relocation against local STT_GNU_IFUNC symbol.  */\n+\t  if (ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)\n+\t    continue;\n+\n+\t  eh = (struct elf_x86_link_hash_entry *) h;\n+\t  resolved_to_zero = false;\n+\t}\n+      else\n+\t{\n+\t  /* Get H and SEC for GENERATE_DYNAMIC_RELOCATION_P below.  */\n+\t  h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n+\t  while (h->root.type == bfd_link_hash_indirect\n+\t\t || h->root.type == bfd_link_hash_warning)\n+\t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n+\n+\t  if (h->root.type == bfd_link_hash_defined\n+\t      || h->root.type == bfd_link_hash_defweak)\n+\t    sec = h->root.u.def.section;\n+\n+\t  /* Skip relocation against STT_GNU_IFUNC symbol.  */\n+\t  if (h->type == STT_GNU_IFUNC)\n+\t    continue;\n+\n+\t  eh = (struct elf_x86_link_hash_entry *) h;\n+\t  resolved_to_zero = UNDEFINED_WEAK_RESOLVED_TO_ZERO (info, eh);\n+\n+\t  /* NB: See how elf_backend_finish_dynamic_symbol is called\n+\t     from elf_link_output_extsym.  */\n+\t  if ((h->dynindx != -1 || h->forced_local)\n+\t      && ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT\n+\t\t   || h->root.type != bfd_link_hash_undefweak)\n+\t\t  || !h->forced_local)\n+\t      && h->got.offset != (bfd_vma) -1\n+\t      && ! GOT_TLS_GD_ANY_P (elf_x86_hash_entry (h)->tls_type)\n+\t      && elf_x86_hash_entry (h)->tls_type != GOT_TLS_IE\n+\t      && !resolved_to_zero\n+\t      && SYMBOL_REFERENCES_LOCAL_P (info, h)\n+\t      && SYMBOL_DEFINED_NON_SHARED_P (h))\n+\t    dynamic_relative_reloc_p = true;\n+\n+\t  isym = NULL;\n+\t}\n+\n+      if (X86_GOT_TYPE_P (is_x86_64, r_type))\n+\t{\n+\t  /* Pack GOT relative relocations.  There should be only a\n+\t     single R_*_RELATIVE relocation in GOT.  */\n+\t  if (eh != NULL)\n+\t    {\n+\t      if (eh->got_relative_reloc_done)\n+\t\tcontinue;\n+\n+\t      if (!(dynamic_relative_reloc_p\n+\t\t    || (RESOLVED_LOCALLY_P (info, h, htab)\n+\t\t\t&& GENERATE_RELATIVE_RELOC_P (info, h))))\n+\t\tcontinue;\n+\n+\t      if (!dynamic_relative_reloc_p)\n+\t\teh->no_finish_dynamic_symbol = 1;\n+\t      eh->got_relative_reloc_done = 1;\n+\t      offset = h->got.offset;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (elf_x86_relative_reloc_done (abfd)[r_symndx])\n+\t\tcontinue;\n+\n+\t      if (!X86_LOCAL_GOT_RELATIVE_RELOC_P (is_x86_64, info,\n+\t\t\t\t\t\t   isym))\n+\t\tcontinue;\n+\n+\t      elf_x86_relative_reloc_done (abfd)[r_symndx] = 1;\n+\t      offset = local_got_offsets[r_symndx];\n+\t    }\n+\n+\t  if (!elf_x86_relative_reloc_record_add (info,\n+\t\t\t\t\t\t  &htab->relative_reloc,\n+\t\t\t\t\t\t  irel, htab->elf.sgot,\n+\t\t\t\t\t\t  sec, h, isym, offset))\n+\t    goto error_return;\n+\n+\t  continue;\n+\t}\n+\n+      if (is_x86_64\n+\t  && irel->r_addend == 0\n+\t  && !ABI_64_P (info->output_bfd))\n+\t{\n+\t  /* For x32, if addend is zero, treat R_X86_64_64 like\n+\t     R_X86_64_32 and R_X86_64_SIZE64 like R_X86_64_SIZE32.  */\n+\t  if (r_type == R_X86_64_64)\n+\t    r_type = R_X86_64_32;\n+\t  else if (r_type == R_X86_64_SIZE64)\n+\t    r_type = R_X86_64_SIZE32;\n+\t}\n+\n+      if (!X86_RELATIVE_RELOC_TYPE_P (is_x86_64, r_type))\n+\tcontinue;\n+\n+      /* Pack non-GOT relative relocations.  */\n+      if (is_x86_64)\n+\t{\n+\t  need_copy_reloc_in_pie =\n+\t    (bfd_link_pie (info)\n+\t     && h != NULL\n+\t     && (h->needs_copy\n+\t\t || eh->needs_copy\n+\t\t || (h->root.type == bfd_link_hash_undefined))\n+\t     && (X86_PCREL_TYPE_P (true, r_type)\n+\t\t || X86_SIZE_TYPE_P (true, r_type)));\n+\t  pc32_reloc = false;\n+\t}\n+      else\n+\t{\n+\t  need_copy_reloc_in_pie = false;\n+\t  pc32_reloc = r_type == R_386_PC32;\n+\t}\n+\n+      if (GENERATE_DYNAMIC_RELOCATION_P (is_x86_64, info, eh, r_type,\n+\t\t\t\t\t sec, need_copy_reloc_in_pie,\n+\t\t\t\t\t resolved_to_zero, pc32_reloc))\n+\t{\n+\t  /* When generating a shared object, these relocations\n+\t     are copied into the output file to be resolved at run\n+\t     time.\t*/\n+\t  offset = _bfd_elf_section_offset (info->output_bfd, info,\n+\t\t\t\t\t    input_section,\n+\t\t\t\t\t    irel->r_offset);\n+\t  if (offset == (bfd_vma) -1\n+\t      || offset == (bfd_vma) -2\n+\t      || COPY_INPUT_RELOC_P (is_x86_64, info, h, r_type))\n+\t    continue;\n+\n+\t  /* This symbol is local, or marked to become local.  When\n+\t     relocation overflow check is disabled, we convert\n+\t     R_X86_64_32 to dynamic R_X86_64_RELATIVE.  */\n+\t  if (is_x86_64\n+\t      && !(r_type == htab->pointer_r_type\n+\t\t   || (r_type == R_X86_64_32\n+\t\t       && htab->params->no_reloc_overflow_check)))\n+\t    continue;\n+\n+\t  if (!elf_x86_relative_reloc_record_add\n+\t        (info,\n+\t\t ((unaligned_section || unaligned_offset)\n+\t\t  ? &htab->unaligned_relative_reloc\n+\t\t  : &htab->relative_reloc),\n+\t\t irel, input_section, sec, h, isym, offset))\n+\t    goto error_return;\n+\t}\n+    }\n+\n+  input_section->relative_reloc_packed = 1;\n+\n+  return true;\n+\n+error_return:\n+  if ((unsigned char *) isymbuf != symtab_hdr->contents)\n+    free (isymbuf);\n+  if (elf_section_data (input_section)->relocs != internal_relocs)\n+    free (internal_relocs);\n+  return false;\n+}\n+\n+/* Add an entry to the 64-bit DT_RELR bitmap.  */\n+\n+static void\n+elf64_dt_relr_bitmap_add\n+  (struct bfd_link_info *info, struct elf_dt_relr_bitmap *bitmap,\n+   uint64_t entry)\n+{\n+  bfd_size_type newidx;\n+\n+  if (bitmap->u.elf64 == NULL)\n+    {\n+      bitmap->u.elf64 = bfd_malloc (sizeof (uint64_t));\n+      bitmap->count = 0;\n+      bitmap->size = 1;\n+    }\n+\n+  newidx = bitmap->count++;\n+\n+  if (bitmap->count > bitmap->size)\n+    {\n+      bitmap->size <<= 1;\n+      bitmap->u.elf64 = bfd_realloc (bitmap->u.elf64,\n+\t\t\t\t     (bitmap->size * sizeof (uint64_t)));\n+    }\n+\n+  if (bitmap->u.elf64 == NULL)\n+    {\n+      info->callbacks->einfo\n+\t/* xgettext:c-format */\n+\t(_(\"%F%P: %pB: failed to allocate 64-bit DT_RELR bitmap\\n\"),\n+\t info->output_bfd);\n+    }\n+\n+  bitmap->u.elf64[newidx] = entry;\n+}\n+\n+/* Add an entry to the 32-bit DT_RELR bitmap.  */\n+\n+static void\n+elf32_dt_relr_bitmap_add\n+  (struct bfd_link_info *info, struct elf_dt_relr_bitmap *bitmap,\n+   uint32_t entry)\n+{\n+  bfd_size_type newidx;\n+\n+  if (bitmap->u.elf32 == NULL)\n+    {\n+      bitmap->u.elf32 = bfd_malloc (sizeof (uint32_t));\n+      bitmap->count = 0;\n+      bitmap->size = 1;\n+    }\n+\n+  newidx = bitmap->count++;\n+\n+  if (bitmap->count > bitmap->size)\n+    {\n+      bitmap->size <<= 1;\n+      bitmap->u.elf32 = bfd_realloc (bitmap->u.elf32,\n+\t\t\t\t     (bitmap->size * sizeof (uint32_t)));\n+    }\n+\n+  if (bitmap->u.elf32 == NULL)\n+    {\n+      info->callbacks->einfo\n+\t/* xgettext:c-format */\n+\t(_(\"%F%P: %pB: failed to allocate 32-bit DT_RELR bitmap\\n\"),\n+\t info->output_bfd);\n+    }\n+\n+  bitmap->u.elf32[newidx] = entry;\n+}\n+\n+void\n+_bfd_elf32_write_addend (bfd *abfd, uint64_t value, void *addr)\n+{\n+  bfd_put_32 (abfd, value, addr);\n+}\n+\n+void\n+_bfd_elf64_write_addend (bfd *abfd, uint64_t value, void *addr)\n+{\n+  bfd_put_64 (abfd, value, addr);\n+}\n+\n+/* Size or finish relative relocations to determine the run-time\n+   addresses for DT_RELR bitmap computation later.  OUTREL is set\n+   to NULL in the sizing phase and non-NULL in the finising phase\n+   where the regular relative relocations will be written out.  */\n+\n+static void\n+elf_x86_size_or_finish_relative_reloc\n+  (bool is_x86_64, struct bfd_link_info *info,\n+   struct elf_x86_link_hash_table *htab, bool unaligned,\n+   Elf_Internal_Rela *outrel)\n+{\n+  unsigned int align_mask;\n+  bfd_size_type i, count;\n+  asection *sec, *srel;\n+  struct elf_link_hash_entry *h;\n+  bfd_vma offset;\n+  Elf_Internal_Sym *sym;\n+  asection *sym_sec;\n+  asection *sgot = htab->elf.sgot;\n+  asection *srelgot = htab->elf.srelgot;\n+  struct elf_x86_relative_reloc_data *relative_reloc;\n+\n+  if (unaligned)\n+    {\n+      align_mask = 0;\n+      relative_reloc = &htab->unaligned_relative_reloc;\n+    }\n+  else\n+    {\n+      align_mask = 1;\n+      relative_reloc = &htab->relative_reloc;\n+    }\n+\n+  count = relative_reloc->count;\n+  for (i = 0; i < count; i++)\n+    {\n+      sec = relative_reloc->data[i].sec;\n+      sym = relative_reloc->data[i].sym;\n+\n+      /* If SYM is NULL, it must be a global symbol.  */\n+      if (sym == NULL)\n+\th = relative_reloc->data[i].u.h;\n+      else\n+\th = NULL;\n+\n+      if (is_x86_64)\n+\t{\n+\t  bfd_vma relocation;\n+\t  /* This function may be called more than once and REL may be\n+\t     updated by _bfd_elf_rela_local_sym below.  */\n+\t  Elf_Internal_Rela rel = relative_reloc->data[i].rel;\n+\n+\t  if (h != NULL)\n+\t    {\n+\t      if (h->root.type == bfd_link_hash_defined\n+\t\t  || h->root.type == bfd_link_hash_defweak)\n+\t\t{\n+\t\t  sym_sec = h->root.u.def.section;\n+\t\t  relocation = (h->root.u.def.value\n+\t\t\t\t+ sym_sec->output_section->vma\n+\t\t\t\t+ sym_sec->output_offset);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Allow undefined symbol only at the sizing phase.  */\n+\t\t  if (outrel == NULL)\n+\t\t    relocation = 0;\n+\t\t  else\n+\t\t    abort ();\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      sym_sec = relative_reloc->data[i].u.sym_sec;\n+\t      relocation = _bfd_elf_rela_local_sym\n+\t\t(info->output_bfd, sym, &sym_sec, &rel);\n+\t    }\n+\n+\t  if (outrel != NULL)\n+\t    {\n+\t      outrel->r_addend = relocation;\n+\t      if (sec == sgot)\n+\t\t{\n+\t\t  if (h != NULL && h->needs_plt)\n+\t\t    abort ();\n+\t\t}\n+\t      else\n+\t\toutrel->r_addend += rel.r_addend;\n+\n+\t      /* Write the implicit addend if ALIGN_MASK isn't 0.  */\n+\t      if (align_mask)\n+\t\t{\n+\t\t  if (sec == sgot)\n+\t\t    {\n+\t\t      if (relative_reloc->data[i].offset >= sec->size)\n+\t\t\tabort ();\n+\t\t      htab->elf_write_addend_in_got\n+\t\t\t(info->output_bfd, outrel->r_addend,\n+\t\t\t sec->contents + relative_reloc->data[i].offset);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (rel.r_offset >= sec->size)\n+\t\t\tabort ();\n+\t\t      htab->elf_write_addend\n+\t\t\t(info->output_bfd, outrel->r_addend,\n+\t\t\t (elf_section_data (sec)->this_hdr.contents\n+\t\t\t  + rel.r_offset));\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (sec == sgot)\n+\tsrel = srelgot;\n+      else\n+\tsrel = elf_section_data (sec)->sreloc;\n+      offset = (sec->output_section->vma + sec->output_offset\n+\t\t+ relative_reloc->data[i].offset);\n+      relative_reloc->data[i].address = offset;\n+      if (outrel != NULL)\n+\t{\n+\t  outrel->r_offset = offset;\n+\n+\t  if ((outrel->r_offset & align_mask) != 0)\n+\t    abort ();\n+\n+\t  if (htab->params->report_relative_reloc)\n+\t    _bfd_x86_elf_link_report_relative_reloc\n+\t      (info, sec, h, sym, htab->relative_r_name, outrel);\n+\n+\t  /* Generate regular relative relocation if ALIGN_MASK is 0.  */\n+\t  if (align_mask == 0)\n+\t    htab->elf_append_reloc (info->output_bfd, srel, outrel);\n+\t}\n+    }\n+}\n+\n+/* Compute the DT_RELR section size.  Set NEED_PLAYOUT to true if\n+   the DT_RELR section size has been increased.  */\n+\n+static void\n+elf_x86_compute_dl_relr_bitmap\n+  (struct bfd_link_info *info, struct elf_x86_link_hash_table *htab,\n+   bool *need_layout)\n+{\n+  bfd_vma base;\n+  bfd_size_type i, count, new_count;\n+  struct elf_x86_relative_reloc_data *relative_reloc =\n+    &htab->relative_reloc;\n+  /* Save the old DT_RELR bitmap count.  Don't shrink the DT_RELR bitmap\n+     if the new DT_RELR bitmap count is smaller than the old one.  Pad\n+     with trailing 1s which won't be decoded to more relocations.  */\n+  bfd_size_type dt_relr_bitmap_count = htab->dt_relr_bitmap.count;\n+\n+  /* Clear the DT_RELR bitmap count.  */\n+  htab->dt_relr_bitmap.count = 0;\n+\n+  count = relative_reloc->count;\n+\n+  if (ABI_64_P (info->output_bfd))\n+    {\n+      /* Compute the 64-bit DT_RELR bitmap.  */\n+      i = 0;\n+      while (i < count)\n+\t{\n+\t  if ((relative_reloc->data[i].address % 1) != 0)\n+\t    abort ();\n+\n+\t  elf64_dt_relr_bitmap_add (info, &htab->dt_relr_bitmap,\n+\t\t\t\t    relative_reloc->data[i].address);\n+\n+\t  base = relative_reloc->data[i].address + 8;\n+\t  i++;\n+\n+\t  while (i < count)\n+\t    {\n+\t      uint64_t bitmap = 0;\n+\t      for (; i < count; i++)\n+\t\t{\n+\t\t  bfd_vma delta = (relative_reloc->data[i].address\n+\t\t\t\t   - base);\n+\t\t  /* Stop if it is too far from base.  */\n+\t\t  if (delta >= 63 * 8)\n+\t\t    break;\n+\t\t  /* Stop if it isn't a multiple of 8.  */\n+\t\t  if ((delta % 8) != 0)\n+\t\t    break;\n+\t\t  bitmap |= 1ULL << (delta / 8);\n+\t\t}\n+\n+\t      if (bitmap == 0)\n+\t\tbreak;\n+\n+\t      elf64_dt_relr_bitmap_add (info, &htab->dt_relr_bitmap,\n+\t\t\t\t\t(bitmap << 1) | 1);\n+\n+\t      base += 63 * 8;\n+\t    }\n+\t}\n+\n+      new_count = htab->dt_relr_bitmap.count;\n+      if (dt_relr_bitmap_count > new_count)\n+\t{\n+\t  /* Don't shrink the DT_RELR section size to avoid section\n+\t     layout oscillation.  Instead, pad the DT_RELR bitmap with\n+\t     1s which do not decode to more relocations.  */\n+\n+\t  htab->dt_relr_bitmap.count = dt_relr_bitmap_count;\n+\t  count = dt_relr_bitmap_count - new_count;\n+\t  for (i = 0; i < count; i++)\n+\t    htab->dt_relr_bitmap.u.elf64[new_count + i] = 1;\n+\t}\n+    }\n+  else\n+    {\n+      /* Compute the 32-bit DT_RELR bitmap.  */\n+      i = 0;\n+      while (i < count)\n+\t{\n+\t  if ((relative_reloc->data[i].address % 1) != 0)\n+\t    abort ();\n+\n+\t  elf32_dt_relr_bitmap_add (info, &htab->dt_relr_bitmap,\n+\t\t\t\t    relative_reloc->data[i].address);\n+\n+\t  base = relative_reloc->data[i].address + 4;\n+\t  i++;\n+\n+\t  while (i < count)\n+\t    {\n+\t      uint32_t bitmap = 0;\n+\t      for (; i < count; i++)\n+\t\t{\n+\t\t  bfd_vma delta = (relative_reloc->data[i].address\n+\t\t\t\t   - base);\n+\t\t  /* Stop if it is too far from base.  */\n+\t\t  if (delta >= 31 * 4)\n+\t\t    break;\n+\t\t  /* Stop if it isn't a multiple of 4.  */\n+\t\t  if ((delta % 4) != 0)\n+\t\t    break;\n+\t\t  bitmap |= 1ULL << (delta / 4);\n+\t\t}\n+\n+\t      if (bitmap == 0)\n+\t\tbreak;\n+\n+\t      elf32_dt_relr_bitmap_add (info, &htab->dt_relr_bitmap,\n+\t\t\t\t\t(bitmap << 1) | 1);\n+\n+\t      base += 31 * 4;\n+\t    }\n+\t}\n+\n+      new_count = htab->dt_relr_bitmap.count;\n+      if (dt_relr_bitmap_count > new_count)\n+\t{\n+\t  /* Don't shrink the DT_RELR section size to avoid section\n+\t     layout oscillation.  Instead, pad the DT_RELR bitmap with\n+\t     1s which do not decode to more relocations.  */\n+\n+\t  htab->dt_relr_bitmap.count = dt_relr_bitmap_count;\n+\t  count = dt_relr_bitmap_count - new_count;\n+\t  for (i = 0; i < count; i++)\n+\t    htab->dt_relr_bitmap.u.elf32[new_count + i] = 1;\n+\t}\n+    }\n+\n+  if (htab->dt_relr_bitmap.count != dt_relr_bitmap_count)\n+    {\n+      if (need_layout)\n+\t{\n+\t  /* The .relr.dyn section size is changed.  Update the section\n+\t     size and tell linker to layout sections again.  */\n+\t  htab->elf.srelrdyn->size =\n+\t    (htab->dt_relr_bitmap.count\n+\t     * (ABI_64_P (info->output_bfd) ? 8 : 4));\n+\n+\t  *need_layout = true;\n+\t}\n+      else\n+\tinfo->callbacks->einfo\n+\t  /* xgettext:c-format */\n+\t  (_(\"%F%P: %pB: size of compact relative reloc section is \"\n+\t     \"changed: new (%lu) != old (%lu)\\n\"),\n+\t   info->output_bfd, htab->dt_relr_bitmap.count,\n+\t   dt_relr_bitmap_count);\n+    }\n+}\n+\n+/* Write out the DT_RELR section.  */\n+\n+static void\n+elf_x86_write_dl_relr_bitmap (struct bfd_link_info *info,\n+\t\t\t      struct elf_x86_link_hash_table *htab)\n+{\n+  asection *sec = htab->elf.srelrdyn;\n+  bfd_size_type size = sec->size;\n+  bfd_size_type i;\n+  unsigned char *contents;\n+\n+  contents = (unsigned char *) bfd_alloc (sec->owner, size);\n+  if (contents == NULL)\n+    info->callbacks->einfo\n+      /* xgettext:c-format */\n+      (_(\"%F%P: %pB: failed to allocate compact relative reloc section\\n\"),\n+       info->output_bfd);\n+\n+  /* Cache the section contents for elf_link_input_bfd.  */\n+  sec->contents = contents;\n+\n+  if (ABI_64_P (info->output_bfd))\n+    for (i = 0; i < htab->dt_relr_bitmap.count; i++, contents += 8)\n+      bfd_put_64 (info->output_bfd, htab->dt_relr_bitmap.u.elf64[i],\n+\t\t  contents);\n+  else\n+    for (i = 0; i < htab->dt_relr_bitmap.count; i++, contents += 4)\n+      bfd_put_32 (info->output_bfd, htab->dt_relr_bitmap.u.elf32[i],\n+\t\t  contents);\n+}\n+\n+/* Sort relative relocations by address.  */\n+\n+static int\n+elf_x86_relative_reloc_compare (const void *pa, const void *pb)\n+{\n+  struct elf_x86_relative_reloc_record *a =\n+    (struct elf_x86_relative_reloc_record *) pa;\n+  struct elf_x86_relative_reloc_record *b =\n+    (struct elf_x86_relative_reloc_record *) pb;\n+  if (a->address < b->address)\n+    return -1;\n+  if (a->address > b->address)\n+    return 1;\n+  return 0;\n+}\n+\n+bool\n+_bfd_elf_x86_size_relative_relocs (struct bfd_link_info *info,\n+\t\t\t\t   bool *need_layout)\n+{\n+  struct elf_x86_link_hash_table *htab;\n+  const struct elf_backend_data *bed;\n+  bool is_x86_64;\n+  bfd_size_type i, count, unaligned_count;\n+  asection *sec, *srel;\n+\n+  /* Do nothing for ld -r.  */\n+  if (bfd_link_relocatable (info))\n+    return true;\n+\n+  bed = get_elf_backend_data (info->output_bfd);\n+  htab = elf_x86_hash_table (info, bed->target_id);\n+  if (htab == NULL)\n+    return false;\n+\n+  count = htab->relative_reloc.count;\n+  unaligned_count = htab->unaligned_relative_reloc.count;\n+  if (count == 0)\n+    {\n+      if (htab->generate_relative_reloc_pass == 0\n+\t  && htab->elf.srelrdyn != NULL)\n+\t{\n+\t  /* Remove the empty .relr.dyn sections now.  */\n+\t  if (!bfd_is_abs_section (htab->elf.srelrdyn->output_section))\n+\t    {\n+\t      bfd_section_list_remove\n+\t\t(info->output_bfd, htab->elf.srelrdyn->output_section);\n+\t      info->output_bfd->section_count--;\n+\t    }\n+\t  bfd_section_list_remove (htab->elf.srelrdyn->owner,\n+\t\t\t\t   htab->elf.srelrdyn);\n+\t  htab->elf.srelrdyn->owner->section_count--;\n+\t}\n+      if (unaligned_count == 0)\n+\t{\n+\t  htab->generate_relative_reloc_pass++;\n+\t  return true;\n+\t}\n+    }\n+\n+  is_x86_64 = bed->target_id == X86_64_ELF_DATA;\n+\n+  /* Size relative relocations.  */\n+  if (htab->generate_relative_reloc_pass)\n+    {\n+      /* Reset the regular relative relocation count.  */\n+      for (i = 0; i < unaligned_count; i++)\n+\t{\n+\t  sec = htab->unaligned_relative_reloc.data[i].sec;\n+\t  srel = elf_section_data (sec)->sreloc;\n+\t  srel->reloc_count = 0;\n+\t}\n+    }\n+  else\n+    {\n+      /* Remove the reserved space for compact relative relocations.  */\n+      if (count)\n+\t{\n+\t  asection *sgot = htab->elf.sgot;\n+\t  asection *srelgot = htab->elf.srelgot;\n+\n+\t  for (i = 0; i < count; i++)\n+\t    {\n+\t      sec = htab->relative_reloc.data[i].sec;\n+\t      if (sec == sgot)\n+\t\tsrel = srelgot;\n+\t      else\n+\t\tsrel = elf_section_data (sec)->sreloc;\n+\t      srel->size -= htab->sizeof_reloc;\n+\t    }\n+\t}\n+    }\n+\n+  /* Size unaligned relative relocations.  */\n+  if (unaligned_count)\n+    elf_x86_size_or_finish_relative_reloc (is_x86_64, info, htab,\n+\t\t\t\t\t   true, NULL);\n+\n+  if (count)\n+    {\n+      elf_x86_size_or_finish_relative_reloc (is_x86_64, info, htab,\n+\t\t\t\t\t     false, NULL);\n+\n+      /* Sort relative relocations by addresses.  We only need to\n+\t sort them in the first pass since the relative positions\n+\t won't change.  */\n+      if (htab->generate_relative_reloc_pass == 0)\n+\tqsort (htab->relative_reloc.data, count,\n+\t       sizeof (struct elf_x86_relative_reloc_record),\n+\t       elf_x86_relative_reloc_compare);\n+\n+      elf_x86_compute_dl_relr_bitmap (info, htab, need_layout);\n+    }\n+\n+  htab->generate_relative_reloc_pass++;\n+\n+  return true;\n+}\n+\n+bool\n+_bfd_elf_x86_finish_relative_relocs (struct bfd_link_info *info)\n+{\n+  struct elf_x86_link_hash_table *htab;\n+  const struct elf_backend_data *bed;\n+  Elf_Internal_Rela outrel;\n+  bool is_x86_64;\n+  bfd_size_type count;\n+\n+  /* Do nothing for ld -r.  */\n+  if (bfd_link_relocatable (info))\n+    return true;\n+\n+  bed = get_elf_backend_data (info->output_bfd);\n+  htab = elf_x86_hash_table (info, bed->target_id);\n+  if (htab == NULL)\n+    return false;\n+\n+  is_x86_64 = bed->target_id == X86_64_ELF_DATA;\n+\n+  outrel.r_info = htab->r_info (0, htab->relative_r_type);\n+\n+  if (htab->unaligned_relative_reloc.count)\n+    elf_x86_size_or_finish_relative_reloc (is_x86_64, info, htab,\n+\t\t\t\t\t   true, &outrel);\n+\n+  count = htab->relative_reloc.count;\n+  if (count)\n+    {\n+      elf_x86_size_or_finish_relative_reloc (is_x86_64, info, htab,\n+\t\t\t\t\t     false, &outrel);\n+\n+      elf_x86_compute_dl_relr_bitmap (info, htab, NULL);\n+\n+      elf_x86_write_dl_relr_bitmap (info, htab);\n+    }\n+\n+  return true;\n+}\n+\n bool\n _bfd_elf_x86_valid_reloc_p (asection *input_section,\n \t\t\t    struct bfd_link_info *info,\n@@ -1332,6 +2256,11 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n       if ((s->flags & SEC_LINKER_CREATED) == 0)\n \tcontinue;\n \n+      /* The .relr.dyn section for compact relative relocation will\n+\t be filled later.  */\n+      if (s == htab->elf.srelrdyn)\n+\tcontinue;\n+\n       if (s == htab->elf.splt\n \t  || s == htab->elf.sgot)\n \t{\n@@ -1459,6 +2388,7 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,\n   asection *sdyn;\n   bfd_byte *dyncon, *dynconend;\n   bfd_size_type sizeof_dyn;\n+  bfd_size_type dt_relr_bitmap_count;\n \n   bed = get_elf_backend_data (output_bfd);\n   htab = elf_x86_hash_table (info, bed->target_id);\n@@ -1517,6 +2447,8 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,\n   if (sdyn == NULL || htab->elf.sgot == NULL)\n     abort ();\n \n+  dt_relr_bitmap_count = htab->dt_relr_bitmap.count;\n+\n   sizeof_dyn = bed->s->sizeof_dyn;\n   dyncon = sdyn->contents;\n   dynconend = sdyn->contents + sdyn->size;\n@@ -1535,6 +2467,28 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,\n \t    break;\n \t  continue;\n \n+\tcase DT_NULL:\n+\t  if (dt_relr_bitmap_count != 0)\n+\t    {\n+\t      /* Convert 3 spare dynamic tags to DT_RELR, DT_RELRSZ and\n+\t\t DT_RELRENT for compact relative relocation.  */\n+\t      s = htab->elf.srelrdyn;\n+\t      dyn.d_tag = DT_RELR;\n+\t      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;\n+\t      (*bed->s->swap_dyn_out) (output_bfd, &dyn, dyncon);\n+\t      dyncon += sizeof_dyn;\n+\t      dyn.d_tag = DT_RELRSZ;\n+\t      dyn.d_un.d_val = s->size;\n+\t      (*bed->s->swap_dyn_out) (output_bfd, &dyn, dyncon);\n+\t      dyncon += sizeof_dyn;\n+\t      dyn.d_tag = DT_RELRENT;\n+\t      dyn.d_un.d_val = ABI_64_P (output_bfd) ? 8 : 4;\n+\t      elf_section_data (s->output_section)->this_hdr.sh_entsize\n+\t\t= dyn.d_un.d_val;\n+\t      dt_relr_bitmap_count = 0;\n+\t    }\n+\t  break;\n+\n \tcase DT_PLTGOT:\n \t  s = htab->elf.sgotplt;\n \t  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;"
    },
    {
      "sha": "4b5784ca08a168608fa05ee9b7526ecb027ddadd",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 140,
      "deletions": 7,
      "changes": 147,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5af6f000d88622107e7382d337af2884fd211da2/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5af6f000d88622107e7382d337af2884fd211da2/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=5af6f000d88622107e7382d337af2884fd211da2",
      "patch": "@@ -47,30 +47,59 @@\n #define X86_SIZE_TYPE_P(IS_X86_64, TYPE) \\\n   ((IS_X86_64) ? X86_64_SIZE_TYPE_P(TYPE) : I386_SIZE_TYPE_P (TYPE))\n \n-#define X86_64_NEED_DYNAMIC_RELOC_TYPE_P(TYPE) \\\n-  (X86_64_SIZE_TYPE_P (TYPE) \\\n-   || X86_64_PCREL_TYPE_P (TYPE) \\\n+#define X86_64_GOT_TYPE_P(TYPE) \\\n+  ((TYPE) == R_X86_64_GOTPCREL \\\n+   || (TYPE) == R_X86_64_GOTPCRELX \\\n+   || (TYPE) == R_X86_64_REX_GOTPCRELX)\n+#define I386_GOT_TYPE_P(TYPE) \\\n+  ((TYPE) == R_386_GOT32 || (TYPE) == R_386_GOT32X)\n+#define X86_GOT_TYPE_P(IS_X86_64, TYPE) \\\n+  ((IS_X86_64) ? X86_64_GOT_TYPE_P (TYPE) : I386_GOT_TYPE_P (TYPE))\n+\n+#define X86_64_RELATIVE_RELOC_TYPE_P(TYPE) \\\n+  (X86_64_PCREL_TYPE_P (TYPE) \\\n    || (TYPE) == R_X86_64_8 \\\n    || (TYPE) == R_X86_64_16 \\\n    || (TYPE) == R_X86_64_32 \\\n    || (TYPE) == R_X86_64_32S \\\n    || (TYPE) == R_X86_64_64)\n+#define I386_RELATIVE_RELOC_TYPE_P(TYPE) \\\n+  ((TYPE) == R_386_32 || (TYPE) == R_386_PC32)\n+#define X86_RELATIVE_RELOC_TYPE_P(IS_X86_64, TYPE) \\\n+  ((IS_X86_64) \\\n+   ? X86_64_RELATIVE_RELOC_TYPE_P (TYPE) \\\n+   : I386_RELATIVE_RELOC_TYPE_P(TYPE))\n+\n+#define X86_64_NEED_DYNAMIC_RELOC_TYPE_P(TYPE) \\\n+  (X86_64_SIZE_TYPE_P (TYPE) \\\n+   || X86_64_RELATIVE_RELOC_TYPE_P (TYPE))\n #define I386_NEED_DYNAMIC_RELOC_TYPE_P(TYPE) \\\n   (I386_SIZE_TYPE_P (TYPE) \\\n-   || I386_PCREL_TYPE_P (TYPE) \\\n-   || (TYPE) == R_386_32 \\\n+   || I386_RELATIVE_RELOC_TYPE_P (TYPE) \\\n    || (TYPE) == R_386_TLS_LE \\\n    || (TYPE) == R_386_TLS_LE_32)\n #define X86_NEED_DYNAMIC_RELOC_TYPE_P(IS_X86_64, TYPE) \\\n   ((IS_X86_64) \\\n    ? X86_64_NEED_DYNAMIC_RELOC_TYPE_P (TYPE) \\\n    : I386_NEED_DYNAMIC_RELOC_TYPE_P (TYPE))\n \n+#define X86_LOCAL_GOT_RELATIVE_RELOC_P(IS_X86_64, INFO, SYM) \\\n+  (bfd_link_pic (INFO) \\\n+   && (!(IS_X86_64) || ((SYM) != NULL && (SYM)->st_shndx != SHN_ABS)))\n+\n #define PLT_CIE_LENGTH\t\t20\n #define PLT_FDE_LENGTH\t\t36\n #define PLT_FDE_START_OFFSET\t4 + PLT_CIE_LENGTH + 8\n #define PLT_FDE_LEN_OFFSET\t4 + PLT_CIE_LENGTH + 12\n \n+#define I386_PCREL_TYPE_P(TYPE) ((TYPE) == R_386_PC32)\n+#define X86_64_PCREL_TYPE_P(TYPE) \\\n+  ((TYPE) == R_X86_64_PC8 \\\n+   || (TYPE) == R_X86_64_PC16 \\\n+   || (TYPE) == R_X86_64_PC32 \\\n+   || (TYPE) == R_X86_64_PC32_BND \\\n+   || (TYPE) == R_X86_64_PC64)\n+\n #define ABI_64_P(abfd) \\\n   (get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)\n \n@@ -160,12 +189,18 @@\n    relocations against resolved undefined weak symbols in PIE, except\n    when PC32_RELOC is TRUE.  Undefined weak symbol is bound locally\n    when PIC is false.  Don't generate dynamic relocations against\n-   non-preemptible absolute symbol.  */\n+   non-preemptible absolute symbol.  NB: rel_from_abs is set on symbols\n+   defined by linker scripts from \"dot\" (also SEGMENT_START or ORIGIN)\n+   outside of an output section statement, which will be converted from\n+   absolute to section-relative in set_sym_sections called from\n+   ldexp_finalize_syms after ldemul_finish.   */\n #define GENERATE_DYNAMIC_RELOCATION_P(IS_X86_64, INFO, EH, R_TYPE, \\\n \t\t\t\t      SEC, NEED_COPY_RELOC_IN_PIE, \\\n \t\t\t\t      RESOLVED_TO_ZERO, PC32_RELOC) \\\n   ((bfd_link_pic (INFO) \\\n     && !(bfd_is_abs_section (SEC) \\\n+\t && ((EH) == NULL \\\n+\t     || (EH)->elf.root.rel_from_abs == 0) \\\n \t && ((EH) == NULL \\\n \t     || SYMBOL_REFERENCES_LOCAL (INFO, &(EH)->elf))) \\\n     && !(NEED_COPY_RELOC_IN_PIE) \\\n@@ -302,6 +337,10 @@ struct elf_x86_link_hash_entry\n   /* Don't call finish_dynamic_symbol on this symbol.  */\n   unsigned int no_finish_dynamic_symbol : 1;\n \n+  /* R_*_RELATIVE relocation in GOT for this symbol has been\n+     processed.  */\n+  unsigned int got_relative_reloc_done : 1;\n+\n   /* TRUE if symbol is __tls_get_addr.  */\n   unsigned int tls_get_addr : 1;\n \n@@ -481,6 +520,52 @@ struct elf_x86_plt_layout\n #define elf_x86_hash_entry(ent) \\\n   ((struct elf_x86_link_hash_entry *)(ent))\n \n+/* Information of an input relocation used to compute its contribution\n+   to the DT_RELR section size.  */\n+\n+struct elf_x86_relative_reloc_record\n+{\n+  /* The original relocation info.  */\n+  Elf_Internal_Rela rel;\n+  /* The input or the GOT section where the relocation is applied.  */\n+  asection *sec;\n+  /* Local symbol info.  NULL for global symbol.  */\n+  Elf_Internal_Sym *sym;\n+  union\n+    {\n+      /* Section where the local symbol is defined.  */\n+      asection *sym_sec;\n+      /* Global symbol hash.  */\n+      struct elf_link_hash_entry *h;\n+    } u;\n+  /* The offset into the output section where the relative relocation\n+     will be applied at run-time.  */\n+  bfd_vma offset;\n+  /* The run-time address.  */\n+  bfd_vma address;\n+};\n+\n+struct elf_x86_relative_reloc_data\n+{\n+  bfd_size_type count;\n+  bfd_size_type size;\n+  struct elf_x86_relative_reloc_record *data;\n+};\n+\n+/* DT_RELR bitmap.  */\n+struct elf_dt_relr_bitmap\n+{\n+  bfd_size_type count;\n+  bfd_size_type size;\n+  union\n+    {\n+      /* 32-bit bitmap.  */\n+      uint32_t *elf32;\n+      /* 64-bit bitmap.  */\n+      uint64_t *elf64;\n+    } u;\n+};\n+\n /* x86 ELF linker hash table.  */\n \n struct elf_x86_link_hash_table\n@@ -533,6 +618,18 @@ struct elf_x86_link_hash_table\n      is only used for i386.  */\n   bfd_vma next_tls_desc_index;\n \n+  /* DT_RELR bitmap.  */\n+  struct elf_dt_relr_bitmap dt_relr_bitmap;\n+\n+  /* Relative relocation data.  */\n+  struct elf_x86_relative_reloc_data relative_reloc;\n+\n+  /* Unaligned relative relocation data.  */\n+  struct elf_x86_relative_reloc_data unaligned_relative_reloc;\n+\n+  /* Number of relative reloc generation pass.  */\n+  unsigned int generate_relative_reloc_pass;\n+\n    /* Value used to fill the unused bytes of the first PLT entry.  This\n       is only used for i386.  */\n   bfd_byte plt0_pad_byte;\n@@ -554,9 +651,14 @@ struct elf_x86_link_hash_table\n   unsigned int sizeof_reloc;\n   unsigned int got_entry_size;\n   unsigned int pointer_r_type;\n+  unsigned int relative_r_type;\n   int dynamic_interpreter_size;\n   const char *dynamic_interpreter;\n   const char *tls_get_addr;\n+  const char *relative_r_name;\n+  void (*elf_append_reloc) (bfd *, asection *, Elf_Internal_Rela *);\n+  void (*elf_write_addend) (bfd *, uint64_t, void *);\n+  void (*elf_write_addend_in_got) (bfd *, uint64_t, void *);\n \n   /* Options passed from the linker.  */\n   struct elf_linker_x86_params *params;\n@@ -591,6 +693,10 @@ struct elf_x86_obj_tdata\n \n   /* GOTPLT entries for TLS descriptors.  */\n   bfd_vma *local_tlsdesc_gotent;\n+\n+  /* R_*_RELATIVE relocation in GOT for this local symbol has been\n+     processed.  */\n+  char *relative_reloc_done;\n };\n \n enum elf_x86_plt_type\n@@ -626,6 +732,9 @@ struct elf_x86_plt\n #define elf_x86_local_tlsdesc_gotent(abfd) \\\n   (elf_x86_tdata (abfd)->local_tlsdesc_gotent)\n \n+#define elf_x86_relative_reloc_done(abfd) \\\n+  (elf_x86_tdata (abfd)->relative_reloc_done)\n+\n #define elf_x86_compute_jump_table_size(htab) \\\n   ((htab)->elf.srelplt->reloc_count * (htab)->got_entry_size)\n \n@@ -637,6 +746,7 @@ struct elf_x86_plt\n /* Rename some of the generic section flags to better document how they\n    are used here.  */\n #define check_relocs_failed\tsec_flg0\n+#define relative_reloc_packed\tsec_flg1\n \n extern bool _bfd_x86_elf_mkobject\n   (bfd *);\n@@ -676,6 +786,18 @@ extern bool _bfd_x86_elf_check_relocs\n   (bfd *, struct bfd_link_info *, asection *,\n    const Elf_Internal_Rela *);\n \n+extern bool _bfd_x86_elf_link_relax_section\n+  (bfd *, asection *, struct bfd_link_info *, bool *);\n+\n+extern bool _bfd_elf_x86_size_relative_relocs\n+  (struct bfd_link_info *, bool *);\n+\n+extern bool _bfd_elf_x86_finish_relative_relocs\n+  (struct bfd_link_info *);\n+\n+extern void _bfd_elf32_write_addend (bfd *, uint64_t, void *);\n+extern void _bfd_elf64_write_addend (bfd *, uint64_t, void *);\n+\n extern bool _bfd_elf_x86_valid_reloc_p\n   (asection *, struct bfd_link_info *, struct elf_x86_link_hash_table *,\n    const Elf_Internal_Rela *, struct elf_link_hash_entry *,\n@@ -752,6 +874,10 @@ extern void _bfd_x86_elf_link_report_relative_reloc\n   _bfd_x86_elf_link_check_relocs\n #define bfd_elf32_bfd_link_check_relocs \\\n   _bfd_x86_elf_link_check_relocs\n+#define bfd_elf32_bfd_relax_section \\\n+  _bfd_x86_elf_link_relax_section\n+#define bfd_elf64_bfd_relax_section \\\n+  _bfd_x86_elf_link_relax_section\n \n #define elf_backend_check_relocs \\\n   _bfd_x86_elf_check_relocs\n@@ -777,6 +903,10 @@ extern void _bfd_x86_elf_link_report_relative_reloc\n   _bfd_x86_elf_merge_gnu_properties\n #define elf_backend_fixup_gnu_properties \\\n   _bfd_x86_elf_link_fixup_gnu_properties\n+#define elf_backend_size_relative_relocs \\\n+  _bfd_elf_x86_size_relative_relocs\n+#define elf_backend_finish_relative_relocs \\\n+  _bfd_elf_x86_finish_relative_relocs\n \n #define ELF_P_ALIGN ELF_MINPAGESIZE\n \n@@ -789,7 +919,8 @@ elf_x86_allocate_local_got_info (bfd *abfd, bfd_size_type count)\n   if (local_got_refcounts == NULL)\n     {\n       bfd_size_type size = count * (sizeof (bfd_signed_vma)\n-\t\t\t\t    + sizeof (bfd_vma) + sizeof(char));\n+\t\t\t\t    + sizeof (bfd_vma)\n+\t\t\t\t    + 2 * sizeof(char));\n       local_got_refcounts = (bfd_signed_vma *) bfd_zalloc (abfd, size);\n       if (local_got_refcounts == NULL)\n \treturn false;\n@@ -798,6 +929,8 @@ elf_x86_allocate_local_got_info (bfd *abfd, bfd_size_type count)\n \t(bfd_vma *) (local_got_refcounts + count);\n       elf_x86_local_got_tls_type (abfd) =\n \t(char *) (local_got_refcounts + 2 * count);\n+      elf_x86_relative_reloc_done (abfd) =\n+\t((char *) (local_got_refcounts + 2 * count)) + count;\n     }\n   return true;\n }"
    }
  ]
}