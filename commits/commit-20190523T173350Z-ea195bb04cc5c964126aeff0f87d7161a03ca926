{
  "sha": "ea195bb04cc5c964126aeff0f87d7161a03ca926",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWExOTViYjA0Y2M1Yzk2NDEyNmFlZmYwZjg3ZDcxNjFhMDNjYTkyNg==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-05-23T17:03:59Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-05-23T17:33:50Z"
    },
    "message": "cpu: add eBPF cpu description\n\nThis patch adds a CPU description for the Linux kernel eBPF virtual\nmachine, plus supporting code for disassembler and assembler.\n\ncpu/ChangeLog:\n\n2019-05-23  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\n\t* bpf.cpu: New file.\n\t* bpf.opc: Likewise.",
    "tree": {
      "sha": "460e3677c9b35ad26bdee3c876619b3fffa42e14",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/460e3677c9b35ad26bdee3c876619b3fffa42e14"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ea195bb04cc5c964126aeff0f87d7161a03ca926",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea195bb04cc5c964126aeff0f87d7161a03ca926",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ea195bb04cc5c964126aeff0f87d7161a03ca926",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea195bb04cc5c964126aeff0f87d7161a03ca926/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fd0de36e274c8141a5dd4579cd04856dc88370da",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd0de36e274c8141a5dd4579cd04856dc88370da",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fd0de36e274c8141a5dd4579cd04856dc88370da"
    }
  ],
  "stats": {
    "total": 843,
    "additions": 843,
    "deletions": 0
  },
  "files": [
    {
      "sha": "b573c69da346348b2d0d2330e6e3e6c0e12d6332",
      "filename": "cpu/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea195bb04cc5c964126aeff0f87d7161a03ca926/cpu/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea195bb04cc5c964126aeff0f87d7161a03ca926/cpu/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/ChangeLog?ref=ea195bb04cc5c964126aeff0f87d7161a03ca926",
      "patch": "@@ -1,3 +1,8 @@\n+2019-05-23  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* bpf.cpu: New file.\n+\t* bpf.opc: Likewise.\n+\n 2018-06-24  Nick Clifton  <nickc@redhat.com>\n \n \t2.32 branch created."
    },
    {
      "sha": "85bac2152f5fa1d88103d540920163ad578a8f5d",
      "filename": "cpu/bpf.cpu",
      "status": "added",
      "additions": 647,
      "deletions": 0,
      "changes": 647,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea195bb04cc5c964126aeff0f87d7161a03ca926/cpu/bpf.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea195bb04cc5c964126aeff0f87d7161a03ca926/cpu/bpf.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/bpf.cpu?ref=ea195bb04cc5c964126aeff0f87d7161a03ca926",
      "patch": "@@ -0,0 +1,647 @@\n+;; Linux BPF CPU description  -*- Scheme -*-\n+;; Copyright (C) 2019 Free Software Foundation, Inc.\n+;;\n+;; Contributed by Oracle Inc.\n+;;\n+;; This file is part of the GNU Binutils and of GDB.\n+;;\n+;; This program is free software; you can redistribute it and/or\n+;; modify it under the terms of the GNU General Public License as\n+;; published by the Free Software Foundation; either version 3 of the\n+;; License, or (at your option) any later version.\n+;;\n+;; This program is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with this program; if not, write to the Free Software\n+;; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; This file contains a CGEN CPU description for the Linux kernel eBPF\n+;; instruction set.  eBPF is documented in the linux kernel source\n+;; tree.  See linux/Documentation/networking/filter.txt, and also the\n+;; sources in the networking subsystem, notably\n+;; linux/net/core/filter.c.\n+\n+(include \"simplify.inc\")\n+\n+(define-arch\n+  (name bpf)\n+  (comment \"Linux kernel BPF\")\n+  (insn-lsb0? #t)\n+  (machs bpf)\n+  (isas ebpfle ebpfbe))\n+\n+;;;; The ISAs\n+\n+;; Logically, eBPF comforms a single instruction set featuring two\n+;; kind of instructions: 64-bit instructions and 128-bit instructions.\n+;;\n+;; The 64-bit instructions have the form:\n+;;\n+;;      code:8 regs:8 offset:16 imm:32\n+;;\n+;; Whereas the 128-bit instructions (at the moment there is only one\n+;; of such instructions, lddw) have the form:\n+;;\n+;;      code:8 regs:8 offset:16 imm:32 imm:32 unused:32\n+;;\n+;; In both formats `regs' is itself composed by two fields:\n+;;\n+;;      dst:4 src:4\n+;;\n+;; The ISA is supposed to be orthogonal to endianness: the endianness\n+;; of the instruction fields follow the endianness of the host running\n+;; the eBPF program, and that's all.  However, this is not entirely\n+;; true.  The definition of an eBPF code in the Linux kernel is:\n+;;\n+;; struct bpf_insn {\n+;;\t__u8\tcode;\t\t/* opcode */\n+;;\t__u8\tdst_reg:4;\t/* dest register */\n+;;\t__u8\tsrc_reg:4;\t/* source register */\n+;;\t__s16\toff;\t\t/* signed offset */\n+;;\t__s32\timm;\t\t/* signed immediate constant */\n+;; };\n+;;\n+;; Since the ordering of fields in C bitmaps is defined by the\n+;; implementation, the impact of endianness in the encoding of eBPF\n+;; instructions is effectively defined by GCC.  In particular, GCC\n+;; places dst_reg before src_reg in little-endian code, and the other\n+;; way around in big-endian code.\n+;;\n+;; So, in reality, eBPF comprises two instruction sets: one for\n+;; little-endian with instructions like:\n+;;\n+;;   code:8 src:4 dst:4 offset:16 imm:32 [unused:32 imm:32]\n+;;\n+;; and another for big-endian with instructions like:\n+;;\n+;;   code:8 dst:4 src:4 offset:16 imm:32 [unused:32 imm:32]\n+;;\n+;; where `offset' and the immediate fields are encoded in\n+;; little-endian and big-endian byte-order, respectively.\n+\n+(define-pmacro (define-bpf-isa x-endian)\n+  (define-isa\n+    (name (.sym ebpf x-endian))\n+    (comment \"The eBPF instruction set\")\n+    ;; Default length to record in ifields.  This is used in\n+    ;; calculations involving bit numbers.\n+    (default-insn-word-bitsize 64)\n+    ;; Length of an unknown instruction.  Used by disassembly and by the\n+    ;; simulator's invalid insn handler.\n+    (default-insn-bitsize 64)\n+    ;; Number of bits of insn that can be initially fetched.  XXX this\n+    ;; should be 64 (the size of the smallest insn) but until CGEN\n+    ;; gets fixed to place constant fields in their own words, we have\n+    ;; to use this workaround to avoid the opcode byte to be placed at\n+    ;; the wrong side of the instruction when assembling in\n+    ;; big-endian.\n+    (base-insn-bitsize 8)))\n+\n+(define-bpf-isa le)\n+(define-bpf-isa be)\n+\n+(define-pmacro all-isas () (ISA ebpfle,ebpfbe))\n+\n+;;;; Hardware Hierarchy\n+\n+;;\n+;;     bpf         architecture\n+;;      |\n+;;    bpfbf        cpu-family\n+;;      |\n+;;     bpf         machine\n+;;      |\n+;;   bpf-def       model\n+\n+(define-cpu\n+  (name bpfbf)\n+  (comment \"Linux kernel eBPF virtual CPU\")\n+  (word-bitsize 32))\n+\n+(define-mach\n+  (name bpf)\n+  (comment \"Linux eBPF\")\n+  (cpu bpfbf)\n+  (isas ebpfle ebpfbe))\n+\n+(define-model\n+  (name bpf-def)\n+  (comment \"Linux eBPF default model\")\n+  (mach bpf)\n+  (unit u-exec \"execution unit\" ()\n+    1 ; issue\n+    1 ; done\n+    () ; state\n+    () ; inputs\n+    () ; outputs\n+    () ; profile action (default)\n+    ))\n+\n+;;;; Hardware Elements\n+\n+;; eBPF programs can access 10 general-purpose registers which are\n+;; 64-bit.\n+\n+(define-hardware\n+  (name h-gpr)\n+  (comment \"General Purpose Registers\")\n+  (attrs all-isas (MACH bpf))\n+  (type register DI (16))\n+  (indices keyword \"%\"\n+           ;; XXX the frame pointer fp is read-only, so it should\n+           ;; go in a different hardware.\n+           (;; ABI names.  Take priority when disassembling.\n+            (a 0) (r1 1) (r2 2) (r3 3) (r4 4) (r5 5) (ctx 6)\n+            (r7 7) (r8 8) (r9 9) (fp 10)\n+            ;; Additional names recognized when assembling.\n+            (r0 0) (r6 6) (r10 10))))\n+\n+;; The program counter.  CGEN requires it, even if it is not visible\n+;; to eBPF programs.\n+\n+(dnh h-pc \"program counter\" (PC PROFILE) (pc) () () ())\n+\n+;; A 64-bit h-sint to be used by the imm64 operand below.  XXX this\n+;; shouldn't be needed, as h-sint is supposed to be able to hold\n+;; 64-bit values.  However, in practice CGEN limits h-sint to 32 bits\n+;; in 32-bit hosts.  To be fixed in CGEN.\n+\n+(dnh h-sint64 \"signed 64-bit integer\" (all-isas) (immediate DI)\n+     () () ())\n+\n+;;;; The Instruction Sets\n+\n+;;; Fields and Opcodes\n+\n+;; Convenience macro to shorten the definition of the fields below.\n+(define-pmacro (dwf x-name x-comment x-attrs\n+                    x-word-offset x-word-length x-start x-length\n+                    x-mode)\n+  \"Define a field including its containing word.\"\n+  (define-ifield\n+    (name x-name)\n+    (comment x-comment)\n+    (.splice attrs (.unsplice x-attrs))\n+    (word-offset x-word-offset)\n+    (word-length x-word-length)\n+    (start x-start)\n+    (length x-length)\n+    (mode x-mode)))\n+\n+;; For arithmetic and jump instructions the 8-bit code field is\n+;; subdivided in:\n+;;\n+;;  op-code:4 op-src:1 op-class:3\n+\n+(dwf f-op-code \"eBPF opcode code\" (all-isas) 0 8 7 4 UINT)\n+(dwf f-op-src \"eBPF opcode source\" (all-isas) 0 8 3 1 UINT)\n+(dwf f-op-class \"eBPF opcode instruction class\" (all-isas) 0 8 2 3 UINT)\n+\n+(define-normal-insn-enum insn-op-code-alu \"eBPF instruction codes\"\n+  (all-isas) OP_CODE_ f-op-code\n+  (;; Codes for OP_CLASS_ALU and OP_CLASS_ALU64\n+   (ADD #x0) (SUB #x1) (MUL #x2) (DIV #x3) (OR #x4) (AND #x5)\n+   (LSH #x6) (RSH #x7) (NEG #x8) (MOD #x9) (XOR #xa) (MOV #xb)\n+   (ARSH #xc) (END #xd)\n+   ;; Codes for OP_CLASS_JMP\n+   (JA #x0) (JEQ #x1) (JGT #x2) (JGE #x3) (JSET #x4)\n+   (JNE #x5) (JSGT #x6) (JSGE #x7) (CALL #x8) (EXIT #x9)\n+   (JLT #xa) (JLE #xb) (JSLT #xc) (JSLE #xd)))\n+\n+(define-normal-insn-enum insn-op-src \"eBPF instruction source\"\n+  (all-isas) OP_SRC_ f-op-src\n+  ;; X => use `src' as source operand.\n+  ;; K => use `imm32' as source operand.\n+  ((K #b0) (X #b1)))\n+\n+(define-normal-insn-enum insn-op-class \"eBPF instruction class\"\n+  (all-isas) OP_CLASS_ f-op-class\n+  ((LD    #b000) (LDX   #b001) (ST    #b010) (STX   #b011)\n+   (ALU   #b100) (JMP   #b101) (ALU64 #b111)))\n+\n+;; For load/store instructions, the 8-bit code field is subdivided in:\n+;;\n+;; op-mode:3 op-size:2 op-class:3\n+\n+(dwf f-op-mode \"eBPF opcode mode\" (all-isas) 0 8 7 3 UINT)\n+(dwf f-op-size \"eBPF opcode size\" (all-isas) 0 8 4 2 UINT)\n+\n+(define-normal-insn-enum insn-op-mode \"eBPF load/store instruction modes\"\n+  (all-isas) OP_MODE_ f-op-mode\n+  ((IMM #b000) (ABS #b001) (IND #b010) (MEM #b011)\n+   ;; #b100 and #b101 are used in classic BPF only, reserved in eBPF.\n+   (XADD #b110)))\n+\n+(define-normal-insn-enum insn-op-size \"eBPF load/store instruction sizes\"\n+  (all-isas) OP_SIZE_ f-op-size\n+  ((W  #b00)   ;; Word:        4 byte\n+   (H  #b01)   ;; Half-word:   2 byte\n+   (B  #b10)   ;; Byte:        1 byte\n+   (DW #b11))) ;; Double-word: 8 byte\n+\n+;; The fields for the source and destination registers are a bit\n+;; tricky.  Due to the bizarre nibble swap between little-endian and\n+;; big-endian ISAs we need to keep different variants of the fields.\n+;;\n+;; Note that f-regs is used in the format spec of instructions that do\n+;; NOT use registers, where endianness is irrelevant i.e. f-regs is a\n+;; constant 0 opcode.\n+\n+(dwf f-dstle \"eBPF dst register field\" ((ISA ebpfle)) 8 8 3 4 UINT)\n+(dwf f-srcle \"eBPF source register field\" ((ISA ebpfle)) 8 8 7 4 UINT)\n+\n+(dwf f-dstbe \"eBPF dst register field\" ((ISA ebpfbe)) 8 8 7 4 UINT)\n+(dwf f-srcbe \"eBPF source register field\" ((ISA ebpfbe)) 8 8 3 4 UINT)\n+\n+(dwf f-regs \"eBPF registers field\" (all-isas) 8 8 7 8 UINT)\n+\n+;; Finally, the fields for the immediates.\n+;;\n+;; The 16-bit offsets and 32-bit immediates do not present any special\n+;; difficulty: we put them in their own instruction word so the\n+;; byte-endianness will be properly applied.\n+\n+(dwf f-offset16 \"eBPF offset field\" (all-isas) 16 16 15 16 INT)\n+(dwf f-imm32 \"eBPF 32-bit immediate field\" (all-isas) 32 32 31 32 INT)\n+\n+;; For the disjoint 64-bit signed immediate, however, we need to use a\n+;; multi-ifield.\n+\n+(dwf f-imm64-a \"eBPF 64-bit immediate a\" (all-isas) 32 32 31 32 UINT)\n+(dwf f-imm64-b \"eBPF 64-bit immediate b\" (all-isas) 64 32 31 32 UINT)\n+(dwf f-imm64-c \"eBPF 64-bit immediate c\" (all-isas) 96 32 31 32 UINT)\n+\n+(define-multi-ifield\n+  (name f-imm64)\n+  (comment \"eBPF 64-bit immediate field\")\n+  (attrs all-isas)\n+  (mode DI)\n+  (subfields f-imm64-a f-imm64-b f-imm64-c)\n+  (insert (sequence ()\n+                    (set (ifield f-imm64-b) (const 0))\n+                    (set (ifield f-imm64-c) (srl (ifield f-imm64) (const 32)))\n+                    (set (ifield f-imm64-a) (and (ifield f-imm64) (const #xffffffff)))))\n+  (extract (sequence ()\n+                     (set (ifield f-imm64)\n+                          (or (sll DI (zext DI (ifield f-imm64-c)) (const 32))\n+                              (zext DI (ifield f-imm64-a)))))))\n+\n+;;; Operands\n+\n+;; A couple of source and destination register operands are defined\n+;; for each ISA: ebpfle and ebpfbe.\n+\n+(dno dstle \"destination register\" ((ISA ebpfle)) h-gpr f-dstle)\n+(dno srcle \"source register\" ((ISA ebpfle)) h-gpr f-srcle)\n+\n+(dno dstbe \"destination register\" ((ISA ebpfbe)) h-gpr f-dstbe)\n+(dno srcbe \"source register\" ((ISA ebpfbe)) h-gpr f-srcbe)\n+\n+;; Jump instructions have a 16-bit PC-relative address.\n+;; CALL instructions have a 32-bit PC-relative address.\n+\n+(dno disp16 \"16-bit PC-relative address\" (all-isas PCREL-ADDR) h-sint\n+     f-offset16)\n+(dno disp32 \"32-bit PC-relative address\" (all-isas PCREL-ADDR) h-sint\n+     f-imm32)\n+\n+;; Immediate operands in eBPF are signed, and we want the disassembler\n+;; to print negative values in a sane way.  Therefore we use the macro\n+;; below to register a printer, which is itself defined as a C\n+;; function in bpf.opc.\n+\n+;; define-normal-signed-immediate-operand\n+(define-pmacro (dnsio x-name x-comment x-attrs x-type x-index)\n+  (define-operand\n+    (name x-name)\n+    (comment x-comment)\n+    (.splice attrs (.unsplice x-attrs))\n+    (type x-type)\n+    (index x-index)\n+    (handlers (print \"immediate\"))))\n+\n+(dnsio imm32 \"32-bit immediate\" (all-isas) h-sint f-imm32)\n+(dnsio offset16 \"16-bit offset\" (all-isas) h-sint f-offset16)\n+\n+;; The 64-bit immediate cannot use the default\n+;; cgen_parse_signed_integer, because it assumes operands are at much\n+;; 32-bit wide.  Use our own.\n+\n+(define-operand\n+  (name imm64)\n+  (comment \"64-bit immediate\")\n+  (attrs all-isas)\n+  (type h-sint64)\n+  (index f-imm64)\n+  (handlers (parse \"imm64\") (print \"immediate\")))\n+\n+;; The endle/endbe instructions take an operand to specify the word\n+;; width in endianness conversions.  We use both a parser and printer,\n+;; which are defined as C functions in bpf.opc.\n+\n+(define-operand\n+  (name endsize)\n+  (comment \"endianness size immediate: 16, 32 or 64\")\n+  (attrs all-isas)\n+  (type h-uint)\n+  (index f-imm32)\n+  (handlers (parse \"endsize\") (print \"endsize\")))\n+\n+;;; ALU instructions\n+\n+;; For each opcode in insn-op-code-alu representing and integer\n+;; arithmetic instruction (ADD, SUB, etc) we define a bunch of\n+;; instruction variants:\n+;;\n+;;   ADD[32]{i,r}le for the little-endian ISA\n+;;   ADD[32]{i,r}be for the big-endian ISA\n+;;\n+;; The `i' variants perform `src OP dst -> dst' operations.\n+;; The `r' variants perform `dst OP imm32 -> dst' operations.\n+;;\n+;; The variants with 32 in their name are of ALU class.  Otherwise\n+;; they are ALU64 class.\n+\n+(define-pmacro (define-alu-insn-un x-basename x-suffix x-op-class x-op-code x-endian)\n+  (dni (.sym x-basename x-suffix x-endian)\n+       (.str x-basename x-suffix)\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str x-basename x-suffix \" $dst\" x-endian)\n+       (+ (f-imm32 0) (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n+          x-op-class OP_SRC_X x-op-code) () ()))\n+\n+(define-pmacro (define-alu-insn-bin x-basename x-suffix x-op-class x-op-code x-endian)\n+  (begin\n+    (dni (.sym x-basename x-suffix \"i\" x-endian)\n+         (.str x-basename x-suffix \" immediate\")\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str x-basename x-suffix \" $dst\" x-endian \",$imm32\")\n+         (+ imm32 (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n+            x-op-class OP_SRC_K x-op-code) () ())\n+    (dni (.sym x-basename x-suffix \"r\" x-endian)\n+         (.str x-basename x-suffix \" register\")\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str x-basename x-suffix \" $dst\" x-endian \",$src\" x-endian)\n+         (+ (f-imm32 0) (f-offset16 0) (.sym src x-endian) (.sym dst x-endian)\n+            x-op-class OP_SRC_X x-op-code) () ())))\n+\n+(define-pmacro (daiu x-basename x-op-code x-endian)\n+  (begin\n+    (define-alu-insn-un x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian)\n+    (define-alu-insn-un x-basename \"32\" OP_CLASS_ALU x-op-code x-endian)))\n+\n+(define-pmacro (daib x-basename x-op-code x-endian)\n+  (begin\n+    (define-alu-insn-bin x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian)\n+    (define-alu-insn-bin x-basename \"32\" OP_CLASS_ALU x-op-code x-endian)))\n+\n+(define-pmacro (define-alu-instructions x-endian)\n+  (begin\n+    (daib add OP_CODE_ADD x-endian)\n+    (daib sub OP_CODE_SUB x-endian)\n+    (daib mul OP_CODE_MUL x-endian)\n+    (daib div OP_CODE_DIV x-endian)\n+    (daib or  OP_CODE_OR x-endian)\n+    (daib and OP_CODE_AND x-endian)\n+    (daib lsh OP_CODE_LSH x-endian)\n+    (daib rsh OP_CODE_RSH x-endian)\n+    (daib mod OP_CODE_MOD x-endian)\n+    (daib xor OP_CODE_XOR x-endian)\n+    (daib mov OP_CODE_MOV x-endian)\n+    (daib arsh OP_CODE_ARSH x-endian)\n+    (daiu neg OP_CODE_NEG x-endian)))\n+\n+(define-alu-instructions le)\n+(define-alu-instructions be)\n+\n+;;; Endianness conversion instructions\n+\n+;; The endianness conversion instructions come in several variants:\n+;;\n+;;  END{le,be}le for the little-endian ISA\n+;;  END{le,be}be for the big-endian ISA\n+;;\n+;; Please do not be confused by the repeated `be' and `le' here.  Each\n+;; ISA has both endle and endbe instructions.  It is the disposition\n+;; of the source and destination register fields that change between\n+;; ISAs, not the semantics of the instructions themselves (see section\n+;; \"The ISAs\" above in this very file.)\n+\n+(define-pmacro (define-endian-insn x-suffix x-op-src x-endian)\n+  (dni (.sym \"end\" x-suffix x-endian)\n+       (.str \"end\" x-suffix \" register\")\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str \"end\" x-suffix \" $dst\" x-endian \",$endsize\")\n+       (+  (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian) endsize\n+           OP_CLASS_ALU x-op-src OP_CODE_END) () ()))\n+\n+(define-endian-insn \"le\" OP_SRC_K le)\n+(define-endian-insn \"be\" OP_SRC_X le)\n+(define-endian-insn \"le\" OP_SRC_K be)\n+(define-endian-insn \"be\" OP_SRC_X be)\n+\n+;;; Load/Store instructions\n+\n+;; The lddw instruction takes a 64-bit immediate as an operand.  Since\n+;; this instruction also takes a `dst' operand, we need to define a\n+;; variant for each ISA:\n+;;\n+;;  LDDWle for the little-endian ISA\n+;;  LDDWbe for the big-endian ISA  \n+\n+(define-pmacro (define-lddw x-endian)\n+  (dni (.sym lddw x-endian)\n+       (.str \"lddw\" x-endian)\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str \"lddw $dst\" x-endian \",$imm64\")\n+       (+ imm64 (f-offset16 0) ((.sym f-src x-endian) 0)\n+          (.sym dst x-endian)\n+          OP_CLASS_LD OP_SIZE_DW OP_MODE_IMM) () ()))\n+\n+(define-lddw le)\n+(define-lddw be)\n+\n+;; The absolute/indirect load instructions are non-generic loads\n+;; designed to be used in socket filters.  They come in several\n+;; variants:\n+;;\n+;; LD{abs,ind}{w,h,b,dw}le for the little-endian ISA\n+;; LD{abs,ind}[w,h,b,dw}be for the big-endian ISA\n+\n+(define-pmacro (dlsi x-basename x-suffix x-class x-size x-mode x-endian)\n+  (dni (.sym x-basename x-suffix x-endian)\n+       (.str x-basename x-suffix)\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str x-basename x-suffix \" $dst\" x-endian \",$src\" x-endian \",$imm32\")\n+       (+ imm32 (f-offset16 0) (.sym src x-endian) (.sym dst x-endian)\n+          (.sym OP_CLASS_ x-class) (.sym OP_SIZE_ x-size)\n+          (.sym OP_MODE_ x-mode)) () ()))\n+\n+(define-pmacro (define-ldabsind x-endian)\n+  (begin\n+    (dlsi \"ldabs\" \"w\" LD W ABS x-endian)\n+    (dlsi \"ldabs\" \"h\" LD H ABS x-endian)\n+    (dlsi \"ldabs\" \"b\" LD B ABS x-endian)\n+    (dlsi \"ldabs\" \"dw\" LD DW ABS x-endian)\n+    \n+    (dlsi \"ldind\" \"w\" LD W IND x-endian)\n+    (dlsi \"ldind\" \"h\" LD H IND x-endian)\n+    (dlsi \"ldind\" \"b\" LD B IND x-endian)\n+    (dlsi \"ldind\" \"dw\" LD DW IND x-endian)))\n+\n+(define-ldabsind le)\n+(define-ldabsind be)\n+\n+;; Generic load and store instructions are provided for several word\n+;; sizes.  They come in several variants:\n+;;\n+;;  LDX{b,h,w,dw}le, STX{b,h,w,dw}le for the little-endian ISA\n+;;\n+;;  LDX{b,h,w,dw}be, STX{b,h,w,dw}be for the big-endian ISA\n+;;\n+;; Loads operate on [$SRC+-OFFSET] -> $DST\n+;; Stores operate on $SRC -> [$DST+-OFFSET]\n+\n+(define-pmacro (dxli x-basename x-suffix x-size x-endian)\n+  (dni (.sym x-basename x-suffix x-endian)\n+       (.str x-basename x-suffix)\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str x-basename x-suffix \" $dst\" x-endian \",[$src\" x-endian \"+$offset16]\")\n+       (+ (f-imm32 0) offset16 (.sym src x-endian) (.sym dst x-endian)\n+          OP_CLASS_LDX (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n+       () ()))\n+\n+(define-pmacro (dxsi x-basename x-suffix x-size x-endian)\n+  (dni (.sym x-basename x-suffix x-endian)\n+       (.str x-basename x-suffix)\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str x-basename x-suffix \" [$dst\" x-endian \"+$offset16],$src\" x-endian)\n+       (+ (f-imm32 0) offset16 (.sym src x-endian) (.sym dst x-endian)\n+          OP_CLASS_STX (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n+       () ()))\n+\n+(define-pmacro (define-ldstx-insns x-endian)\n+  (begin\n+    (dxli \"ldx\" \"w\" W x-endian)\n+    (dxli \"ldx\" \"h\" H x-endian)\n+    (dxli \"ldx\" \"b\" B x-endian)\n+    (dxli \"ldx\" \"dw\" DW x-endian)\n+\n+    (dxsi \"stx\" \"w\" W x-endian)\n+    (dxsi \"stx\" \"h\" H x-endian)\n+    (dxsi \"stx\" \"b\" B x-endian)\n+    (dxsi \"stx\" \"dw\" DW x-endian)))\n+\n+(define-ldstx-insns le)\n+(define-ldstx-insns be)\n+\n+;; Generic store instructions of the form IMM32 -> [$DST+OFFSET] are\n+;; provided in several variants:\n+;;\n+;;  ST{b,h,w,dw}le for the little-endian ISA\n+;;  ST{b,h,w,dw}be for the big-endian ISA\n+\n+(define-pmacro (dsti x-suffix x-size x-endian)\n+  (dni (.sym \"st\" x-suffix x-endian)\n+       (.str \"st\" x-suffix)\n+       ((ISA (.sym ebpf x-endian)))\n+       (.str \"st\" x-suffix \" [$dst\" x-endian \"+$offset16],$imm32\")\n+       (+ imm32 offset16 ((.sym f-src x-endian) 0) (.sym dst x-endian)\n+          OP_CLASS_ST (.sym OP_SIZE_ x-size) OP_MODE_MEM) () ()))\n+\n+(define-pmacro (define-st-insns x-endian)\n+  (begin\n+    (dsti \"b\" B x-endian)\n+    (dsti \"h\" H x-endian)\n+    (dsti \"w\" W x-endian)\n+    (dsti \"dw\" DW x-endian)))\n+\n+(define-st-insns le)\n+(define-st-insns be)\n+\n+;;; Jump instructions\n+\n+;; Compare-and-jump instructions, on the other hand, make use of\n+;; registers.  Therefore, we need to define several variants in both\n+;; ISAs:\n+;;\n+;;   J{eq,gt,ge,lt,le,set,ne,sgt,sge,slt,sle}{i,r}le for the\n+;;   little-endian ISA.\n+;;   J{eq,gt,ge,lt,le,set,ne.sgt,sge,slt,sle}{i,r}be for the\n+;;   big-endian ISA.\n+\n+(define-pmacro (dcji x-cond x-op-code x-endian)\n+  (begin\n+    (dni (.sym j x-cond i x-endian)\n+         (.str j x-cond \"i\")\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str \"j\" x-cond \" $dst\" x-endian \",$imm32,$disp16\")\n+         (+ imm32 disp16 ((.sym f-src x-endian) 0) (.sym dst x-endian)\n+            OP_CLASS_JMP OP_SRC_K (.sym OP_CODE_ x-op-code)) () ())\n+    (dni (.sym j x-cond r x-endian)\n+         (.str j x-cond \"r\")\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str \"j\" x-cond \" $dst\" x-endian \",$src\" x-endian \",$disp16\")\n+         (+ (f-imm32 0) disp16 (.sym src x-endian) (.sym dst x-endian)\n+            OP_CLASS_JMP OP_SRC_X (.sym OP_CODE_ x-op-code)) () ())))\n+\n+(define-pmacro (define-condjump-insns x-endian)\n+  (begin\n+    (dcji \"eq\" JEQ x-endian)\n+    (dcji \"gt\" JGT x-endian)\n+    (dcji \"ge\" JGE x-endian)\n+    (dcji \"lt\" JLT x-endian)\n+    (dcji \"le\" JLE x-endian)\n+    (dcji \"set\" JSET x-endian)\n+    (dcji \"ne\" JNE x-endian)\n+    (dcji \"sgt\" JSGT x-endian)\n+    (dcji \"sge\" JSGE x-endian)\n+    (dcji \"slt\" JSLT x-endian)\n+    (dcji \"sle\" JSLE x-endian)))\n+\n+(define-condjump-insns le)\n+(define-condjump-insns be)\n+\n+;; The jump-always, `call' and `exit' instructions dont make use of\n+;; either source nor destination registers, so only one variant per\n+;; instruction is defined.\n+\n+(dni ja \"ja\" (all-isas) \"ja $disp16\"\n+     (+ (f-imm32 0) disp16 (f-regs 0)\n+        OP_CLASS_JMP OP_SRC_K OP_CODE_JA) () ())\n+\n+(dni call \"call\" (all-isas) \"call $disp32\"\n+     (+ disp32 (f-offset16 0) (f-regs 0)\n+        OP_CLASS_JMP OP_SRC_K OP_CODE_CALL) () ())\n+\n+(dni \"exit\" \"exit\" (all-isas) \"exit\"\n+     (+ (f-imm32 0) (f-offset16 0) (f-regs 0)\n+        OP_CLASS_JMP (f-op-src 0) OP_CODE_EXIT) () ())\n+\n+;;; Atomic instructions\n+\n+;; The atomic exchange-and-add instructions come in two flavors: one\n+;; for swapping 64-bit quantities and another for 32-bit quantities.\n+\n+(define-pmacro (define-atomic-insns x-endian)\n+  (begin\n+    (dni (.str \"xadddw\" x-endian)\n+         \"xadddw\"\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str \"xadddw [$dst\" x-endian \"+$offset16],$src\" x-endian)\n+         (+ (f-imm32 0) (.sym src x-endian) (.sym dst x-endian)\n+            offset16 OP_MODE_XADD OP_SIZE_DW OP_CLASS_STX) () ())\n+    (dni (.str \"xaddw\" x-endian)\n+         \"xaddw\"\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str \"xaddw [$dst\" x-endian \"+$offset16],$src\" x-endian)\n+         (+ (f-imm32 0) (.sym src x-endian) (.sym dst x-endian)\n+            offset16 OP_MODE_XADD OP_SIZE_W OP_CLASS_STX) () ())))\n+\n+(define-atomic-insns le)\n+(define-atomic-insns be)"
    },
    {
      "sha": "e70ee04841df05bb8267961968c6b8d64e49f40c",
      "filename": "cpu/bpf.opc",
      "status": "added",
      "additions": 191,
      "deletions": 0,
      "changes": 191,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea195bb04cc5c964126aeff0f87d7161a03ca926/cpu/bpf.opc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea195bb04cc5c964126aeff0f87d7161a03ca926/cpu/bpf.opc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/bpf.opc?ref=ea195bb04cc5c964126aeff0f87d7161a03ca926",
      "patch": "@@ -0,0 +1,191 @@\n+/* EBPF opcode support.  -*- c -*-\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   Contributed by Oracle, Inc.\n+\n+   This file is part of the GNU Binutils and of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/*\n+   Each section is delimited with start and end markers.\n+\n+   <arch>-opc.h additions use: \"-- opc.h\"\n+   <arch>-opc.c additions use: \"-- opc.c\"\n+   <arch>-asm.c additions use: \"-- asm.c\"\n+   <arch>-dis.c additions use: \"-- dis.c\"\n+   <arch>-ibd.h additions use: \"-- ibd.h\".  */\n+\f\n+/* -- opc.h */\n+\n+#undef CGEN_DIS_HASH_SIZE\n+#define CGEN_DIS_HASH_SIZE 1\n+\n+#undef CGEN_DIS_HASH\n+#define CGEN_DIS_HASH(buffer, value) 0\n+\n+/* Allows reason codes to be output when assembler errors occur.  */\n+#define CGEN_VERBOSE_ASSEMBLER_ERRORS\n+\n+#define CGEN_VALIDATE_INSN_SUPPORTED\n+extern int bpf_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);\n+\n+\f\n+/* -- opc.c */\n+\f\n+/* -- asm.c */\n+\n+/* Parse a signed 64-bit immediate.  */\n+\n+static const char *\n+parse_imm64 (CGEN_CPU_DESC cd,\n+             const char **strp,\n+             int opindex,\n+             int64_t *valuep)\n+{\n+  bfd_vma value;\n+  enum cgen_parse_operand_result result;\n+  const char *errmsg;\n+\n+  errmsg = (* cd->parse_operand_fn)\n+    (cd, CGEN_PARSE_OPERAND_INTEGER, strp, opindex, BFD_RELOC_NONE,\n+     &result, &value);\n+  if (!errmsg)\n+    *valuep = value;\n+\n+  return errmsg;\n+}\n+\n+/* Endianness size operands are integer immediates whose values can be\n+   16, 32 or 64.  */\n+\n+static const char *\n+parse_endsize (CGEN_CPU_DESC cd,\n+               const char **strp,\n+               int opindex,\n+               unsigned long *valuep)\n+{\n+  const char *errmsg;\n+\n+  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);\n+  if (errmsg)\n+    return errmsg;\n+\n+  switch (*valuep)\n+    {\n+    case 16:\n+    case 32:\n+    case 64:\n+      break;\n+    default:\n+      return _(\"expected 16, 32 or 64 in\");\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Special check to ensure that the right instruction variant is used\n+   for the given endianness induced by the ISA selected in the CPU.\n+   See bpf.cpu for a discussion on how eBPF is really two instruction\n+   sets.  */\n+\n+int\n+bpf_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)\n+{\n+  CGEN_BITSET isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);\n+\n+  return cgen_bitset_intersect_p (&isas, cd->isas);\n+}\n+\n+\f\n+/* -- dis.c */\n+\n+/* We need to customize the disassembler a bit:\n+   - Use 8 bytes per line by default.\n+*/\n+\n+#define CGEN_PRINT_INSN bpf_print_insn\n+\n+static int\n+bpf_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)\n+{\n+  bfd_byte buf[CGEN_MAX_INSN_SIZE];\n+  int buflen;\n+  int status;\n+\n+  info->bytes_per_chunk = 1;\n+  info->bytes_per_line = 8;\n+\n+  /* Attempt to read the base part of the insn.  */\n+  buflen = cd->base_insn_bitsize / 8;\n+  status = (*info->read_memory_func) (pc, buf, buflen, info);\n+\n+  /* Try again with the minimum part, if min < base.  */\n+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))\n+    {\n+      buflen = cd->min_insn_bitsize / 8;\n+      status = (*info->read_memory_func) (pc, buf, buflen, info);\n+    }\n+\n+  if (status != 0)\n+    {\n+      (*info->memory_error_func) (status, pc, info);\n+      return -1;\n+    }\n+\n+  return print_insn (cd, pc, info, buf, buflen);\n+}\n+\n+/* Signed immediates should be printed in hexadecimal.  */\n+\n+static void\n+print_immediate (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+                 void *dis_info,\n+                 int64_t value,\n+                 unsigned int attrs ATTRIBUTE_UNUSED,\n+                 bfd_vma pc ATTRIBUTE_UNUSED,\n+                 int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+\n+  if (value <= 9)\n+    (*info->fprintf_func) (info->stream, \"%\" PRId64, value);\n+  else\n+    (*info->fprintf_func) (info->stream, \"%#\" PRIx64, value);\n+\n+  /* This is to avoid -Wunused-function for print_normal.  */\n+  if (0)\n+    print_normal (cd, dis_info, value, attrs, pc, length);\n+}\n+\n+/* Endianness bit sizes should be printed in decimal.  */\n+\n+static void\n+print_endsize (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+               void *dis_info,\n+               unsigned long value,\n+               unsigned int attrs ATTRIBUTE_UNUSED,\n+               bfd_vma pc ATTRIBUTE_UNUSED,\n+               int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+  (*info->fprintf_func) (info->stream, \"%lu\", value);\n+}\n+\n+\f\n+/* -- */\n+"
    }
  ]
}