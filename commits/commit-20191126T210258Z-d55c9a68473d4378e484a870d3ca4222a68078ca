{
  "sha": "d55c9a68473d4378e484a870d3ca4222a68078ca",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDU1YzlhNjg0NzNkNDM3OGU0ODRhODcwZDNjYTQyMjJhNjgwNzhjYQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-03T17:15:30Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-11-26T21:02:58Z"
    },
    "message": "Demangle minsyms in parallel\n\nThis patch introduces a simple parallel for_each and changes the\nminimal symbol reader to use it when computing the demangled name for\na minimal symbol.  This yields a speedup when reading minimal symbols.\n\n2019-11-26  Christian Biesinger  <cbiesinger@google.com>\n\t    Tom Tromey  <tom@tromey.com>\n\n\t* minsyms.c (minimal_symbol_reader::install): Use\n\tparallel_for_each.\n\t* gdbsupport/parallel-for.h: New file.\n\t* Makefile.in (HFILES_NO_SRCDIR): Add gdbsupport/parallel-for.h.\n\nChange-Id: I220341f70e94dd02df5dd424272c50a5afb64978",
    "tree": {
      "sha": "481619709ee6a4382df2f8b48d6d9835d942a31a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/481619709ee6a4382df2f8b48d6d9835d942a31a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d55c9a68473d4378e484a870d3ca4222a68078ca",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d55c9a68473d4378e484a870d3ca4222a68078ca",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d55c9a68473d4378e484a870d3ca4222a68078ca",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d55c9a68473d4378e484a870d3ca4222a68078ca/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a0b57563b1317e0000a67a7bed4c1712403682f3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a0b57563b1317e0000a67a7bed4c1712403682f3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a0b57563b1317e0000a67a7bed4c1712403682f3"
    }
  ],
  "stats": {
    "total": 176,
    "additions": 158,
    "deletions": 18
  },
  "files": [
    {
      "sha": "b73ae8dd813ff08f1814c4095a4f9a4933626fc1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d55c9a68473d4378e484a870d3ca4222a68078ca",
      "patch": "@@ -1,3 +1,11 @@\n+2019-11-26  Christian Biesinger  <cbiesinger@google.com>\n+\t    Tom Tromey  <tom@tromey.com>\n+\n+\t* minsyms.c (minimal_symbol_reader::install): Use\n+\tparallel_for_each.\n+\t* gdbsupport/parallel-for.h: New file.\n+\t* Makefile.in (HFILES_NO_SRCDIR): Add gdbsupport/parallel-for.h.\n+\n 2019-11-26  Christian Biesinger  <cbiesinger@google.com>\n \t    Tom Tromey  <tom@tromey.com>\n "
    },
    {
      "sha": "58f5f93c54f015382f7d1fdc0e10a6dd58a3aa3a",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=d55c9a68473d4378e484a870d3ca4222a68078ca",
      "patch": "@@ -1491,6 +1491,7 @@ HFILES_NO_SRCDIR = \\\n \tgdbsupport/common-inferior.h \\\n \tgdbsupport/netstuff.h \\\n \tgdbsupport/host-defs.h \\\n+\tgdbsupport/parallel-for.h \\\n \tgdbsupport/pathstuff.h \\\n \tgdbsupport/print-utils.h \\\n \tgdbsupport/ptid.h \\"
    },
    {
      "sha": "70fdacd496d30eddd50336409e5cc238b3ffed83",
      "filename": "gdb/gdbsupport/parallel-for.h",
      "status": "added",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/gdbsupport/parallel-for.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/gdbsupport/parallel-for.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbsupport/parallel-for.h?ref=d55c9a68473d4378e484a870d3ca4222a68078ca",
      "patch": "@@ -0,0 +1,86 @@\n+/* Parallel for loops\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDBSUPPORT_PARALLEL_FOR_H\n+#define GDBSUPPORT_PARALLEL_FOR_H\n+\n+#include <algorithm>\n+#if CXX_STD_THREAD\n+#include <thread>\n+#include \"gdbsupport/thread-pool.h\"\n+#endif\n+\n+namespace gdb\n+{\n+\n+/* A very simple \"parallel for\".  This splits the range of iterators\n+   into subranges, and then passes each subrange to the callback.  The\n+   work may or may not be done in separate threads.\n+\n+   This approach was chosen over having the callback work on single\n+   items because it makes it simple for the caller to do\n+   once-per-subrange initialization and destruction.  */\n+\n+template<class RandomIt, class RangeFunction>\n+void\n+parallel_for_each (RandomIt first, RandomIt last, RangeFunction callback)\n+{\n+#if CXX_STD_THREAD\n+  /* So we can use a local array below.  */\n+  const size_t local_max = 16;\n+  size_t n_threads = std::min (thread_pool::g_thread_pool->thread_count (),\n+\t\t\t       local_max);\n+  size_t n_actual_threads = 0;\n+  std::future<void> futures[local_max];\n+\n+  size_t n_elements = last - first;\n+  if (n_threads > 1)\n+    {\n+      /* Arbitrarily require that there should be at least 10 elements\n+\t in a thread.  */\n+      if (n_elements / n_threads < 10)\n+\tn_threads = std::max (n_elements / 10, (size_t) 1);\n+      size_t elts_per_thread = n_elements / n_threads;\n+      n_actual_threads = n_threads - 1;\n+      for (int i = 0; i < n_actual_threads; ++i)\n+\t{\n+\t  RandomIt end = first + elts_per_thread;\n+\t  auto task = [=] ()\n+\t\t      {\n+\t\t\tcallback (first, end);\n+\t\t      };\n+\n+\t  futures[i] = gdb::thread_pool::g_thread_pool->post_task (task);\n+\t  first = end;\n+\t}\n+    }\n+#endif /* CXX_STD_THREAD */\n+\n+  /* Process all the remaining elements in the main thread.  */\n+  callback (first, last);\n+\n+#if CXX_STD_THREAD\n+  for (int i = 0; i < n_actual_threads; ++i)\n+    futures[i].wait ();\n+#endif /* CXX_STD_THREAD */\n+}\n+\n+}\n+\n+#endif /* GDBSUPPORT_PARALLEL_FOR_H */"
    },
    {
      "sha": "03a193270e5acb1521728fc8be82f8ddc59a2d57",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 41,
      "deletions": 9,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=d55c9a68473d4378e484a870d3ca4222a68078ca",
      "patch": "@@ -53,6 +53,11 @@\n #include \"gdbsupport/symbol.h\"\n #include <algorithm>\n #include \"safe-ctype.h\"\n+#include \"gdbsupport/parallel-for.h\"\n+\n+#if CXX_STD_THREAD\n+#include <mutex>\n+#endif\n \n /* See minsyms.h.  */\n \n@@ -1359,16 +1364,43 @@ minimal_symbol_reader::install ()\n       m_objfile->per_bfd->minimal_symbol_count = mcount;\n       m_objfile->per_bfd->msymbols = std::move (msym_holder);\n \n+#if CXX_STD_THREAD\n+      /* Mutex that is used when modifying or accessing the demangled\n+\t hash table.  */\n+      std::mutex demangled_mutex;\n+#endif\n+\n       msymbols = m_objfile->per_bfd->msymbols.get ();\n-      for (int i = 0; i < mcount; ++i)\n-\t{\n-\t  if (!msymbols[i].name_set)\n-\t    {\n-\t      symbol_set_names (&msymbols[i], msymbols[i].name,\n-\t\t\t\tfalse, m_objfile->per_bfd);\n-\t      msymbols[i].name_set = 1;\n-\t    }\n-\t}\n+      gdb::parallel_for_each\n+\t(&msymbols[0], &msymbols[mcount],\n+\t [&] (minimal_symbol *start, minimal_symbol *end)\n+\t {\n+\t   for (minimal_symbol *msym = start; msym < end; ++msym)\n+\t     {\n+\t       if (!msym->name_set)\n+\t\t {\n+\t\t   /* This will be freed later, by symbol_set_names.  */\n+\t\t   char *demangled_name\n+\t\t     = symbol_find_demangled_name (msym, msym->name);\n+\t\t   symbol_set_demangled_name\n+\t\t     (msym, demangled_name,\n+\t\t      &m_objfile->per_bfd->storage_obstack);\n+\t\t   msym->name_set = 1;\n+\t\t }\n+\t     }\n+\t   {\n+\t     /* To limit how long we hold the lock, we only acquire it here\n+\t        and not while we demangle the names above.  */\n+#if CXX_STD_THREAD\n+\t     std::lock_guard<std::mutex> guard (demangled_mutex);\n+#endif\n+\t     for (minimal_symbol *msym = start; msym < end; ++msym)\n+\t       {\n+\t\t symbol_set_names (msym, msym->name, false,\n+\t\t\t\t   m_objfile->per_bfd);\n+\t       }\n+\t   }\n+\t });\n \n       build_minimal_symbol_hash_tables (m_objfile);\n     }"
    },
    {
      "sha": "b5c8109fde327d698a3180b2f8e5cddf38989f79",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 12,
      "deletions": 9,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=d55c9a68473d4378e484a870d3ca4222a68078ca",
      "patch": "@@ -787,13 +787,9 @@ create_demangled_names_hash (struct objfile_per_bfd_storage *per_bfd)\n      free_demangled_name_entry, xcalloc, xfree));\n }\n \n-/* Try to determine the demangled name for a symbol, based on the\n-   language of that symbol.  If the language is set to language_auto,\n-   it will attempt to find any demangling algorithm that works and\n-   then set the language appropriately.  The returned name is allocated\n-   by the demangler and should be xfree'd.  */\n+/* See symtab.h  */\n \n-static char *\n+char *\n symbol_find_demangled_name (struct general_symbol_info *gsymbol,\n \t\t\t    const char *mangled)\n {\n@@ -894,8 +890,15 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n       else\n \tlinkage_name_copy = linkage_name;\n \n-      gdb::unique_xmalloc_ptr<char> demangled_name_ptr\n-\t(symbol_find_demangled_name (gsymbol, linkage_name_copy.data ()));\n+      /* The const_cast is safe because the only reason it is already\n+         initialized is if we purposefully set it from a background\n+         thread to avoid doing the work here.  However, it is still\n+         allocated from the heap and needs to be freed by us, just\n+         like if we called symbol_find_demangled_name here.  */\n+      gdb::unique_xmalloc_ptr<char> demangled_name\n+\t(gsymbol->language_specific.demangled_name\n+\t ? const_cast<char *> (gsymbol->language_specific.demangled_name)\n+\t : symbol_find_demangled_name (gsymbol, linkage_name_copy.data ()));\n \n       /* Suppose we have demangled_name==NULL, copy_name==0, and\n \t linkage_name_copy==linkage_name.  In this case, we already have the\n@@ -929,7 +932,7 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n \t  new (*slot) demangled_name_entry\n \t    (gdb::string_view (mangled_ptr, linkage_name.length ()));\n \t}\n-      (*slot)->demangled = std::move (demangled_name_ptr);\n+      (*slot)->demangled = std::move (demangled_name);\n       (*slot)->language = gsymbol->language;\n     }\n   else if (gsymbol->language == language_unknown"
    },
    {
      "sha": "9c2aea7cf74a9ab668dc7f4bdd8e4f17f6a50d1f",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d55c9a68473d4378e484a870d3ca4222a68078ca/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=d55c9a68473d4378e484a870d3ca4222a68078ca",
      "patch": "@@ -528,6 +528,16 @@ extern void symbol_set_language (struct general_symbol_info *symbol,\n                                  enum language language,\n \t\t\t\t struct obstack *obstack);\n \n+\n+/* Try to determine the demangled name for a symbol, based on the\n+   language of that symbol.  If the language is set to language_auto,\n+   it will attempt to find any demangling algorithm that works and\n+   then set the language appropriately.  The returned name is allocated\n+   by the demangler and should be xfree'd.  */\n+\n+extern char *symbol_find_demangled_name (struct general_symbol_info *gsymbol,\n+\t\t\t\t\t const char *mangled);\n+\n /* Set just the linkage name of a symbol; do not try to demangle\n    it.  Used for constructs which do not have a mangled name,\n    e.g. struct tags.  Unlike SYMBOL_SET_NAMES, linkage_name must"
    }
  ]
}