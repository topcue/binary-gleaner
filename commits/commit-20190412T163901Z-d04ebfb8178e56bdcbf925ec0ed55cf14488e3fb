{
  "sha": "d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDA0ZWJmYjgxNzhlNTZiZGNiZjkyNWVjMGVkNTVjZjE0NDg4ZTNmYg==",
  "commit": {
    "author": {
      "name": "John Darrington",
      "email": "john@darrington.wattle.id.au",
      "date": "2019-04-12T16:39:01Z"
    },
    "committer": {
      "name": "John Darrington",
      "email": "john@darrington.wattle.id.au",
      "date": "2019-04-12T16:39:01Z"
    },
    "message": "GAS: tc-s12z.c: int -> bfd_boolean\n\nUse bfd_boolean where appropriate.",
    "tree": {
      "sha": "3826a2a52ad86dc73124f8c546fde5a0f6663ef3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3826a2a52ad86dc73124f8c546fde5a0f6663ef3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "51196bbc5618a3741bd7bbed01ac76b25a2e6f9c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/51196bbc5618a3741bd7bbed01ac76b25a2e6f9c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/51196bbc5618a3741bd7bbed01ac76b25a2e6f9c"
    }
  ],
  "stats": {
    "total": 416,
    "additions": 210,
    "deletions": 206
  },
  "files": [
    {
      "sha": "54229d78abc6143a363120fe1f75e436ec3517e9",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb",
      "patch": "@@ -1,3 +1,7 @@\n+2019-04-01  John Darrington <john@darrington.wattle.id.au>\n+\t\n+\tconfig/tc-s12z.c: Use bfd_boolean where appropriate.\n+\n 2019-04-11  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* testsuite/gas/xtensa/loop-relax-2.d: New test definition."
    },
    {
      "sha": "b9c247671d6c2782ea0b9353811dd7a6c9b1387c",
      "filename": "gas/config/tc-s12z.c",
      "status": "modified",
      "additions": 206,
      "deletions": 206,
      "changes": 412,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb/gas/config/tc-s12z.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb/gas/config/tc-s12z.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s12z.c?ref=d04ebfb8178e56bdcbf925ec0ed55cf14488e3fb",
      "patch": "@@ -164,9 +164,9 @@ s12z_new_insn (int size)\n \n \f\n \n-static int lex_reg_name (uint16_t which, int *reg);\n+static bfd_boolean lex_reg_name (uint16_t which, int *reg);\n \n-static int\n+static bfd_boolean\n lex_constant (long *v)\n {\n   char *end = NULL;\n@@ -178,33 +178,33 @@ lex_constant (long *v)\n   if (lex_reg_name (~0, &dummy))\n     {\n       input_line_pointer = p;\n-      return 0;\n+      return false;\n     }\n \n   errno = 0;\n   *v = strtol (p, &end, 0);\n   if (errno == 0 && end != p)\n     {\n       input_line_pointer = end;\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n lex_match (char x)\n {\n   char *p = input_line_pointer;\n   if (*p != x)\n-    return 0;\n+    return false;\n \n   input_line_pointer++;\n-  return 1;\n+  return true;\n }\n \n \n-static int\n+static bfd_boolean\n lex_expression (expressionS *exp)\n {\n   char *ilp = input_line_pointer;\n@@ -219,19 +219,19 @@ lex_expression (expressionS *exp)\n \n   expression (exp);\n   if (exp->X_op != O_absent)\n-    return 1;\n+    return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n /* Immediate operand.\n    If EXP_O is non-null, then a symbolic expression is permitted,\n    in which case, EXP_O will be populated with the parsed expression.\n  */\n-static int\n+static bfd_boolean\n lex_imm (long *v, expressionS *exp_o)\n {\n   char *ilp = input_line_pointer;\n@@ -253,32 +253,32 @@ lex_imm (long *v, expressionS *exp_o)\n     }\n \n   *v = exp.X_add_number;\n-  return 1;\n+  return true;\n \n fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n /* Short mmediate operand */\n-static int\n+static bfd_boolean\n lex_imm_e4 (long *val)\n {\n   char *ilp = input_line_pointer;\n   if ((lex_imm (val, NULL)))\n     {\n       if ((*val == -1) || (*val > 0 && *val <= 15))\n \t{\n-\t  return 1;\n+\t  return true;\n \t}\n     }\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n lex_match_string (const char *s)\n {\n   char *p = input_line_pointer;\n@@ -289,15 +289,15 @@ lex_match_string (const char *s)\n \n   size_t len = p - input_line_pointer;\n   if (len != strlen (s))\n-    return 0;\n+    return false;\n \n   if (0 == strncasecmp (s, input_line_pointer, len))\n     {\n       input_line_pointer = p;\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Parse a register name.\n@@ -306,7 +306,7 @@ lex_match_string (const char *s)\n    On success, REG will be filled with the index of the register which\n    was successfully scanned.\n */\n-static int\n+static bfd_boolean\n lex_reg_name (uint16_t which, int *reg)\n {\n   char *p = input_line_pointer;\n@@ -319,7 +319,7 @@ lex_reg_name (uint16_t which, int *reg)\n   size_t len = p - input_line_pointer;\n \n   if (len <= 0)\n-    return 0;\n+    return false;\n \n   int i;\n   for (i = 0; i < S12Z_N_REGISTERS; ++i)\n@@ -333,12 +333,12 @@ lex_reg_name (uint16_t which, int *reg)\n \t    {\n \t      input_line_pointer = p;\n \t      *reg = i;\n-\t      return 1;\n+\t      return true;\n \t    }\n \t}\n     }\n \n-  return 0;\n+  return false;\n }\n \n static int\n@@ -348,14 +348,14 @@ lex_force_match (char x)\n   if (*p != x)\n     {\n       as_bad (_(\"Expecting '%c'\"), x);\n-      return 0;\n+      return false;\n     }\n \n   input_line_pointer++;\n-  return 1;\n+  return true;\n }\n \n-static int\n+static bfd_boolean\n lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n \t bool immediate_ok)\n {\n@@ -371,22 +371,22 @@ lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n       if (!immediate_ok)\n \t{\n \t  as_bad (_(\"An immediate value in a source operand is inappropriate\"));\n-\t  return 0;\n+\t  return false;\n \t}\n       if (imm > 0)\n \t*xb = imm;\n       else\n \t*xb = 0;\n       *xb |= 0x70;\n       *n_bytes = 1;\n-      return 1;\n+      return true;\n     }\n   else if (lex_reg_name (REG_BIT_Dn, &reg))\n     {\n       *xb = reg;\n       *xb |= 0xb8;\n       *n_bytes = 1;\n-      return 1;\n+      return true;\n     }\n   else if (lex_match ('['))\n     {\n@@ -457,7 +457,7 @@ lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n \t}\n       if (!lex_force_match (']'))\n \tgoto fail;\n-      return 1;\n+      return true;\n     }\n   else if (lex_match ('('))\n     {\n@@ -618,7 +618,7 @@ lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n \n       if (! lex_match (')'))\n \tgoto fail;\n-      return 1;\n+      return true;\n     }\n   else if (lex_expression (exp))\n     {\n@@ -658,26 +658,26 @@ lex_opr (uint8_t *buffer, int *n_bytes, expressionS *exp,\n \t      buffer[3] = value;\n \t    }\n \t}\n-      return 1;\n+      return true;\n     }\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n lex_offset (long *val)\n {\n   char *end = NULL;\n   char *p = input_line_pointer;\n \n   if (*p++ != '*')\n-    return 0;\n+    return false;\n \n   if (*p != '+' && *p != '-')\n-    return 0;\n+    return false;\n \n   bool negative =  (*p == '-');\n   p++;\n@@ -689,10 +689,10 @@ lex_offset (long *val)\n       if (negative)\n \t*val *= -1;\n       input_line_pointer = end;\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n \f\n@@ -727,7 +727,7 @@ no_operands (const struct instruction *insn)\n   if (*input_line_pointer != '\\0')\n     {\n       as_bad (_(\"Garbage at end of instruction\"));\n-      return 0;\n+      return false;\n     }\n \n   char *f = s12z_new_insn (insn->page);\n@@ -736,7 +736,7 @@ no_operands (const struct instruction *insn)\n \n   number_to_chars_bigendian (f++, insn->opc, 1);\n \n-  return 1;\n+  return true;\n }\n \n \n@@ -783,7 +783,7 @@ emit_ext24 (char *f, long v)\n   return f + 3;\n }\n \n-static int\n+static bfd_boolean \n opr (const struct instruction *insn)\n {\n   uint8_t buffer[4];\n@@ -813,16 +813,16 @@ opr (const struct instruction *insn)\n \n \t  emit_opr (f, buffer, n_bytes, &exp);\n \t}\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Parse a 15 bit offset, as an expression.\n    LONG_DISPLACEMENT will be set to true if the offset is wider than 7 bits.\n    */\n-static int\n+static bfd_boolean\n lex_15_bit_offset (bool *long_displacement, expressionS *exp)\n {\n   char *ilp = input_line_pointer;\n@@ -844,7 +844,7 @@ lex_15_bit_offset (bool *long_displacement, expressionS *exp)\n \t  /* If a symbol was parsed we don't know the displacement.\n \t     We have to assume it is long, and relax it later if possible. */\n \t  *long_displacement = true;\n-\t  return 1;\n+\t  return true;\n \t}\n     }\n   else\n@@ -856,17 +856,17 @@ lex_15_bit_offset (bool *long_displacement, expressionS *exp)\n   if (val > 0x3FFF || val < -0x4000)\n     {\n       as_fatal (_(\"Offset is outside of 15 bit range\"));\n-      return 0;\n+      return false;\n     }\n \n   *long_displacement = (val > 63 || val < -64);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n static void\n@@ -897,22 +897,22 @@ emit_15_bit_offset (char *f, int where, expressionS *exp)\n     }\n }\n \n-static int\n+static bfd_boolean\n rel (const struct instruction *insn)\n {\n   bool long_displacement;\n \n   expressionS exp;\n   if (! lex_15_bit_offset (&long_displacement, &exp))\n-    return 0;\n+    return false;\n \n   char *f = s12z_new_insn (long_displacement ? 3 : 2);\n   number_to_chars_bigendian (f++, insn->opc, 1);\n   emit_15_bit_offset (f, 3, &exp);\n-  return 1;\n+  return true;\n }\n \n-static int\n+static bfd_boolean\n reg_inh (const struct instruction *insn)\n {\n   int reg;\n@@ -923,31 +923,31 @@ reg_inh (const struct instruction *insn)\n \tnumber_to_chars_bigendian (f++, PAGE2_PREBYTE, 1);\n \n       number_to_chars_bigendian (f++, insn->opc + reg, 1);\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n \n /* Special case for CLR X and CLR Y */\n-static int\n+static bfd_boolean\n clr_xy (const struct instruction *insn ATTRIBUTE_UNUSED)\n {\n   int reg;\n   if (lex_reg_name (REG_BIT_XY, &reg))\n     {\n       char *f = s12z_new_insn (1);\n       number_to_chars_bigendian (f, 0x9a + reg - REG_X, 1);\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Some instructions have a suffix like \".l\", \".b\", \".w\" etc\n    which indicates the size of the operands. */\n-static int\n+static bfd_boolean\n size_from_suffix  (const struct instruction *insn, int idx)\n {\n   const char *dot = strchr (insn->name, '.');\n@@ -977,7 +977,7 @@ size_from_suffix  (const struct instruction *insn, int idx)\n   return size;\n }\n \n-static int\n+static bfd_boolean\n mul_reg_reg_reg (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1025,16 +1025,16 @@ mul_reg_reg_reg (const struct instruction *insn)\n \n   number_to_chars_bigendian (f++, mb, 1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n mul_reg_reg_imm (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1086,16 +1086,16 @@ mul_reg_reg_imm (const struct instruction *insn)\n   number_to_chars_bigendian (f++, mb, 1);\n   number_to_chars_bigendian (f++, imm, size);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n mul_reg_reg_opr (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1149,15 +1149,15 @@ mul_reg_reg_opr (const struct instruction *insn)\n \n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n mul_reg_opr_opr (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1214,12 +1214,12 @@ mul_reg_opr_opr (const struct instruction *insn)\n   f = emit_opr (f, buffer1, n_bytes1, &exp1);\n   f = emit_opr (f, buffer2, n_bytes2, &exp2);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n@@ -1265,16 +1265,16 @@ lex_reg_list (uint16_t grp, uint16_t *reg_bits)\n     {\n       int reg;\n       if (!lex_reg_name (grp, &reg))\n-\treturn 0;\n+\treturn false;\n       *reg_bits |= 0x1u << reg;\n       lex_reg_list (grp, reg_bits);\n     }\n \n   /* Empty list */\n-  return 1;\n+  return true;\n }\n \n-static int\n+static bfd_boolean\n psh_pull (const struct instruction *insn)\n {\n   uint8_t pb =\n@@ -1318,15 +1318,15 @@ psh_pull (const struct instruction *insn)\n   char *f = s12z_new_insn (2);\n   number_to_chars_bigendian (f++, insn->opc, 1);\n   number_to_chars_bigendian (f++, pb, 1);\n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n tfr (const struct instruction *insn)\n {\n   int reg1;\n@@ -1355,19 +1355,19 @@ tfr (const struct instruction *insn)\n   number_to_chars_bigendian (f++, insn->opc, 1);\n   number_to_chars_bigendian (f++, reg1 << 4 | reg2, 1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n imm8 (const struct instruction *insn)\n {\n   long imm;\n   if (! lex_imm (&imm, NULL))\n-    return 0;\n+    return false;\n   if (imm > 127 || imm < -128)\n     {\n       as_bad (_(\"Immediate value %ld is out of range for instruction %s\"),\n@@ -1378,10 +1378,10 @@ imm8 (const struct instruction *insn)\n   number_to_chars_bigendian (f++, insn->opc, 1);\n   number_to_chars_bigendian (f++, imm, 1);\n \n-  return 1;\n+  return true;\n }\n \n-static int\n+static bfd_boolean\n reg_imm (const struct instruction *insn, int allowed_reg)\n {\n   char *ilp = input_line_pointer;\n@@ -1401,36 +1401,36 @@ reg_imm (const struct instruction *insn, int allowed_reg)\n \n       number_to_chars_bigendian (f++, insn->opc + reg, 1);\n       number_to_chars_bigendian (f++, imm, size);\n-      return 1;\n+      return true;\n     }\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n regd_imm (const struct instruction *insn)\n {\n   return reg_imm (insn, REG_BIT_Dn);\n }\n \n-static int\n+static bfd_boolean\n regdxy_imm (const struct instruction *insn)\n {\n   return reg_imm (insn, REG_BIT_Dn | REG_BIT_XY);\n }\n \n \n-static int\n+static bfd_boolean\n regs_imm (const struct instruction *insn)\n {\n   return reg_imm (insn, 0x1U << REG_S);\n }\n \n-static int\n+static bfd_boolean\n trap_imm (const struct instruction *insn ATTRIBUTE_UNUSED)\n {\n   long imm = -1;\n@@ -1442,27 +1442,27 @@ trap_imm (const struct instruction *insn ATTRIBUTE_UNUSED)\n       (imm >= 0xB0 && imm <= 0xB7))\n     {\n       as_bad (_(\"trap value %ld is not valid\"), imm);\n-      return 0;\n+      return false;\n     }\n   else\n     {\n       char *f = s12z_new_insn (2);\n       number_to_chars_bigendian (f++, PAGE2_PREBYTE, 1);\n       number_to_chars_bigendian (f++, imm & 0xFF, 1);\n-      return 1;\n+      return true;\n     }\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n-  return 0;\n+  return false;\n }\n \n \n \n /* Special one byte instruction CMP X, Y */\n-static int\n+static bfd_boolean\n regx_regy (const struct instruction *insn)\n {\n   int reg;\n@@ -1474,15 +1474,15 @@ regx_regy (const struct instruction *insn)\n \t    {\n \t      char *f = s12z_new_insn (1);\n \t      number_to_chars_bigendian (f, insn->opc, 1);\n-\t      return 1;\n+\t      return true;\n \t    }\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n /* Special one byte instruction SUB D6, X, Y */\n-static int\n+static bfd_boolean\n regd6_regx_regy (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1504,16 +1504,16 @@ regd6_regx_regy (const struct instruction *insn)\n \n   char *f = s12z_new_insn (1);\n   number_to_chars_bigendian (f, insn->opc, 1);\n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n /* Special one byte instruction SUB D6, Y, X */\n-static int\n+static bfd_boolean\n regd6_regy_regx (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1535,15 +1535,15 @@ regd6_regy_regx (const struct instruction *insn)\n \n   char *f = s12z_new_insn (1);\n   number_to_chars_bigendian (f, insn->opc, 1);\n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n reg_opr (const struct instruction *insn, int allowed_regs,\n \t bool immediate_ok)\n {\n@@ -1586,52 +1586,52 @@ reg_opr (const struct instruction *insn, int allowed_regs,\n \t      emit_opr (f, buffer, n_bytes, &exp);\n \t    }\n \n-\t  return 1;\n+\t  return true;\n \t}\n     }\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n regdxy_opr_dest (const struct instruction *insn)\n {\n   return reg_opr (insn, REG_BIT_Dn | REG_BIT_XY, false);\n }\n \n-static int\n+static bfd_boolean\n regdxy_opr_src (const struct instruction *insn)\n {\n   return reg_opr (insn, REG_BIT_Dn | REG_BIT_XY, true);\n }\n \n \n-static int\n+static bfd_boolean\n regd_opr (const struct instruction *insn)\n {\n   return reg_opr (insn, REG_BIT_Dn, true);\n }\n \n \n /* OP0: S; OP1: destination OPR */\n-static int\n+static bfd_boolean\n regs_opr_dest (const struct instruction *insn)\n {\n   return reg_opr (insn, 0x1U << REG_S, false);\n }\n \n /* OP0: S; OP1: source OPR */\n-static int\n+static bfd_boolean\n regs_opr_src (const struct instruction *insn)\n {\n   return reg_opr (insn, 0x1U << REG_S, true);\n }\n \n-static int\n+static bfd_boolean\n imm_opr  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1671,15 +1671,15 @@ imm_opr  (const struct instruction *insn)\n \n   emit_opr (f, buffer, n_bytes, &exp1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n opr_opr  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -1706,38 +1706,38 @@ opr_opr  (const struct instruction *insn)\n   f = emit_opr (f, buffer1, n_bytes1, &exp1);\n   f = emit_opr (f, buffer2, n_bytes2, &exp2);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n reg67sxy_opr  (const struct instruction *insn)\n {\n   int reg;\n   if (!lex_reg_name (REG_BIT_XYS | (0x1U << REG_D6) | (0x1U << REG_D7), &reg))\n-    return 0;\n+    return false;\n \n   if (!lex_match (','))\n-    return 0;\n+    return false;\n \n   uint8_t buffer[4];\n   int n_bytes;\n   expressionS exp;\n   if (!lex_opr (buffer, &n_bytes, &exp, false))\n-    return 0;\n+    return false;\n \n   char *f = s12z_new_insn (1 + n_bytes);\n   number_to_chars_bigendian (f++, insn->opc + reg - REG_D6, 1);\n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n }\n \n-static int\n+static bfd_boolean\n rotate  (const struct instruction *insn, short dir)\n {\n   uint8_t buffer[4];\n@@ -1757,19 +1757,19 @@ rotate  (const struct instruction *insn, short dir)\n       number_to_chars_bigendian (f++, sb, 1);\n       emit_opr (f, buffer, n_bytes, &exp);\n \n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n rol  (const struct instruction *insn)\n {\n   return rotate (insn, 1);\n }\n \n-static int\n+static bfd_boolean\n ror  (const struct instruction *insn)\n {\n   return rotate (insn, 0);\n@@ -1780,7 +1780,7 @@ ror  (const struct instruction *insn)\n    left = 1; right = 0;\n    logical = 0; arithmetic = 1;\n */\n-static int\n+static bfd_boolean\n lex_shift_reg_imm1  (const struct instruction *insn, short type, short dir)\n {\n   /*\n@@ -1830,18 +1830,18 @@ lex_shift_reg_imm1  (const struct instruction *insn, short type, short dir)\n   number_to_chars_bigendian (f++, sb, 1);\n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n /* Shift instruction with a register operand.\n    left = 1; right = 0;\n    logical = 0; arithmetic = 1; */\n-static int\n+static bfd_boolean\n lex_shift_reg  (const struct instruction *insn, short type, short dir)\n {\n   int Dd, Ds, Dn;\n@@ -1875,7 +1875,7 @@ lex_shift_reg  (const struct instruction *insn, short type, short dir)\n       xb |= Dn;\n       number_to_chars_bigendian (f++, xb, 1);\n \n-      return 1;\n+      return true;\n     }\n   else if (lex_imm (&imm, NULL))\n     {\n@@ -1906,12 +1906,12 @@ lex_shift_reg  (const struct instruction *insn, short type, short dir)\n \t  number_to_chars_bigendian (f++, xb, 1);\n \t}\n \n-      return 1;\n+      return true;\n     }\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n-  return 0;\n+  return false;\n }\n \n static void\n@@ -1947,7 +1947,7 @@ impute_shift_dir_and_type (const struct instruction *insn, short *type, short *d\n }\n \n /* Shift instruction with a OPR operand */\n-static int\n+static bfd_boolean\n shift_two_operand  (const struct instruction *insn)\n {\n   uint8_t sb = 0x34;\n@@ -1986,16 +1986,16 @@ shift_two_operand  (const struct instruction *insn)\n   number_to_chars_bigendian (f++, sb, 1);\n   emit_opr (f, buffer, n_opr_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n /* Shift instruction with a OPR operand */\n-static int\n+static bfd_boolean\n shift_opr_imm  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2083,29 +2083,29 @@ shift_opr_imm  (const struct instruction *insn)\n       f = emit_opr (f, buffer2, n_opr_bytes2, &exp2);\n     }\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n /* Shift instruction with a register operand */\n-static int\n+static bfd_boolean\n shift_reg  (const struct instruction *insn)\n {\n   short dir = -1;\n   short type = -1;\n   impute_shift_dir_and_type (insn, &type, &dir);\n \n   if (lex_shift_reg_imm1 (insn, type, dir))\n-    return 1;\n+    return true;\n \n   return lex_shift_reg (insn, type, dir);\n }\n \n-static int\n+static bfd_boolean\n bm_regd_imm  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2128,15 +2128,15 @@ bm_regd_imm  (const struct instruction *insn)\n   number_to_chars_bigendian (f++, insn->opc, 1);\n   number_to_chars_bigendian (f++, bm, 1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n bm_opr_reg  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2166,16 +2166,16 @@ bm_opr_reg  (const struct instruction *insn)\n \n   emit_opr (f, buffer, n_opr_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n bm_opr_imm  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2217,16 +2217,16 @@ bm_opr_imm  (const struct instruction *insn)\n   number_to_chars_bigendian (f++, bm, 1);\n   emit_opr (f, buffer, n_opr_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n bm_regd_reg  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2251,19 +2251,19 @@ bm_regd_reg  (const struct instruction *insn)\n   number_to_chars_bigendian (f++, bm, 1);\n   number_to_chars_bigendian (f++, xb, 1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n \f\n \n \n-static int\n+static bfd_boolean\n bf_reg_opr_imm  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2324,16 +2324,16 @@ bf_reg_opr_imm  (const struct instruction *insn, short ie)\n \n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n bf_opr_reg_imm  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2393,17 +2393,17 @@ bf_opr_reg_imm  (const struct instruction *insn, short ie)\n \n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n \n-static int\n+static bfd_boolean\n bf_reg_reg_imm  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2458,15 +2458,15 @@ bf_reg_reg_imm  (const struct instruction *insn, short ie)\n   number_to_chars_bigendian (f++, bb, 1);\n   number_to_chars_bigendian (f++, i1, 1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n bf_reg_reg_reg  (const struct instruction *insn ATTRIBUTE_UNUSED, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2501,15 +2501,15 @@ bf_reg_reg_reg  (const struct instruction *insn ATTRIBUTE_UNUSED, short ie)\n   number_to_chars_bigendian (f++, 0x08 | Dd, 1);\n   number_to_chars_bigendian (f++, bb , 1);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n bf_opr_reg_reg  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2553,16 +2553,16 @@ bf_opr_reg_reg  (const struct instruction *insn, short ie)\n \n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n bf_reg_opr_reg  (const struct instruction *insn, short ie)\n {\n   char *ilp = input_line_pointer;\n@@ -2604,85 +2604,85 @@ bf_reg_opr_reg  (const struct instruction *insn, short ie)\n \n   emit_opr (f, buffer, n_bytes, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n \n-static int\n+static bfd_boolean\n bfe_reg_reg_reg  (const struct instruction *insn)\n {\n   return bf_reg_reg_reg (insn, 0);\n }\n \n-static int\n+static bfd_boolean\n bfi_reg_reg_reg  (const struct instruction *insn)\n {\n   return bf_reg_reg_reg (insn, 1);\n }\n \n-static int\n+static bfd_boolean\n bfe_reg_reg_imm  (const struct instruction *insn)\n {\n   return bf_reg_reg_imm (insn, 0);\n }\n \n-static int\n+static bfd_boolean\n bfi_reg_reg_imm  (const struct instruction *insn)\n {\n   return bf_reg_reg_imm (insn, 1);\n }\n \n \n-static int\n+static bfd_boolean\n bfe_reg_opr_reg  (const struct instruction *insn)\n {\n   return bf_reg_opr_reg (insn, 0);\n }\n \n-static int\n+static bfd_boolean\n bfi_reg_opr_reg  (const struct instruction *insn)\n {\n   return bf_reg_opr_reg (insn, 1);\n }\n \n \n-static int\n+static bfd_boolean\n bfe_opr_reg_reg  (const struct instruction *insn)\n {\n   return bf_opr_reg_reg (insn, 0);\n }\n \n-static int\n+static bfd_boolean\n bfi_opr_reg_reg  (const struct instruction *insn)\n {\n   return bf_opr_reg_reg (insn, 1);\n }\n \n-static int\n+static bfd_boolean\n bfe_reg_opr_imm  (const struct instruction *insn)\n {\n   return bf_reg_opr_imm (insn, 0);\n }\n \n-static int\n+static bfd_boolean\n bfi_reg_opr_imm  (const struct instruction *insn)\n {\n   return bf_reg_opr_imm (insn, 1);\n }\n \n-static int\n+static bfd_boolean\n bfe_opr_reg_imm  (const struct instruction *insn)\n {\n   return bf_opr_reg_imm (insn, 0);\n }\n \n-static int\n+static bfd_boolean\n bfi_opr_reg_imm  (const struct instruction *insn)\n {\n   return bf_opr_reg_imm (insn, 1);\n@@ -2691,7 +2691,7 @@ bfi_opr_reg_imm  (const struct instruction *insn)\n \f\n \n \n-static int\n+static bfd_boolean\n tb_reg_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2751,16 +2751,16 @@ tb_reg_rel  (const struct instruction *insn)\n \n   emit_15_bit_offset (f, 4, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n tb_opr_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2817,18 +2817,18 @@ tb_opr_rel  (const struct instruction *insn)\n \n   emit_15_bit_offset (f, n_bytes + 4, &exp2);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \f\n \n \n-static int\n+static bfd_boolean\n test_br_reg_reg_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2867,15 +2867,15 @@ test_br_reg_reg_rel  (const struct instruction *insn)\n \n   emit_15_bit_offset (f, 5, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n-static int\n+static bfd_boolean\n test_br_opr_reg_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2915,16 +2915,16 @@ test_br_opr_reg_rel  (const struct instruction *insn)\n \n   emit_15_bit_offset (f, n, &exp2);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n test_br_opr_imm_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -2970,16 +2970,16 @@ test_br_opr_imm_rel  (const struct instruction *insn)\n \n   emit_15_bit_offset (f, n_bytes + 4,  &exp2);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n-static int\n+static bfd_boolean\n test_br_reg_imm_rel  (const struct instruction *insn)\n {\n   char *ilp = input_line_pointer;\n@@ -3016,12 +3016,12 @@ test_br_reg_imm_rel  (const struct instruction *insn)\n \n   emit_15_bit_offset (f, 4, &exp);\n \n-  return 1;\n+  return true;\n \n  fail:\n   fail_line_pointer = input_line_pointer;\n   input_line_pointer = ilp;\n-  return 0;\n+  return false;\n }\n \n \n@@ -3782,7 +3782,7 @@ long\n s12z_relax_frag (segT seg ATTRIBUTE_UNUSED, fragS *fragP ATTRIBUTE_UNUSED,\n \t\t   long stretch ATTRIBUTE_UNUSED)\n {\n-  return 0;\n+  return false;\n }\n \n void\n@@ -3801,7 +3801,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, asection *sec ATTRIBUTE_UNUSED,\n int\n md_estimate_size_before_relax (fragS *fragP ATTRIBUTE_UNUSED, asection *segment ATTRIBUTE_UNUSED)\n {\n-  return 0;\n+  return false;\n }\n \n \n@@ -3843,10 +3843,10 @@ tc_s12z_force_relocation (fixS *fixP)\n    we need to make sure that the linker relaxation is done\n    correctly, so in some cases we force the original symbol to be\n    used.  */\n-int\n+bfd_boolean\n tc_s12z_fix_adjustable (fixS *fixP ATTRIBUTE_UNUSED)\n {\n-  return 1;\n+  return true;\n }\n \n void"
    }
  ]
}