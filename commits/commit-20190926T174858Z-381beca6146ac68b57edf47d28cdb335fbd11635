{
  "sha": "381beca6146ac68b57edf47d28cdb335fbd11635",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzgxYmVjYTYxNDZhYzY4YjU3ZWRmNDdkMjhjZGIzMzVmYmQxMTYzNQ==",
  "commit": {
    "author": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@redhat.com",
      "date": "2019-08-16T23:36:37Z"
    },
    "committer": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@redhat.com",
      "date": "2019-09-26T17:48:58Z"
    },
    "message": "Improve ptrace-error detection on Linux targets\n\nIn Fedora GDB, we carry the following patch:\n\n  https://src.fedoraproject.org/rpms/gdb/blob/8ac06474ff1e2aa4920d14e0666b083eeaca8952/f/gdb-attach-fail-reasons-5of5.patch\n\nIts purpose is to try to detect a specific scenario where SELinux's\n'deny_ptrace' option is enabled, which prevents GDB from ptrace'ing in\norder to debug the inferior (PTRACE_ATTACH and PTRACE_TRACEME will\nfail with EACCES in this case).\n\nI like the idea of improving error detection and providing more\ninformation to the user (a simple \"Permission denied\" can be really\nfrustrating), but I don't fully agree with the way the patch was\nimplemented: it makes GDB link against libselinux only for the sake of\nconsulting the 'deny_ptrace' setting, and then prints a warning if\nptrace failed and this setting is on.\n\nMy first thought (and attempt) was to make GDB print a generic warning\nwhen a ptrace error happened; this message would just point the user\nto our documentation, where she could find more information about\npossible causes for the error (and try to diagnose/fix the problem).\nThis proved to be too simple, and I was convinced that it is actually\na good idea to go the extra kilometre and try to pinpoint the specific\nproblem (or problems) preventing ptrace from working, as well as\nprovide useful suggestions on how the user can fix things.\n\nHere is the patch I came up with.  It implements a new function,\n'linux_ptrace_restricted_fail_reason', which does a few things to\ncheck what's wrong with ptrace:\n\n  - It dlopen's \"libselinux.so.1\" and checks if the \"deny_ptrace\"\n    option is enabled.\n\n  - It reads the contents of \"/proc/sys/kernel/yama/ptrace_scope\" and\n    checks if it's different than 0.\n\nFor each of these checks, if it succeeds, the user will see a message\ninforming about the restriction in place, and how it can be disabled.\nFor example, if \"deny_ptrace\" is enabled, the user will see:\n\n  # gdb /usr/bin/true\n  ...\n  Starting program: /usr/bin/true\n  warning: Could not trace the inferior process.\n  warning: ptrace: Permission denied\n  The SELinux 'deny_ptrace' option is enabled and preventing GDB\n  from using 'ptrace'.  You can disable it by executing (as root):\n\n    setsebool deny_ptrace off\n\n  If you are debugging the inferior remotely, the ptrace restriction(s) need\n  to be disabled in the target system (e.g., where GDBserver is running).\n  During startup program exited with code 127.\n  (gdb)\n\nIn case \"/proc/sys/kernel/yama/ptrace_scope\" is > 0:\n\n  # gdb /usr/bin/true\n  ...\n  Starting program: /usr/bin/true\n  warning: Could not trace the inferior process.\n  warning: ptrace: Operation not permitted\n  The Linux kernel's Yama ptrace scope is in effect, which can prevent\n  GDB from using 'ptrace'.  You can disable it by executing (as root):\n\n    echo 0 > /proc/sys/kernel/yama/ptrace_scope\n\n  If you are debugging the inferior remotely, the ptrace restriction(s) need\n  to be disabled in the target system (e.g., where GDBserver is running).\n  During startup program exited with code 127.\n  (gdb)\n\nIf both restrictions are enabled, both messages will show up.\n\nThis works for gdbserver as well, and actually fixes a latent bug I\nfound: when ptrace is restricted, gdbserver would hang due to an\nunchecked ptrace call:\n\n  # gdbserver :9988 /usr/bin/true\n  gdbserver: linux_ptrace_test_ret_to_nx: Cannot PTRACE_TRACEME: Operation not permitted\n  gdbserver: linux_ptrace_test_ret_to_nx: status 256 is not WIFSTOPPED!\n  gdbserver: linux_ptrace_test_ret_to_nx: failed to kill child pid 2668100 No such process\n  [ Here you would have to issue a C-c ]\n\nNow, you will see:\n\n  # gdbserver :9988 /usr/bin/true\n  gdbserver: linux_ptrace_test_ret_to_nx: Cannot PTRACE_TRACEME: Permission denied\n  gdbserver: linux_ptrace_test_ret_to_nx: status 256 is not WIFSTOPPED!\n  gdbserver: linux_ptrace_test_ret_to_nx: failed to kill child pid 2766868 No such process\n  gdbserver: Could not trace the inferior process.\n  gdbserver: ptrace: Permission denied\n  The SELinux 'deny_ptrace' option is enabled and preventing GDB\n  from using 'ptrace'.  You can disable it by executing (as root):\n\n    setsebool deny_ptrace off\n\n  If you are debugging the inferior remotely, the ptrace restriction(s) need\n  to be disabled in the target system (e.g., where GDBserver is running).\n  #\n\n(I decided to keep all the other messages, even though I find them a\nbit distracting).\n\nIf GDB can't determine the cause for the failure, it will still print\nthe generic error message which tells the user to check our\ndocumentation:\n\n  There might be restrictions preventing ptrace from working.  Please see\n  the appendix \"Linux kernel ptrace restrictions\" in the GDB documentation\n  for more details.\n  If you are debugging the inferior remotely, the ptrace restriction(s) need\n  to be disabled in the target system (e.g., where GDBserver is running).\n\nThis means that the patch expands our documentation and creates a new\nappendix section named \"Linux kernel ptrace restrictions\", with\nsub-sections for each possible restriction that might be in place.\n\nNotice how, on every message, we instruct the user to \"do the right\nthing\" if gdbserver is being used.  This is because if the user\nstarted gdbserver *before* any ptrace restriction was in place, and\nthen, for some reason, one or more restrictions get enabled, then the\nerror message will be displayed both on gdbserver *and* on the\nconnected GDB.  Since the user will be piloting GDB, it's important to\nexplicitly say that the ptrace restrictions are enabled in the target,\nwhere gdbserver is running.\n\nThe current list of possible restrictions is:\n\n  - SELinux's 'deny_ptrace' option (detected).\n\n  - YAMA's /proc/sys/kernel/yama/ptrace_scope setting (detected).\n\n  - seccomp on Docker containers (I couldn't find how to detect).\n\nIt's important to mention that all of this is Linux-specific; as far\nas I know, SELinux, YAMA and seccomp are Linux-only features.\n\nI tested this patch locally, on my Fedora 30 machine (actually, a\nFedora Rawhide VM), but I'm not proposing a testcase for it because of\nthe difficulty of writing one.\n\nWDYT?\n\ngdb/doc/ChangeLog:\n2019-09-26  Sergio Durigan Junior  <sergiodj@redhat.com>\n\n\t* gdb.texinfo (Linux kernel ptrace restrictions): New appendix\n\tsection.\n\ngdb/ChangeLog:\n2019-09-26  Sergio Durigan Junior  <sergiodj@redhat.com>\n\t    Jan Kratochvil  <jan.kratochvil@redhat.com>\n\t    Pedro Alves  <palves@redhat.com>\n\n\t* gdbsupport/gdb-dlfcn.h (gdb_dlopen): Update comment and\n\tmention that the function throws an error.\n\t* inf-ptrace.c (default_inf_ptrace_me_fail_reason): New\n\tfunction.\n\t(inf_ptrace_me_fail_reason): New variable.\n\t(inf_ptrace_me): Update call to 'trace_start_error_with_name'.\n\t* inf-ptrace.h (inf_ptrace_me_fail_reason): New variable.\n\t* linux-nat.c (attach_proc_task_lwp_callback): Call\n\t'linux_ptrace_attach_fail_reason_lwp'.\n\t(linux_nat_target::attach): Update call to\n\t'linux_ptrace_attach_fail_reason'.\n\t(_initialize_linux_nat): Set 'inf_ptrace_me_fail_reason'.\n\t* nat/fork-inferior.c (trace_start_error_with_name): Add\n\toptional 'append' argument.\n\t* nat/fork-inferior.h (trace_start_error_with_name): Update\n\tprototype.\n\t* nat/linux-ptrace.c: Include \"gdbsupport/gdb-dlfcn.h\",\n\t\"gdbsupport/filestuff.h\" and \"nat/fork-inferior.h\".\n\t(selinux_ftype): New typedef.\n\t(linux_ptrace_restricted_fail_reason): New function.\n\t(linux_ptrace_attach_fail_reason_1): New function.\n\t(linux_ptrace_attach_fail_reason): Change first argument type\n\tfrom 'ptid_t' to 'pid_t'.  Call\n\t'linux_ptrace_attach_fail_reason_1' and\n\t'linux_ptrace_restricted_fail_reason'.\n\t(linux_ptrace_attach_fail_reason_lwp): New function.\n\t(linux_ptrace_me_fail_reason): New function.\n\t(errno_pipe): New variable.\n\t(linux_fork_to_function): Initialize pipe before forking.\n\t(linux_child_function): Deal with errno-passing from child.\n\tHandle ptrace error.\n\t(linux_check_child_ptrace_errno): New function.\n\t(linux_check_child_ptrace_errno): Call\n\t'linux_check_child_ptrace_errno'.\n\t* nat/linux-ptrace.h (linux_ptrace_attach_fail_reason): Update\n\tprototype.\n\t(linux_ptrace_attach_fail_reason_lwp): New prototype.\n\t(linux_ptrace_me_fail_reason): New prototype.\n\t* remote.c (extended_remote_target::attach): Handle error\n\tmessage passed by the server when attach fails.\n\ngdb/gdbserver/ChangeLog:\n2019-09-26  Sergio Durigan Junior  <sergiodj@redhat.com>\n\t    Pedro Alves  <palves@redhat.com>\n\n\t* linux-low.c (linux_ptrace_fun): Call\n\t'linux_ptrace_me_fail_reason'.\n\t(attach_proc_task_lwp_callback): Call\n\t'linux_ptrace_attach_fail_reason_lwp'.\n\t(linux_attach): Call 'linux_ptrace_attach_fail_reason'.\n\t* server.c (handle_v_attach): Use try..catch when calling\n\t'attach_inferior', and send an error message to the client\n\twhen needed.\n\t* thread-db.c (attach_thread): Call\n\t'linux_ptrace_attach_fail_reason_lwp'.",
    "tree": {
      "sha": "d749798327198ef279f40fb49eef33feb06defdf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d749798327198ef279f40fb49eef33feb06defdf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/381beca6146ac68b57edf47d28cdb335fbd11635",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/381beca6146ac68b57edf47d28cdb335fbd11635",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/381beca6146ac68b57edf47d28cdb335fbd11635",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/381beca6146ac68b57edf47d28cdb335fbd11635/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "ececd218c5254902db3301d700546f6702112c85",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ececd218c5254902db3301d700546f6702112c85",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ececd218c5254902db3301d700546f6702112c85"
    }
  ],
  "stats": {
    "total": 518,
    "additions": 487,
    "deletions": 31
  },
  "files": [
    {
      "sha": "37626bdd1e1e576f9bae7e44889dccf7318edbb5",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 45,
      "deletions": 0,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -1,3 +1,48 @@\n+2019-09-26  Sergio Durigan Junior  <sergiodj@redhat.com>\n+\t    Jan Kratochvil  <jan.kratochvil@redhat.com>\n+\t    Pedro Alves  <palves@redhat.com>\n+\n+\t* gdbsupport/gdb-dlfcn.h (gdb_dlopen): Update comment and\n+\tmention that the function throws an error.\n+\t* inf-ptrace.c (default_inf_ptrace_me_fail_reason): New\n+\tfunction.\n+\t(inf_ptrace_me_fail_reason): New variable.\n+\t(inf_ptrace_me): Update call to 'trace_start_error_with_name'.\n+\t* inf-ptrace.h (inf_ptrace_me_fail_reason): New variable.\n+\t* linux-nat.c (attach_proc_task_lwp_callback): Call\n+\t'linux_ptrace_attach_fail_reason_lwp'.\n+\t(linux_nat_target::attach): Update call to\n+\t'linux_ptrace_attach_fail_reason'.\n+\t(_initialize_linux_nat): Set 'inf_ptrace_me_fail_reason'.\n+\t* nat/fork-inferior.c (trace_start_error_with_name): Add\n+\toptional 'append' argument.\n+\t* nat/fork-inferior.h (trace_start_error_with_name): Update\n+\tprototype.\n+\t* nat/linux-ptrace.c: Include \"gdbsupport/gdb-dlfcn.h\",\n+\t\"gdbsupport/filestuff.h\" and \"nat/fork-inferior.h\".\n+\t(selinux_ftype): New typedef.\n+\t(linux_ptrace_restricted_fail_reason): New function.\n+\t(linux_ptrace_attach_fail_reason_1): New function.\n+\t(linux_ptrace_attach_fail_reason): Change first argument type\n+\tfrom 'ptid_t' to 'pid_t'.  Call\n+\t'linux_ptrace_attach_fail_reason_1' and\n+\t'linux_ptrace_restricted_fail_reason'.\n+\t(linux_ptrace_attach_fail_reason_lwp): New function.\n+\t(linux_ptrace_me_fail_reason): New function.\n+\t(errno_pipe): New variable.\n+\t(linux_fork_to_function): Initialize pipe before forking.\n+\t(linux_child_function): Deal with errno-passing from child.\n+\tHandle ptrace error.\n+\t(linux_check_child_ptrace_errno): New function.\n+\t(linux_check_child_ptrace_errno): Call\n+\t'linux_check_child_ptrace_errno'.\n+\t* nat/linux-ptrace.h (linux_ptrace_attach_fail_reason): Update\n+\tprototype.\n+\t(linux_ptrace_attach_fail_reason_lwp): New prototype.\n+\t(linux_ptrace_me_fail_reason): New prototype.\n+\t* remote.c (extended_remote_target::attach): Handle error\n+\tmessage passed by the server when attach fails.\n+\n 2019-09-26  Christian Biesinger  <cbiesinger@google.com>\n \n \t* blockframe.c (find_pc_partial_function): Change return type to bool."
    },
    {
      "sha": "003c8c2ffea47de467b5ef9e0f595f794c12d8f3",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -1,3 +1,8 @@\n+2019-09-26  Sergio Durigan Junior  <sergiodj@redhat.com>\n+\n+\t* gdb.texinfo (Linux kernel ptrace restrictions): New appendix\n+\tsection.\n+\n 2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* doc/gdb.texinfo (Remote Configuration): Remove documentation for"
    },
    {
      "sha": "e7b5b18f2b329afc4a628918e5e6b7e87116430f",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 143,
      "deletions": 0,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -182,6 +182,9 @@ software in general.  We will miss him.\n                                 @value{GDBN}\n * Operating System Information:: Getting additional information from\n                                  the operating system\n+* Linux kernel ptrace restrictions::        Restrictions sometimes\n+                                            imposed by the Linux\n+                                            kernel on @code{ptrace}\n * Trace File Format::\t\tGDB trace file format\n * Index Section Format::        .gdb_index section format\n * Man Pages::\t\t\tManual pages\n@@ -44665,6 +44668,146 @@ should contain a comma-separated list of cores that this process\n is running on.  Target may provide additional columns,\n which @value{GDBN} currently ignores.\n \n+@node Linux kernel ptrace restrictions\n+@appendix Linux kernel @code{ptrace} restrictions\n+@cindex linux kernel ptrace restrictions, attach\n+\n+The @code{ptrace} system call is used by @value{GDBN} and\n+@code{gdbserver} on GNU/Linux to, among other things, attach to a new\n+or existing inferior in order to start debugging it.  Due to security\n+concerns, some distributions and vendors disable or severely restrict\n+the ability to perform these operations, which can make @value{GDBN}\n+or @code{gdbserver} malfunction.  In this section, we will expand on\n+how this malfunction can manifest itself, and how to modify the\n+system's settings in order to be able to use @value{GDBN} and\n+@code{gdbserver} properly.\n+\n+@menu\n+* The error message::                   The error message displayed when the\n+                                        system prevents @value{GDBN}\n+                                        or @code{gdbserver} from using\n+                                        @code{ptrace}\n+* SELinux's deny_ptrace::               SELinux and the @code{deny_ptrace} option\n+* Yama's ptrace_scope::                 Yama and the @code{ptrace_scope} setting\n+* Docker and seccomp::                  Docker and the @code{seccomp}\n+                                        infrastructure\n+@end menu\n+\n+@node The error message\n+@appendixsection The error message\n+\n+When the system prevents @value{GDBN} or @code{gdbserver} from using\n+the @code{ptrace} system call, you will likely see a descriptive error\n+message explaining what is wrong and how to attempt to fix the\n+problem.  For example, when SELinux's @code{deny_ptrace} option is\n+enabled, you can see:\n+\n+@smallexample\n+$ gdb program\n+...\n+(@value{GDBP}) run\n+Starting program: program\n+warning: Could not trace the inferior process.\n+Error:\n+warning: ptrace: Permission denied\n+The SELinux 'deny_ptrace' option is enabled and preventing @value{GDBN}\n+from using 'ptrace'.  You can disable it by executing (as root):\n+\n+  setsebool deny_ptrace off\n+\n+If you are debugging the inferior remotely, the instruction(s) above must\n+be performed in the target system (e.g., where GDBserver is running).\n+During startup program exited with code 127.\n+(@value{GDBP})\n+@end smallexample\n+\n+Sometimes, it may not be possible to acquire the necessary data to\n+determine the root cause of the failure.  In this case, you will see a\n+generic error message pointing you to this section:\n+\n+@smallexample\n+$ gdb program\n+...\n+Starting program: program\n+warning: Could not trace the inferior process.\n+Error:\n+warning: ptrace: Permission denied\n+There might be restrictions preventing ptrace from working.  Please see\n+the appendix \"Linux kernel ptrace restrictions\" in the GDB documentation\n+for more details.\n+During startup program exited with code 127.\n+(@value{GDBP})\n+@end smallexample\n+\n+@node SELinux's deny_ptrace\n+@appendixsection SELinux's @code{deny_ptrace}\n+@cindex SELinux\n+@cindex deny_ptrace\n+\n+If you are using SELinux, you might want to check whether the\n+@code{deny_ptrace} option is enabled by doing:\n+\n+@smallexample\n+$ getsebool deny_ptrace\n+deny_ptrace --> on\n+@end smallexample\n+\n+If the option is enabled, you can disable it by doing, as root:\n+\n+@smallexample\n+# setsebool deny_ptrace off\n+@end smallexample\n+\n+The option will be disabled until the next reboot.  If you would like\n+to disable it permanently, you can do (as root):\n+\n+@smallexample\n+# setsebool -P deny_ptrace off\n+@end smallexample\n+\n+@node Yama's ptrace_scope\n+@appendixsection Yama's @code{ptrace_scope}\n+@cindex yama, ptrace_scope\n+\n+If your system has Yama enabled, you might want to check whether the\n+@code{ptrace_scope} setting is enabled by checking the value of\n+@file{/proc/sys/kernel/yama/ptrace_scope}:\n+\n+@smallexample\n+$ cat /proc/sys/kernel/yama/ptrace_scope\n+0\n+@end smallexample\n+\n+If you see anything other than @code{0}, @value{GDBN} or\n+@code{gdbserver} can be affected by it.  You can temporarily disable\n+the feature by doing, as root:\n+\n+@smallexample\n+# sysctl kernel.yama.ptrace_scope=0\n+kernel.yama.ptrace_scope = 0\n+@end smallexample\n+\n+You can make this permanent by doing, as root:\n+\n+@smallexample\n+# sysctl -w kernel.yama.ptrace_scope=0\n+kernel.yama.ptrace_scope = 0\n+@end smallexample\n+\n+@node Docker and seccomp\n+@appendixsection Docker and @code{seccomp}\n+@cindex docker, seccomp\n+\n+If you are using Docker (@uref{https://www.docker.com/}) containers,\n+you will probably have to disable its @code{seccomp} protections in\n+order to be able to use @value{GDBN} or @code{gdbserver}.  To do that,\n+you can use the options @code{--cap-add=SYS_PTRACE --security-opt\n+seccomp=unconfined} when invoking Docker:\n+\n+@smallexample\n+$ docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined\n+@end smallexample\n+\n @node Trace File Format\n @appendix Trace File Format\n @cindex trace file format"
    },
    {
      "sha": "e60980dc560b0032f1c55aefda98586845c0d659",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -1,3 +1,17 @@\n+2019-09-26  Sergio Durigan Junior  <sergiodj@redhat.com>\n+\t    Pedro Alves  <palves@redhat.com>\n+\n+\t* linux-low.c (linux_ptrace_fun): Call\n+\t'linux_ptrace_me_fail_reason'.\n+\t(attach_proc_task_lwp_callback): Call\n+\t'linux_ptrace_attach_fail_reason_lwp'.\n+\t(linux_attach): Call 'linux_ptrace_attach_fail_reason'.\n+\t* server.c (handle_v_attach): Use try..catch when calling\n+\t'attach_inferior', and send an error message to the client\n+\twhen needed.\n+\t* thread-db.c (attach_thread): Call\n+\t'linux_ptrace_attach_fail_reason_lwp'.\n+\n 2019-09-20  Christian Biesinger  <cbiesinger@google.com>\n \n \t* debug.c (debug_threads): Remove comment in favor of the header."
    },
    {
      "sha": "c0e15c122f2a7314594c5149d53934061313701d",
      "filename": "gdb/gdbserver/linux-low.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/linux-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/linux-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-low.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -967,7 +967,8 @@ linux_ptrace_fun ()\n {\n   if (ptrace (PTRACE_TRACEME, 0, (PTRACE_TYPE_ARG3) 0,\n \t      (PTRACE_TYPE_ARG4) 0) < 0)\n-    trace_start_error_with_name (\"ptrace\");\n+    trace_start_error_with_name (\"ptrace\",\n+\t\t\t\t linux_ptrace_me_fail_reason (errno).c_str ());\n \n   if (setpgid (0, 0) < 0)\n     trace_start_error_with_name (\"setpgid\");\n@@ -1165,7 +1166,7 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n       else if (err != 0)\n \t{\n \t  std::string reason\n-\t    = linux_ptrace_attach_fail_reason_string (ptid, err);\n+\t    = linux_ptrace_attach_fail_reason_lwp (ptid, err);\n \n \t  warning (_(\"Cannot attach to lwp %d: %s\"), lwpid, reason.c_str ());\n \t}\n@@ -1197,8 +1198,8 @@ linux_attach (unsigned long pid)\n     {\n       remove_process (proc);\n \n-      std::string reason = linux_ptrace_attach_fail_reason_string (ptid, err);\n-      error (\"Cannot attach to process %ld: %s\", pid, reason.c_str ());\n+      std::string reason = linux_ptrace_attach_fail_reason (pid, err);\n+      error (_(\"Cannot attach to process %ld: %s\"), pid, reason.c_str ());\n     }\n \n   /* Don't ignore the initial SIGSTOP if we just attached to this"
    },
    {
      "sha": "976ecbd2dfbfe2d137a6a37944df804b1c93bb7d",
      "filename": "gdb/gdbserver/server.c",
      "status": "modified",
      "additions": 13,
      "deletions": 1,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/server.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/server.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/server.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -2893,9 +2893,21 @@ handle_v_attach (char *own_buf)\n {\n   client_state &cs = get_client_state ();\n   int pid;\n+  int ret;\n \n   pid = strtol (own_buf + 8, NULL, 16);\n-  if (pid != 0 && attach_inferior (pid) == 0)\n+\n+  try\n+    {\n+      ret = attach_inferior (pid);\n+    }\n+  catch (const gdb_exception_error &e)\n+    {\n+      snprintf (own_buf, PBUFSIZ, \"E.%s\", e.what ());\n+      return 0;\n+    }\n+\n+  if (pid != 0 && ret == 0)\n     {\n       /* Don't report shared library events after attaching, even if\n \t some libraries are preloaded.  GDB will always poll the"
    },
    {
      "sha": "e3acf83850245467c5f4b66fecc3656388a30955",
      "filename": "gdb/gdbserver/thread-db.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbserver/thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/thread-db.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -224,7 +224,7 @@ attach_thread (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p)\n   err = linux_attach_lwp (ptid);\n   if (err != 0)\n     {\n-      std::string reason = linux_ptrace_attach_fail_reason_string (ptid, err);\n+      std::string reason = linux_ptrace_attach_fail_reason_lwp (ptid, err);\n \n       warning (\"Could not attach to thread %ld (LWP %d): %s\",\n \t       (unsigned long) ti_p->ti_tid, ti_p->ti_lid, reason.c_str ());"
    },
    {
      "sha": "e933b7a473e2c0401c198e49125a042ab829103e",
      "filename": "gdb/gdbsupport/gdb-dlfcn.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbsupport/gdb-dlfcn.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/gdbsupport/gdb-dlfcn.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbsupport/gdb-dlfcn.h?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -32,8 +32,8 @@ struct dlclose_deleter\n typedef std::unique_ptr<void, dlclose_deleter> gdb_dlhandle_up;\n \n /* Load the dynamic library file named FILENAME, and return a handle\n-   for that dynamic library.  Return NULL if the loading fails for any\n-   reason.  */\n+   for that dynamic library.  Throw an error if the loading fails for\n+   any reason.  */\n \n gdb_dlhandle_up gdb_dlopen (const char *filename);\n "
    },
    {
      "sha": "b792af00d10d085d5482d779e9bd41e80fc3a8b8",
      "filename": "gdb/inf-ptrace.c",
      "status": "modified",
      "additions": 16,
      "deletions": 1,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/inf-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/inf-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -94,14 +94,29 @@ inf_ptrace_target::remove_fork_catchpoint (int pid)\n #endif /* PT_GET_PROCESS_STATE */\n \f\n \n+/* Default method for \"inf_ptrace_me_fail_reason\", which returns an\n+   empty string.  */\n+\n+static std::string\n+default_inf_ptrace_me_fail_reason (int err)\n+{\n+  return {};\n+}\n+\n+/* See inf-ptrace.h.  */\n+\n+std::string (*inf_ptrace_me_fail_reason) (int err)\n+  = default_inf_ptrace_me_fail_reason;\n+\n /* Prepare to be traced.  */\n \n static void\n inf_ptrace_me (void)\n {\n   /* \"Trace me, Dr. Memory!\"  */\n   if (ptrace (PT_TRACE_ME, 0, (PTRACE_TYPE_ARG3) 0, 0) < 0)\n-    trace_start_error_with_name (\"ptrace\");\n+    trace_start_error_with_name (\"ptrace\",\n+\t\t\t\t inf_ptrace_me_fail_reason (errno).c_str ());\n }\n \n /* Start a new inferior Unix child process.  EXEC_FILE is the file to"
    },
    {
      "sha": "7cdab9af892d44cefa86dcb0e5ad4d54bfc8219f",
      "filename": "gdb/inf-ptrace.h",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/inf-ptrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/inf-ptrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.h?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -83,4 +83,14 @@ struct inf_ptrace_target : public inf_child_target\n \n extern pid_t get_ptrace_pid (ptid_t);\n \n+/* Pointer to \"inf_ptrace_me_fail_reason\", which implements a function\n+   that can be called by \"inf_ptrace_me\" in order to obtain the reason\n+   for a ptrace failure.  ERR is the ERRNO value set by the failing\n+   ptrace call.\n+\n+   This pointer can be overriden by targets that want to personalize\n+   the error message printed when ptrace fails (see linux-nat.c, for\n+   example).  */\n+extern std::string (*inf_ptrace_me_fail_reason) (int err);\n+\n #endif"
    },
    {
      "sha": "2c7ded70436cbbd989484d9651762383ad8e83b6",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -1132,7 +1132,7 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t  else\n \t    {\n \t      std::string reason\n-\t\t= linux_ptrace_attach_fail_reason_string (ptid, err);\n+\t\t= linux_ptrace_attach_fail_reason_lwp (ptid, err);\n \n \t      warning (_(\"Cannot attach to lwp %d: %s\"),\n \t\t       lwpid, reason.c_str ());\n@@ -1187,8 +1187,9 @@ linux_nat_target::attach (const char *args, int from_tty)\n     }\n   catch (const gdb_exception_error &ex)\n     {\n+      int saved_errno = errno;\n       pid_t pid = parse_pid_to_attach (args);\n-      std::string reason = linux_ptrace_attach_fail_reason (pid);\n+      std::string reason = linux_ptrace_attach_fail_reason (pid, saved_errno);\n \n       if (!reason.empty ())\n \tthrow_error (ex.error, \"warning: %s\\n%s\", reason.c_str (),\n@@ -4567,6 +4568,10 @@ Enables printf debugging output.\"),\n   sigemptyset (&blocked_mask);\n \n   lwp_lwpid_htab_create ();\n+\n+  /* Set the proper function to generate a message when ptrace\n+     fails.  */\n+  inf_ptrace_me_fail_reason = linux_ptrace_me_fail_reason;\n }\n \f\n "
    },
    {
      "sha": "2ead4a4858b4c77e94427e8aff8e7aa53ee85cb7",
      "filename": "gdb/nat/fork-inferior.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/fork-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/fork-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/fork-inferior.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -591,7 +591,7 @@ trace_start_error (const char *fmt, ...)\n /* See nat/fork-inferior.h.  */\n \n void\n-trace_start_error_with_name (const char *string)\n+trace_start_error_with_name (const char *string, const char *append)\n {\n-  trace_start_error (\"%s: %s\", string, safe_strerror (errno));\n+  trace_start_error (\"%s: %s%s\", string, safe_strerror (errno), append);\n }"
    },
    {
      "sha": "405f2cf548bae2a6b20065a609f26f73056fa7bf",
      "filename": "gdb/nat/fork-inferior.h",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/fork-inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/fork-inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/fork-inferior.h?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -98,9 +98,10 @@ extern void trace_start_error (const char *fmt, ...)\n   ATTRIBUTE_NORETURN ATTRIBUTE_PRINTF (1, 2);\n \n /* Like \"trace_start_error\", but the error message is constructed by\n-   combining STRING with the system error message for errno.  This\n-   function does not return.  */\n-extern void trace_start_error_with_name (const char *string)\n+   combining STRING with the system error message for errno, and\n+   (optionally) with APPEND.  This function does not return.  */\n+extern void trace_start_error_with_name (const char *string,\n+\t\t\t\t\t const char *append = \"\")\n   ATTRIBUTE_NORETURN;\n \n #endif /* NAT_FORK_INFERIOR_H */"
    },
    {
      "sha": "8a048d2ec99cb08d4039600e81ae827e973277e0",
      "filename": "gdb/nat/linux-ptrace.c",
      "status": "modified",
      "additions": 185,
      "deletions": 7,
      "changes": 192,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/linux-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/linux-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-ptrace.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -21,6 +21,9 @@\n #include \"linux-procfs.h\"\n #include \"linux-waitpid.h\"\n #include \"gdbsupport/buffer.h\"\n+#include \"gdbsupport/gdb-dlfcn.h\"\n+#include \"nat/fork-inferior.h\"\n+#include \"gdbsupport/filestuff.h\"\n #ifdef HAVE_SYS_PROCFS_H\n #include <sys/procfs.h>\n #endif\n@@ -30,11 +33,94 @@\n    of 0 means there are no supported features.  */\n static int supported_ptrace_options = -1;\n \n-/* Find all possible reasons we could fail to attach PID and return these\n-   as a string.  An empty string is returned if we didn't find any reason.  */\n+typedef int (*selinux_ftype) (const char *);\n \n-std::string\n-linux_ptrace_attach_fail_reason (pid_t pid)\n+/* Helper function which checks if ptrace is probably restricted\n+   (i.e., if ERR is either EACCES or EPERM), and returns a string with\n+   possible workarounds.  */\n+\n+static std::string\n+linux_ptrace_restricted_fail_reason (int err)\n+{\n+  if (err != EACCES && err != EPERM)\n+    {\n+      /* It just makes sense to perform the checks below if errno was\n+\t either EACCES or EPERM.  */\n+      return {};\n+    }\n+\n+  std::string ret;\n+  gdb_dlhandle_up handle;\n+\n+  try\n+    {\n+      handle = gdb_dlopen (\"libselinux.so.1\");\n+    }\n+  catch (const gdb_exception_error &e)\n+    {\n+      handle.reset (nullptr);\n+    }\n+\n+  if (handle != nullptr)\n+    {\n+      selinux_ftype selinux_get_bool\n+\t= (selinux_ftype) gdb_dlsym (handle, \"security_get_boolean_active\");\n+\n+      if (selinux_get_bool != NULL\n+\t  && (*selinux_get_bool) (\"deny_ptrace\") == 1)\n+\tstring_appendf (ret,\n+\t\t\t_(\"\\n\\\n+The SELinux 'deny_ptrace' option is enabled and preventing GDB\\n\\\n+from using 'ptrace'.  You can disable it by executing (as root):\\n\\\n+\\n\\\n+  setsebool deny_ptrace off\\n\"));\n+    }\n+\n+  gdb_file_up yama_ptrace_scope\n+    = gdb_fopen_cloexec (\"/proc/sys/kernel/yama/ptrace_scope\", \"r\");\n+\n+  if (yama_ptrace_scope != nullptr)\n+    {\n+      char yama_scope = fgetc (yama_ptrace_scope.get ());\n+\n+      if (yama_scope != '0')\n+\tstring_appendf (ret,\n+\t\t\t_(\"\\n\\\n+The Linux kernel's Yama ptrace scope is in effect, which can prevent\\n\\\n+GDB from using 'ptrace'.  You can disable it by executing (as root):\\n\\\n+\\n\\\n+  echo 0 > /proc/sys/kernel/yama/ptrace_scope\\n\"));\n+    }\n+\n+  if (ret.empty ())\n+    {\n+      /* It wasn't possible to determine the exact reason for the\n+\t ptrace error.  Let's just emit a generic error message\n+\t pointing the user to our documentation, where she can find\n+\t instructions on how to try to diagnose the problem.  */\n+      ret = _(\"\\n\\\n+There might be restrictions preventing ptrace from working.  Please see\\n\\\n+the appendix \\\"Linux kernel ptrace restrictions\\\" in the GDB documentation\\n\\\n+for more details.\");\n+    }\n+\n+  /* The user may be debugging remotely, so we have to warn that\n+     the instructions above should be performed in the target.  */\n+  string_appendf (ret,\n+\t\t  _(\"\\n\\\n+If you are debugging the inferior remotely, the ptrace restriction(s) must\\n\\\n+be disabled in the target system (e.g., where GDBserver is running).\"));\n+\n+  return ret;\n+}\n+\n+/* Find all possible reasons we could fail to attach PID and return\n+   these as a string.  An empty string is returned if we didn't find\n+   any reason.  Helper for linux_ptrace_attach_fail_reason and\n+   linux_ptrace_attach_fail_reason_lwp.  */\n+\n+static std::string\n+linux_ptrace_attach_fail_reason_1 (pid_t pid)\n {\n   pid_t tracerpid = linux_proc_get_tracerpid_nowarn (pid);\n   std::string result;\n@@ -56,10 +142,24 @@ linux_ptrace_attach_fail_reason (pid_t pid)\n /* See linux-ptrace.h.  */\n \n std::string\n-linux_ptrace_attach_fail_reason_string (ptid_t ptid, int err)\n+linux_ptrace_attach_fail_reason (pid_t pid, int err)\n+{\n+  std::string result = linux_ptrace_attach_fail_reason_1 (pid);\n+  std::string ptrace_restrict = linux_ptrace_restricted_fail_reason (err);\n+\n+  if (!ptrace_restrict.empty ())\n+    result += \"\\n\" + ptrace_restrict;\n+\n+  return result;\n+}\n+\n+/* See linux-ptrace.h.  */\n+\n+std::string\n+linux_ptrace_attach_fail_reason_lwp (ptid_t ptid, int err)\n {\n   long lwpid = ptid.lwp ();\n-  std::string reason = linux_ptrace_attach_fail_reason (lwpid);\n+  std::string reason = linux_ptrace_attach_fail_reason_1 (lwpid);\n \n   if (!reason.empty ())\n     return string_printf (\"%s (%d), %s\", safe_strerror (err), err,\n@@ -68,6 +168,14 @@ linux_ptrace_attach_fail_reason_string (ptid_t ptid, int err)\n     return string_printf (\"%s (%d)\", safe_strerror (err), err);\n }\n \n+/* See linux-ptrace.h.  */\n+\n+std::string\n+linux_ptrace_me_fail_reason (int err)\n+{\n+  return linux_ptrace_restricted_fail_reason (err);\n+}\n+\n #if defined __i386__ || defined __x86_64__\n \n /* Address of the 'ret' instruction in asm code block below.  */\n@@ -257,6 +365,12 @@ linux_ptrace_test_ret_to_nx (void)\n #endif /* defined __i386__ || defined __x86_64__ */\n }\n \n+/* If the PTRACE_TRACEME call on linux_child_function errors, we need\n+   to be able to send ERRNO back to the parent so that it can check\n+   whether there are restrictions in place preventing ptrace from\n+   working.  We do that with a pipe.  */\n+static int errno_pipe[2];\n+\n /* Helper function to fork a process and make the child process call\n    the function FUNCTION, passing CHILD_STACK as parameter.\n \n@@ -273,6 +387,11 @@ linux_fork_to_function (gdb_byte *child_stack, int (*function) (void *))\n   /* Sanity check the function pointer.  */\n   gdb_assert (function != NULL);\n \n+  /* Create the pipe that will be used by the child to pass ERRNO\n+     after the PTRACE_TRACEME call.  */\n+  if (pipe (errno_pipe) != 0)\n+    trace_start_error_with_name (\"pipe\");\n+\n #if defined(__UCLIBC__) && defined(HAS_NOMMU)\n #define STACK_SIZE 4096\n \n@@ -321,7 +440,21 @@ linux_grandchild_function (void *child_stack)\n static int\n linux_child_function (void *child_stack)\n {\n-  ptrace (PTRACE_TRACEME, 0, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0);\n+  /* Close read end.  */\n+  close (errno_pipe[0]);\n+\n+  int ret = ptrace (PTRACE_TRACEME, 0, (PTRACE_TYPE_ARG3) 0,\n+\t\t    (PTRACE_TYPE_ARG4) 0);\n+  int ptrace_errno = errno;\n+\n+  /* Write ERRNO to the pipe, even if it's zero, and close the writing\n+     end of the pipe.  */\n+  write (errno_pipe[1], &ptrace_errno, sizeof (ptrace_errno));\n+  close (errno_pipe[1]);\n+\n+  if (ret != 0)\n+    _exit (0);\n+\n   kill (getpid (), SIGSTOP);\n \n   /* Fork a grandchild.  */\n@@ -336,6 +469,48 @@ static void linux_test_for_tracesysgood (int child_pid);\n static void linux_test_for_tracefork (int child_pid);\n static void linux_test_for_exitkill (int child_pid);\n \n+/* Helper function to wait for the child to send us the ptrace ERRNO,\n+   and check if it's OK.  */\n+\n+static void\n+linux_check_child_ptrace_errno ()\n+{\n+  int child_errno;\n+  fd_set rset;\n+  struct timeval timeout;\n+\n+  /* Close the writing end of the pipe.  */\n+  close (errno_pipe[1]);\n+\n+  FD_ZERO (&rset);\n+  FD_SET (errno_pipe[0], &rset);\n+\n+  /* One second should be plenty of time to wait for the child's\n+     reply.  */\n+  timeout.tv_sec = 1;\n+  timeout.tv_usec = 0;\n+\n+  int ret = select (errno_pipe[0] + 1, &rset, NULL, NULL, &timeout);\n+\n+  if (ret < 0)\n+    trace_start_error_with_name (\"select\");\n+  else if (ret == 0)\n+    error (_(\"Timeout while waiting for child's ptrace errno\"));\n+  else\n+    read (errno_pipe[0], &child_errno, sizeof (child_errno));\n+\n+  if (child_errno != 0)\n+    {\n+      /* The child can't use PTRACE_TRACEME.  We just bail out.  */\n+      std::string reason = linux_ptrace_restricted_fail_reason (child_errno);\n+\n+      errno = child_errno;\n+      trace_start_error_with_name (\"ptrace\", reason.c_str ());\n+    }\n+\n+  close (errno_pipe[0]);\n+}\n+\n /* Determine ptrace features available on this target.  */\n \n void\n@@ -352,6 +527,9 @@ linux_check_ptrace_features (void)\n      reporting.  */\n   child_pid = linux_fork_to_function (NULL, linux_child_function);\n \n+  /* Check if the child can successfully use ptrace.  */\n+  linux_check_child_ptrace_errno ();\n+\n   ret = my_waitpid (child_pid, &status, 0);\n   if (ret == -1)\n     perror_with_name ((\"waitpid\"));"
    },
    {
      "sha": "90afb60f3414aabecf4bc06954b97f11758bb8a5",
      "filename": "gdb/nat/linux-ptrace.h",
      "status": "modified",
      "additions": 21,
      "deletions": 6,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/linux-ptrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/nat/linux-ptrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-ptrace.h?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -176,12 +176,27 @@ struct buffer;\n # define TRAP_HWBKPT 4\n #endif\n \n-extern std::string linux_ptrace_attach_fail_reason (pid_t pid);\n-\n-/* Find all possible reasons we could have failed to attach to PTID\n-   and return them as a string.  ERR is the error PTRACE_ATTACH failed\n-   with (an errno).  */\n-extern std::string linux_ptrace_attach_fail_reason_string (ptid_t ptid, int err);\n+/* Find all possible reasons we could fail to attach PID and return\n+   these as a string.  An empty string is returned if we didn't find\n+   any reason.  If ERR is EACCES or EPERM, we also add a warning about\n+   possible restrictions to use ptrace.  */\n+extern std::string linux_ptrace_attach_fail_reason (pid_t pid, int err);\n+\n+/* Find all possible reasons we could have failed to attach to PID's\n+   LWPID and return them as a string.  ERR is the error PTRACE_ATTACH\n+   failed with (an errno).  Unlike linux_ptrace_attach_fail_reason,\n+   this function should be used when attaching to an LWP other than\n+   the leader; it does not warn about ptrace restrictions.  */\n+extern std::string linux_ptrace_attach_fail_reason_lwp (ptid_t pid, int err);\n+\n+/* When the call to 'ptrace (PTRACE_TRACEME...' fails, and we have\n+   already forked, this function can be called in order to try to\n+   obtain the reason why ptrace failed.  ERR should be the ERRNO value\n+   returned by ptrace.\n+\n+   This function will return a 'std::string' containing the fail\n+   reason, or an empty string otherwise.  */\n+extern std::string linux_ptrace_me_fail_reason (int err);\n \n extern void linux_ptrace_init_warnings (void);\n extern void linux_check_ptrace_features (void);"
    },
    {
      "sha": "efc5084cfe5dc0dec6341cdcb2cc0824a760495e",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 14,
      "deletions": 2,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/381beca6146ac68b57edf47d28cdb335fbd11635/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=381beca6146ac68b57edf47d28cdb335fbd11635",
      "patch": "@@ -5825,8 +5825,20 @@ extended_remote_target::attach (const char *args, int from_tty)\n     case PACKET_UNKNOWN:\n       error (_(\"This target does not support attaching to a process\"));\n     default:\n-      error (_(\"Attaching to %s failed\"),\n-\t     target_pid_to_str (ptid_t (pid)).c_str ());\n+      {\n+\tstd::string errmsg = rs->buf.data ();\n+\n+\tif (!errmsg.empty ())\n+\t  {\n+\t    /* Get rid of the \"E.\" prefix.  */\n+\t    errmsg.erase (0, 2);\n+\t  }\n+\n+\terror (_(\"Attaching to %s failed%s%s\"),\n+\t       target_pid_to_str (ptid_t (pid)).c_str (),\n+\t       !errmsg.empty () ? \"\\n\" : \"\",\n+\t       errmsg.c_str ());\n+      }\n     }\n \n   set_current_inferior (remote_add_inferior (false, pid, 1, 0));"
    }
  ]
}