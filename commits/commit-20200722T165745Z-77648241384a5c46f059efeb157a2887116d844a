{
  "sha": "77648241384a5c46f059efeb157a2887116d844a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzc2NDgyNDEzODRhNWM0NmYwNTllZmViMTU3YTI4ODcxMTZkODQ0YQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-02T21:26:38Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T16:57:45Z"
    },
    "message": "libctf, hash: introduce the ctf_dynset\n\nThere are many places in the deduplicator which use hashtables as tiny\nsets: keys with no value (and usually, but not always, no freeing\nfunction) often with only one or a few members.  For each of these, even\nafter the last change to not store the freeing functions, we are storing\na little malloced block for each item just to track the key/value pair,\nand a little malloced block for the hash table itself just to track the\nfreeing function because we can't use libiberty hashtab's freeing\nfunction because we are using that to free the little malloced per-item\nblock.\n\nIf we only have a key, we don't need any of that: we can ditch the\nper-malloced block because we don't have a value, and we can ditch the\nper-hashtab structure because we don't need to independently track the\nfreeing functions since libiberty hashtab is doing it for us.  That\nmeans we don't need an owner field in the (now nonexistent) item block\neither.\n\nRoughly speaking, this datatype saves about 25% in time and 20% in peak\nmemory usage for normal links, even fairly big ones.  So this might seem\nredundant, but it's really worth it.\n\nInstead of a _lookup function, a dynset has two distinct functions:\nctf_dynset_exists, which returns true or false and an optional pointer\nto the set member, and ctf_dynhash_lookup_any, which is used if all\nmembers of the set are expected to be equivalent and we just want *any*\nmember and we don't care which one.\n\nThere is no iterator in this set of functions, not because we don't\niterate over dynset members -- we do, a lot -- but because the iterator\nhere is a member of an entirely new family of much more convenient\niteration functions, introduced in the next commit.\n\nlibctf/\n\t* ctf-hash.c (ctf_dynset_eq_string): New.\n\t(ctf_dynset_create): New.\n\t(DYNSET_EMPTY_ENTRY_REPLACEMENT): New.\n\t(DYNSET_DELETED_ENTRY_REPLACEMENT): New.\n\t(key_to_internal): New.\n\t(internal_to_key): New.\n\t(ctf_dynset_insert): New.\n\t(ctf_dynset_remove): New.\n\t(ctf_dynset_destroy): New.\n\t(ctf_dynset_lookup): New.\n\t(ctf_dynset_exists): New.\n\t(ctf_dynset_lookup_any): New.\n\t(ctf_hash_insert_type): Coding style.\n\t(ctf_hash_define_type): Likewise.\n\n\t* ctf-impl.h (ctf_dynset_t): New.\n\t(ctf_dynset_eq_string): New.\n\t(ctf_dynset_create): New.\n\t(ctf_dynset_insert): New.\n\t(ctf_dynset_remove): New.\n\t(ctf_dynset_destroy): New.\n\t(ctf_dynset_lookup): New.\n\t(ctf_dynset_exists): New.\n\t(ctf_dynset_lookup_any): New.\n\t* ctf-inlines.h (ctf_dynset_cinsert): New.",
    "tree": {
      "sha": "469c5085a14fb2c9151c127ec0fbc36e80afbdc1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/469c5085a14fb2c9151c127ec0fbc36e80afbdc1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/77648241384a5c46f059efeb157a2887116d844a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/77648241384a5c46f059efeb157a2887116d844a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/77648241384a5c46f059efeb157a2887116d844a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/77648241384a5c46f059efeb157a2887116d844a/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a49c6c6a656c429dc222e04628e085a903194b51",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a49c6c6a656c429dc222e04628e085a903194b51",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a49c6c6a656c429dc222e04628e085a903194b51"
    }
  ],
  "stats": {
    "total": 214,
    "additions": 203,
    "deletions": 11
  },
  "files": [
    {
      "sha": "329e69c5f2ea8f99605cd63a56148643448f9708",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/77648241384a5c46f059efeb157a2887116d844a/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/77648241384a5c46f059efeb157a2887116d844a/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=77648241384a5c46f059efeb157a2887116d844a",
      "patch": "@@ -1,3 +1,30 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-hash.c (ctf_dynset_eq_string): New.\n+\t(ctf_dynset_create): New.\n+\t(DYNSET_EMPTY_ENTRY_REPLACEMENT): New.\n+\t(DYNSET_DELETED_ENTRY_REPLACEMENT): New.\n+\t(key_to_internal): New.\n+\t(internal_to_key): New.\n+\t(ctf_dynset_insert): New.\n+\t(ctf_dynset_remove): New.\n+\t(ctf_dynset_destroy): New.\n+\t(ctf_dynset_lookup): New.\n+\t(ctf_dynset_exists): New.\n+\t(ctf_dynset_lookup_any): New.\n+\t(ctf_hash_insert_type): Coding style.\n+\t(ctf_hash_define_type): Likewise.\n+\t* ctf-impl.h (ctf_dynset_t): New.\n+\t(ctf_dynset_eq_string): New.\n+\t(ctf_dynset_create): New.\n+\t(ctf_dynset_insert): New.\n+\t(ctf_dynset_remove): New.\n+\t(ctf_dynset_destroy): New.\n+\t(ctf_dynset_lookup): New.\n+\t(ctf_dynset_exists): New.\n+\t(ctf_dynset_lookup_any): New.\n+\t* ctf-inlines.h (ctf_dynset_cinsert): New.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-hash.c (ctf_helem_t) <key_free>: Remove."
    },
    {
      "sha": "7eba494a51d5af7ce7e3201cf97da7b4fe004595",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 157,
      "deletions": 11,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/77648241384a5c46f059efeb157a2887116d844a/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/77648241384a5c46f059efeb157a2887116d844a/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=77648241384a5c46f059efeb157a2887116d844a",
      "patch": "@@ -22,14 +22,21 @@\n #include \"libiberty.h\"\n #include \"hashtab.h\"\n \n-/* We have two hashtable implementations: one, ctf_dynhash_*(), is an interface to\n-   a dynamically-expanding hash with unknown size that should support addition\n-   of large numbers of items, and removal as well, and is used only at\n-   type-insertion time; the other, ctf_dynhash_*(), is an interface to a\n-   fixed-size hash from const char * -> ctf_id_t with number of elements\n-   specified at creation time, that should support addition of items but need\n-   not support removal.  These can be implemented by the same underlying hashmap\n-   if you wish.  */\n+/* We have three hashtable implementations:\n+\n+   - ctf_hash_* is an interface to a fixed-size hash from const char * ->\n+     ctf_id_t with number of elements specified at creation time, that should\n+     support addition of items but need not support removal.\n+\n+   - ctf_dynhash_* is an interface to a dynamically-expanding hash with\n+     unknown size that should support addition of large numbers of items, and\n+     removal as well, and is used only at type-insertion time and during\n+     linking.\n+\n+   - ctf_dynset_* is an interface to a dynamically-expanding hash that contains\n+     only keys: no values.\n+\n+   These can be implemented by the same underlying hashmap if you wish.  */\n \n /* The helem is used for general key/value mappings in both the ctf_hash and\n    ctf_dynhash: the owner may not have space allocated for it, and will be\n@@ -51,7 +58,7 @@ struct ctf_dynhash\n   ctf_hash_free_fun value_free;\n };\n \n-/* Hash functions. */\n+/* Hash and eq functions for the dynhash and hash. */\n \n unsigned int\n ctf_hash_integer (const void *ptr)\n@@ -109,6 +116,16 @@ ctf_hash_eq_type_mapping_key (const void *a, const void *b)\n     && (key_a->cltm_idx == key_b->cltm_idx);\n }\n \n+\n+/* Hash and eq functions for the dynset.  Most of these can just use the\n+   underlying hashtab functions directly.   */\n+\n+int\n+ctf_dynset_eq_string (const void *a, const void *b)\n+{\n+  return !strcmp((const char *) a, (const char *) b);\n+}\n+\n /* The dynhash, used for hashes whose size is not known at creation time. */\n \n /* Free a single ctf_helem with arbitrary key/value functions.  */\n@@ -369,6 +386,135 @@ ctf_dynhash_destroy (ctf_dynhash_t *hp)\n   free (hp);\n }\n \n+/* The dynset, used for sets of keys with no value.  The implementation of this\n+   can be much simpler, because without a value the slot can simply be the\n+   stored key, which means we don't need to store the freeing functions and the\n+   dynset itself is just a htab.  */\n+\n+ctf_dynset_t *\n+ctf_dynset_create (htab_hash hash_fun, htab_eq eq_fun,\n+\t\t   ctf_hash_free_fun key_free)\n+{\n+  /* 7 is arbitrary and untested for now.  */\n+  return (ctf_dynset_t *) htab_create_alloc (7, (htab_hash) hash_fun, eq_fun,\n+\t\t\t\t\t     key_free, xcalloc, free);\n+}\n+\n+/* The dynset has one complexity: the underlying implementation reserves two\n+   values for internal hash table implementation details (empty versus deleted\n+   entries).  These values are otherwise very useful for pointers cast to ints,\n+   so transform the ctf_dynset_inserted value to allow for it.  (This\n+   introduces an ambiguity in that one can no longer store these two values in\n+   the dynset, but if we pick high enough values this is very unlikely to be a\n+   problem.)\n+\n+   We leak this implementation detail to the freeing functions on the grounds\n+   that any use of these functions is overwhelmingly likely to be in sets using\n+   real pointers, which will be unaffected.  */\n+\n+#define DYNSET_EMPTY_ENTRY_REPLACEMENT ((void *) (uintptr_t) -64)\n+#define DYNSET_DELETED_ENTRY_REPLACEMENT ((void *) (uintptr_t) -63)\n+\n+static void *\n+key_to_internal (const void *key)\n+{\n+  if (key == HTAB_EMPTY_ENTRY)\n+    return DYNSET_EMPTY_ENTRY_REPLACEMENT;\n+  else if (key == HTAB_DELETED_ENTRY)\n+    return DYNSET_DELETED_ENTRY_REPLACEMENT;\n+\n+  return (void *) key;\n+}\n+\n+static void *\n+internal_to_key (const void *internal)\n+{\n+  if (internal == DYNSET_EMPTY_ENTRY_REPLACEMENT)\n+    return HTAB_EMPTY_ENTRY;\n+  else if (internal == DYNSET_DELETED_ENTRY_REPLACEMENT)\n+    return HTAB_DELETED_ENTRY;\n+  return (void *) internal;\n+}\n+\n+int\n+ctf_dynset_insert (ctf_dynset_t *hp, void *key)\n+{\n+  struct htab *htab = (struct htab *) hp;\n+  void **slot;\n+\n+  slot = htab_find_slot (htab, key, INSERT);\n+\n+  if (!slot)\n+    {\n+      errno = ENOMEM;\n+      return -errno;\n+    }\n+\n+  if (*slot)\n+    {\n+      if (htab->del_f)\n+\t(*htab->del_f) (*slot);\n+    }\n+\n+  *slot = key_to_internal (key);\n+\n+  return 0;\n+}\n+\n+void\n+ctf_dynset_remove (ctf_dynset_t *hp, const void *key)\n+{\n+  htab_remove_elt ((struct htab *) hp, key_to_internal (key));\n+}\n+\n+void\n+ctf_dynset_destroy (ctf_dynset_t *hp)\n+{\n+  if (hp != NULL)\n+    htab_delete ((struct htab *) hp);\n+}\n+\n+void *\n+ctf_dynset_lookup (ctf_dynset_t *hp, const void *key)\n+{\n+  void **slot = htab_find_slot ((struct htab *) hp,\n+\t\t\t\tkey_to_internal (key), NO_INSERT);\n+\n+  if (slot)\n+    return internal_to_key (*slot);\n+  return NULL;\n+}\n+\n+/* TRUE/FALSE return.  */\n+int\n+ctf_dynset_exists (ctf_dynset_t *hp, const void *key, const void **orig_key)\n+{\n+  void **slot = htab_find_slot ((struct htab *) hp,\n+\t\t\t\tkey_to_internal (key), NO_INSERT);\n+\n+  if (orig_key && slot)\n+    *orig_key = internal_to_key (*slot);\n+  return (slot != NULL);\n+}\n+\n+/* Look up a completely random value from the set, if any exist.\n+   Keys with value zero cannot be distinguished from a nonexistent key.  */\n+void *\n+ctf_dynset_lookup_any (ctf_dynset_t *hp)\n+{\n+  struct htab *htab = (struct htab *) hp;\n+  void **slot = htab->entries;\n+  void **limit = slot + htab_size (htab);\n+\n+  while (slot < limit\n+\t && (*slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY))\n+      slot++;\n+\n+  if (slot < limit)\n+    return internal_to_key (*slot);\n+  return NULL;\n+}\n+\n /* ctf_hash, used for fixed-size maps from const char * -> ctf_id_t without\n    removal.  This is a straight cast of a hashtab.  */\n \n@@ -415,12 +561,12 @@ ctf_hash_insert_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n \n /* if the key is already in the hash, override the previous definition with\n    this new official definition. If the key is not present, then call\n-   ctf_hash_insert_type() and hash it in.  */\n+   ctf_hash_insert_type and hash it in.  */\n int\n ctf_hash_define_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n                       uint32_t name)\n {\n-  /* This matches the semantics of ctf_hash_insert_type() in this\n+  /* This matches the semantics of ctf_hash_insert_type in this\n      implementation anyway.  */\n \n   return ctf_hash_insert_type (hp, fp, type, name);"
    },
    {
      "sha": "7d583ab6679065a36a61c32667b127f855150557",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/77648241384a5c46f059efeb157a2887116d844a/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/77648241384a5c46f059efeb157a2887116d844a/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=77648241384a5c46f059efeb157a2887116d844a",
      "patch": "@@ -34,6 +34,7 @@\n #include <ctype.h>\n #include <elf.h>\n #include <bfd.h>\n+#include \"hashtab.h\"\n \n #ifdef\t__cplusplus\n extern \"C\"\n@@ -73,6 +74,7 @@ extern \"C\"\n \n typedef struct ctf_fixed_hash ctf_hash_t; /* Private to ctf-hash.c.  */\n typedef struct ctf_dynhash ctf_dynhash_t; /* Private to ctf-hash.c.  */\n+typedef struct ctf_dynset ctf_dynset_t;   /* Private to ctf-hash.c.  */\n \n typedef struct ctf_strs\n {\n@@ -378,6 +380,8 @@ extern int ctf_hash_eq_integer (const void *, const void *);\n extern int ctf_hash_eq_string (const void *, const void *);\n extern int ctf_hash_eq_type_mapping_key (const void *, const void *);\n \n+extern int ctf_dynset_eq_string (const void *, const void *);\n+\n typedef void (*ctf_hash_free_fun) (void *);\n \n typedef void (*ctf_hash_iter_f) (void *key, void *value, void *arg);\n@@ -407,6 +411,15 @@ extern void ctf_dynhash_iter_remove (ctf_dynhash_t *, ctf_hash_iter_remove_f,\n extern void *ctf_dynhash_iter_find (ctf_dynhash_t *, ctf_hash_iter_find_f,\n \t\t\t\t    void *);\n \n+extern ctf_dynset_t *ctf_dynset_create (htab_hash, htab_eq, ctf_hash_free_fun);\n+extern int ctf_dynset_insert (ctf_dynset_t *, void *);\n+extern void ctf_dynset_remove (ctf_dynset_t *, const void *);\n+extern void ctf_dynset_destroy (ctf_dynset_t *);\n+extern void *ctf_dynset_lookup (ctf_dynset_t *, const void *);\n+extern int ctf_dynset_exists (ctf_dynset_t *, const void *key,\n+\t\t\t      const void **orig_key);\n+extern void *ctf_dynset_lookup_any (ctf_dynset_t *);\n+\n #define\tctf_list_prev(elem)\t((void *)(((ctf_list_t *)(elem))->l_prev))\n #define\tctf_list_next(elem)\t((void *)(((ctf_list_t *)(elem))->l_next))\n "
    },
    {
      "sha": "f9c1b2adbfbd27e2fc87e2276b45ba5f5f5c423f",
      "filename": "libctf/ctf-inlines.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/77648241384a5c46f059efeb157a2887116d844a/libctf/ctf-inlines.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/77648241384a5c46f059efeb157a2887116d844a/libctf/ctf-inlines.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-inlines.h?ref=77648241384a5c46f059efeb157a2887116d844a",
      "patch": "@@ -38,6 +38,12 @@ ctf_dynhash_cinsert (ctf_dynhash_t *h, const void *k, const void *v)\n   return ctf_dynhash_insert (h, (void *) k, (void *) v);\n }\n \n+static inline int\n+ctf_dynset_cinsert (ctf_dynset_t *h, const void *k)\n+{\n+  return ctf_dynset_insert (h, (void *) k);\n+}\n+\n #ifdef\t__cplusplus\n }\n #endif"
    }
  ]
}