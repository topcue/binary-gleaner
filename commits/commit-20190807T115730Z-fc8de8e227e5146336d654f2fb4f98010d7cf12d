{
  "sha": "fc8de8e227e5146336d654f2fb4f98010d7cf12d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmM4ZGU4ZTIyN2U1MTQ2MzM2ZDY1NGYyZmI0Zjk4MDEwZDdjZjEyZA==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-08-07T09:33:13Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-08-07T11:57:30Z"
    },
    "message": "bfd: use the ELF linker to perform relocations in BPF targets\n\nThis patch changes the eBPF linker to provide a relocate_section\nfunction instead of relying on using special functions in relocation\nhowtos.\n\nTested in x86_64 host.\nNo regressions.\n\nbfd/ChangeLog:\n\n2019-08-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\n\t* elf64-bpf.c (bpf_elf_relocate_section): New function.\n\t(bpf_elf_insn_disp_reloc): Delete function.\n\t(elf_backend_relocate_section): Define.",
    "tree": {
      "sha": "898b2d933b509006b8fee2ff5580751ff1574428",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/898b2d933b509006b8fee2ff5580751ff1574428"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fc8de8e227e5146336d654f2fb4f98010d7cf12d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fc8de8e227e5146336d654f2fb4f98010d7cf12d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fc8de8e227e5146336d654f2fb4f98010d7cf12d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fc8de8e227e5146336d654f2fb4f98010d7cf12d/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "97b031c5d6d42ff2b1758a8a8c332cb44ba9c06f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/97b031c5d6d42ff2b1758a8a8c332cb44ba9c06f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/97b031c5d6d42ff2b1758a8a8c332cb44ba9c06f"
    }
  ],
  "stats": {
    "total": 288,
    "additions": 193,
    "deletions": 95
  },
  "files": [
    {
      "sha": "7b0da656230775b352d19dda47a94c162341cc00",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fc8de8e227e5146336d654f2fb4f98010d7cf12d/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fc8de8e227e5146336d654f2fb4f98010d7cf12d/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=fc8de8e227e5146336d654f2fb4f98010d7cf12d",
      "patch": "@@ -1,3 +1,9 @@\n+2019-08-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* elf64-bpf.c (bpf_elf_relocate_section): New function.\n+\t(bpf_elf_insn_disp_reloc): Delete function.\n+\t(elf_backend_relocate_section): Define.\n+\n 2019-08-07  Alan Modra  <amodra@gmail.com>\n \n \tPR 24644"
    },
    {
      "sha": "3e11f089ecb7f0adda32a5eb1ab4a6f3d355e164",
      "filename": "bfd/elf64-bpf.c",
      "status": "modified",
      "additions": 187,
      "deletions": 95,
      "changes": 282,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fc8de8e227e5146336d654f2fb4f98010d7cf12d/bfd/elf64-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fc8de8e227e5146336d654f2fb4f98010d7cf12d/bfd/elf64-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-bpf.c?ref=fc8de8e227e5146336d654f2fb4f98010d7cf12d",
      "patch": "@@ -31,96 +31,6 @@\n \n #define BASEADDR(SEC)\t((SEC)->output_section->vma + (SEC)->output_offset)\n \n-/* Handler for PC-relative relocations, which must be handled in\n-   64-bit words.  */\n-\n-static bfd_reloc_status_type\n-bpf_elf_insn_disp_reloc (bfd *abfd,\n-                         arelent *reloc_entry,\n-                         asymbol *symbol,\n-                         void *data,\n-                         asection *input_section,\n-                         bfd *output_bfd,\n-                         char **error_message ATTRIBUTE_UNUSED)\n-{\n-  bfd_signed_vma relocation;\n-  bfd_signed_vma addend;\n-  reloc_howto_type *howto = reloc_entry->howto;\n-\n-  /* This part is from bfd_elf_generic_reloc.  */\n-  if (output_bfd != NULL\n-      && (symbol->flags & BSF_SECTION_SYM) == 0\n-      && (! reloc_entry->howto->partial_inplace\n-\t  || reloc_entry->addend == 0))\n-    {\n-      reloc_entry->address += input_section->output_offset;\n-      return bfd_reloc_ok;\n-    }\n-\n-  /* This works because partial_inplace is FALSE.  */\n-  if (output_bfd != NULL)\n-    return bfd_reloc_continue;\n-\n-  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))\n-    return bfd_reloc_outofrange;\n-\n-  relocation = (symbol->value\n-\t\t+ symbol->section->output_section->vma\n-\t\t+ symbol->section->output_offset);\n-  /* Make it PC relative.  */\n-  relocation -= (input_section->output_section->vma\n-                 + input_section->output_offset);\n-  relocation -= reloc_entry->address;\n-  /* Make it 64-bit words.  */\n-  relocation = relocation / 8;\n-\n-  /* Get the addend from the instruction and apply it.  */\n-  switch (howto->bitsize)\n-    {\n-    default:\n-      abort ();\n-      break;\n-    case 16:\n-      addend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);\n-      break;\n-    case 32:\n-      addend = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address + 4);\n-      break;\n-    }\n-\n-  if ((addend & (((~howto->src_mask) >> 1) & howto->src_mask)) != 0)\n-    addend -= (((~howto->src_mask) >> 1) & howto->src_mask) << 1;\n-  relocation += addend;\n-\n-  /* Write out the relocated value.  */\n-  switch (howto->bitsize)\n-    {\n-    default:\n-      abort ();\n-      break;\n-    case 16:\n-      bfd_put_16 (abfd, relocation, (bfd_byte *) data + reloc_entry->address + 2);\n-      break;\n-    case 32:\n-      bfd_put_32 (abfd, relocation, (bfd_byte *) data + reloc_entry->address + 4);\n-      break;\n-    }\n-\n-  /* Check for overflow.  */\n-  if (howto->complain_on_overflow == complain_overflow_signed)\n-    {\n-      bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;\n-      bfd_signed_vma reloc_signed_min = ~reloc_signed_max;\n-      \n-      if (relocation > reloc_signed_max || relocation < reloc_signed_min)\n-        return bfd_reloc_overflow;\n-    }\n-  else\n-    abort();\n-\n-  return bfd_reloc_ok;\n-}\n-\n /* Relocation tables.  */\n static reloc_howto_type bpf_elf_howto_table [] =\n {\n@@ -192,7 +102,7 @@ static reloc_howto_type bpf_elf_howto_table [] =\n \t TRUE,\t\t\t/* pc_relative */\n \t 32,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n-\t bpf_elf_insn_disp_reloc, /* special_function */\n+\t bfd_elf_generic_reloc, /* special_function */\n \t \"R_BPF_INSN_DISP16\",   /* name */\n \t FALSE,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n@@ -277,7 +187,7 @@ static reloc_howto_type bpf_elf_howto_table [] =\n \t TRUE,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n-\t bpf_elf_insn_disp_reloc, /* special_function */\n+\t bfd_elf_generic_reloc, /* special_function */\n \t \"R_BPF_INSN_DISP32\",   /* name */\n \t FALSE,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n@@ -336,9 +246,9 @@ static reloc_howto_type *\n bpf_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,\n                         bfd_reloc_code_real_type code)\n {\n-  /* Note that the bpf_elf_howto_table is indxed by the R_\n-     constants.  Thus, the order that the howto records appear in the\n-     table *must* match the order of the relocation types defined in\n+  /* Note that the bpf_elf_howto_table is indexed by the R_ constants.\n+     Thus, the order that the howto records appear in the table *must*\n+     match the order of the relocation types defined in\n      include/elf/bpf.h.  */\n \n   switch (code)\n@@ -419,6 +329,187 @@ bpf_info_to_howto (bfd *abfd, arelent *bfd_reloc,\n   return TRUE;\n }\n \n+/* Relocate an eBPF ELF section.\n+\n+   The RELOCATE_SECTION function is called by the new ELF backend linker\n+   to handle the relocations for a section.\n+\n+   The relocs are always passed as Rela structures; if the section\n+   actually uses Rel structures, the r_addend field will always be\n+   zero.\n+\n+   This function is responsible for adjusting the section contents as\n+   necessary, and (if using Rela relocs and generating a relocatable\n+   output file) adjusting the reloc addend as necessary.\n+\n+   This function does not have to worry about setting the reloc\n+   address or the reloc symbol index.\n+\n+   LOCAL_SYMS is a pointer to the swapped in local symbols.\n+\n+   LOCAL_SECTIONS is an array giving the section in the input file\n+   corresponding to the st_shndx field of each local symbol.\n+\n+   The global hash table entry for the global symbols can be found\n+   via elf_sym_hashes (input_bfd).\n+\n+   When generating relocatable output, this function must handle\n+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is\n+   going to be the section symbol corresponding to the output\n+   section, which means that the addend must be adjusted\n+   accordingly.  */\n+\n+#define sec_addr(sec) ((sec)->output_section->vma + (sec)->output_offset)\n+\n+static bfd_boolean\n+bpf_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n+                          struct bfd_link_info *info,\n+                          bfd *input_bfd,\n+                          asection *input_section,\n+                          bfd_byte *contents,\n+                          Elf_Internal_Rela *relocs,\n+                          Elf_Internal_Sym *local_syms,\n+                          asection **local_sections)\n+{\n+  Elf_Internal_Shdr *symtab_hdr;\n+  struct elf_link_hash_entry **sym_hashes;\n+  Elf_Internal_Rela *rel;\n+  Elf_Internal_Rela *relend;\n+\n+  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;\n+  sym_hashes = elf_sym_hashes (input_bfd);\n+  relend     = relocs + input_section->reloc_count;\n+\n+  for (rel = relocs; rel < relend; rel ++)\n+    {\n+      reloc_howto_type *\t   howto;\n+      unsigned long\t\t   r_symndx;\n+      Elf_Internal_Sym *\t   sym;\n+      asection *\t\t   sec;\n+      struct elf_link_hash_entry * h;\n+      bfd_vma\t\t\t   relocation;\n+      bfd_reloc_status_type\t   r;\n+      const char *\t\t   name = NULL;\n+      int\t\t\t   r_type ATTRIBUTE_UNUSED;\n+\n+      r_type = ELF64_R_TYPE (rel->r_info);\n+      r_symndx = ELF64_R_SYM (rel->r_info);\n+      howto  = bpf_elf_howto_table + ELF64_R_TYPE (rel->r_info);\n+      h      = NULL;\n+      sym    = NULL;\n+      sec    = NULL;\n+\n+      if (r_symndx < symtab_hdr->sh_info)\n+\t{\n+\t  sym = local_syms + r_symndx;\n+\t  sec = local_sections [r_symndx];\n+\t  relocation = BASEADDR (sec) + sym->st_value;\n+\n+\t  name = bfd_elf_string_from_elf_section\n+\t    (input_bfd, symtab_hdr->sh_link, sym->st_name);\n+\t  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;\n+\t}\n+      else\n+\t{\n+\t  bfd_boolean warned ATTRIBUTE_UNUSED;\n+\t  bfd_boolean unresolved_reloc ATTRIBUTE_UNUSED;\n+\t  bfd_boolean ignored ATTRIBUTE_UNUSED;\n+\n+\t  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,\n+\t\t\t\t   r_symndx, symtab_hdr, sym_hashes,\n+\t\t\t\t   h, sec, relocation,\n+\t\t\t\t   unresolved_reloc, warned, ignored);\n+\n+\t  name = h->root.root.string;\n+\t}\n+\n+      if (sec != NULL && discarded_section (sec))\n+\tRELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,\n+\t\t\t\t\t rel, 1, relend, howto, 0, contents);\n+\n+      if (bfd_link_relocatable (info))\n+\tcontinue;\n+\n+      switch (howto->type)\n+        {\n+        case R_BPF_INSN_DISP16:\n+        case R_BPF_INSN_DISP32:\n+          {\n+            bfd_signed_vma addend;\n+            \n+            /* Make the relocation PC-relative, and change its unit to\n+               64-bit words.  */\n+            relocation -= sec_addr (input_section) + rel->r_offset;\n+            /* Make it 64-bit words.  */\n+            relocation = relocation / 8;\n+            \n+            /* Get the addend from the instruction and apply it.  */\n+            addend = bfd_get (howto->bitsize, input_bfd,\n+                              contents + rel->r_offset\n+                              + (howto->bitsize == 16 ? 2 : 4));\n+                              \n+            if ((addend & (((~howto->src_mask) >> 1) & howto->src_mask)) != 0)\n+              addend -= (((~howto->src_mask) >> 1) & howto->src_mask) << 1;\n+            relocation += addend;\n+\n+            /* Write out the relocated value.  */\n+            bfd_put (howto->bitsize, input_bfd, relocation,\n+                     contents + rel->r_offset\n+                     + (howto->bitsize == 16 ? 2 : 4));\n+\n+            r = bfd_reloc_ok;\n+            break;\n+          }\n+        default:\n+          r = _bfd_final_link_relocate (howto, input_bfd, input_section,\n+                                        contents, rel->r_offset, relocation,\n+                                        rel->r_addend);\n+        }\n+\n+      if (r != bfd_reloc_ok)\n+\t{\n+\t  const char * msg = NULL;\n+\n+\t  switch (r)\n+\t    {\n+\t    case bfd_reloc_overflow:\n+\t      (*info->callbacks->reloc_overflow)\n+\t\t(info, (h ? &h->root : NULL), name, howto->name,\n+\t\t (bfd_vma) 0, input_bfd, input_section, rel->r_offset);\n+\t      break;\n+\n+\t    case bfd_reloc_undefined:\n+\t      (*info->callbacks->undefined_symbol)\n+\t\t(info, name, input_bfd, input_section, rel->r_offset, TRUE);\n+\t      break;\n+\n+\t    case bfd_reloc_outofrange:\n+\t      msg = _(\"internal error: out of range error\");\n+\t      break;\n+\n+\t    case bfd_reloc_notsupported:\n+\t      if (sym != NULL) /* Only if it's not an unresolved symbol.  */\n+                msg = _(\"internal error: relocation not supported\");\n+\t      break;\n+\n+\t    case bfd_reloc_dangerous:\n+\t      msg = _(\"internal error: dangerous relocation\");\n+\t      break;\n+\n+\t    default:\n+\t      msg = _(\"internal error: unknown error\");\n+\t      break;\n+\t    }\n+\n+\t  if (msg)\n+\t    (*info->callbacks->warning) (info, msg, name, input_bfd,\n+\t\t\t\t\t input_section, rel->r_offset);\n+\t}\n+    }\n+\n+  return TRUE;\n+}\n+\n /* Merge backend specific data from an object file to the output\n    object file when linking.  */\n \n@@ -451,6 +542,7 @@ elf64_bpf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n #define elf_backend_may_use_rel_p\t\t1\n #define elf_backend_may_use_rela_p\t\t0\n #define elf_backend_default_use_rela_p\t\t0\n+#define elf_backend_relocate_section\t\tbpf_elf_relocate_section\n \n #define elf_backend_can_gc_sections\t\t0\n "
    }
  ]
}