{
  "sha": "d50964864b7caf0dbde0915c0c8ada3aea48ef7a",
  "node_id": "C_kwDOANOeidoAKGQ1MDk2NDg2NGI3Y2FmMGRiZGUwOTE1YzBjOGFkYTNhZWE0OGVmN2E",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-22T16:47:29Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2022-01-07T14:42:35Z"
    },
    "message": "gdb/doc: shorten some source lines, and prevent some line breaks\n\nBuilding on the previous commit, this makes use of a trailing @ to\nsplit long @deffn lines in the guile.texi source file.  This splitting\ndoesn't change how the document is laid out by texinfo.\n\nI have also wrapped keyword and argument name pairs in @w{...} to\nprevent line breaks appearing between the two.  I've currently only\ndone this for the longer @deffn lines, where a line break is\npossible.  This makes the @deffn lines much nicer to read in the\ngenerated pdf.",
    "tree": {
      "sha": "5a57802de61bec4f98c13024ef61c128771902ec",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5a57802de61bec4f98c13024ef61c128771902ec"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d50964864b7caf0dbde0915c0c8ada3aea48ef7a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d50964864b7caf0dbde0915c0c8ada3aea48ef7a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d50964864b7caf0dbde0915c0c8ada3aea48ef7a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d50964864b7caf0dbde0915c0c8ada3aea48ef7a/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "8af9b8009b8b8a5ad39d014ef9aab51a8117a520",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8af9b8009b8b8a5ad39d014ef9aab51a8117a520",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8af9b8009b8b8a5ad39d014ef9aab51a8117a520"
    }
  ],
  "stats": {
    "total": 30,
    "additions": 17,
    "deletions": 13
  },
  "files": [
    {
      "sha": "3c517230929a6da229e67d9a2ee12fdcd5ba5c9f",
      "filename": "gdb/doc/guile.texi",
      "status": "modified",
      "additions": 17,
      "deletions": 13,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d50964864b7caf0dbde0915c0c8ada3aea48ef7a/gdb/doc/guile.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d50964864b7caf0dbde0915c0c8ada3aea48ef7a/gdb/doc/guile.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/guile.texi?ref=d50964864b7caf0dbde0915c0c8ada3aea48ef7a",
      "patch": "@@ -239,8 +239,8 @@ int\n \n The @code{(gdb)} module provides these basic Guile functions.\n \n-@c TODO: line length \n-@deffn {Scheme Procedure} execute command @r{[}#:from-tty boolean@r{]} @r{[}#:to-string boolean@r{]}\n+@deffn {Scheme Procedure} execute command @w{@r{[}#:from-tty boolean@r{]}} @\n+    @w{@r{[}#:to-string boolean@r{]}}\n Evaluate @var{command}, a string, as a @value{GDBN} CLI command.\n If a @value{GDBN} exception happens while @var{command} runs, it is\n translated as described in\n@@ -853,8 +853,9 @@ Return a Scheme bytevector with the raw contents of @code{<gdb:value>}\n @var{value}.  No transformation, endian or otherwise, is performed.\n @end deffn\n \n-@c TODO: line length\n-@deffn {Scheme Procedure} value->string value @r{[}#:encoding encoding@r{]} @r{[}#:errors errors@r{]} @r{[}#:length length@r{]}\n+@deffn {Scheme Procedure} value->string value @\n+    @w{@r{[}#:encoding encoding@r{]}} @w{@r{[}#:errors errors@r{]}} @\n+    @w{@r{[}#:length length@r{]}}\n If @var{value>} represents a string, then this method\n converts the contents to a Guile string.  Otherwise, this method will\n throw an exception.\n@@ -895,8 +896,8 @@ fetched and converted to the given length.\n The length must be a Scheme integer and not a @code{<gdb:value>} integer.\n @end deffn\n \n-@c TODO: line length\n-@deffn {Scheme Procedure} value->lazy-string value @r{[}#:encoding encoding@r{]} @r{[}#:length length@r{]}\n+@deffn {Scheme Procedure} value->lazy-string value @\n+    @w{@r{[}#:encoding encoding@r{]}} @w{@r{[}#:length length@r{]}}\n If this @code{<gdb:value>} represents a string, then this method\n converts @var{value} to a @code{<gdb:lazy-string} (@pxref{Lazy Strings\n In Guile}).  Otherwise, this method will throw an exception.\n@@ -2736,8 +2737,8 @@ its value, then @var{frame} must be given.  If @var{frame} is not\n given, or if @var{frame} is invalid, then an exception is thrown.\n @end deffn\n \n-@c TODO: line length\n-@deffn {Scheme Procedure} lookup-symbol name @r{[}#:block block@r{]} @r{[}#:domain domain@r{]}\n+@deffn {Scheme Procedure} lookup-symbol name @w{@r{[}#:block block@r{]}} @\n+    @w{@r{[}#:domain domain@r{]}}\n This function searches for a symbol by name.  The search scope can be\n restricted to the parameters defined in the optional domain and block\n arguments.\n@@ -2971,8 +2972,9 @@ outside of Guile.\n The following breakpoint-related procedures are provided by the\n @code{(gdb)} module:\n \n-@c TODO: line length\n-@deffn {Scheme Procedure} make-breakpoint location @r{[}#:type type@r{]} @r{[}#:wp-class wp-class@r{]} @r{[}#:internal internal@r{]} @r{[}#:temporary temporary@r{]}\n+@deffn {Scheme Procedure} make-breakpoint location @w{@r{[}#:type type@r{]}} @\n+    @w{@r{[}#:wp-class wp-class@r{]}} @w{@r{[}#:internal internal@r{]}} @\n+    @w{@r{[}#:temporary temporary@r{]}}\n Create a new breakpoint at @var{location}, a string naming the\n location of the breakpoint, or an expression that defines a watchpoint.\n The contents can be any location recognized by the @code{break} command,\n@@ -3476,8 +3478,9 @@ The disassembler can be invoked from Scheme code.\n Furthermore, the disassembler can take a Guile port as input,\n allowing one to disassemble from any source, and not just target memory.\n \n-@c TODO: line length\n-@deffn {Scheme Procedure} arch-disassemble arch start-pc @r{[}#:port port@r{]} @r{[}#:offset offset@r{]} @r{[}#:size size@r{]} @r{[}#:count count@r{]}\n+@deffn {Scheme Procedure} arch-disassemble arch start-pc @\n+    @w{@r{[}#:port port@r{]}} @w{@r{[}#:offset offset@r{]}} @\n+    @w{@r{[}#:size size@r{]}} @w{@r{[}#:count count@r{]}}\n Return a list of disassembled instructions starting from the memory\n address @var{start-pc}.\n \n@@ -3568,7 +3571,8 @@ This allows Guile code to read/write target memory using Guile's port and\n bytevector functionality.  The main routine is @code{open-memory} which\n returns a port object.  One can then read/write memory using that object.\n \n-@deffn {Scheme Procedure} open-memory @r{[}#:mode mode{]} @r{[}#:start address{]} @r{[}#:size size{]}\n+@deffn {Scheme Procedure} open-memory @w{@r{[}#:mode mode@r{]}} @\n+    @w{@r{[}#:start address@r{]}} @w{@r{[}#:size size@r{]}}\n Return a port object that can be used for reading and writing memory.\n The port will be open according to @var{mode}, which is the standard\n mode argument to Guile port open routines, except that the @samp{\"a\"}"
    }
  ]
}