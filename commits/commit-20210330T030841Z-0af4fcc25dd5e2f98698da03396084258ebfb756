{
  "sha": "0af4fcc25dd5e2f98698da03396084258ebfb756",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGFmNGZjYzI1ZGQ1ZTJmOTg2OThkYTAzMzk2MDg0MjU4ZWJmYjc1Ng==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-30T01:55:03Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-30T03:08:41Z"
    },
    "message": "PR27625, powerpc64 gold __tls_get_addr calls\n\nThis patch supports linking powerpc64 glibc with gold, specifically\nthe __tls_get_addr call in elf/dl-sym.c.  That call lacks marker\nrelocations tying it to the arg setup instructions, but the arg setup\ninsns are also contructed lacking the usual relocations on a Global\nDynamic TLS code sequence.  So there is no chance that anything in\nthat sequence might be wrongly edited by the linker.\n\nIn fact, the aim of linking glibc could have been supported by simply\nomitting the error whenever TLS optimisation is disabled, as it is\nwhen linking a shared library.  The patch goes further than that,\ndisabling TLS GD and LD sequence optimisation on a per-object basis\nfor object files lacking marker relocs.\n\n\tPR gold/27625\n\t* powerpc.cc (Powerpc_relobj): Add no_tls_marker_, tls_marker_,\n\tand tls_opt_error_ variables and accessors.\n\t(Target_powerpc::Scan::local, global): Call set_tls_marker and\n\tset_no_tls_marker for GD and LD code sequence relocations.\n\t(Target_powerpc::Relocate::relocate): Downgrade the \"lacks marker\n\treloc\" error to a warning when safe to do so, and omit the error\n\tentirely if not optimising TLS sequences.  Do not optimise GD and\n\tLD sequences for objects lacking marker relocs.\n\t(Target_powerpc::relocate_relocs): Heed no_tls_marker here too.",
    "tree": {
      "sha": "a385cfc8b484a255c8b8cb2ddebaee42aedfe777",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a385cfc8b484a255c8b8cb2ddebaee42aedfe777"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0af4fcc25dd5e2f98698da03396084258ebfb756",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0af4fcc25dd5e2f98698da03396084258ebfb756",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0af4fcc25dd5e2f98698da03396084258ebfb756",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0af4fcc25dd5e2f98698da03396084258ebfb756/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1b82252e8c2964ca79de7f352a3972549183155b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1b82252e8c2964ca79de7f352a3972549183155b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1b82252e8c2964ca79de7f352a3972549183155b"
    }
  ],
  "stats": {
    "total": 250,
    "additions": 197,
    "deletions": 53
  },
  "files": [
    {
      "sha": "82dae337bb369b68f9e2d6c4cd9931fcd194d804",
      "filename": "gold/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0af4fcc25dd5e2f98698da03396084258ebfb756/gold/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0af4fcc25dd5e2f98698da03396084258ebfb756/gold/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/ChangeLog?ref=0af4fcc25dd5e2f98698da03396084258ebfb756",
      "patch": "@@ -1,3 +1,16 @@\n+2021-03-30  Alan Modra  <amodra@gmail.com>\n+\n+\tPR gold/27625\n+\t* powerpc.cc (Powerpc_relobj): Add no_tls_marker_, tls_marker_,\n+\tand tls_opt_error_ variables and accessors.\n+\t(Target_powerpc::Scan::local, global): Call set_tls_marker and\n+\tset_no_tls_marker for GD and LD code sequence relocations.\n+\t(Target_powerpc::Relocate::relocate): Downgrade the \"lacks marker\n+\treloc\" error to a warning when safe to do so, and omit the error\n+\tentirely if not optimising TLS sequences.  Do not optimise GD and\n+\tLD sequences for objects lacking marker relocs.\n+\t(Target_powerpc::relocate_relocs): Heed no_tls_marker here too.\n+\n 2021-03-19  Cary Coutant  <ccoutant@gmail.com>\n \n \tPR gold/27615"
    },
    {
      "sha": "6b12ed8869b928da5cba4cda85c9f679221dbc19",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 184,
      "deletions": 53,
      "changes": 237,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0af4fcc25dd5e2f98698da03396084258ebfb756/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0af4fcc25dd5e2f98698da03396084258ebfb756/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=0af4fcc25dd5e2f98698da03396084258ebfb756",
      "patch": "@@ -101,6 +101,7 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n     : Sized_relobj_file<size, big_endian>(name, input_file, offset, ehdr),\n       uniq_(object_id++), special_(0), relatoc_(0), toc_(0),\n       has_small_toc_reloc_(false), opd_valid_(false),\n+      no_tls_marker_(false), tls_marker_(false), tls_opt_error_(false),\n       e_flags_(ehdr.get_e_flags()), no_toc_opt_(), opd_ent_(),\n       access_from_map_(), has14_(), stub_table_index_(), st_other_(),\n       attributes_section_data_(NULL)\n@@ -161,6 +162,30 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n     return this->no_toc_opt_[off];\n   }\n \n+  void\n+  set_no_tls_marker()\n+  {\n+    if (!this->no_tls_marker_ && this->tls_marker_)\n+      this->tls_opt_error_ = true;\n+    this->no_tls_marker_ = true;\n+  }\n+\n+  bool\n+  no_tls_marker() const\n+  { return this->no_tls_marker_; }\n+\n+  void\n+  set_tls_marker()\n+  { this->tls_marker_ = true; }\n+\n+  bool\n+  tls_marker() const\n+  { return this->tls_marker_; }\n+\n+  bool\n+  tls_opt_error() const\n+  { return this->tls_opt_error_; }\n+\n   // The .got2 section shndx.\n   unsigned int\n   got2_shndx() const\n@@ -454,6 +479,19 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n   // access_from_map_.\n   bool opd_valid_;\n \n+  // Set when finding a __tls_get_addr call without marker relocs.\n+  // Such a call disables GD and LD tls optimisations for the object file.\n+  bool no_tls_marker_;\n+\n+  // Set when finding a __tls_get_addr call with marker relocs, or\n+  // when finding a relocation that needs __tls_get_addr calls with\n+  // marker relocs.\n+  bool tls_marker_;\n+\n+  // Set when seeing a __tls_get_addr call without marker relocs after\n+  // seeing some __tls_get_addr calls with marker relocs.\n+  bool tls_opt_error_;\n+\n   // Header e_flags\n   elfcpp::Elf_Word e_flags_;\n \n@@ -7863,28 +7901,47 @@ Target_powerpc<size, big_endian>::Scan::local(\n     const elfcpp::Sym<size, big_endian>& lsym,\n     bool is_discarded)\n {\n-  this->maybe_skip_tls_get_addr_call(target, r_type, NULL);\n+  Powerpc_relobj<size, big_endian>* ppc_object\n+    = static_cast<Powerpc_relobj<size, big_endian>*>(object);\n+\n+  switch (this->maybe_skip_tls_get_addr_call(target, r_type, NULL))\n+    {\n+    case Track_tls::NOT_EXPECTED:\n+      ppc_object->set_no_tls_marker();\n+      break;\n+    default:\n+      break;\n+    }\n \n   if ((size == 64 && r_type == elfcpp::R_PPC64_TLSGD)\n       || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))\n     {\n       this->expect_tls_get_addr_call();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_gd(true);\n-      if (tls_type != tls::TLSOPT_NONE)\n-\tthis->skip_next_tls_get_addr_call();\n+      if (!ppc_object->no_tls_marker())\n+\t{\n+\t  tls::Tls_optimization tls_type = target->optimize_tls_gd(true);\n+\t  if (tls_type != tls::TLSOPT_NONE)\n+\t    {\n+\t      this->skip_next_tls_get_addr_call();\n+\t      ppc_object->set_tls_marker();\n+\t    }\n+\t}\n     }\n   else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)\n \t   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))\n     {\n       this->expect_tls_get_addr_call();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_ld();\n-      if (tls_type != tls::TLSOPT_NONE)\n-\tthis->skip_next_tls_get_addr_call();\n+      if (!ppc_object->no_tls_marker())\n+\t{\n+\t  tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+\t  if (tls_type != tls::TLSOPT_NONE)\n+\t    {\n+\t      this->skip_next_tls_get_addr_call();\n+\t      ppc_object->set_tls_marker();\n+\t    }\n+\t}\n     }\n \n-  Powerpc_relobj<size, big_endian>* ppc_object\n-    = static_cast<Powerpc_relobj<size, big_endian>*>(object);\n-\n   if (is_discarded)\n     {\n       if (size == 64\n@@ -8179,7 +8236,9 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HA:\n       {\n-\tconst tls::Tls_optimization tls_type = target->optimize_tls_gd(true);\n+\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\tif (!ppc_object->no_tls_marker())\n+\t  tls_type = target->optimize_tls_gd(true);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    Output_data_got_powerpc<size, big_endian>* got\n@@ -8192,6 +8251,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n \t  {\n \t    // no GOT relocs needed for Local Exec.\n+\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -8204,7 +8264,9 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HA:\n       {\n-\tconst tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\tif (!ppc_object->no_tls_marker())\n+\t  tls_type = target->optimize_tls_ld();\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  target->tlsld_got_offset(symtab, layout, object);\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n@@ -8216,6 +8278,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t\tgold_assert(os != NULL);\n \t\tos->set_needs_symtab_index();\n \t      }\n+\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -8241,7 +8304,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_POWERPC_GOT_TPREL16_HI:\n     case elfcpp::R_POWERPC_GOT_TPREL16_HA:\n       {\n-\tconst tls::Tls_optimization tls_type = target->optimize_tls_ie(true);\n+\ttls::Tls_optimization tls_type = target->optimize_tls_ie(true);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n@@ -8545,9 +8608,19 @@ Target_powerpc<size, big_endian>::Scan::global(\n     unsigned int r_type,\n     Symbol* gsym)\n {\n-  if (this->maybe_skip_tls_get_addr_call(target, r_type, gsym)\n-      == Track_tls::SKIP)\n-    return;\n+  Powerpc_relobj<size, big_endian>* ppc_object\n+    = static_cast<Powerpc_relobj<size, big_endian>*>(object);\n+\n+  switch (this->maybe_skip_tls_get_addr_call(target, r_type, gsym))\n+    {\n+    case Track_tls::NOT_EXPECTED:\n+      ppc_object->set_no_tls_marker();\n+      break;\n+    case Track_tls::SKIP:\n+      return;\n+    default:\n+      break;\n+    }\n \n   if (target->replace_tls_get_addr(gsym))\n     // Change a __tls_get_addr reference to __tls_get_addr_opt\n@@ -8558,23 +8631,32 @@ Target_powerpc<size, big_endian>::Scan::global(\n       || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))\n     {\n       this->expect_tls_get_addr_call();\n-      const bool final = gsym->final_value_is_known();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n-      if (tls_type != tls::TLSOPT_NONE)\n-\tthis->skip_next_tls_get_addr_call();\n+      if (!ppc_object->no_tls_marker())\n+\t{\n+\t  bool final = gsym->final_value_is_known();\n+\t  tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n+\t  if (tls_type != tls::TLSOPT_NONE)\n+\t    {\n+\t      this->skip_next_tls_get_addr_call();\n+\t      ppc_object->set_tls_marker();\n+\t    }\n+\t}\n     }\n   else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)\n \t   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))\n     {\n       this->expect_tls_get_addr_call();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_ld();\n-      if (tls_type != tls::TLSOPT_NONE)\n-\tthis->skip_next_tls_get_addr_call();\n+      if (!ppc_object->no_tls_marker())\n+\t{\n+\t  tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+\t  if (tls_type != tls::TLSOPT_NONE)\n+\t    {\n+\t      this->skip_next_tls_get_addr_call();\n+\t      ppc_object->set_tls_marker();\n+\t    }\n+\t}\n     }\n \n-  Powerpc_relobj<size, big_endian>* ppc_object\n-    = static_cast<Powerpc_relobj<size, big_endian>*>(object);\n-\n   // A STT_GNU_IFUNC symbol may require a PLT entry.\n   bool is_ifunc = gsym->type() == elfcpp::STT_GNU_IFUNC;\n   bool pushed_ifunc = false;\n@@ -8951,8 +9033,12 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HA:\n       {\n-\tconst bool final = gsym->final_value_is_known();\n-\tconst tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n+\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\tif (!ppc_object->no_tls_marker())\n+\t  {\n+\t    bool final = gsym->final_value_is_known();\n+\t    tls_type = target->optimize_tls_gd(final);\n+\t  }\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    Output_data_got_powerpc<size, big_endian>* got\n@@ -8984,10 +9070,12 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t\t\t\t\t\t\t   got, off, 0);\n \t\t  }\n \t      }\n+\t    ppc_object->set_tls_marker();\n \t  }\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n \t  {\n \t    // no GOT relocs needed for Local Exec.\n+\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -9000,7 +9088,9 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HA:\n       {\n-\tconst tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\tif (!ppc_object->no_tls_marker())\n+\t  tls_type = target->optimize_tls_ld();\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  target->tlsld_got_offset(symtab, layout, object);\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n@@ -9012,6 +9102,7 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t\tgold_assert(os != NULL);\n \t\tos->set_needs_symtab_index();\n \t      }\n+\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -9044,8 +9135,8 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_GOT_TPREL16_HI:\n     case elfcpp::R_POWERPC_GOT_TPREL16_HA:\n       {\n-\tconst bool final = gsym->final_value_is_known();\n-\tconst tls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n+\tbool final = gsym->final_value_is_known();\n+\ttls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    if (!gsym->has_got_offset(GOT_TYPE_TPREL))\n@@ -10357,11 +10448,25 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \n   const elfcpp::Rela<size, big_endian> rela(preloc);\n   unsigned int r_type = elfcpp::elf_r_type<size>(rela.get_r_info());\n+  Powerpc_relobj<size, big_endian>* const object\n+    = static_cast<Powerpc_relobj<size, big_endian>*>(relinfo->object);\n   switch (this->maybe_skip_tls_get_addr_call(target, r_type, gsym))\n     {\n     case Track_tls::NOT_EXPECTED:\n-      gold_error_at_location(relinfo, relnum, rela.get_r_offset(),\n-\t\t\t     _(\"__tls_get_addr call lacks marker reloc\"));\n+      if (!parameters->options().shared()\n+\t  && parameters->options().tls_optimize())\n+\t{\n+\t  // It is a hard error to see a __tls_get_addr call without\n+\t  // marker relocs after seeing calls with marker relocs in the\n+\t  // same object file, because dynamic relocation accounting\n+\t  // will be wrong.\n+\t  if (object->tls_opt_error())\n+\t    gold_error_at_location(relinfo, relnum, rela.get_r_offset(),\n+\t\t\t\t   _(\"__tls_get_addr call lacks marker reloc\"));\n+\t  else\n+\t    gold_warning_at_location(relinfo, relnum, rela.get_r_offset(),\n+\t\t\t\t     _(\"__tls_get_addr call lacks marker reloc\"));\n+\t}\n       break;\n     case Track_tls::EXPECTED:\n       // We have already complained.\n@@ -10394,8 +10499,6 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n   // Offset from start of insn to d-field reloc.\n   const int d_offset = big_endian ? 2 : 0;\n \n-  Powerpc_relobj<size, big_endian>* const object\n-    = static_cast<Powerpc_relobj<size, big_endian>*>(relinfo->object);\n   Address value = 0;\n   bool has_stub_value = false;\n   bool localentry0 = false;\n@@ -10646,8 +10749,12 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t   || r_type == elfcpp::R_PPC64_GOT_TLSGD_PCREL34)\n     {\n       // First instruction of a global dynamic sequence, arg setup insn.\n-      const bool final = gsym == NULL || gsym->final_value_is_known();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n+      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+      if (!object->no_tls_marker())\n+\t{\n+\t  bool final = gsym == NULL || gsym->final_value_is_known();\n+\t  tls_type = target->optimize_tls_gd(final);\n+\t}\n       enum Got_type got_type = GOT_TYPE_STANDARD;\n       if (tls_type == tls::TLSOPT_NONE)\n \tgot_type = GOT_TYPE_TLSGD;\n@@ -10752,7 +10859,9 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t   || r_type == elfcpp::R_PPC64_GOT_TLSLD_PCREL34)\n     {\n       // First instruction of a local dynamic sequence, arg setup insn.\n-      const tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+      if (!object->no_tls_marker())\n+\ttls_type = target->optimize_tls_ld();\n       if (tls_type == tls::TLSOPT_NONE)\n \t{\n \t  value = target->tlsld_got_offset();\n@@ -10831,8 +10940,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t   || r_type == elfcpp::R_PPC64_GOT_TPREL_PCREL34)\n     {\n       // First instruction of initial exec sequence.\n-      const bool final = gsym == NULL || gsym->final_value_is_known();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n+      bool final = gsym == NULL || gsym->final_value_is_known();\n+      tls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n       if (tls_type == tls::TLSOPT_NONE)\n \t{\n \t  if (gsym != NULL)\n@@ -10897,8 +11006,12 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       // Second instruction of a global dynamic sequence,\n       // the __tls_get_addr call\n       this->expect_tls_get_addr_call(relinfo, relnum, rela.get_r_offset());\n-      const bool final = gsym == NULL || gsym->final_value_is_known();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n+      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+      if (!object->no_tls_marker())\n+\t{\n+\t  bool final = gsym == NULL || gsym->final_value_is_known();\n+\t  tls_type = target->optimize_tls_gd(final);\n+\t}\n       if (tls_type != tls::TLSOPT_NONE)\n \t{\n \t  if (tls_type == tls::TLSOPT_TO_IE)\n@@ -10949,7 +11062,9 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       // Second instruction of a local dynamic sequence,\n       // the __tls_get_addr call\n       this->expect_tls_get_addr_call(relinfo, relnum, rela.get_r_offset());\n-      const tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+      if (!object->no_tls_marker())\n+\ttls_type = target->optimize_tls_ld();\n       if (tls_type == tls::TLSOPT_TO_LE)\n \t{\n \t  bool is_pcrel = false;\n@@ -10985,8 +11100,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n   else if (r_type == elfcpp::R_POWERPC_TLS)\n     {\n       // Second instruction of an initial exec sequence\n-      const bool final = gsym == NULL || gsym->final_value_is_known();\n-      const tls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n+      bool final = gsym == NULL || gsym->final_value_is_known();\n+      tls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n       if (tls_type == tls::TLSOPT_TO_LE)\n \t{\n \t  Address roff = rela.get_r_offset() & 3;\n@@ -12439,8 +12554,13 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // First instruction of a global dynamic sequence,\n \t      // arg setup insn.\n-\t      const bool final = gsym == NULL || gsym->final_value_is_known();\n-\t      switch (this->optimize_tls_gd(final))\n+\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\t      if (!object->no_tls_marker())\n+\t\t{\n+\t\t  bool final = gsym == NULL || gsym->final_value_is_known();\n+\t\t  tls_type = this->optimize_tls_gd(final);\n+\t\t}\n+\t      switch (tls_type)\n \t\t{\n \t\tcase tls::TLSOPT_TO_IE:\n \t\t  r_type += (elfcpp::R_POWERPC_GOT_TPREL16\n@@ -12467,7 +12587,10 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // First instruction of a local dynamic sequence,\n \t      // arg setup insn.\n-\t      if (this->optimize_tls_ld() == tls::TLSOPT_TO_LE)\n+\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\t      if (!object->no_tls_marker())\n+\t\ttls_type = this->optimize_tls_ld();\n+\t      if (tls_type == tls::TLSOPT_TO_LE)\n \t\t{\n \t\t  if (r_type == elfcpp::R_POWERPC_GOT_TLSLD16\n \t\t      || r_type == elfcpp::R_POWERPC_GOT_TLSLD16_LO)\n@@ -12493,7 +12616,7 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t\t   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_HA)\n \t    {\n \t      // First instruction of initial exec sequence.\n-\t      const bool final = gsym == NULL || gsym->final_value_is_known();\n+\t      bool final = gsym == NULL || gsym->final_value_is_known();\n \t      if (this->optimize_tls_ie(final) == tls::TLSOPT_TO_LE)\n \t\t{\n \t\t  if (r_type == elfcpp::R_POWERPC_GOT_TPREL16\n@@ -12511,8 +12634,13 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // Second instruction of a global dynamic sequence,\n \t      // the __tls_get_addr call\n-\t      const bool final = gsym == NULL || gsym->final_value_is_known();\n-\t      switch (this->optimize_tls_gd(final))\n+\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\t      if (!object->no_tls_marker())\n+\t\t{\n+\t\t  bool final = gsym == NULL || gsym->final_value_is_known();\n+\t\t  tls_type = this->optimize_tls_gd(final);\n+\t\t}\n+\t      switch (tls_type)\n \t\t{\n \t\tcase tls::TLSOPT_TO_IE:\n \t\t  r_type = elfcpp::R_POWERPC_NONE;\n@@ -12532,7 +12660,10 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // Second instruction of a local dynamic sequence,\n \t      // the __tls_get_addr call\n-\t      if (this->optimize_tls_ld() == tls::TLSOPT_TO_LE)\n+\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n+\t      if (!object->no_tls_marker())\n+\t\ttls_type = this->optimize_tls_ld();\n+\t      if (tls_type == tls::TLSOPT_TO_LE)\n \t\t{\n \t\t  const Output_section* os = relinfo->layout->tls_segment()\n \t\t    ->first_section();\n@@ -12548,7 +12679,7 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t  else if (r_type == elfcpp::R_POWERPC_TLS)\n \t    {\n \t      // Second instruction of an initial exec sequence\n-\t      const bool final = gsym == NULL || gsym->final_value_is_known();\n+\t      bool final = gsym == NULL || gsym->final_value_is_known();\n \t      if (this->optimize_tls_ie(final) == tls::TLSOPT_TO_LE)\n \t\t{\n \t\t  r_type = elfcpp::R_POWERPC_TPREL16_LO;"
    }
  ]
}