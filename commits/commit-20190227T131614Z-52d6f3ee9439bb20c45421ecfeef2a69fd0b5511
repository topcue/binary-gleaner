{
  "sha": "52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTJkNmYzZWU5NDM5YmIyMGM0NTQyMWVjZmVlZjJhNjlmZDBiNTUxMQ==",
  "commit": {
    "author": {
      "name": "Matthew Malcomson",
      "email": "matthew.malcomson@arm.com",
      "date": "2019-02-27T13:15:10Z"
    },
    "committer": {
      "name": "Tamar Christina",
      "email": "tamar.christina@arm.com",
      "date": "2019-02-27T13:16:14Z"
    },
    "message": "Testsuite: Allow multiple lines of \"as\" in testsuite.\n\nCommitted on behalf of Matthew Malcomson.\n\nThis allows checking the command line parsing more easily than before by\nallowing many command line invokations from the same .d file.\n\nEach line is used as a set of flags, and the tests are ran against the output\nof the assembler with each set.\nEach line of assembler is treated as another set of tests (as if the test file\nwere copied to another with a different #as: line).\n\nThis patch includes some example uses where multiple testcases can be merged\ninto one file using this new functionality.\n\nbinutils/ChangeLog:\n\n\t* testsuite/lib/binutils-common.exp: Allow multiple \"as\" lines.\n\ngas/ChangeLog:\n\n\t* testsuite/gas/aarch64/dotproduct.d: Use multiple \"as\" lines.\n\t* testsuite/gas/aarch64/dotproduct_armv8_4.d: Remove.\n\t* testsuite/gas/aarch64/dotproduct_armv8_4.s: Remove.\n\t* testsuite/gas/aarch64/illegal-dotproduct.d: Use multiple \"as\"\n\tlines.\n\t* testsuite/gas/aarch64/ldst-rcpc-armv8_2.d: Remove.\n\t* testsuite/gas/aarch64/ldst-rcpc.d: Use multiple \"as\" lines.",
    "tree": {
      "sha": "0a3e567e7a34a95bc9549150797abbe527b4485a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0a3e567e7a34a95bc9549150797abbe527b4485a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/comments",
  "author": {
    "login": "mmalcomson",
    "id": 57484298,
    "node_id": "MDQ6VXNlcjU3NDg0Mjk4",
    "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/mmalcomson",
    "html_url": "https://github.com/mmalcomson",
    "followers_url": "https://api.github.com/users/mmalcomson/followers",
    "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}",
    "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions",
    "organizations_url": "https://api.github.com/users/mmalcomson/orgs",
    "repos_url": "https://api.github.com/users/mmalcomson/repos",
    "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}",
    "received_events_url": "https://api.github.com/users/mmalcomson/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "TamarChristinaArm",
    "id": 48126768,
    "node_id": "MDQ6VXNlcjQ4MTI2NzY4",
    "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/TamarChristinaArm",
    "html_url": "https://github.com/TamarChristinaArm",
    "followers_url": "https://api.github.com/users/TamarChristinaArm/followers",
    "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}",
    "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions",
    "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs",
    "repos_url": "https://api.github.com/users/TamarChristinaArm/repos",
    "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bf9a735e239cb7a27c81aa7c98679f7f83fa8314",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf9a735e239cb7a27c81aa7c98679f7f83fa8314",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bf9a735e239cb7a27c81aa7c98679f7f83fa8314"
    }
  ],
  "stats": {
    "total": 741,
    "additions": 379,
    "deletions": 362
  },
  "files": [
    {
      "sha": "6bb43845739a53bdfd0f0f83821f9869dc723066",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
      "patch": "@@ -1,3 +1,7 @@\n+2019-02-27  Matthew Malcomson  <matthew.malcomson@arm.com>\n+\n+\t* testsuite/lib/binutils-common.exp: Allow multiple \"as\" lines.\n+\n 2019-02-25  Nick Clifton  <nickc@redhat.com>\n \n \t* objdump.c (sym_ok): New function."
    },
    {
      "sha": "e01b3fb48462cbe6b5bd06ae8860a1e1a8c8e5e6",
      "filename": "binutils/testsuite/lib/binutils-common.exp",
      "status": "modified",
      "additions": 361,
      "deletions": 329,
      "changes": 690,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/binutils/testsuite/lib/binutils-common.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/binutils/testsuite/lib/binutils-common.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/lib/binutils-common.exp?ref=52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
      "patch": "@@ -523,6 +523,13 @@ if ![string length [info proc prune_warnings]] {\n #\tWhen assembling, pass FLAGS to the assembler.\n #\tIf assembling several files, you can pass different assembler\n #\toptions in the \"source\" directives.  See below.\n+#       Multiple instances of this directive tells run_dump_test to run the test\n+#       multiple times -- one time with each set of flags provided.\n+#       Each instance will run exactly as a file with a single \"as\" line, it is\n+#       not possible to condition any behaviour on which set of \"as\" flags is\n+#       used.  That means that the \"source\" specific options are appended to\n+#       the \"as\" flags for their corresponding files, and any extra processing\n+#       (e.g. with \"ld\" and \"objcopy\") is repeated for each test.\n #\n #   ld: FLAGS\n #\tLink assembled files using FLAGS, in the order of the \"source\"\n@@ -690,6 +697,8 @@ proc run_dump_test { name {extra_options {}} } {\n     set opts(anyskip) {}\n     set opts(ar) {}\n     set opts(as) {}\n+    set as_final_flags {}\n+    set as_additional_flags {}\n     set opts(dump) {}\n     set opts(elfedit) {}\n     set opts(error) {}\n@@ -781,7 +790,9 @@ proc run_dump_test { name {extra_options {}} } {\n \t\tlappend objfile_names $new_objfile\n \t    }\n \t    default {\n-\t\tif { !$in_extra && [string length $opts($opt_name)] } {\n+\t\tif { !$in_extra\n+                     && [string length $opts($opt_name)]\n+                     && $opt_name != \"as\" } {\n \t\t    perror \"option $opt_name multiply set in $file.d\"\n \t\t    unresolved $subdir/$name\n \t\t    return\n@@ -805,16 +816,35 @@ proc run_dump_test { name {extra_options {}} } {\n \t    error {\n \t\tappend opts($opt_name) $opt_val\n \t    }\n+            as {\n+                if { $in_extra } {\n+                    set as_additional_flags [concat $as_additional_flags $opt_val]\n+                } else {\n+                    lappend opts(as) $opt_val\n+                }\n+            }\n \t    default {\n \t\tset opts($opt_name) [concat $opts($opt_name) $opt_val]\n \t    }\n \t}\n     }\n \n-    foreach opt { as ld } {\n-\tregsub {\\[big_or_little_endian\\]} $opts($opt) \\\n-\t    [big_or_little_endian] opts($opt)\n+    # Ensure there is something in $opts(as) for the lmap below.\n+    if { [llength $opts(as)] == 0 } {\n+        set opts(as) [list \" \"]\n     }\n+    set as_final_flags [lmap x $opts(as) {\n+        if { [string length $x] && [string length $as_additional_flags] } {\n+            append x \" \"\n+        }\n+        append x $as_additional_flags\n+        regsub {\\[big_or_little_endian\\]} $x \\\n+            [big_or_little_endian] x\n+        expr {$x}\n+    }]\n+\n+    regsub {\\[big_or_little_endian\\]} $opts(ld) \\\n+        [big_or_little_endian] opts(ld)\n \n     if { $opts(name) == \"\" } {\n \tset testname \"$subdir/$name\"\n@@ -947,334 +977,336 @@ proc run_dump_test { name {extra_options {}} } {\n \tsetup_xfail $targ\n     }\n \n-    # Assemble each file.\n-    set objfiles {}\n-    for { set i 0 } { $i < [llength $sourcefiles] } { incr i } {\n-\tset sourcefile [lindex $sourcefiles $i]\n-\tset sourceasflags [lindex $asflags $i]\n-\tset run_objcopy_objects 0\n-\n-\tif { [string match \"*RUN_OBJCOPY*\" $sourceasflags] } {\n-\t    set run_objcopy_objects 1\n-\t}\n-\tregsub \"RUN_OBJCOPY\" $sourceasflags \"\" sourceasflags\n-\n-\tset objfile [lindex $objfile_names $i]\n-\tcatch \"exec rm -f $objfile\" exec_output\n-\tlappend objfiles $objfile\n-\n-\tif { $opts(as) == \"binary\" } {\n-\t    while {[file type $sourcefile] eq \"link\"} {\n-\t\tset newfile [file readlink $sourcefile]\n-\t\tif {[string index $newfile 0] ne \"/\"} {\n-\t\t    set newfile [file dirname $sourcefile]/$newfile\n-\t\t}\n-\t\tset sourcefile $newfile\n-\t    }\n-\t    set newfile [remote_download host $sourcefile $objfile]\n-\t    set cmdret 0\n-\t    if { $newfile == \"\" } {\n-\t\tset cmdret 1\n-\t    }\n-\t} else {\n-\t    if { [istarget \"hppa*-*-*\"] \\\n-\t\t     && ![istarget \"*-*-linux*\"] \\\n-\t\t     && ![istarget \"*-*-netbsd*\" ] } {\n-\t\tset cmd \"sed -e 's/^\\[\t \\]*\\.comm \\\\(\\[^,\\]*\\\\),\\\\(.*\\\\)/\\\\1 .comm \\\\2/' < $sourcefile > tmpdir/asm.s\"\n-\t\tsend_log \"$cmd\\n\"\n-\t\tset cmdret [remote_exec host [concat sh -c [list \"$cmd\"]]]\n-\t\tset cmdret [lindex $cmdret 0]\n-\t\tif { $cmdret != 0 } {\n-\t\t    perror \"sed failure\"\n-\t\t    unresolved $testname\n-\t\t    return\n-\t\t}\n-\t\tset sourcefile tmpdir/asm.s\n-\t    }\n-\t    set cmd \"$AS $ASFLAGS $opts(as) $sourceasflags -o $objfile $sourcefile\"\n-\n-\t    send_log \"$cmd\\n\"\n-\t    set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n-\t    remote_upload host \"dump.tmp\"\n-\t    set comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-\t    remote_file host delete \"dump.tmp\"\n-\t    remote_file build delete \"dump.tmp\"\n-\t    set cmdret [lindex $cmdret 0]\n-\t}\n-\tif { $cmdret == 0 && $run_objcopy_objects } {\n-\t    set cmd \"$OBJCOPY $opts(objcopy_objects) $objfile\"\n-\n-\t    send_log \"$cmd\\n\"\n-\t    set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \\\n-\t\t\t\"\" \"/dev/null\" \"dump.tmp\"]\n-\t    remote_upload host \"dump.tmp\"\n-\t    append comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-\t    remote_file host delete \"dump.tmp\"\n-\t    remote_file build delete \"dump.tmp\"\n-\t    set cmdret [lindex $cmdret 0]\n-\t}\n-    }\n-\n-    # Perhaps link the file(s).\n-    if { $cmdret == 0 && $run_ld } {\n-\tset objfile \"tmpdir/dump\"\n-\tcatch \"exec rm -f $objfile\" exec_output\n-\n-\tset ld_extra_opt \"\"\n-\tglobal ld\n-\tset ld \"$LD\"\n-\tif { [is_elf_format] && [check_shared_lib_support] } {\n-\t    set ld_extra_opt \"$ld_elf_shared_opt\"\n-\t}\n-\n-\t# Add -L$srcdir/$subdir so that the linker command can use\n-\t# linker scripts in the source directory.\n-\tset cmd \"$LD $ld_extra_opt $LDFLAGS -L$srcdir/$subdir \\\n+    foreach as_flags $as_final_flags {\n+        # Assemble each file.\n+        set objfiles {}\n+        for { set i 0 } { $i < [llength $sourcefiles] } { incr i } {\n+            set sourcefile [lindex $sourcefiles $i]\n+            set sourceasflags [lindex $asflags $i]\n+            set run_objcopy_objects 0\n+\n+            if { [string match \"*RUN_OBJCOPY*\" $sourceasflags] } {\n+                set run_objcopy_objects 1\n+            }\n+            regsub \"RUN_OBJCOPY\" $sourceasflags \"\" sourceasflags\n+\n+            set objfile [lindex $objfile_names $i]\n+            catch \"exec rm -f $objfile\" exec_output\n+            lappend objfiles $objfile\n+\n+            if { $as_flags == \"binary\" } {\n+                while {[file type $sourcefile] eq \"link\"} {\n+                    set newfile [file readlink $sourcefile]\n+                    if {[string index $newfile 0] ne \"/\"} {\n+                        set newfile [file dirname $sourcefile]/$newfile\n+                    }\n+                    set sourcefile $newfile\n+                }\n+                set newfile [remote_download host $sourcefile $objfile]\n+                set cmdret 0\n+                if { $newfile == \"\" } {\n+                    set cmdret 1\n+                }\n+            } else {\n+                if { [istarget \"hppa*-*-*\"] \\\n+                         && ![istarget \"*-*-linux*\"] \\\n+                         && ![istarget \"*-*-netbsd*\" ] } {\n+                    set cmd \"sed -e 's/^\\[\t \\]*\\.comm \\\\(\\[^,\\]*\\\\),\\\\(.*\\\\)/\\\\1 .comm \\\\2/' < $sourcefile > tmpdir/asm.s\"\n+                    send_log \"$cmd\\n\"\n+                    set cmdret [remote_exec host [concat sh -c [list \"$cmd\"]]]\n+                    set cmdret [lindex $cmdret 0]\n+                    if { $cmdret != 0 } {\n+                        perror \"sed failure\"\n+                        unresolved $testname\n+                        continue\n+                    }\n+                    set sourcefile tmpdir/asm.s\n+                }\n+                set cmd \"$AS $ASFLAGS $as_flags $sourceasflags -o $objfile $sourcefile\"\n+\n+                send_log \"$cmd\\n\"\n+                set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n+                remote_upload host \"dump.tmp\"\n+                set comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+                remote_file host delete \"dump.tmp\"\n+                remote_file build delete \"dump.tmp\"\n+                set cmdret [lindex $cmdret 0]\n+            }\n+            if { $cmdret == 0 && $run_objcopy_objects } {\n+                set cmd \"$OBJCOPY $opts(objcopy_objects) $objfile\"\n+\n+                send_log \"$cmd\\n\"\n+                set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \\\n+                                \"\" \"/dev/null\" \"dump.tmp\"]\n+                remote_upload host \"dump.tmp\"\n+                append comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+                remote_file host delete \"dump.tmp\"\n+                remote_file build delete \"dump.tmp\"\n+                set cmdret [lindex $cmdret 0]\n+            }\n+        }\n+\n+        # Perhaps link the file(s).\n+        if { $cmdret == 0 && $run_ld } {\n+            set objfile \"tmpdir/dump\"\n+            catch \"exec rm -f $objfile\" exec_output\n+\n+            set ld_extra_opt \"\"\n+            global ld\n+            set ld \"$LD\"\n+            if { [is_elf_format] && [check_shared_lib_support] } {\n+                set ld_extra_opt \"$ld_elf_shared_opt\"\n+            }\n+\n+            # Add -L$srcdir/$subdir so that the linker command can use\n+            # linker scripts in the source directory.\n+            set cmd \"$LD $ld_extra_opt $LDFLAGS -L$srcdir/$subdir \\\n \t\t   $opts(ld) -o $objfile $objfiles $opts(ld_after_inputfiles)\"\n \n-\t# If needed then check for, or add a -Map option.\n-\tset mapfile \"\"\n-\tif { $opts(map) != \"\" } then {\n-\t    if { [regexp -- \"-Map=(\\[^ \\]+)\" $cmd all mapfile] } then {\n-\t\t# Found existing mapfile option\n-\t\tverbose -log \"Existing mapfile '$mapfile' found\"\n-\t    } else {\n-\t\t# No mapfile option.\n-\t\tset mapfile \"tmpdir/dump.map\"\n-\t\tverbose -log \"Adding mapfile '$mapfile'\"\n-\t\tset cmd \"$cmd -Map=$mapfile\"\n-\t    }\n-\t}\n-\n-\tsend_log \"$cmd\\n\"\n-\tset cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n-\tremote_upload host \"dump.tmp\"\n-\tappend comp_output [file_contents \"dump.tmp\"]\n-\tremote_file host delete \"dump.tmp\"\n-\tremote_file build delete \"dump.tmp\"\n-\tset cmdret [lindex $cmdret 0]\n-\n-\tif { $cmdret == 0 && $run_objcopy } {\n-\t    set infile $objfile\n-\t    set objfile \"tmpdir/dump1\"\n-\t    remote_file host delete $objfile\n-\n-\t    # Note that we don't use OBJCOPYFLAGS here; any flags must be\n-\t    # explicitly specified.\n-\t    set cmd \"$OBJCOPY $opts(objcopy_linked_file) $infile $objfile\"\n-\n-\t    send_log \"$cmd\\n\"\n-\t    set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n-\t    remote_upload host \"dump.tmp\"\n-\t    append comp_output [file_contents \"dump.tmp\"]\n-\t    remote_file host delete \"dump.tmp\"\n-\t    remote_file build delete \"dump.tmp\"\n-\t    set cmdret [lindex $cmdret 0]\n-\t}\n-    } else {\n-\tset objfile [lindex $objfiles 0]\n-    }\n-\n-    if { $cmdret == 0 && $opts(PROG) != \"\" } {\n-\tset destopt ${copyfile}.o\n-\tswitch -- $opts(PROG) {\n-\t    ar\t\t{ set program ar }\n-\t    elfedit\t{\n-\t\tset program elfedit\n-\t\tset destopt \"\"\n-\t    }\n-\t    nm\t\t{ set program nm }\n-\t    objcopy\t{ set program objcopy }\n-\t    ranlib\t{ set program ranlib }\n-\t    strings\t{ set program strings }\n-\t    strip\t{\n-\t\tset program strip\n-\t\tset destopt \"-o $destopt\"\n-\t    }\n-\t    default\t{\n-\t\tperror \"unrecognized PROG option $opts(PROG) in $file.d\"\n-\t\tunresolved $testname\n-\t\treturn\n-\t    }\n-\t}\n-\n-\tset progopts1 $opts($program)\n-\teval set progopts \\$[string toupper $program]FLAGS\n-\teval set binary \\$[string toupper $program]\n-\n-\tif { ![is_remote host] && [which $binary] == 0 } {\n-\t    untested $testname\n-\t    return\n-\t}\n-\n-\tverbose \"running $binary $progopts $progopts1\" 3\n-\tset cmd \"$binary $progopts $progopts1 $objfile $destopt\"\n-\n-\t# Ensure consistent sorting of symbols\n-\tif {[info exists env(LC_ALL)]} {\n-\t    set old_lc_all $env(LC_ALL)\n-\t}\n-\tset env(LC_ALL) \"C\"\n-\tsend_log \"$cmd\\n\"\n-\tset cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n-\tset cmdret [lindex $cmdret 0]\n-\tremote_upload host \"dump.tmp\"\n-\tappend comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-\tremote_file host delete \"dump.tmp\"\n-\tremote_file build delete \"dump.tmp\"\n-\tif {[info exists old_lc_all]} {\n-\t    set env(LC_ALL) $old_lc_all\n-\t} else {\n-\t    unset env(LC_ALL)\n-\t}\n-\tif { $destopt != \"\" } {\n-\t    set objfile ${copyfile}.o\n-\t}\n+            # If needed then check for, or add a -Map option.\n+            set mapfile \"\"\n+            if { $opts(map) != \"\" } then {\n+                if { [regexp -- \"-Map=(\\[^ \\]+)\" $cmd all mapfile] } then {\n+                    # Found existing mapfile option\n+                    verbose -log \"Existing mapfile '$mapfile' found\"\n+                } else {\n+                    # No mapfile option.\n+                    set mapfile \"tmpdir/dump.map\"\n+                    verbose -log \"Adding mapfile '$mapfile'\"\n+                    set cmd \"$cmd -Map=$mapfile\"\n+                }\n+            }\n+\n+            send_log \"$cmd\\n\"\n+            set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n+            remote_upload host \"dump.tmp\"\n+            append comp_output [file_contents \"dump.tmp\"]\n+            remote_file host delete \"dump.tmp\"\n+            remote_file build delete \"dump.tmp\"\n+            set cmdret [lindex $cmdret 0]\n+\n+            if { $cmdret == 0 && $run_objcopy } {\n+                set infile $objfile\n+                set objfile \"tmpdir/dump1\"\n+                remote_file host delete $objfile\n+\n+                # Note that we don't use OBJCOPYFLAGS here; any flags must be\n+                # explicitly specified.\n+                set cmd \"$OBJCOPY $opts(objcopy_linked_file) $infile $objfile\"\n+\n+                send_log \"$cmd\\n\"\n+                set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n+                remote_upload host \"dump.tmp\"\n+                append comp_output [file_contents \"dump.tmp\"]\n+                remote_file host delete \"dump.tmp\"\n+                remote_file build delete \"dump.tmp\"\n+                set cmdret [lindex $cmdret 0]\n+            }\n+        } else {\n+            set objfile [lindex $objfiles 0]\n+        }\n+\n+        if { $cmdret == 0 && $opts(PROG) != \"\" } {\n+            set destopt ${copyfile}.o\n+            switch -- $opts(PROG) {\n+                ar\t\t{ set program ar }\n+                elfedit\t{\n+                    set program elfedit\n+                    set destopt \"\"\n+                }\n+                nm\t\t{ set program nm }\n+                objcopy\t{ set program objcopy }\n+                ranlib\t{ set program ranlib }\n+                strings\t{ set program strings }\n+                strip\t{\n+                    set program strip\n+                    set destopt \"-o $destopt\"\n+                }\n+                default\t{\n+                    perror \"unrecognized PROG option $opts(PROG) in $file.d\"\n+                    unresolved $testname\n+                    continue\n+                }\n+            }\n+\n+            set progopts1 $opts($program)\n+            eval set progopts \\$[string toupper $program]FLAGS\n+            eval set binary \\$[string toupper $program]\n+\n+            if { ![is_remote host] && [which $binary] == 0 } {\n+                untested $testname\n+                continue\n+            }\n+\n+            verbose \"running $binary $progopts $progopts1\" 3\n+            set cmd \"$binary $progopts $progopts1 $objfile $destopt\"\n+\n+            # Ensure consistent sorting of symbols\n+            if {[info exists env(LC_ALL)]} {\n+                set old_lc_all $env(LC_ALL)\n+            }\n+            set env(LC_ALL) \"C\"\n+            send_log \"$cmd\\n\"\n+            set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n+            set cmdret [lindex $cmdret 0]\n+            remote_upload host \"dump.tmp\"\n+            append comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+            remote_file host delete \"dump.tmp\"\n+            remote_file build delete \"dump.tmp\"\n+            if {[info exists old_lc_all]} {\n+                set env(LC_ALL) $old_lc_all\n+            } else {\n+                unset env(LC_ALL)\n+            }\n+            if { $destopt != \"\" } {\n+                set objfile ${copyfile}.o\n+            }\n+        }\n+\n+        set want_out(source) \"\"\n+        set want_out(terminal) 0\n+        if { $err_warn } {\n+            if { $opts(error) != \"\" || $opts(error_output) != \"\" } {\n+                set want_out(terminal) 1\n+            }\n+\n+            if { $opts(error) != \"\" || $opts(warning) != \"\" } {\n+                set want_out(source) \"regex\"\n+                if { $opts(error) != \"\" } {\n+                    set want_out(regex) $opts(error)\n+                } else {\n+                    set want_out(regex) $opts(warning)\n+                }\n+            } else {\n+                set want_out(source) \"file\"\n+                if { $opts(error_output) != \"\" } {\n+                    set want_out(file) $opts(error_output)\n+                } else {\n+                    set want_out(file) $opts(warning_output)\n+                }\n+            }\n+        }\n+\n+        regsub \"\\n$\" $comp_output \"\" comp_output\n+        if { $cmdret != 0 || $comp_output != \"\" || $want_out(source) != \"\" } {\n+            set exitstat \"succeeded\"\n+            if { $cmdret != 0 } { set exitstat \"failed\" }\n+\n+            if { $want_out(source) == \"regex\" } {\n+                verbose -log \"$exitstat with: <$comp_output>, expected: <$want_out(regex)>\"\n+            } elseif { $want_out(source) == \"file\" } {\n+                verbose -log \"$exitstat with: <$comp_output>, expected in file $want_out(file)\"\n+                set_file_contents \"tmpdir/ld.messages\" \"$comp_output\"\n+            } else {\n+                verbose -log \"$exitstat with: <$comp_output>, no expected output\"\n+            }\n+\n+            if { (($want_out(source) == \"\") == ($comp_output == \"\")) \\\n+                     && (($cmdret == 0) == ($want_out(terminal) == 0)) \\\n+                     && ((($want_out(source) == \"regex\") \\\n+                              && [regexp -- $want_out(regex) $comp_output]) \\\n+                             || (($want_out(source) == \"file\") \\\n+                                     && (![regexp_diff \"tmpdir/ld.messages\" \"$srcdir/$subdir/$want_out(file)\"]))) } {\n+                # We have the expected output.\n+                if { $want_out(terminal) || $dumpprogram == \"\" } {\n+                    pass $testname\n+                    continue\n+                }\n+            } else {\n+                fail $testname\n+                continue\n+            }\n+        }\n+\n+        # We must not have expected failure if we get here.\n+        if { $opts(error) != \"\" } {\n+            fail $testname\n+            continue\n+        }\n+\n+        if { $opts(map) != \"\" } then {\n+            # Check the map file matches.\n+            set map_pattern_file $srcdir/$subdir/$opts(map)\n+            verbose -log \"Compare '$mapfile' against '$map_pattern_file'\"\n+            if { [regexp_diff $mapfile $map_pattern_file] } then {\n+                fail \"$testname (map file check)\"\n+            } else {\n+                pass \"$testname (map file check)\"\n+            }\n+\n+            if { $dumpprogram == \"\" } then {\n+                continue\n+            }\n+        }\n+\n+        set progopts1 $opts($dumpprogram)\n+        eval set progopts \\$[string toupper $dumpprogram]FLAGS\n+        eval set binary \\$[string toupper $dumpprogram]\n+\n+        if { ![is_remote host] && [which $binary] == 0 } {\n+            untested $testname\n+            continue\n+        }\n+\n+        # For objdump of gas output, automatically translate standard section names\n+        set sect_names \"\"\n+        if { !$run_ld && $dumpprogram == \"objdump\" \\\n+                 && $opts(section_subst) != \"no\" \\\n+                 && ![string match \"*-b binary*\" $progopts1] } {\n+            set sect_names [get_standard_section_names]\n+            if { $sect_names != \"\"} {\n+                regsub -- \"\\\\.text\" $progopts1 \"[lindex $sect_names 0]\" progopts1\n+                regsub -- \"\\\\.data\" $progopts1 \"[lindex $sect_names 1]\" progopts1\n+                regsub -- \"\\\\.bss\"  $progopts1 \"[lindex $sect_names 2]\" progopts1\n+            }\n+        }\n+\n+        if { $progopts1 == \"\" } { set $progopts1 \"-r\" }\n+        verbose \"running $binary $progopts $progopts1\" 3\n+\n+        set cmd \"$binary $progopts $progopts1 $objfile > $dumpfile\"\n+\n+        # Ensure consistent sorting of symbols\n+        if {[info exists env(LC_ALL)]} {\n+            set old_lc_all $env(LC_ALL)\n+        }\n+        set env(LC_ALL) \"C\"\n+        send_log \"$cmd\\n\"\n+        set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n+        set cmdret [lindex $cmdret 0]\n+        remote_upload host \"dump.tmp\"\n+        set comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+        remote_file host delete \"dump.tmp\"\n+        remote_file build delete \"dump.tmp\"\n+        if {[info exists old_lc_all]} {\n+            set env(LC_ALL) $old_lc_all\n+        } else {\n+            unset env(LC_ALL)\n+        }\n+        if { $cmdret != 0 || $comp_output != \"\" } {\n+            send_log \"exited abnormally with $cmdret, output:$comp_output\\n\"\n+            fail $testname\n+            continue\n+        }\n+\n+        if { $verbose > 2 } then { verbose \"output is [file_contents $dumpfile]\" 3 }\n+\n+        # Create the substition list for objdump output.\n+        set regexp_subst \"\"\n+        if { $sect_names != \"\" } {\n+            set regexp_subst [list \"\\\\\\\\?\\\\.text\" [lindex $sect_names 0] \\\n+                                  \"\\\\\\\\?\\\\.data\" [lindex $sect_names 1] \\\n+                                  \"\\\\\\\\?\\\\.bss\" [lindex $sect_names 2] ]\n+        }\n+\n+        if { [regexp_diff $dumpfile \"${dfile}\" $regexp_subst] } then {\n+            fail $testname\n+            if { $verbose == 2 } then { verbose \"output is [file_contents $dumpfile]\" 2 }\n+            continue\n+        }\n+\n+        pass $testname\n     }\n-\n-    set want_out(source) \"\"\n-    set want_out(terminal) 0\n-    if { $err_warn } {\n-\tif { $opts(error) != \"\" || $opts(error_output) != \"\" } {\n-\t    set want_out(terminal) 1\n-\t}\n-\n-\tif { $opts(error) != \"\" || $opts(warning) != \"\" } {\n-\t    set want_out(source) \"regex\"\n-\t    if { $opts(error) != \"\" } {\n-\t\tset want_out(regex) $opts(error)\n-\t    } else {\n-\t\tset want_out(regex) $opts(warning)\n-\t    }\n-\t} else {\n-\t    set want_out(source) \"file\"\n-\t    if { $opts(error_output) != \"\" } {\n-\t\tset want_out(file) $opts(error_output)\n-\t    } else {\n-\t\tset want_out(file) $opts(warning_output)\n-\t    }\n-\t}\n-    }\n-\n-    regsub \"\\n$\" $comp_output \"\" comp_output\n-    if { $cmdret != 0 || $comp_output != \"\" || $want_out(source) != \"\" } {\n-\tset exitstat \"succeeded\"\n-\tif { $cmdret != 0 } { set exitstat \"failed\" }\n-\n-\tif { $want_out(source) == \"regex\" } {\n-\t    verbose -log \"$exitstat with: <$comp_output>, expected: <$want_out(regex)>\"\n-\t} elseif { $want_out(source) == \"file\" } {\n-\t    verbose -log \"$exitstat with: <$comp_output>, expected in file $want_out(file)\"\n-\t    set_file_contents \"tmpdir/ld.messages\" \"$comp_output\"\n-\t} else {\n-\t    verbose -log \"$exitstat with: <$comp_output>, no expected output\"\n-\t}\n-\n-\tif { (($want_out(source) == \"\") == ($comp_output == \"\")) \\\n-\t     && (($cmdret == 0) == ($want_out(terminal) == 0)) \\\n-\t     && ((($want_out(source) == \"regex\") \\\n-\t\t  && [regexp -- $want_out(regex) $comp_output]) \\\n-\t\t || (($want_out(source) == \"file\") \\\n-\t\t     && (![regexp_diff \"tmpdir/ld.messages\" \"$srcdir/$subdir/$want_out(file)\"]))) } {\n-\t    # We have the expected output.\n-\t    if { $want_out(terminal) || $dumpprogram == \"\" } {\n-\t\tpass $testname\n-\t\treturn\n-\t    }\n-\t} else {\n-\t    fail $testname\n-\t    return\n-\t}\n-    }\n-\n-    # We must not have expected failure if we get here.\n-    if { $opts(error) != \"\" } {\n-\tfail $testname\n-\treturn\n-    }\n-\n-    if { $opts(map) != \"\" } then {\n-\t# Check the map file matches.\n-\tset map_pattern_file $srcdir/$subdir/$opts(map)\n-\tverbose -log \"Compare '$mapfile' against '$map_pattern_file'\"\n-\tif { [regexp_diff $mapfile $map_pattern_file] } then {\n-\t    fail \"$testname (map file check)\"\n-\t} else {\n-\t    pass \"$testname (map file check)\"\n-\t}\n-\n-\tif { $dumpprogram == \"\" } then {\n-\t    return\n-\t}\n-    }\n-\n-    set progopts1 $opts($dumpprogram)\n-    eval set progopts \\$[string toupper $dumpprogram]FLAGS\n-    eval set binary \\$[string toupper $dumpprogram]\n-\n-    if { ![is_remote host] && [which $binary] == 0 } {\n-\tuntested $testname\n-\treturn\n-    }\n-\n-    # For objdump of gas output, automatically translate standard section names\n-    set sect_names \"\"\n-    if { !$run_ld && $dumpprogram == \"objdump\" \\\n-\t     && $opts(section_subst) != \"no\" \\\n-\t     && ![string match \"*-b binary*\" $progopts1] } {\n-\tset sect_names [get_standard_section_names]\n-\tif { $sect_names != \"\"} {\n-\t    regsub -- \"\\\\.text\" $progopts1 \"[lindex $sect_names 0]\" progopts1\n-\t    regsub -- \"\\\\.data\" $progopts1 \"[lindex $sect_names 1]\" progopts1\n-\t    regsub -- \"\\\\.bss\"  $progopts1 \"[lindex $sect_names 2]\" progopts1\n-\t}\n-    }\n-\n-    if { $progopts1 == \"\" } { set $progopts1 \"-r\" }\n-    verbose \"running $binary $progopts $progopts1\" 3\n-\n-    set cmd \"$binary $progopts $progopts1 $objfile > $dumpfile\"\n-\n-    # Ensure consistent sorting of symbols\n-    if {[info exists env(LC_ALL)]} {\n-\tset old_lc_all $env(LC_ALL)\n-    }\n-    set env(LC_ALL) \"C\"\n-    send_log \"$cmd\\n\"\n-    set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n-    set cmdret [lindex $cmdret 0]\n-    remote_upload host \"dump.tmp\"\n-    set comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-    remote_file host delete \"dump.tmp\"\n-    remote_file build delete \"dump.tmp\"\n-    if {[info exists old_lc_all]} {\n-\tset env(LC_ALL) $old_lc_all\n-    } else {\n-\tunset env(LC_ALL)\n-    }\n-    if { $cmdret != 0 || $comp_output != \"\" } {\n-\tsend_log \"exited abnormally with $cmdret, output:$comp_output\\n\"\n-\tfail $testname\n-\treturn\n-    }\n-\n-    if { $verbose > 2 } then { verbose \"output is [file_contents $dumpfile]\" 3 }\n-\n-    # Create the substition list for objdump output.\n-    set regexp_subst \"\"\n-    if { $sect_names != \"\" } {\n-\tset regexp_subst [list \"\\\\\\\\?\\\\.text\" [lindex $sect_names 0] \\\n-\t\t\t      \"\\\\\\\\?\\\\.data\" [lindex $sect_names 1] \\\n-\t\t\t      \"\\\\\\\\?\\\\.bss\" [lindex $sect_names 2] ]\n-    }\n-\n-    if { [regexp_diff $dumpfile \"${dfile}\" $regexp_subst] } then {\n-\tfail $testname\n-\tif { $verbose == 2 } then { verbose \"output is [file_contents $dumpfile]\" 2 }\n-\treturn\n-    }\n-\n-    pass $testname\n }\n \n proc slurp_options { file } {"
    },
    {
      "sha": "3508c5a0385dfd50b500227e31f9742e50c6721c",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
      "patch": "@@ -1,3 +1,13 @@\n+2019-02-27  Matthew Malcomson  <matthew.malcomson@arm.com>\n+\n+\t* testsuite/gas/aarch64/dotproduct.d: Use multiple \"as\" lines.\n+\t* testsuite/gas/aarch64/dotproduct_armv8_4.d: Remove.\n+\t* testsuite/gas/aarch64/dotproduct_armv8_4.s: Remove.\n+\t* testsuite/gas/aarch64/illegal-dotproduct.d: Use multiple \"as\"\n+\tlines.\n+\t* testsuite/gas/aarch64/ldst-rcpc-armv8_2.d: Remove.\n+\t* testsuite/gas/aarch64/ldst-rcpc.d: Use multiple \"as\" lines.\n+\n 2019-02-24  Alan Modra  <amodra@gmail.com>\n \n \t* config/tc-ppc.c (parse_tls_arg): Wrap in #ifdef OBJ_ELF."
    },
    {
      "sha": "fd2f0ebf4c66de3e9bd3e831c8cb9828cae932aa",
      "filename": "gas/testsuite/gas/aarch64/dotproduct.d",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/testsuite/gas/aarch64/dotproduct.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/testsuite/gas/aarch64/dotproduct.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/aarch64/dotproduct.d?ref=52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
      "patch": "@@ -1,4 +1,5 @@\n #as: -march=armv8.2-a+dotprod\n+#as: -march=armv8.4-a\n #objdump: -dr\n \n .*:     file format .*"
    },
    {
      "sha": "121eb11bb40a12b57ebf1f52beaeade1bdb29e16",
      "filename": "gas/testsuite/gas/aarch64/dotproduct_armv8_4.d",
      "status": "removed",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf9a735e239cb7a27c81aa7c98679f7f83fa8314/gas/testsuite/gas/aarch64/dotproduct_armv8_4.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf9a735e239cb7a27c81aa7c98679f7f83fa8314/gas/testsuite/gas/aarch64/dotproduct_armv8_4.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/aarch64/dotproduct_armv8_4.d?ref=bf9a735e239cb7a27c81aa7c98679f7f83fa8314",
      "patch": "@@ -1,10 +0,0 @@\n-#as: -march=armv8.4-a\n-#objdump: -dr\n-\n-.*:     file format .*\n-\n-Disassembly of section \\.text:\n-\n-0+ <.*>:\n-[^:]+:\\s+2e809400 \tudot\tv0.2s, v0.8b, v0.8b\n-[^:]+:\\s+2e8b9400 \tudot\tv0.2s, v0.8b, v11.8b"
    },
    {
      "sha": "37538d9bb8270832a003a27e89e3f2d0e6ab44c0",
      "filename": "gas/testsuite/gas/aarch64/dotproduct_armv8_4.s",
      "status": "removed",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf9a735e239cb7a27c81aa7c98679f7f83fa8314/gas/testsuite/gas/aarch64/dotproduct_armv8_4.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf9a735e239cb7a27c81aa7c98679f7f83fa8314/gas/testsuite/gas/aarch64/dotproduct_armv8_4.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/aarch64/dotproduct_armv8_4.s?ref=bf9a735e239cb7a27c81aa7c98679f7f83fa8314",
      "patch": "@@ -1,2 +0,0 @@\n-UDOT\tV0.2S, V0.8B, V0.8B\n-UDOT\tV0.2S, V0.8B, V11.8B"
    },
    {
      "sha": "0e15b9fbed4f90dd9d68c1923f73239e73dcde20",
      "filename": "gas/testsuite/gas/aarch64/illegal-dotproduct.d",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/testsuite/gas/aarch64/illegal-dotproduct.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/testsuite/gas/aarch64/illegal-dotproduct.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/aarch64/illegal-dotproduct.d?ref=52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
      "patch": "@@ -1,4 +1,5 @@\n #as: -march=armv8.2-a+dotprod\n+#as: -march=armv8.4-a\n #name: Invalid dotproduct instructions.\n #source: illegal-dotproduct.s\n #error_output: illegal-dotproduct.l"
    },
    {
      "sha": "ac8938fc086c6d55170d1de2900420fbe70881d3",
      "filename": "gas/testsuite/gas/aarch64/ldst-rcpc-armv8_2.d",
      "status": "removed",
      "additions": 0,
      "deletions": 21,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf9a735e239cb7a27c81aa7c98679f7f83fa8314/gas/testsuite/gas/aarch64/ldst-rcpc-armv8_2.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf9a735e239cb7a27c81aa7c98679f7f83fa8314/gas/testsuite/gas/aarch64/ldst-rcpc-armv8_2.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/aarch64/ldst-rcpc-armv8_2.d?ref=bf9a735e239cb7a27c81aa7c98679f7f83fa8314",
      "patch": "@@ -1,21 +0,0 @@\n-#objdump: -dr\n-#as: -march=armv8.2-a+rcpc\n-#source: ldst-rcpc.s\n-\n-.*:     file format .*\n-\n-Disassembly of section \\.text:\n-\n-0+ <.*>:\n-   0:\t38bfc0e1 \tldaprb\tw1, \\[x7\\]\n-   4:\t38bfc0e1 \tldaprb\tw1, \\[x7\\]\n-   8:\t38bfc0e1 \tldaprb\tw1, \\[x7\\]\n-   c:\t78bfc0e1 \tldaprh\tw1, \\[x7\\]\n-  10:\t78bfc0e1 \tldaprh\tw1, \\[x7\\]\n-  14:\t78bfc0e1 \tldaprh\tw1, \\[x7\\]\n-  18:\tb8bfc0e1 \tldapr\tw1, \\[x7\\]\n-  1c:\tb8bfc0e1 \tldapr\tw1, \\[x7\\]\n-  20:\tb8bfc0e1 \tldapr\tw1, \\[x7\\]\n-  24:\tf8bfc0e1 \tldapr\tx1, \\[x7\\]\n-  28:\tf8bfc0e1 \tldapr\tx1, \\[x7\\]\n-  2c:\tf8bfc0e1 \tldapr\tx1, \\[x7\\]"
    },
    {
      "sha": "f9e951bdcb49ce1e7e1be57f37cf0e1938a2fc8a",
      "filename": "gas/testsuite/gas/aarch64/ldst-rcpc.d",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/testsuite/gas/aarch64/ldst-rcpc.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52d6f3ee9439bb20c45421ecfeef2a69fd0b5511/gas/testsuite/gas/aarch64/ldst-rcpc.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/aarch64/ldst-rcpc.d?ref=52d6f3ee9439bb20c45421ecfeef2a69fd0b5511",
      "patch": "@@ -1,5 +1,7 @@\n #objdump: -dr\n #as: -march=armv8.3-a\n+#as: -march=armv8.2-a+rcpc\n+#source: ldst-rcpc.s\n \n .*:     file format .*\n "
    }
  ]
}