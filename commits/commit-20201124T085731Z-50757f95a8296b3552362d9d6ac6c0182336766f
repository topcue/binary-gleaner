{
  "sha": "50757f95a8296b3552362d9d6ac6c0182336766f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTA3NTdmOTVhODI5NmIzNTUyMzYyZDlkNmFjNmMwMTgyMzM2NzY2Zg==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-11-24T08:56:38Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-11-24T08:57:31Z"
    },
    "message": "gdb/testsuite: do not hard-code location indices in condbreak-multi-context.exp\n\nBreakpoint locations are sorted according to their addresses.  The\naddresses are determined by how the compiler emits the code.\nTherefore, we may have a different order of locations depending on the\ncompiler we use.  To make the gdb.base/condbreak-multi-context.exp\ntest flexible enough for different compilers' output, do not hard-code\nlocation indices.\n\nTested with GCC and Clang.\n\ngdb/testsuite/ChangeLog:\n2020-11-24  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gdb.base/condbreak-multi-context.exp: Do not hard-code location\n\tindices.",
    "tree": {
      "sha": "9c4090ddc838868cd326480f0f92864934909b10",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9c4090ddc838868cd326480f0f92864934909b10"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/50757f95a8296b3552362d9d6ac6c0182336766f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/50757f95a8296b3552362d9d6ac6c0182336766f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/50757f95a8296b3552362d9d6ac6c0182336766f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/50757f95a8296b3552362d9d6ac6c0182336766f/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2c20a6018c56797f4ce9c2d3c462168cb2d76831",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c20a6018c56797f4ce9c2d3c462168cb2d76831",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2c20a6018c56797f4ce9c2d3c462168cb2d76831"
    }
  ],
  "stats": {
    "total": 195,
    "additions": 128,
    "deletions": 67
  },
  "files": [
    {
      "sha": "5f62e45fed82ca5d75f2156f1be1f6810f906aa6",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50757f95a8296b3552362d9d6ac6c0182336766f/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50757f95a8296b3552362d9d6ac6c0182336766f/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=50757f95a8296b3552362d9d6ac6c0182336766f",
      "patch": "@@ -1,3 +1,8 @@\n+2020-11-24  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gdb.base/condbreak-multi-context.exp: Do not hard-code location\n+\tindices.\n+\n 2020-11-24  Joel Brobecker  <brobecker@adacore.com>\n \n \t* gdb.dwarf2/dw2-fixed-point.exp: Fix the expected output of"
    },
    {
      "sha": "f89452f54c529f5ca1f46be517bff1bd2179c8e4",
      "filename": "gdb/testsuite/gdb.base/condbreak-multi-context.exp",
      "status": "modified",
      "additions": 123,
      "deletions": 67,
      "changes": 190,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50757f95a8296b3552362d9d6ac6c0182336766f/gdb/testsuite/gdb.base/condbreak-multi-context.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50757f95a8296b3552362d9d6ac6c0182336766f/gdb/testsuite/gdb.base/condbreak-multi-context.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/condbreak-multi-context.exp?ref=50757f95a8296b3552362d9d6ac6c0182336766f",
      "patch": "@@ -25,57 +25,116 @@ if {[prepare_for_testing \"failed to prepare\" ${binfile} ${srcfile}]} {\n set warning \"warning: failed to validate condition\"\n set fill \"\\[^\\r\\n\\]*\"\n \n-# Check that breakpoints are as expected.\n+# Location indices are determined by their address, which depends on\n+# how the compiler emits the code.  We keep a map from the location\n+# index to the location context (i.e. A, Base, or C), so that we can\n+# write tests without hard-coding location indices.\n+set loc_name(1) \"\"\n+set loc_name(2) \"\"\n+set loc_name(3) \"\"\n+# And, for convenience, a reverse map from the name to the index.\n+set loc_index(A)    0\n+set loc_index(Base) 0\n+set loc_index(C)    0\n+\n+# Find breakpoint location contexts.\n+\n+proc find_location_contexts {} {\n+    global loc_name loc_index bpnum1 fill\n+    global decimal hex gdb_prompt\n+\n+    gdb_test_multiple \"info breakpoint $bpnum1\" \"find_location_indices\" {\n+\t-re \"stop only if ${fill}\\r\\n\" {\n+\t    exp_continue\n+\t}\n+\t-re \"^${bpnum1}\\.($decimal) ${fill} ${hex} in (A|Base|C)::func${fill}\\r\\n\" {\n+\t    set index $expect_out(1,string)\n+\t    set name $expect_out(2,string)\n+\t    set loc_name($index) $name\n+\t    set loc_index($name) $index\n+\t    exp_continue\n+\t}\n+\t-re \"$gdb_prompt $\" {\n+\t    verbose -log \"Loc names: $loc_name(1), $loc_name(2), $loc_name(3)\"\n+\t    gdb_assert { ![string equal $loc_name(1) $loc_name(2)] }\n+\t    gdb_assert { ![string equal $loc_name(1) $loc_name(3)] }\n+\t    gdb_assert { ![string equal $loc_name(2) $loc_name(3)] }\n+\t    gdb_assert { [string length $loc_name(1)] > 0 }\n+\t    gdb_assert { [string length $loc_name(2)] > 0 }\n+\t    gdb_assert { [string length $loc_name(3)] > 0 }\n+\t}\n+    }\n+}\n \n-proc test_info_break {suffix} {\n-    global bpnum1 bpnum2 fill\n+# Test the breakpoint location enabled states.  STATES is a list of\n+# location states.  We assume STATES to contain the state for A, Base,\n+# and C, and in this order.  E.g. {N* y n} for 'N*' at A::func, 'y' at\n+# B::func, and 'n' at C::func, respectively.\n \n-    set bp_hit_info \"${fill}(\\r\\n${fill}breakpoint already hit 1 time)?\"\n+proc check_bp_locations {bpnum states cond {msg \"\"}} {\n+    global loc_name fill\n \n-    gdb_test \"info break ${bpnum1} ${bpnum2}\" \\\n-\t[multi_line \\\n-\t     \"Num${fill}\" \\\n-\t     \"${bpnum1}${fill}breakpoint${fill}keep y${fill}MULTIPLE${fill}\" \\\n-\t     \"${fill}stop only if a == 10${bp_hit_info}\" \\\n-\t     \"${bpnum1}.1${fill}N\\\\*${fill}Base::func${fill}\" \\\n-\t     \"${bpnum1}.2${fill}y${fill}A::func${fill}\" \\\n-\t     \"${bpnum1}.3${fill}N\\\\*${fill}C::func${fill}\" \\\n-\t     \"${bpnum2}${fill}breakpoint${fill}keep y${fill}MULTIPLE${fill}\" \\\n-\t     \"${fill}stop only if c == 30${bp_hit_info}\" \\\n-\t     \"${bpnum2}.1${fill}N\\\\*${fill}Base::func${fill}\" \\\n-\t     \"${bpnum2}.2${fill}N\\\\*${fill}A::func${fill}\" \\\n-\t     \"${bpnum2}.3${fill}y${fill}C::func${fill}\" \\\n-\t     \"\\\\(\\\\*\\\\): Breakpoint condition is invalid at this location.\"] \\\n-\t\"info break $suffix\"\n+    # Map location names to location states.\n+    set loc_states(A)    [lindex $states 0]\n+    set loc_states(Base) [lindex $states 1]\n+    set loc_states(C)    [lindex $states 2]\n+\n+    if {$cond == \"\"} {\n+\tset cond_info \"\"\n+    } else {\n+\tset bp_hit_info \"${fill}(\\r\\n${fill}breakpoint already hit 1 time)?\"\n+\tset cond_info \"\\r\\n${fill}stop only if ${cond}${bp_hit_info}\"\n+    }\n+\n+    set expected [multi_line \\\n+\t\"Num${fill}\" \\\n+\t\"${bpnum}${fill}breakpoint${fill}keep y${fill}MULTIPLE${fill}${cond_info}\" \\\n+\t\"${bpnum}.1${fill} $loc_states($loc_name(1)) ${fill}\" \\\n+\t\"${bpnum}.2${fill} $loc_states($loc_name(2)) ${fill}\" \\\n+\t\"${bpnum}.3${fill} $loc_states($loc_name(3)) ${fill}\"]\n+\n+    if {[lsearch $states N*] >= 0} {\n+\tappend expected \"\\r\\n\\\\(\\\\*\\\\): Breakpoint condition is invalid at this location.\"\n+    }\n+\n+    gdb_test \"info break $bpnum\" $expected \"check bp $bpnum $msg\"\n }\n \n # Scenario 1: Define breakpoints conditionally, using the \"break N if\n # cond\" syntax.  Run the program, check that we hit those locations\n # only.\n \n with_test_prefix \"scenario 1\" {\n-    # Define the conditional breakpoints.\n+    # Define the conditional breakpoints.  Two locations (Base::func\n+    # and C::func) should be disabled.  We do not test location\n+    # indices strictly at this moment, because we don't know them,\n+    # yet.  We have strict location index tests below.\n     gdb_test \"break func if a == 10\" \\\n \t[multi_line \\\n-\t     \"${warning} at location 1, disabling:\" \\\n+\t     \"${warning} at location $decimal, disabling:\" \\\n \t     \"  No symbol \\\"a\\\" in current context.\" \\\n-\t     \"${warning} at location 3, disabling:\" \\\n+\t     \"${warning} at location $decimal, disabling:\" \\\n \t     \"  No symbol \\\"a\\\" in current context.\" \\\n \t     \"Breakpoint $decimal at $fill .3 locations.\"] \\\n \t\"define bp with condition a == 10\"\n     set bpnum1 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum1\"]\n \n     gdb_test \"break func if c == 30\" \\\n \t[multi_line \\\n-\t     \".*${warning} at location 1, disabling:\" \\\n+\t     \".*${warning} at location $decimal, disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\" \\\n-\t     \".*${warning} at location 2, disabling:\" \\\n+\t     \".*${warning} at location $decimal, disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\" \\\n \t     \".*Breakpoint $decimal at $fill .3 locations.\"] \\\n \t\"define bp with condition c == 30\"\n     set bpnum2 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum2\"]\n \n-    test_info_break 1\n+    find_location_contexts\n+\n+    with_test_prefix \"before run\" {\n+\tcheck_bp_locations $bpnum1 {y N* N*} \"a == 10\"\n+\tcheck_bp_locations $bpnum2 {N* N* y} \"c == 30\"\n+    }\n \n     # Do not use runto_main, it deletes all breakpoints.\n     gdb_run_cmd\n@@ -92,14 +151,17 @@ with_test_prefix \"scenario 1\" {\n     # No more hits!\n     gdb_continue_to_end\n \n-    test_info_break 2\n+    with_test_prefix \"after run\" {\n+\tcheck_bp_locations $bpnum1 {y N* N*} \"a == 10\"\n+\tcheck_bp_locations $bpnum2 {N* N* y} \"c == 30\"\n+    }\n }\n \n # Start GDB with two breakpoints and define the conditions separately.\n \n proc setup_bps {} {\n-    global srcfile binfile srcfile2\n-    global bpnum1 bpnum2 bp_location warning\n+    global srcfile binfile srcfile2 decimal\n+    global bpnum1 bpnum2 bp_location warning loc_index\n \n     clean_restart ${binfile}\n \n@@ -111,19 +173,21 @@ proc setup_bps {} {\n     set bpnum2 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum2\"]\n \n     # Defining a condition on 'a' disables 2 locations.\n+    set locs [lsort -integer \"$loc_index(Base) $loc_index(C)\"]\n     gdb_test \"cond $bpnum1 a == 10\" \\\n \t[multi_line \\\n-\t     \"$warning at location ${bpnum1}.1, disabling:\" \\\n+\t     \"$warning at location ${bpnum1}.[lindex $locs 0], disabling:\" \\\n \t     \"  No symbol \\\"a\\\" in current context.\" \\\n-\t     \"$warning at location ${bpnum1}.3, disabling:\" \\\n+\t     \"$warning at location ${bpnum1}.[lindex $locs 1], disabling:\" \\\n \t     \"  No symbol \\\"a\\\" in current context.\"]\n \n     # Defining a condition on 'c' disables 2 locations.\n+    set locs [lsort -integer \"$loc_index(Base) $loc_index(A)\"]\n     gdb_test \"cond $bpnum2 c == 30\" \\\n \t[multi_line \\\n-\t     \"$warning at location ${bpnum2}.1, disabling:\" \\\n+\t     \"$warning at location ${bpnum2}.[lindex $locs 0], disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\" \\\n-\t     \"$warning at location ${bpnum2}.2, disabling:\" \\\n+\t     \"$warning at location ${bpnum2}.[lindex $locs 1], disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\"]\n }\n \n@@ -135,7 +199,10 @@ proc setup_bps {} {\n with_test_prefix \"scenario 2\" {\n     setup_bps\n \n-    test_info_break 1\n+    with_test_prefix \"before run\" {\n+\tcheck_bp_locations $bpnum1 {y N* N*} \"a == 10\"\n+\tcheck_bp_locations $bpnum2 {N* N* y} \"c == 30\"\n+    }\n \n     # Do not use runto_main, it deletes all breakpoints.\n     gdb_run_cmd\n@@ -152,67 +219,56 @@ with_test_prefix \"scenario 2\" {\n     # No more hits!\n     gdb_continue_to_end\n \n-    test_info_break 2\n-}\n-\n-# Test the breakpoint location enabled states.\n-\n-proc check_bp_locations {bpnum states msg} {\n-    global fill\n-\n-    set expected  \".*${bpnum}.1${fill} [lindex $states 0] ${fill}\\r\\n\"\n-    append expected \"${bpnum}.2${fill} [lindex $states 1] ${fill}\\r\\n\"\n-    append expected \"${bpnum}.3${fill} [lindex $states 2] ${fill}\"\n-    if {[lsearch $states N*] >= 0} {\n-\tappend expected \"\\r\\n\\\\(\\\\*\\\\): Breakpoint condition is invalid at this location.\"\n+    with_test_prefix \"after run\" {\n+\tcheck_bp_locations $bpnum1 {y N* N*} \"a == 10\"\n+\tcheck_bp_locations $bpnum2 {N* N* y} \"c == 30\"\n     }\n-\n-    gdb_test \"info break $bpnum\" $expected \"check bp $bpnum $msg\"\n }\n \n # Scenario 3: Apply misc. checks on the already-defined breakpoints.\n \n with_test_prefix \"scenario 3\" {\n     setup_bps\n \n+    set locs [lsort -integer \"$loc_index(Base) $loc_index(A)\"]\n     gdb_test \"cond $bpnum1 c == 30\" \\\n \t[multi_line \\\n-\t     \"${warning} at location ${bpnum1}.1, disabling:\" \\\n+\t     \"${warning} at location ${bpnum1}.[lindex $locs 0], disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\" \\\n-\t     \"${warning} at location ${bpnum1}.2, disabling:\" \\\n+\t     \"${warning} at location ${bpnum1}.[lindex $locs 1], disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\" \\\n-\t     \"Breakpoint ${bpnum1}'s condition is now valid at location 3, enabling.\"] \\\n+\t     \"Breakpoint ${bpnum1}'s condition is now valid at location $loc_index(C), enabling.\"] \\\n \t\"change the condition of bp 1\"\n-    check_bp_locations $bpnum1 {N* N* y} \"after changing the condition\"\n+    check_bp_locations $bpnum1 {N* N* y} \"c == 30\" \"after changing the condition\"\n \n     gdb_test \"cond $bpnum1\" \\\n \t[multi_line \\\n-\t     \"Breakpoint ${bpnum1}'s condition is now valid at location 1, enabling.\" \\\n-\t     \"Breakpoint ${bpnum1}'s condition is now valid at location 2, enabling.\" \\\n+\t     \"Breakpoint ${bpnum1}'s condition is now valid at location [lindex $locs 0], enabling.\" \\\n+\t     \"Breakpoint ${bpnum1}'s condition is now valid at location [lindex $locs 1], enabling.\" \\\n \t     \"Breakpoint ${bpnum1} now unconditional.\"] \\\n \t\"reset the condition of bp 1\"\n-    check_bp_locations $bpnum1 {y y y} \"after resetting the condition\"\n+    check_bp_locations $bpnum1 {y y y} \"\" \"after resetting the condition\"\n \n-    gdb_test_no_output \"disable ${bpnum2}.2\"\n-    check_bp_locations $bpnum2 {N* N* y} \"after disabling loc 2\"\n+    gdb_test_no_output \"disable ${bpnum2}.$loc_index(A)\"\n+    check_bp_locations $bpnum2 {N* N* y} \"c == 30\" \"after disabling loc for A\"\n \n     gdb_test \"cond $bpnum2\" \".*\" \"reset the condition of bp 2\"\n-    check_bp_locations $bpnum2 {y n y} \"loc 2 should remain disabled\"\n+    check_bp_locations $bpnum2 {n y y} \"\" \"loc for A should remain disabled\"\n \n-    gdb_test_no_output \"disable ${bpnum2}.3\"\n-    check_bp_locations $bpnum2 {y n n} \"after disabling loc 3\"\n+    gdb_test_no_output \"disable ${bpnum2}.$loc_index(C)\"\n+    check_bp_locations $bpnum2 {n y n} \"\" \"after disabling loc for C\"\n \n     gdb_test \"cond $bpnum2 c == 30\" \\\n \t[multi_line \\\n-\t     \"${warning} at location ${bpnum2}.1, disabling:\" \\\n+\t     \"${warning} at location ${bpnum2}.$loc_index(Base), disabling:\" \\\n \t     \"  No symbol \\\"c\\\" in current context.\"] \\\n \t\"re-define a condition\"\n-    check_bp_locations $bpnum2 {N* N* n} \"loc 3 should remain disabled\"\n+    check_bp_locations $bpnum2 {N* N* n} \"c == 30\" \"loc for C should remain disabled\"\n \n-    gdb_test \"enable ${bpnum2}.1\" \\\n-\t\"Breakpoint ${bpnum2}'s condition is invalid at location 1, cannot enable.\" \\\n+    gdb_test \"enable ${bpnum2}.$loc_index(Base)\" \\\n+\t\"Breakpoint ${bpnum2}'s condition is invalid at location $loc_index(Base), cannot enable.\" \\\n \t\"reject enabling a location that is disabled-by-cond\"\n-    check_bp_locations $bpnum2 {N* N* n} \"after enable attempt\"\n+    check_bp_locations $bpnum2 {N* N* n} \"c == 30\" \"after enable attempt\"\n \n     gdb_test \"cond $bpnum2 garbage\" \\\n \t\"No symbol \\\"garbage\\\" in current context.\" \\\n@@ -246,10 +302,10 @@ with_test_prefix \"force\" {\n \t     \"${warning} at location ${bpnum1}.3, disabling:\" \\\n \t     \"  No symbol \\\"foo\\\" in current context.\"] \\\n \t\"force the condition of bp 1\"\n-    check_bp_locations $bpnum1 {N* N* N*} \"after forcing the condition\"\n+    check_bp_locations $bpnum1 {N* N* N*} \"foo\" \"after forcing the condition\"\n \n     # Now with the 'break' command.\n     gdb_breakpoint \"func -force-condition if baz\"\n     set bpnum2 [get_integer_valueof \"\\$bpnum\" 0 \"get bpnum2\"]\n-    check_bp_locations $bpnum2 {N* N* N*} \"set using the break command\"\n+    check_bp_locations $bpnum2 {N* N* N*} \"baz\" \"set using the break command\"\n }"
    }
  ]
}