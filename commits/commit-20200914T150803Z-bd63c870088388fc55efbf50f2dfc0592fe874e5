{
  "sha": "bd63c870088388fc55efbf50f2dfc0592fe874e5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmQ2M2M4NzAwODgzODhmYzU1ZWZiZjUwZjJkZmMwNTkyZmU4NzRlNQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-09-14T15:08:03Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-09-14T15:08:03Z"
    },
    "message": "gdb: remove TYPE_VECTOR\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (TYPE_VECTOR): Remove, replace all\n\tuses with type::is_vector.\n\nChange-Id: I1ac28755af44b1585c190553f9961288c8fb9137",
    "tree": {
      "sha": "fc002e3c53ff9e8ae8a194b83cc9c87c5292d448",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fc002e3c53ff9e8ae8a194b83cc9c87c5292d448"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bd63c870088388fc55efbf50f2dfc0592fe874e5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bd63c870088388fc55efbf50f2dfc0592fe874e5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bd63c870088388fc55efbf50f2dfc0592fe874e5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bd63c870088388fc55efbf50f2dfc0592fe874e5/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2062087b358cc5320d52b32c50866dbd08fb2631",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2062087b358cc5320d52b32c50866dbd08fb2631",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2062087b358cc5320d52b32c50866dbd08fb2631"
    }
  ],
  "stats": {
    "total": 188,
    "additions": 96,
    "deletions": 92
  },
  "files": [
    {
      "sha": "b8f2361b9052dc458e6f70d5ce70153f296f46a3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -1,3 +1,8 @@\n+2020-09-14  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (TYPE_VECTOR): Remove, replace all\n+\tuses with type::is_vector.\n+\n 2020-09-14  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (struct type) <is_vector, set_is_vector>: New methods."
    },
    {
      "sha": "a2547d12dc6b784a1d2db34c05cdf96f83917959",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -1393,7 +1393,7 @@ static ULONGEST\n aarch64_type_align (gdbarch *gdbarch, struct type *t)\n {\n   t = check_typedef (t);\n-  if (t->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (t))\n+  if (t->code () == TYPE_CODE_ARRAY && t->is_vector ())\n     {\n       /* Use the natural alignment for vector types (the same for\n \t scalar type), but the maximum alignment is 128-bit.  */\n@@ -1453,7 +1453,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n \n     case TYPE_CODE_ARRAY:\n       {\n-\tif (TYPE_VECTOR (type))\n+\tif (type->is_vector ())\n \t  {\n \t    if (TYPE_LENGTH (type) != 8 && TYPE_LENGTH (type) != 16)\n \t      return -1;\n@@ -1760,7 +1760,7 @@ pass_in_v_vfp_candidate (struct gdbarch *gdbarch, struct regcache *regcache,\n       }\n \n     case TYPE_CODE_ARRAY:\n-      if (TYPE_VECTOR (arg_type))\n+      if (arg_type->is_vector ())\n \treturn pass_in_v (gdbarch, regcache, info, TYPE_LENGTH (arg_type),\n \t\t\t  value_contents (arg));\n       /* fall through.  */"
    },
    {
      "sha": "5470332e1c10113a36d33a0af86d9bcef3201200",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -3417,7 +3417,7 @@ static ULONGEST\n arm_type_align (gdbarch *gdbarch, struct type *t)\n {\n   t = check_typedef (t);\n-  if (t->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (t))\n+  if (t->code () == TYPE_CODE_ARRAY && t->is_vector ())\n     {\n       /* Use the natural alignment for vector types (the same for\n \t scalar type), but the maximum alignment is 64-bit.  */\n@@ -3562,7 +3562,7 @@ arm_vfp_cprc_sub_candidate (struct type *t,\n \n     case TYPE_CODE_ARRAY:\n       {\n-\tif (TYPE_VECTOR (t))\n+\tif (t->is_vector ())\n \t  {\n \t    /* A 64-bit or 128-bit containerized vector type are VFP\n \t       CPRCs.  */\n@@ -8017,7 +8017,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n       && TYPE_CODE_ARRAY != code && TYPE_CODE_COMPLEX != code)\n     return 0;\n \n-  if (TYPE_CODE_ARRAY == code && TYPE_VECTOR (type))\n+  if (TYPE_CODE_ARRAY == code && type->is_vector ())\n     {\n       /* Vector values should be returned using ARM registers if they\n \t are not over 16 bytes.  */"
    },
    {
      "sha": "b642c881787e9d7da5229ffdaca1545885bcdece",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -133,7 +133,7 @@ c_print_type_1 (struct type *type,\n \t      && (code == TYPE_CODE_PTR || code == TYPE_CODE_FUNC\n \t\t  || code == TYPE_CODE_METHOD\n \t\t  || (code == TYPE_CODE_ARRAY\n-\t\t      && !TYPE_VECTOR (type))\n+\t\t      && !type->is_vector ())\n \t\t  || code == TYPE_CODE_MEMBERPTR\n \t\t  || code == TYPE_CODE_METHODPTR\n \t\t  || TYPE_IS_REFERENCE (type))))\n@@ -772,7 +772,7 @@ c_type_print_varspec_suffix (struct type *type,\n     case TYPE_CODE_ARRAY:\n       {\n \tLONGEST low_bound, high_bound;\n-\tint is_vector = TYPE_VECTOR (type);\n+\tint is_vector = type->is_vector ();\n \n \tif (passed_a_ptr)\n \t  fprintf_filtered (stream, \")\");"
    },
    {
      "sha": "6d9bb37b17ce92678b7eae04a046690a56c0f58a",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -56,7 +56,7 @@ convert_array (compile_c_instance *context, struct type *type)\n     {\n       gcc_type result;\n \n-      if (TYPE_VECTOR (type))\n+      if (type->is_vector ())\n \treturn context->plugin ().error (_(\"variably-sized vector type\"\n \t\t\t\t\t   \" is not supported\"));\n \n@@ -78,7 +78,7 @@ convert_array (compile_c_instance *context, struct type *type)\n \t  count = high_bound + 1;\n \t}\n \n-      if (TYPE_VECTOR (type))\n+      if (type->is_vector ())\n \treturn context->plugin ().build_vector_type (element_type, count);\n       return context->plugin ().build_array_type (element_type, count);\n     }"
    },
    {
      "sha": "bb4b267e9af25eeefd6097fe66ee837318f9e017",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -475,7 +475,7 @@ compile_cplus_convert_array (compile_cplus_instance *instance,\n   if (range->bounds ()->high.kind () == PROP_LOCEXPR\n       || range->bounds ()->high.kind () == PROP_LOCLIST)\n     {\n-      if (TYPE_VECTOR (type))\n+      if (type->is_vector ())\n \t{\n \t  const char *s = _(\"variably-sized vector type is not supported\");\n \n@@ -499,7 +499,7 @@ compile_cplus_convert_array (compile_cplus_instance *instance,\n \t  count = high_bound + 1;\n \t}\n \n-      if (TYPE_VECTOR (type))\n+      if (type->is_vector ())\n \treturn instance->plugin ().build_vector_type (element_type, count);\n \n       return instance->plugin ().build_array_type (element_type, count);"
    },
    {
      "sha": "2d27198162636ebf69ac7b7f94c7c680a9965057",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -622,7 +622,7 @@ ptrmath_type_p (const struct language_defn *lang, struct type *type)\n       return 1;\n \n     case TYPE_CODE_ARRAY:\n-      return TYPE_VECTOR (type) ? 0 : lang->c_style_arrays;\n+      return type->is_vector () ? 0 : lang->c_style_arrays;\n \n     default:\n       return 0;\n@@ -3137,7 +3137,7 @@ evaluate_subexp_with_coercion (struct expression *exp,\n       var = exp->elts[pc + 2].symbol;\n       type = check_typedef (SYMBOL_TYPE (var));\n       if (type->code () == TYPE_CODE_ARRAY\n-\t  && !TYPE_VECTOR (type)\n+\t  && !type->is_vector ()\n \t  && CAST_IS_CONVERSION (exp->language_defn))\n \t{\n \t  (*pos) += 4;"
    },
    {
      "sha": "89f428faf21d26e3e8298532012d4522f58fd6a1",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -3993,7 +3993,7 @@ check_types_equal (struct type *type1, struct type *type2,\n       || type1->has_no_signedness () != type2->has_no_signedness ()\n       || TYPE_ENDIANITY_NOT_DEFAULT (type1) != TYPE_ENDIANITY_NOT_DEFAULT (type2)\n       || type1->has_varargs () != type2->has_varargs ()\n-      || TYPE_VECTOR (type1) != TYPE_VECTOR (type2)\n+      || type1->is_vector () != type2->is_vector ()\n       || TYPE_NOTTEXT (type1) != TYPE_NOTTEXT (type2)\n       || TYPE_INSTANCE_FLAGS (type1) != TYPE_INSTANCE_FLAGS (type2)\n       || type1->num_fields () != type2->num_fields ())\n@@ -5095,7 +5095,7 @@ recursive_dump_type (struct type *type, int spaces)\n   /* This is used for things like AltiVec registers on ppc.  Gcc emits\n      an attribute for the array type, which tells whether or not we\n      have a vector, instead of a regular array.  */\n-  if (TYPE_VECTOR (type))\n+  if (type->is_vector ())\n     {\n       puts_filtered (\" TYPE_VECTOR\");\n     }"
    },
    {
      "sha": "4d567e42ab7d12530c830f934739e048c4ee6b7c",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -216,11 +216,6 @@ DEF_ENUM_FLAGS_TYPE (enum type_instance_flag_value, type_instance_flags);\n \n #define TYPE_ENDIANITY_NOT_DEFAULT(t) (TYPE_MAIN_TYPE (t)->flag_endianity_not_default)\n \n-/* * Identify a vector type.  Gcc is handling this by adding an extra\n-   attribute to the array type.  We slurp that in as a new flag of a\n-   type.  This is used only in dwarf2read.c.  */\n-#define TYPE_VECTOR(t)\t\t((t)->is_vector ())\n-\n /* * The debugging formats (especially STABS) do not contain enough\n    information to represent all Ada types---especially those whose\n    size depends on dynamic quantities.  Therefore, the GNAT Ada\n@@ -1116,6 +1111,10 @@ struct type\n     this->main_type->m_flag_varargs = has_varargs;\n   }\n \n+  /* Identify a vector type.  Gcc is handling this by adding an extra\n+     attribute to the array type.  We slurp that in as a new flag of a\n+     type.  This is used only in dwarf2read.c.  */\n+\n   bool is_vector () const\n   {\n     return this->main_type->m_flag_vector;"
    },
    {
      "sha": "82b28af62b3ead2953c138d8e05b8baa3755aa9d",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -109,7 +109,7 @@ darwin_dwarf_signal_frame_p (struct gdbarch *gdbarch,\n static int\n i386_m128_p (struct type *type)\n {\n-  return (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+  return (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n           && TYPE_LENGTH (type) == 16);\n }\n \n@@ -124,7 +124,7 @@ i386_darwin_arg_type_alignment (struct type *type)\n          aligned to 8-byte boundaries.\n      7.  [...]  The caller aligns 128-bit vectors in the parameter area to\n          16-byte boundaries.  */\n-  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     return TYPE_LENGTH (type);\n   /* 4.  The caller places all the fields of structures (or unions) with no\n          vector elements in the parameter area.  These structures are 4-byte"
    },
    {
      "sha": "64e42dcbfe62b80c2929de1b788317c232c29e8f",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -2636,7 +2636,7 @@ i386_16_byte_align_p (struct type *type)\n {\n   type = check_typedef (type);\n   if ((type->code () == TYPE_CODE_DECFLOAT\n-       || (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)))\n+       || (type->code () == TYPE_CODE_ARRAY && type->is_vector ()))\n       && TYPE_LENGTH (type) == 16)\n     return 1;\n   if (type->code () == TYPE_CODE_ARRAY)"
    },
    {
      "sha": "6abf8336954c115499b9e985d29574a49adba736",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -329,7 +329,7 @@ ia64_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n   int raw_p;\n   if (group == all_reggroup)\n     return 1;\n-  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));\n+  vector_p = register_type (gdbarch, regnum)->is_vector ();\n   float_p = register_type (gdbarch, regnum)->code () == TYPE_CODE_FLT;\n   raw_p = regnum < NUM_IA64_RAW_REGS;\n   if (group == float_reggroup)"
    },
    {
      "sha": "9539d38142886873dcf0d4ff75f600001db3d1a6",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -220,7 +220,7 @@ value_arg_coerce (struct gdbarch *gdbarch, struct value *arg,\n          they are vectors, in which case we want to leave them alone,\n          because they are passed by value.  */\n       if (current_language->c_style_arrays)\n-\tif (!TYPE_VECTOR (type))\n+\tif (!type->is_vector ())\n \t  type = lookup_pointer_type (TYPE_TARGET_TYPE (type));\n       break;\n     case TYPE_CODE_UNDEF:"
    },
    {
      "sha": "6f20b7d1eed2d5d9f64638e10af5dc957ee1e4e4",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -2134,7 +2134,7 @@ default_print_one_register_info (struct ui_file *file,\n       common_val_print (val, &format_stream, 0, &opts, current_language);\n       /* If not a vector register, print it also according to its\n \t natural format.  */\n-      if (print_raw_format && TYPE_VECTOR (regtype) == 0)\n+      if (print_raw_format && regtype->is_vector () == 0)\n \t{\n \t  pad_to_column (format_stream, value_column_2);\n \t  get_user_print_options (&opts);"
    },
    {
      "sha": "9e2a9cba529c9d8ec18fed0bb67f363af94fb701",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -686,7 +686,7 @@ mips_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n   int pseudo = regnum / gdbarch_num_regs (gdbarch);\n   if (reggroup == all_reggroup)\n     return pseudo;\n-  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));\n+  vector_p = register_type (gdbarch, regnum)->is_vector ();\n   float_p = register_type (gdbarch, regnum)->code () == TYPE_CODE_FLT;\n   /* FIXME: cagney/2003-04-13: Can't yet use gdbarch_num_regs\n      (gdbarch), as not all architectures are multi-arch.  */"
    },
    {
      "sha": "2d5ae17c36d4551eaaed1926fb31823bf8ee98e8",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -96,7 +96,7 @@ lookup_opencl_vector_type (struct gdbarch *gdbarch, enum type_code code,\n     {\n       LONGEST lowb, highb;\n \n-      if (types[i]->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (types[i])\n+      if (types[i]->code () == TYPE_CODE_ARRAY && types[i]->is_vector ()\n \t  && get_array_bounds (types[i], &lowb, &highb)\n \t  && TYPE_TARGET_TYPE (types[i])->code () == code\n \t  && TYPE_TARGET_TYPE (types[i])->is_unsigned () == flag_unsigned\n@@ -497,7 +497,7 @@ opencl_logical_not (struct expression *exp, struct value *arg)\n   struct type *rettype;\n   struct value *ret;\n \n-  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n       LONGEST lowb, highb;\n@@ -586,8 +586,8 @@ vector_relop (struct expression *exp, struct value *val1, struct value *val2,\n   type1 = check_typedef (value_type (val1));\n   type2 = check_typedef (value_type (val2));\n \n-  t1_is_vec = (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1));\n-  t2_is_vec = (type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2));\n+  t1_is_vec = (type1->code () == TYPE_CODE_ARRAY && type1->is_vector ());\n+  t2_is_vec = (type2->code () == TYPE_CODE_ARRAY && type2->is_vector ());\n \n   if (!t1_is_vec || !t2_is_vec)\n     error (_(\"Vector operations are not supported on scalar types\"));\n@@ -658,7 +658,7 @@ opencl_value_cast (struct type *type, struct value *arg)\n \t\t|| code2 == TYPE_CODE_DECFLOAT || code2 == TYPE_CODE_ENUM\n \t\t|| code2 == TYPE_CODE_RANGE);\n \n-      if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (to_type) && scalar)\n+      if (code1 == TYPE_CODE_ARRAY && to_type->is_vector () && scalar)\n \t{\n \t  struct type *eltype;\n \n@@ -688,9 +688,9 @@ opencl_relop (struct expression *exp, struct value *arg1, struct value *arg2,\n   struct type *type1 = check_typedef (value_type (arg1));\n   struct type *type2 = check_typedef (value_type (arg2));\n   int t1_is_vec = (type1->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type1));\n+\t\t   && type1->is_vector ());\n   int t2_is_vec = (type2->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type2));\n+\t\t   && type2->is_vector ());\n \n   if (!t1_is_vec && !t2_is_vec)\n     {\n@@ -831,8 +831,8 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t  type1 = check_typedef (value_type (arg1));\n \t  type2 = check_typedef (value_type (arg2));\n \n-\t  if ((type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n-\t      || (type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)))\n+\t  if ((type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n+\t      || (type2->code () == TYPE_CODE_ARRAY && type2->is_vector ()))\n \t    {\n \t      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \n@@ -867,7 +867,7 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n       (*pos)++;\n       arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type1 = check_typedef (value_type (arg1));\n-      if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+      if (type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n \t{\n \t  struct value *arg3, *tmp, *ret;\n \t  struct type *eltype2, *type3, *eltype3;\n@@ -879,9 +879,9 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t  type2 = check_typedef (value_type (arg2));\n \t  type3 = check_typedef (value_type (arg3));\n \t  t2_is_vec\n-\t    = type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2);\n+\t    = type2->code () == TYPE_CODE_ARRAY && type2->is_vector ();\n \t  t3_is_vec\n-\t    = type3->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type3);\n+\t    = type3->code () == TYPE_CODE_ARRAY && type3->is_vector ();\n \n \t  /* Widen the scalar operand to a vector if necessary.  */\n \t  if (t2_is_vec || !t3_is_vec)\n@@ -970,7 +970,7 @@ Cannot perform conditional operation on vectors with different sizes\"));\n \t    return value_from_longest (builtin_type (exp->gdbarch)->\n \t\t\t\t       builtin_int, 1);\n \t  }\n-\telse if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+\telse if (type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n \t  {\n \t    return opencl_component_ref (exp, arg1, &exp->elts[pc + 2].string,\n \t\t\t\t\t noside);\n@@ -1062,7 +1062,7 @@ class opencl_language : public language_defn\n     if (show > 0)\n       {\n \ttype = check_typedef (type);\n-\tif (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+\tif (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n \t    && type->name () != NULL)\n \t  show = 0;\n       }"
    },
    {
      "sha": "91b206681250bc1d7ee5552a386c508f6c01205a",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -253,7 +253,7 @@ ppc_linux_return_value (struct gdbarch *gdbarch, struct value *function,\n   if ((valtype->code () == TYPE_CODE_STRUCT\n        || valtype->code () == TYPE_CODE_UNION)\n       && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)\n-\t   && TYPE_VECTOR (valtype)))\n+\t   && valtype->is_vector ()))\n     return RETURN_VALUE_STRUCT_CONVENTION;\n   else\n     return ppc_sysv_abi_return_value (gdbarch, function, valtype, regcache,"
    },
    {
      "sha": "fa90243d9648bfcb9bf8515f4298ce463b882998",
      "filename": "gdb/ppc-nbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ppc-nbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ppc-nbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-nbsd-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -78,7 +78,7 @@ ppcnbsd_return_value (struct gdbarch *gdbarch, struct value *function,\n   if ((valtype->code () == TYPE_CODE_STRUCT\n        || valtype->code () == TYPE_CODE_UNION)\n       && !((TYPE_LENGTH (valtype) == 16 || TYPE_LENGTH (valtype) == 8)\n-\t    && TYPE_VECTOR (valtype))\n+\t    && valtype->is_vector ())\n       && !(TYPE_LENGTH (valtype) == 1\n \t   || TYPE_LENGTH (valtype) == 2\n \t   || TYPE_LENGTH (valtype) == 4"
    },
    {
      "sha": "08c65cff2ffd7b4ba697b24e9196b48f658d14e2",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -335,7 +335,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t    }\n \t  else if (len < 16\n \t\t   && type->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type)\n+\t\t   && type->is_vector ()\n \t\t   && opencl_abi)\n \t    {\n \t      /* OpenCL vectors shorter than 16 bytes are passed as if\n@@ -422,7 +422,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t    }\n \t  else if (len >= 16\n \t\t   && type->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type)\n+\t\t   && type->is_vector ()\n \t\t   && opencl_abi)\n \t    {\n \t      /* OpenCL vectors 16 bytes or longer are passed as if\n@@ -451,7 +451,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t    }\n \t  else if (len == 16\n \t\t   && type->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type)\n+\t\t   && type->is_vector ()\n \t\t   && tdep->vector_abi == POWERPC_VEC_ALTIVEC)\n \t    {\n \t      /* Vector parameter passed in an Altivec register, or\n@@ -472,7 +472,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t    }\n \t  else if (len == 8\n \t\t   && type->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type)\n+\t\t   && type->is_vector ()\n \t\t   && tdep->vector_abi == POWERPC_VEC_SPE)\n \t    {\n \t      /* Vector parameter passed in an e500 register, or when\n@@ -509,7 +509,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t  /* Structs and large values are put in an\n \t\t     aligned stack slot ...  */\n \t\t  if (type->code () == TYPE_CODE_ARRAY\n-\t\t      && TYPE_VECTOR (type)\n+\t\t      && type->is_vector ()\n \t\t      && len >= 16)\n \t\t    structoffset = align_up (structoffset, 16);\n \t\t  else\n@@ -804,7 +804,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n   /* OpenCL vectors < 16 bytes are returned as distinct\n      scalars in f1..f2 or r3..r10.  */\n   if (type->code () == TYPE_CODE_ARRAY\n-      && TYPE_VECTOR (type)\n+      && type->is_vector ()\n       && TYPE_LENGTH (type) < 16\n       && opencl_abi)\n     {\n@@ -858,7 +858,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n     }\n   /* OpenCL vectors >= 16 bytes are returned in v2..v9.  */\n   if (type->code () == TYPE_CODE_ARRAY\n-      && TYPE_VECTOR (type)\n+      && type->is_vector ()\n       && TYPE_LENGTH (type) >= 16\n       && opencl_abi)\n     {\n@@ -880,7 +880,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n     }\n   if (TYPE_LENGTH (type) == 16\n       && type->code () == TYPE_CODE_ARRAY\n-      && TYPE_VECTOR (type)\n+      && type->is_vector ()\n       && tdep->vector_abi == POWERPC_VEC_ALTIVEC)\n     {\n       if (readbuf)\n@@ -897,7 +897,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n     }\n   if (TYPE_LENGTH (type) == 16\n       && type->code () == TYPE_CODE_ARRAY\n-      && TYPE_VECTOR (type)\n+      && type->is_vector ()\n       && tdep->vector_abi == POWERPC_VEC_GENERIC)\n     {\n       /* GCC -maltivec -mabi=no-altivec returns vectors in r3/r4/r5/r6.\n@@ -921,7 +921,7 @@ do_ppc_sysv_return_value (struct gdbarch *gdbarch, struct type *func_type,\n     }\n   if (TYPE_LENGTH (type) == 8\n       && type->code () == TYPE_CODE_ARRAY\n-      && TYPE_VECTOR (type)\n+      && type->is_vector ()\n       && tdep->vector_abi == POWERPC_VEC_SPE)\n     {\n       /* The e500 ABI places return values for the 64-bit DSP types\n@@ -1101,7 +1101,7 @@ ppc64_aggregate_candidate (struct type *type,\n       break;\n \n     case TYPE_CODE_ARRAY:\n-      if (TYPE_VECTOR (type))\n+      if (type->is_vector ())\n \t{\n \t  if (!*field_type)\n \t    *field_type = type;\n@@ -1186,7 +1186,7 @@ ppc64_elfv2_abi_homogeneous_aggregate (struct type *type,\n      complex types can be elements of homogeneous aggregates.  */\n   if (type->code () == TYPE_CODE_STRUCT\n       || type->code () == TYPE_CODE_UNION\n-      || (type->code () == TYPE_CODE_ARRAY && !TYPE_VECTOR (type)))\n+      || (type->code () == TYPE_CODE_ARRAY && !type->is_vector ()))\n     {\n       struct type *field_type = NULL;\n       LONGEST field_count = ppc64_aggregate_candidate (type, &field_type);\n@@ -1428,15 +1428,15 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n       ppc64_sysv_abi_push_val (gdbarch, val, TYPE_LENGTH (type), 0, argpos);\n       ppc64_sysv_abi_push_freg (gdbarch, type, val, argpos);\n     }\n-  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+  else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n \t   && tdep->vector_abi == POWERPC_VEC_ALTIVEC\n \t   && TYPE_LENGTH (type) == 16)\n     {\n       /* AltiVec vectors are passed aligned, and in vector registers.  */\n       ppc64_sysv_abi_push_val (gdbarch, val, TYPE_LENGTH (type), 16, argpos);\n       ppc64_sysv_abi_push_vreg (gdbarch, val, argpos);\n     }\n-  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+  else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n \t   && TYPE_LENGTH (type) >= 16)\n     {\n       /* Non-Altivec vectors are passed by reference.  */\n@@ -1520,7 +1520,7 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n \t\t    || eltype->code () == TYPE_CODE_DECFLOAT)\n \t\t  ppc64_sysv_abi_push_freg (gdbarch, eltype, elval, argpos);\n \t\telse if (eltype->code () == TYPE_CODE_ARRAY\n-\t\t\t && TYPE_VECTOR (eltype)\n+\t\t\t && eltype->is_vector ()\n \t\t\t && tdep->vector_abi == POWERPC_VEC_ALTIVEC\n \t\t\t && TYPE_LENGTH (eltype) == 16)\n \t\t  ppc64_sysv_abi_push_vreg (gdbarch, elval, argpos);\n@@ -1644,7 +1644,7 @@ ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,\n \t      ppc64_sysv_abi_push_param (gdbarch, eltype,\n \t\t\t\t \t val + TYPE_LENGTH (eltype), &argpos);\n \t    }\n-\t  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n+\t  else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n \t\t   && opencl_abi)\n \t    {\n \t      /* OpenCL vectors shorter than 16 bytes are passed as if\n@@ -1856,7 +1856,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n \n   /* AltiVec vectors are returned in VRs starting at v2.  */\n   if (TYPE_LENGTH (valtype) == 16\n-      && valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+      && valtype->code () == TYPE_CODE_ARRAY && valtype->is_vector ()\n       && tdep->vector_abi == POWERPC_VEC_ALTIVEC)\n     {\n       int regnum = tdep->ppc_vr0_regnum + 2 + index;\n@@ -1870,7 +1870,7 @@ ppc64_sysv_abi_return_value_base (struct gdbarch *gdbarch, struct type *valtype,\n \n   /* Short vectors are returned in GPRs starting at r3.  */\n   if (TYPE_LENGTH (valtype) <= 8\n-      && valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype))\n+      && valtype->code () == TYPE_CODE_ARRAY && valtype->is_vector ())\n     {\n       int regnum = tdep->ppc_gp0_regnum + 3 + index;\n       int offset = 0;\n@@ -1938,7 +1938,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n   /* OpenCL vectors shorter than 16 bytes are returned as if\n      a series of independent scalars; OpenCL vectors 16 bytes\n      or longer are returned as if a series of AltiVec vectors.  */\n-  if (valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+  if (valtype->code () == TYPE_CODE_ARRAY && valtype->is_vector ()\n       && opencl_abi)\n     {\n       if (TYPE_LENGTH (valtype) < 16)\n@@ -1975,7 +1975,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* Small character arrays are returned, right justified, in r3.  */\n   if (valtype->code () == TYPE_CODE_ARRAY\n-      && !TYPE_VECTOR (valtype)\n+      && !valtype->is_vector ()\n       && TYPE_LENGTH (valtype) <= 8\n       && TYPE_TARGET_TYPE (valtype)->code () == TYPE_CODE_INT\n       && TYPE_LENGTH (TYPE_TARGET_TYPE (valtype)) == 1)\n@@ -1999,7 +1999,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n       && (eltype->code () == TYPE_CODE_FLT\n \t  || eltype->code () == TYPE_CODE_DECFLOAT\n \t  || (eltype->code () == TYPE_CODE_ARRAY\n-\t      && TYPE_VECTOR (eltype)\n+\t      && eltype->is_vector ()\n \t      && tdep->vector_abi == POWERPC_VEC_ALTIVEC\n \t      && TYPE_LENGTH (eltype) == 16)))\n     {\n@@ -2025,7 +2025,7 @@ ppc64_sysv_abi_return_value (struct gdbarch *gdbarch, struct value *function,\n       && (valtype->code () == TYPE_CODE_STRUCT\n \t  || valtype->code () == TYPE_CODE_UNION\n \t  || (valtype->code () == TYPE_CODE_ARRAY\n-\t      && !TYPE_VECTOR (valtype))))\n+\t      && !valtype->is_vector ())))\n     {\n       int n_regs = ((TYPE_LENGTH (valtype) + tdep->wordsize - 1)\n \t\t    / tdep->wordsize);"
    },
    {
      "sha": "c092c9c30b90f50ad297442ca5baf411338b13dd",
      "filename": "gdb/reggroups.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/reggroups.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/reggroups.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/reggroups.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -201,7 +201,7 @@ default_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n     return 0;\n   if (group == all_reggroup)\n     return 1;\n-  vector_p = TYPE_VECTOR (register_type (gdbarch, regnum));\n+  vector_p = register_type (gdbarch, regnum)->is_vector ();\n   float_p = (register_type (gdbarch, regnum)->code () == TYPE_CODE_FLT\n \t     || (register_type (gdbarch, regnum)->code ()\n \t\t == TYPE_CODE_DECFLOAT));"
    },
    {
      "sha": "a7c25642d0352d89df6d2f7ac576a81afed0bba7",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -935,7 +935,7 @@ riscv_print_one_register_info (struct gdbarch *gdbarch,\n \t    {\n \t      /* If not a vector register, print it also according to its\n \t\t natural format.  */\n-\t      if (TYPE_VECTOR (regtype) == 0)\n+\t      if (regtype->is_vector () == 0)\n \t\t{\n \t\t  get_user_print_options (&opts);\n \t\t  opts.deref_ref = 1;\n@@ -1772,7 +1772,7 @@ static ULONGEST\n riscv_type_align (gdbarch *gdbarch, type *type)\n {\n   type = check_typedef (type);\n-  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     return std::min (TYPE_LENGTH (type), (ULONGEST) BIGGEST_ALIGNMENT);\n \n   /* Anything else will be aligned by the generic code.  */"
    },
    {
      "sha": "730dd98f67cc128a8a4bdeb6dd12672f47afcac0",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -527,7 +527,7 @@ rs6000_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* AltiVec extension: Functions that declare a vector data type as a\n      return value place that return value in VR2.  */\n-  if (valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+  if (valtype->code () == TYPE_CODE_ARRAY && valtype->is_vector ()\n       && TYPE_LENGTH (valtype) == 16)\n     {\n       if (readbuf)"
    },
    {
      "sha": "54a1bdcb9526ec0e8bed0dc362379beda4f4a87e",
      "filename": "gdb/rs6000-lynx178-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/rs6000-lynx178-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/rs6000-lynx178-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-lynx178-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -274,7 +274,7 @@ rs6000_lynx178_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* AltiVec extension: Functions that declare a vector data type as a\n      return value place that return value in VR2.  */\n-  if (valtype->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (valtype)\n+  if (valtype->code () == TYPE_CODE_ARRAY && valtype->is_vector ()\n       && TYPE_LENGTH (valtype) == 16)\n     {\n       if (readbuf)"
    },
    {
      "sha": "fc374bcd560c61c38b21454772aebdf637af5526",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -75,7 +75,7 @@ s390_type_align (gdbarch *gdbarch, struct type *t)\n \t  return 8;\n \n \tcase TYPE_CODE_ARRAY:\n-\t  if (TYPE_VECTOR (t))\n+\t  if (t->is_vector ())\n \t    return 8;\n \t  break;\n \t}\n@@ -1697,7 +1697,7 @@ s390_function_arg_vector (struct type *type)\n   /* Structs containing just a vector are passed like a vector.  */\n   type = s390_effective_inner_type (type, TYPE_LENGTH (type));\n \n-  return type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type);\n+  return type->code () == TYPE_CODE_ARRAY && type->is_vector ();\n }\n \n /* Determine whether N is a power of two.  */\n@@ -2093,7 +2093,7 @@ s390_return_value (struct gdbarch *gdbarch, struct value *function,\n       break;\n     case TYPE_CODE_ARRAY:\n       rvc = (gdbarch_tdep (gdbarch)->vector_abi == S390_VECTOR_ABI_128\n-\t     && TYPE_LENGTH (type) <= 16 && TYPE_VECTOR (type))\n+\t     && TYPE_LENGTH (type) <= 16 && type->is_vector ())\n \t? RETURN_VALUE_REGISTER_CONVENTION\n \t: RETURN_VALUE_STRUCT_CONVENTION;\n       break;"
    },
    {
      "sha": "681b8009008334ca95098fd1be11d51f845fa1a3",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -303,7 +303,7 @@ sparc_structure_or_union_p (const struct type *type)\n static bool\n sparc_structure_return_p (const struct type *type)\n {\n-  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n       /* Float vectors are always returned by memory.  */\n       if (sparc_floating_p (check_typedef (TYPE_TARGET_TYPE (type))))\n@@ -331,7 +331,7 @@ sparc_structure_return_p (const struct type *type)\n static bool\n sparc_arg_by_memory_p (const struct type *type)\n {\n-  if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n       /* Float vectors are always passed by memory.  */\n       if (sparc_floating_p (check_typedef (TYPE_TARGET_TYPE (type))))"
    },
    {
      "sha": "eadad86cce1287bb1d17bd35680e1866d789ff41",
      "filename": "gdb/target-descriptions.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/target-descriptions.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/target-descriptions.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-descriptions.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -263,7 +263,7 @@ make_gdb_type (struct gdbarch *gdbarch, struct tdesc_type *ttype)\n \t  /* If any of the children of a union are vectors, flag the\n \t     union as a vector also.  This allows e.g. a union of two\n \t     vector types to show up automatically in \"info vector\".  */\n-\t  if (TYPE_VECTOR (field_gdb_type))\n+\t  if (field_gdb_type->is_vector ())\n \t    m_type->set_is_vector (true);\n \t}\n     }"
    },
    {
      "sha": "c418fc6f55a8007ca8999e3cac491788f38e4a1c",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -1440,7 +1440,7 @@ value_vector_widen (struct value *scalar_value, struct type *vector_type)\n   vector_type = check_typedef (vector_type);\n \n   gdb_assert (vector_type->code () == TYPE_CODE_ARRAY\n-\t      && TYPE_VECTOR (vector_type));\n+\t      && vector_type->is_vector ());\n \n   if (!get_array_bounds (vector_type, &low_bound, &high_bound))\n     error (_(\"Could not determine the vector bounds\"));\n@@ -1480,9 +1480,9 @@ vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)\n   type2 = check_typedef (value_type (val2));\n \n   t1_is_vec = (type1->code () == TYPE_CODE_ARRAY\n-\t       && TYPE_VECTOR (type1)) ? 1 : 0;\n+\t       && type1->is_vector ()) ? 1 : 0;\n   t2_is_vec = (type2->code () == TYPE_CODE_ARRAY\n-\t       && TYPE_VECTOR (type2)) ? 1 : 0;\n+\t       && type2->is_vector ()) ? 1 : 0;\n \n   if (!t1_is_vec || !t2_is_vec)\n     error (_(\"Vector operations are only supported among vectors\"));\n@@ -1525,9 +1525,9 @@ value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n   struct type *type1 = check_typedef (value_type (arg1));\n   struct type *type2 = check_typedef (value_type (arg2));\n   int t1_is_vec = (type1->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type1));\n+\t\t   && type1->is_vector ());\n   int t2_is_vec = (type2->code () == TYPE_CODE_ARRAY\n-\t\t   && TYPE_VECTOR (type2));\n+\t\t   && type2->is_vector ());\n \n   if (!t1_is_vec && !t2_is_vec)\n     val = scalar_binop (arg1, arg2, op);\n@@ -1767,7 +1767,7 @@ value_pos (struct value *arg1)\n   type = check_typedef (value_type (arg1));\n \n   if (is_integral_type (type) || is_floating_value (arg1)\n-      || (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+      || (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n       || type->code () == TYPE_CODE_COMPLEX)\n     return value_from_contents (type, value_contents (arg1));\n   else\n@@ -1784,7 +1784,7 @@ value_neg (struct value *arg1)\n \n   if (is_integral_type (type) || is_floating_type (type))\n     return value_binop (value_from_longest (type, 0), arg1, BINOP_SUB);\n-  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n       struct value *tmp, *val = allocate_value (type);\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n@@ -1826,7 +1826,7 @@ value_complement (struct value *arg1)\n \n   if (is_integral_type (type))\n     val = value_from_longest (type, ~value_as_long (arg1));\n-  else if (type->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type))\n+  else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n       struct value *tmp;\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));"
    },
    {
      "sha": "da2881a3469234b505857bc7c349ba02a318fbb0",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -416,7 +416,7 @@ value_cast (struct type *type, struct value *arg2)\n \n   if (current_language->c_style_arrays\n       && type2->code () == TYPE_CODE_ARRAY\n-      && !TYPE_VECTOR (type2))\n+      && !type2->is_vector ())\n     arg2 = value_coerce_array (arg2);\n \n   if (type2->code () == TYPE_CODE_FUNC)\n@@ -529,11 +529,11 @@ value_cast (struct type *type, struct value *arg2)\n \t minus one, instead of biasing the normal case.  */\n       return value_from_longest (to_type, -1);\n     }\n-  else if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (type)\n-\t   && code2 == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)\n+  else if (code1 == TYPE_CODE_ARRAY && type->is_vector ()\n+\t   && code2 == TYPE_CODE_ARRAY && type2->is_vector ()\n \t   && TYPE_LENGTH (type) != TYPE_LENGTH (type2))\n     error (_(\"Cannot convert between vector values of different sizes\"));\n-  else if (code1 == TYPE_CODE_ARRAY && TYPE_VECTOR (type) && scalar\n+  else if (code1 == TYPE_CODE_ARRAY && type->is_vector () && scalar\n \t   && TYPE_LENGTH (type) != TYPE_LENGTH (type2))\n     error (_(\"can only cast scalar to vector of same size\"));\n   else if (code1 == TYPE_CODE_VOID)\n@@ -854,7 +854,7 @@ value_one (struct type *type)\n     {\n       val = value_from_longest (type, (LONGEST) 1);\n     }\n-  else if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n+  else if (type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n     {\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type1));\n       int i;\n@@ -1361,7 +1361,7 @@ value_must_coerce_to_target (struct value *val)\n   switch (valtype->code ())\n     {\n     case TYPE_CODE_ARRAY:\n-      return TYPE_VECTOR (valtype) ? 0 : 1;\n+      return valtype->is_vector () ? 0 : 1;\n     case TYPE_CODE_STRING:\n       return true;\n     default:"
    },
    {
      "sha": "8f4030e90b203ec78a52c365415173c427b9fc50",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bd63c870088388fc55efbf50f2dfc0592fe874e5/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=bd63c870088388fc55efbf50f2dfc0592fe874e5",
      "patch": "@@ -3687,7 +3687,7 @@ coerce_array (struct value *arg)\n   switch (type->code ())\n     {\n     case TYPE_CODE_ARRAY:\n-      if (!TYPE_VECTOR (type) && current_language->c_style_arrays)\n+      if (!type->is_vector () && current_language->c_style_arrays)\n \targ = value_coerce_array (arg);\n       break;\n     case TYPE_CODE_FUNC:"
    }
  ]
}