{
  "sha": "6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmY1MmZkZjQwNDY1ZWU4ZjU0MjFjNjZjZWIyMWYzNzg1NmJmNmU1ZQ==",
  "commit": {
    "author": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@sergiodj.net",
      "date": "2021-01-03T07:42:52Z"
    },
    "committer": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@sergiodj.net",
      "date": "2021-01-20T18:54:30Z"
    },
    "message": "Fix a few stap parser issues and add a new test for probe expressions\n\nThe creation of this patch was motivated by Tom's \"Change handling of\n'!' operator in stap probes\" patch.\n\nWhile reviewing his patch, I stumbled upon a few issues with the stap\nexpression parser.  They are:\n\n- As it turns out, even with Tom's patch applied the parser doesn't\n  properly handle the '!' operator.  The underlying issue was the fact\n  that stap_parse_argument_conditionally also needed to be patched in\n  order to recognize '!' as an operator that is part of a single\n  operand, and parse it accordingly.\n\n- While writing the testcase I'm proposing on this patch, I found that\n  parenthesized sub-expressions were not being parsed correctly when\n  there was another term after them.  For example:\n\n    1 - (2 + 3) + 4\n\n  In this case, the parser was considering \"1\" to be the left-side of\n  the expression, and \"(2 + 3) + 4\" to be the right-side.  The patch\n  fixes the parser by making it identify whether a parenthesized\n  sub-expression has just been parsed, and act accordingly.\n\nI've tested this on my Debian testing amd64, and everything seems OK.\n\ngdb/ChangeLog:\n2021-01-20  Sergio Durigan Junior  <sergiodj@sergiodj.net>\n\t    Tom Tromey <tom@tromey.com>\n\n\t* stap-probe.c (stap_parse_single_operand): Handle '!'\n\toperator.\n\t(stap_parse_argument_conditionally): Likewise.\n\tSkip spaces after processing open-parenthesis sub-expression.\n\t(stap_parse_argument_1): Skip spaces after call to\n\tstap_parse_argument_conditionally.\n\tHandle case when right-side expression is a parenthesized\n\tsub-expression.\n\tSkip spaces after call to stap_parse_argument_1.\n\ngdb/testsuite/ChangeLog:\n2021-01-20  Sergio Durigan Junior  <sergiodj@sergiodj.net>\n\n\t* gdb.arch/amd64-stap-expressions.S: New file.\n\t* gdb.arch/amd64-stap-expressions.exp: New file.",
    "tree": {
      "sha": "8c91b9f86d579eed54da4d5c21174f90ed34acf0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8c91b9f86d579eed54da4d5c21174f90ed34acf0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "037e8112b9794a633248e5aa5943f3be273e0a20",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/037e8112b9794a633248e5aa5943f3be273e0a20",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/037e8112b9794a633248e5aa5943f3be273e0a20"
    }
  ],
  "stats": {
    "total": 160,
    "additions": 155,
    "deletions": 5
  },
  "files": [
    {
      "sha": "b63d7a6d6edbca4f9100d3946b885ea9356488f3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
      "patch": "@@ -1,3 +1,16 @@\n+2021-01-20  Sergio Durigan Junior  <sergiodj@sergiodj.net>\n+\t    Tom Tromey <tom@tromey.com>\n+\n+\t* stap-probe.c (stap_parse_single_operand): Handle '!'\n+\toperator.\n+\t(stap_parse_argument_conditionally): Likewise.\n+\tSkip spaces after processing open-parenthesis sub-expression.\n+\t(stap_parse_argument_1): Skip spaces after call to\n+\tstap_parse_argument_conditionally.\n+\tHandle case when right-side expression is a parenthesized\n+\tsub-expression.\n+\tSkip spaces after call to stap_parse_argument_1.\n+\n 2021-01-19  Lancelot SIX  <lsix@lancelotsix.com>\n \n \t* top.h (switch_thru_all_uis): Use DISABLE_COPY_AND_ASSIGN."
    },
    {
      "sha": "224dd5714fac05f5077661ae567c18ecb2aca647",
      "filename": "gdb/stap-probe.c",
      "status": "modified",
      "additions": 26,
      "deletions": 5,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/stap-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/stap-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stap-probe.c?ref=6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
      "patch": "@@ -870,7 +870,7 @@ stap_parse_single_operand (struct stap_parse_info *p)\n       return;\n     }\n \n-  if (*p->arg == '-' || *p->arg == '~' || *p->arg == '+')\n+  if (*p->arg == '-' || *p->arg == '~' || *p->arg == '+' || *p->arg == '!')\n     {\n       char c = *p->arg;\n       /* We use this variable to do a lookahead.  */\n@@ -924,6 +924,8 @@ stap_parse_single_operand (struct stap_parse_info *p)\n \t    write_exp_elt_opcode (&p->pstate, UNOP_NEG);\n \t  else if (c == '~')\n \t    write_exp_elt_opcode (&p->pstate, UNOP_COMPLEMENT);\n+\t  else if (c == '!')\n+\t    write_exp_elt_opcode (&p->pstate, UNOP_LOGICAL_NOT);\n \t}\n     }\n   else if (isdigit (*p->arg))\n@@ -1012,7 +1014,7 @@ stap_parse_argument_conditionally (struct stap_parse_info *p)\n {\n   gdb_assert (gdbarch_stap_is_single_operand_p (p->gdbarch));\n \n-  if (*p->arg == '-' || *p->arg == '~' || *p->arg == '+' /* Unary.  */\n+  if (*p->arg == '-' || *p->arg == '~' || *p->arg == '+' || *p->arg == '!'\n       || isdigit (*p->arg)\n       || gdbarch_stap_is_single_operand (p->gdbarch, p->arg))\n     stap_parse_single_operand (p);\n@@ -1027,11 +1029,12 @@ stap_parse_argument_conditionally (struct stap_parse_info *p)\n \n       stap_parse_argument_1 (p, 0, STAP_OPERAND_PREC_NONE);\n \n-      --p->inside_paren_p;\n+      p->arg = skip_spaces (p->arg);\n       if (*p->arg != ')')\n-\terror (_(\"Missign close-paren on expression `%s'.\"),\n+\terror (_(\"Missign close-parenthesis on expression `%s'.\"),\n \t       p->saved_arg);\n \n+      --p->inside_paren_p;\n       ++p->arg;\n       if (p->inside_paren_p)\n \tp->arg = skip_spaces (p->arg);\n@@ -1067,6 +1070,9 @@ stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n       stap_parse_argument_conditionally (p);\n     }\n \n+  if (p->inside_paren_p)\n+    p->arg = skip_spaces (p->arg);\n+\n   /* Start to parse the right-side, and to \"join\" left and right sides\n      depending on the operation specified.\n \n@@ -1104,8 +1110,21 @@ stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n       if (p->inside_paren_p)\n \tp->arg = skip_spaces (p->arg);\n \n-      /* Parse the right-side of the expression.  */\n+      /* Parse the right-side of the expression.\n+\n+\t We save whether the right-side is a parenthesized\n+\t subexpression because, if it is, we will have to finish\n+\t processing this part of the expression before continuing.  */\n+      bool paren_subexp = *p->arg == '(';\n+\n       stap_parse_argument_conditionally (p);\n+      if (p->inside_paren_p)\n+\tp->arg = skip_spaces (p->arg);\n+      if (paren_subexp)\n+\t{\n+\t  write_exp_elt_opcode (&p->pstate, opcode);\n+\t  continue;\n+\t}\n \n       /* While we still have operators, try to parse another\n \t right-side, but using the current right-side as a left-side.  */\n@@ -1130,6 +1149,8 @@ stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n \t  /* Parse the right-side of the expression, but since we already\n \t     have a left-side at this point, set `has_lhs' to 1.  */\n \t  stap_parse_argument_1 (p, 1, lookahead_prec);\n+\t  if (p->inside_paren_p)\n+\t    p->arg = skip_spaces (p->arg);\n \t}\n \n       write_exp_elt_opcode (&p->pstate, opcode);"
    },
    {
      "sha": "a0211565d2e91c387bac1ff05a1f40a222d762ba",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
      "patch": "@@ -1,3 +1,8 @@\n+2021-01-20  Sergio Durigan Junior  <sergiodj@sergiodj.net>\n+\n+\t* gdb.arch/amd64-stap-expressions.S: New file.\n+\t* gdb.arch/amd64-stap-expressions.exp: New file.\n+\n 2021-01-19  Tom de Vries  <tdevries@suse.de>\n \n \t* gdb.base/step-over-syscall.exp: Detect and handle sysenter/int"
    },
    {
      "sha": "76a47aa9b5befe8cae4701afad52694736b72bf3",
      "filename": "gdb/testsuite/gdb.arch/amd64-stap-expressions.S",
      "status": "added",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/testsuite/gdb.arch/amd64-stap-expressions.S",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/testsuite/gdb.arch/amd64-stap-expressions.S",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/amd64-stap-expressions.S?ref=6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
      "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <sys/sdt.h>\n+\n+\t.file\t\"amd64-stap-expressions.S\"\n+\t.text\n+\t.globl\tmain\n+main:\n+\t/* We use a nop here because we don't want the first probe to\n+\t   be placed at the same location as the main label.  */\n+\tnop\n+\n+\t/* Single operands.  */\n+\tSTAP_PROBE1(probe, log_neg, 8@!($0+$1))\n+\tSTAP_PROBE1(probe, minus, -8@-($3+$4))\n+\tSTAP_PROBE1(probe, bit_neg, -8@~$22)\n+\n+\t/* Arithmetic expressions.  */\n+\tSTAP_PROBE1(probe, plus1, 8@$3+($10-$8)-$1)\n+\tSTAP_PROBE1(probe, plus2, 8@$100-(  ($8+$10) -$50)+$3)\n+\tSTAP_PROBE1(probe, plus3, 8@$100-(($8+$10)-$50)+((($8 - $9) + $40) - $4)+$4)\n+\n+\t/* Bitwise expressions.  */\n+\tSTAP_PROBE1(probe, and, 8@$128&$128)\n+\tSTAP_PROBE1(probe, or, 8@$8|$4)\n+\n+\txor\t%rax,%rax\n+\tret"
    },
    {
      "sha": "5e3cb60a9eebacfb7a946191c0bb9b6850ab96ec",
      "filename": "gdb/testsuite/gdb.arch/amd64-stap-expressions.exp",
      "status": "added",
      "additions": 68,
      "deletions": 0,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/testsuite/gdb.arch/amd64-stap-expressions.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f52fdf40465ee8f5421c66ceb21f37856bf6e5e/gdb/testsuite/gdb.arch/amd64-stap-expressions.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/amd64-stap-expressions.exp?ref=6f52fdf40465ee8f5421c66ceb21f37856bf6e5e",
      "patch": "@@ -0,0 +1,68 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+standard_testfile \".S\"\n+\n+if { ![istarget \"x86_64-*-*\"] || ![is_lp64_target] } {\n+    verbose \"Skipping $testfile.exp\"\n+    return\n+}\n+\n+if { [prepare_for_testing \"failed to prepare\" $testfile $srcfile] } {\n+    return -1\n+}\n+\n+# Helper procedure to go to probe NAME\n+\n+proc goto_probe { name } {\n+    global decimal hex\n+\n+    gdb_test \"break -pstap $name\" \"Breakpoint $decimal at $hex\"\n+    gdb_test \"continue\" \"Breakpoint $decimal, main \\\\(\\\\) at .*\\r\\n.*STAP_PROBE1.*${name},.*\\\\)\"\n+}\n+\n+# Helper procedure to test the probe's argument\n+\n+proc test_probe_value { value } {\n+    gdb_test \"print \\$_probe_argc\" \"= 1\"\n+    gdb_test \"print \\$_probe_arg0\" \"= $value\"\n+}\n+\n+if { ![runto_main] } {\n+    return -1\n+}\n+\n+# Name and expected value for each probe.\n+set probe_names_and_values {\n+    { \"log_neg\" \"0\" }\n+    { \"minus\" \"-7\" }\n+    { \"bit_neg\" \"-23\" }\n+\n+    { \"plus1\" \"4\" }\n+    { \"plus2\" \"135\" }\n+    { \"plus3\" \"171\" }\n+\n+    { \"and\" \"128\" }\n+    { \"or\" \"12\" }\n+}\n+\n+foreach probe_info $probe_names_and_values {\n+    set name [lindex $probe_info 0]\n+    set value [lindex $probe_info 1]\n+    with_test_prefix $name {\n+\tgoto_probe $name\n+\ttest_probe_value $value\n+    }\n+}"
    }
  ]
}