{
  "sha": "662df3c3f1453f5c5262f3a345e9e438308c23e8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjYyZGYzYzNmMTQ1M2Y1YzUyNjJmM2EzNDVlOWU0MzgzMDhjMjNlOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-05T21:57:06Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T17:02:19Z"
    },
    "message": "libctf, link: tie in the deduplicating linker\n\nThis fairly intricate commit connects up the CTF linker machinery (which\noperates in terms of ctf_archive_t's on ctf_link_inputs ->\nctf_link_outputs) to the deduplicator (which operates in terms of arrays\nof ctf_file_t's, all the archives exploded).\n\nThe nondeduplicating linker is retained, but is not called unless the\nCTF_LINK_NONDEDUP flag is passed in (which ld never does), or the\nenvironment variable LD_NO_CTF_DEDUP is set.  Eventually, once we have\nconfidence in the much-more-complex deduplicating linker, I hope the\nnondeduplicating linker can be removed.\n\nIn brief, what this does is traverses each input archive in\nctf_link_inputs, opening every member (if not already open) and tying\nchild dicts to their parents, shoving them into an array and\nconstructing a corresponding parents array that tells the deduplicator\nwhich dict is the parent of which child.  We then call ctf_dedup and\nctf_dedup_emit with that array of inputs, taking the outputs that result\nand putting them into ctf_link_outputs where the rest of the CTF linker\nexpects to find them, then linking in the variables just as is done by\nthe nondeduplicating linker.\n\nIt also implements much of the CU-mapping side of things.  The problem\nCU-mapping introduces is that if you map many input CUs into one output,\nthis is saying that you want many translation units to produce at most\none child dict if conflicting types are found in any of them.  This\nmeans you can suddenly have multiple distinct types with the same name\nin the same dict, which libctf cannot really represent because it's not\nsomething you can do with C translation units.\n\nThe deduplicator machinery already committed does as best it can with\nthese, hiding types with conflicting names rather than making child\ndicts out of them: but we still need to call it.  This is done similarly\nto the main link, taking the inputs (one CU output at a time),\ndeduplicating them, taking the output and making it an input to the\nfinal link.  Two (significant) optimizations are done: we share atoms\ntables between all these links and the final link (so e.g. all type hash\nvalues are shared, all decorated type names, etc); and any CU-mapped\nlinks with only one input (and no child dicts) doesn't need to do\nanything other than renaming the CU: the CU-mapped link phase can be\nskipped for it.  Put together, large CU-mapped links can save 50% of\ntheir memory usage and about as much time (and the memory usage for\nCU-mapped links is significant, because all those output CUs have to\nhave all their types stored in memory all at once).\n\ninclude/\n\t* ctf-api.h (CTF_LINK_NONDEDUP): New, turn off the\n\tdeduplicator.\nlibctf/\n\t* ctf-impl.h (ctf_list_splice): New.\n\t* ctf-util.h (ctf_list_splice): Likewise.\n\t* ctf-link.c (link_sort_inputs_cb_arg_t): Likewise.\n\t(ctf_link_sort_inputs): Likewise.\n\t(ctf_link_deduplicating_count_inputs): Likewise.\n\t(ctf_link_deduplicating_open_inputs): Likewise.\n\t(ctf_link_deduplicating_close_inputs): Likewise.\n\t(ctf_link_deduplicating_variables): Likewise.\n\t(ctf_link_deduplicating_per_cu): Likewise.\n\t(ctf_link_deduplicating): Likewise.\n\t(ctf_link): Call it.",
    "tree": {
      "sha": "699f939d42220a971cbd2eae86b1316817bc3e3c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/699f939d42220a971cbd2eae86b1316817bc3e3c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/662df3c3f1453f5c5262f3a345e9e438308c23e8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/662df3c3f1453f5c5262f3a345e9e438308c23e8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/662df3c3f1453f5c5262f3a345e9e438308c23e8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/662df3c3f1453f5c5262f3a345e9e438308c23e8/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e3e8411bec4ef30d331d6185bd2650a3fc56ea09",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e3e8411bec4ef30d331d6185bd2650a3fc56ea09",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e3e8411bec4ef30d331d6185bd2650a3fc56ea09"
    }
  ],
  "stats": {
    "total": 703,
    "additions": 701,
    "deletions": 2
  },
  "files": [
    {
      "sha": "e65e85d1444c04fad930e874097114089c82996f",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/662df3c3f1453f5c5262f3a345e9e438308c23e8/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/662df3c3f1453f5c5262f3a345e9e438308c23e8/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=662df3c3f1453f5c5262f3a345e9e438308c23e8",
      "patch": "@@ -1,3 +1,8 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (CTF_LINK_NONDEDUP): New, turn off the\n+\tdeduplicator.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (CTF_LINK_OMIT_VARIABLES_SECTION): New."
    },
    {
      "sha": "77ea5cd0ef8c7098f42f144d9efa8cec5713ceb6",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/662df3c3f1453f5c5262f3a345e9e438308c23e8/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/662df3c3f1453f5c5262f3a345e9e438308c23e8/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=662df3c3f1453f5c5262f3a345e9e438308c23e8",
      "patch": "@@ -86,6 +86,9 @@ typedef struct ctf_link_sym\n /* Share only types that are used by multiple inputs.  */\n #define CTF_LINK_SHARE_DUPLICATED 0x1\n \n+/* Do a nondeduplicating link.  */\n+#define CTF_LINK_NONDEDUP 0x2\n+\n /* Create empty outputs for all registered CU mappings even if no types are\n    emitted into them.  */\n #define CTF_LINK_EMPTY_CU_MAPPINGS 0x4"
    },
    {
      "sha": "803e8dea99cf5413437b19c91738cc60a11e8485",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=662df3c3f1453f5c5262f3a345e9e438308c23e8",
      "patch": "@@ -1,3 +1,17 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_list_splice): New.\n+\t* ctf-util.h (ctf_list_splice): Likewise.\n+\t* ctf-link.c (link_sort_inputs_cb_arg_t): Likewise.\n+\t(ctf_link_sort_inputs): Likewise.\n+\t(ctf_link_deduplicating_count_inputs): Likewise.\n+\t(ctf_link_deduplicating_open_inputs): Likewise.\n+\t(ctf_link_deduplicating_close_inputs): Likewise.\n+\t(ctf_link_deduplicating_variables): Likewise.\n+\t(ctf_link_deduplicating_per_cu): Likewise.\n+\t(ctf_link_deduplicating): Likewise.\n+\t(ctf_link): Call it.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-link.c (ctf_link_one_input_archive_member): Check"
    },
    {
      "sha": "35320d46f6606aad578a5d50570d21058e0bdbf0",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=662df3c3f1453f5c5262f3a345e9e438308c23e8",
      "patch": "@@ -629,6 +629,7 @@ extern char *ctf_sha1_fini (ctf_sha1_t *, char *);\n extern void ctf_list_append (ctf_list_t *, void *);\n extern void ctf_list_prepend (ctf_list_t *, void *);\n extern void ctf_list_delete (ctf_list_t *, void *);\n+extern void ctf_list_splice (ctf_list_t *, ctf_list_t *);\n extern int ctf_list_empty_p (ctf_list_t *lp);\n \n extern int ctf_dtd_insert (ctf_file_t *, ctf_dtdef_t *, int flag, int kind);"
    },
    {
      "sha": "f269fe7ac0ec734e000b927dea314b6af13f99a4",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 658,
      "deletions": 2,
      "changes": 660,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=662df3c3f1453f5c5262f3a345e9e438308c23e8",
      "patch": "@@ -819,6 +819,659 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n   ctf_link_close_one_input_archive (key, value, NULL);\n }\n \n+typedef struct link_sort_inputs_cb_arg\n+{\n+  int is_cu_mapped;\n+  ctf_file_t *fp;\n+} link_sort_inputs_cb_arg_t;\n+\n+/* Sort the inputs by N (the link order).  For CU-mapped links, this is a\n+   mapping of input to output name, not a mapping of input name to input\n+   ctf_link_input_t: compensate accordingly.  */\n+static int\n+ctf_link_sort_inputs (const ctf_next_hkv_t *one, const ctf_next_hkv_t *two,\n+\t\t      void *arg)\n+{\n+  ctf_link_input_t *input_1;\n+  ctf_link_input_t *input_2;\n+  link_sort_inputs_cb_arg_t *cu_mapped = (link_sort_inputs_cb_arg_t *) arg;\n+\n+  if (!cu_mapped || !cu_mapped->is_cu_mapped)\n+    {\n+      input_1 = (ctf_link_input_t *) one->hkv_value;\n+      input_2 = (ctf_link_input_t *) two->hkv_value;\n+    }\n+  else\n+    {\n+      const char *name_1 = (const char *) one->hkv_key;\n+      const char *name_2 = (const char *) two->hkv_key;\n+\n+      input_1 = ctf_dynhash_lookup (cu_mapped->fp->ctf_link_inputs, name_1);\n+      input_2 = ctf_dynhash_lookup (cu_mapped->fp->ctf_link_inputs, name_2);\n+\n+      /* There is no guarantee that CU-mappings actually have corresponding\n+\t inputs: the relative ordering in that case is unimportant.  */\n+      if (!input_1)\n+\treturn -1;\n+      if (!input_2)\n+\treturn 1;\n+    }\n+\n+  if (input_1->n < input_2->n)\n+    return -1;\n+  else if (input_1->n > input_2->n)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Count the number of input dicts in the ctf_link_inputs, or that subset of the\n+   ctf_link_inputs given by CU_NAMES if set.  Return the number of input dicts,\n+   and optionally the name and ctf_link_input_t of the single input archive if\n+   only one exists (no matter how many dicts it contains).  */\n+static ssize_t\n+ctf_link_deduplicating_count_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n+\t\t\t\t     ctf_link_input_t **only_one_input)\n+{\n+  ctf_dynhash_t *inputs = fp->ctf_link_inputs;\n+  ctf_next_t *i = NULL;\n+  void *name, *input;\n+  ctf_link_input_t *one_input = NULL;\n+  const char *one_name = NULL;\n+  ssize_t count = 0, narcs = 0;\n+  int err;\n+\n+  if (cu_names)\n+    inputs = cu_names;\n+\n+  while ((err = ctf_dynhash_next (inputs, &i, &name, &input)) == 0)\n+    {\n+      ssize_t one_count;\n+\n+      one_name = (const char *) name;\n+      /* If we are processing CU names, get the real input.  */\n+      if (cu_names)\n+\tone_input = ctf_dynhash_lookup (fp->ctf_link_inputs, one_name);\n+      else\n+\tone_input = (ctf_link_input_t *) input;\n+\n+      if (!one_input)\n+\tcontinue;\n+\n+      one_count = ctf_link_lazy_open (fp, one_input);\n+\n+      if (one_count < 0)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  return -1;\t\t\t\t/* errno is set for us.  */\n+\t}\n+\n+      count += one_count;\n+      narcs++;\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      ctf_err_warn (fp, 0, \"Iteration error counting deduplicating CTF link \"\n+\t\t    \"inputs: %s\", ctf_errmsg (err));\n+      ctf_set_errno (fp, err);\n+      return -1;\n+    }\n+\n+  if (!count)\n+    return 0;\n+\n+  if (narcs == 1)\n+    {\n+      if (only_one_input)\n+\t*only_one_input = one_input;\n+    }\n+  else if (only_one_input)\n+    *only_one_input = NULL;\n+\n+  return count;\n+}\n+\n+/* Allocate and populate an inputs array big enough for a given set of inputs:\n+   either a specific set of CU names (those from that set found in the\n+   ctf_link_inputs), or the entire ctf_link_inputs (if cu_names is not set).\n+   The number of inputs (from ctf_link_deduplicating_count_inputs, above) is\n+   passed in NINPUTS: an array of uint32_t containing parent pointers\n+   (corresponding to those members of the inputs that have parents) is allocated\n+   and returned in PARENTS.\n+\n+   The inputs are *archives*, not files: the archive can have multiple members\n+   if it is the result of a previous incremental link.  We want to add every one\n+   in turn, including the shared parent.  (The dedup machinery knows that a type\n+   used by a single dictionary and its parent should not be shared in\n+   CTF_LINK_SHARE_DUPLICATED mode.)\n+\n+   If no inputs exist that correspond to these CUs, return NULL with the errno\n+   set to ECTF_NOCTFDATA.  */\n+static ctf_file_t **\n+ctf_link_deduplicating_open_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n+\t\t\t\t    ssize_t ninputs, uint32_t **parents)\n+{\n+  ctf_dynhash_t *inputs = fp->ctf_link_inputs;\n+  ctf_next_t *i = NULL;\n+  void *name, *input;\n+  link_sort_inputs_cb_arg_t sort_arg;\n+  ctf_file_t **dedup_inputs = NULL;\n+  ctf_file_t **walk;\n+  uint32_t *parents_ = NULL;\n+  int err;\n+\n+  if (cu_names)\n+    inputs = cu_names;\n+\n+  if ((dedup_inputs = calloc (ninputs, sizeof (ctf_file_t *))) == NULL)\n+    goto oom;\n+\n+  if ((parents_ = calloc (ninputs, sizeof (uint32_t))) == NULL)\n+    goto oom;\n+\n+  walk = dedup_inputs;\n+\n+  /* Counting done: push every input into the array, in the order they were\n+     passed to ctf_link_add_ctf (and ultimately ld).  */\n+\n+  sort_arg.is_cu_mapped = (cu_names != NULL);\n+  sort_arg.fp = fp;\n+\n+  while ((err = ctf_dynhash_next_sorted (inputs, &i, &name, &input,\n+\t\t\t\t\t ctf_link_sort_inputs, &sort_arg)) == 0)\n+    {\n+      const char *one_name = (const char *) name;\n+      ctf_link_input_t *one_input;\n+      ctf_file_t *one_fp;\n+      ctf_file_t *parent_fp = NULL;\n+      uint32_t parent_i;\n+      ctf_next_t *j = NULL;\n+\n+      /* If we are processing CU names, get the real input.  All the inputs\n+\t will have been opened, if they contained any CTF at all.  */\n+      if (cu_names)\n+\tone_input = ctf_dynhash_lookup (fp->ctf_link_inputs, one_name);\n+      else\n+\tone_input = (ctf_link_input_t *) input;\n+\n+      if (!one_input || (!one_input->clin_arc && !one_input->clin_fp))\n+\tcontinue;\n+\n+      /* Short-circuit: if clin_fp is set, just use it.   */\n+      if (one_input->clin_fp)\n+\t{\n+\t  parents_[walk - dedup_inputs] = walk - dedup_inputs;\n+\t  *walk = one_input->clin_fp;\n+\t  walk++;\n+\t  continue;\n+\t}\n+\n+      /* Get and insert the parent archive (if any), if this archive has\n+\t multiple members.  We assume, as elsewhere, that the parent is named\n+\t _CTF_SECTION.  */\n+\n+      if ((parent_fp = ctf_arc_open_by_name (one_input->clin_arc,\n+\t\t\t\t\t     _CTF_SECTION, &err)) == NULL)\n+\t{\n+\t  if (err != ECTF_NOMEMBNAM)\n+\t    {\n+\t      ctf_next_destroy (i);\n+\t      ctf_set_errno (fp, err);\n+\t      goto err;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  *walk = parent_fp;\n+\t  parent_i = walk - dedup_inputs;\n+\t  walk++;\n+\t}\n+\n+      /* We disregard the input archive name: either it is the parent (which we\n+\t already have), or we want to put everything into one TU sharing the\n+\t cuname anyway (if this is a CU-mapped link), or this is the final phase\n+\t of a relink with CU-mapping off (i.e. ld -r) in which case the cuname\n+\t is correctly set regardless.  */\n+      while ((one_fp = ctf_archive_next (one_input->clin_arc, &j, NULL,\n+\t\t\t\t\t 1, &err)) != NULL)\n+\t{\n+\t  if (one_fp->ctf_flags & LCTF_CHILD)\n+\t    {\n+\t      /* The contents of the parents array for elements not\n+\t\t corresponding to children is undefined.  If there is no parent\n+\t\t (itself a sign of a likely linker bug or corrupt input), we set\n+\t\t it to itself.  */\n+\n+\t      ctf_import (one_fp, parent_fp);\n+\t      if (parent_fp)\n+\t\tparents_[walk - dedup_inputs] = parent_i;\n+\t      else\n+\t\tparents_[walk - dedup_inputs] = walk - dedup_inputs;\n+\t    }\n+\t  *walk = one_fp;\n+\t  walk++;\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  goto iterr;\n+\t}\n+    }\n+  if (err != ECTF_NEXT_END)\n+    goto iterr;\n+\n+  *parents = parents_;\n+\n+  return dedup_inputs;\n+\n+ oom:\n+  err = ENOMEM;\n+\n+ iterr:\n+  ctf_set_errno (fp, err);\n+\n+ err:\n+  free (dedup_inputs);\n+  free (parents_);\n+  ctf_err_warn (fp, 0, \"Error in deduplicating CTF link input allocation: %s\",\n+\t\tctf_errmsg (ctf_errno (fp)));\n+  return NULL;\n+}\n+\n+/* Close INPUTS that have already been linked, first the passed array, and then\n+   that subset of the ctf_link_inputs archives they came from cited by the\n+   CU_NAMES.  If CU_NAMES is not specified, close all the ctf_link_inputs in one\n+   go, leaving it empty.  */\n+static int\n+ctf_link_deduplicating_close_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n+\t\t\t\t     ctf_file_t **inputs, ssize_t ninputs)\n+{\n+  ctf_next_t *it = NULL;\n+  void *name;\n+  int err;\n+  ssize_t i;\n+\n+  /* This is the inverse of ctf_link_deduplicating_open_inputs: so first, close\n+     all the individual input dicts, opened by the archive iterator.  */\n+  for (i = 0; i < ninputs; i++)\n+    ctf_file_close (inputs[i]);\n+\n+  /* Now close the archives they are part of.  */\n+  if (cu_names)\n+    {\n+      while ((err = ctf_dynhash_next (cu_names, &it, &name, NULL)) == 0)\n+\t{\n+\t  /* Remove the input from the linker inputs, if it exists, which also\n+\t     closes it.  */\n+\n+\t  ctf_dynhash_remove (fp->ctf_link_inputs, (const char *) name);\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"Iteration error in deduplicating link input \"\n+\t\t\t\"freeing: %s\", ctf_errmsg (err));\n+\t  ctf_set_errno (fp, err);\n+\t}\n+    }\n+  else\n+    ctf_dynhash_empty (fp->ctf_link_inputs);\n+\n+  return 0;\n+}\n+\n+/* Do a deduplicating link of all variables in the inputs.  */\n+static int\n+ctf_link_deduplicating_variables (ctf_file_t *fp, ctf_file_t **inputs,\n+\t\t\t\t  size_t ninputs, int cu_mapped)\n+{\n+  ctf_link_in_member_cb_arg_t arg;\n+  size_t i;\n+\n+  arg.cu_mapped = cu_mapped;\n+  arg.out_fp = fp;\n+  arg.in_input_cu_file = 0;\n+\n+  for (i = 0; i < ninputs; i++)\n+    {\n+      arg.in_fp = inputs[i];\n+      if (ctf_cuname (inputs[i]) != NULL)\n+\targ.in_file_name = ctf_cuname (inputs[i]);\n+      else\n+\targ.in_file_name = \"unnamed-CU\";\n+      arg.cu_name = arg.in_file_name;\n+      if (ctf_variable_iter (arg.in_fp, ctf_link_one_variable, &arg) < 0)\n+\treturn ctf_set_errno (fp, ctf_errno (arg.in_fp));\n+\n+      /* Outputs > 0 are per-CU.  */\n+      arg.in_input_cu_file = 1;\n+    }\n+  return 0;\n+}\n+\n+/* Do the per-CU part of a deduplicating link.  */\n+static int\n+ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n+{\n+  ctf_next_t *i = NULL;\n+  int err;\n+  void *out_cu;\n+  void *in_cus;\n+\n+  /* Links with a per-CU mapping in force get a first pass of deduplication,\n+     dedupping the inputs for a given CU mapping into the output for that\n+     mapping.  The outputs from this process get fed back into the final pass\n+     that is carried out even for non-CU links.  */\n+\n+  while ((err = ctf_dynhash_next (fp->ctf_link_out_cu_mapping, &i, &out_cu,\n+\t\t\t\t  &in_cus)) == 0)\n+    {\n+      const char *out_name = (const char *) out_cu;\n+      ctf_dynhash_t *in = (ctf_dynhash_t *) in_cus;\n+      ctf_file_t *out = NULL;\n+      ctf_file_t **inputs;\n+      ctf_file_t **outputs;\n+      ctf_archive_t *in_arc;\n+      ssize_t ninputs;\n+      ctf_link_input_t *only_input;\n+      uint32_t noutputs;\n+      uint32_t *parents;\n+\n+      if ((ninputs = ctf_link_deduplicating_count_inputs (fp, in,\n+\t\t\t\t\t\t\t  &only_input)) == -1)\n+\tgoto err_open_inputs;\n+\n+      /* CU mapping with no inputs?  Skip.  */\n+      if (ninputs == 0)\n+\tcontinue;\n+\n+      if (labs ((long int) ninputs) > 0xfffffffe)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"Too many inputs in deduplicating link: %li\",\n+\t\t\t(long int) ninputs);\n+\t  goto err_open_inputs;\n+\t}\n+\n+      /* Short-circuit: a cu-mapped link with only one input archive with\n+\t unconflicting contents is a do-nothing, and we can just leave the input\n+\t in place: we do have to change the cuname, though, so we unwrap it,\n+\t change the cuname, then stuff it back in the linker input again, via\n+\t the clin_fp short-circuit member.  ctf_link_deduplicating_open_inputs\n+\t will spot this member and jam it straight into the next link phase,\n+\t ignoring the corresponding archive.  */\n+      if (only_input && ninputs == 1)\n+\t{\n+\t  ctf_next_t *ai = NULL;\n+\t  int err;\n+\n+\t  /* We can abuse an archive iterator to get the only member cheaply, no\n+\t     matter what its name.  */\n+\t  only_input->clin_fp = ctf_archive_next (only_input->clin_arc,\n+\t\t\t\t\t\t  &ai, NULL, 0, &err);\n+\t  if (!only_input->clin_fp)\n+\t    {\n+\t      ctf_err_warn (fp, 0, \"Cannot open archive %s in CU-mapped CTF \"\n+\t\t\t    \"link: %s\", only_input->clin_filename,\n+\t\t\t    ctf_errmsg (err));\n+\t      ctf_set_errno (fp, err);\n+\t      goto err_open_inputs;\n+\t    }\n+\t  ctf_next_destroy (ai);\n+\n+\t  if (strcmp (only_input->clin_filename, out_name) != 0)\n+\t    {\n+\t      /* Renaming. We need to add a new input, then null out the\n+\t\t clin_arc and clin_fp of the old one to stop it being\n+\t\t auto-closed on removal.  The new input needs its cuname changed\n+\t\t to out_name, which is doable only because the cuname is a\n+\t\t dynamic property which can be changed even in readonly\n+\t\t dicts. */\n+\n+\t      ctf_cuname_set (only_input->clin_fp, out_name);\n+\t      if (ctf_link_add_ctf_internal (fp, only_input->clin_arc,\n+\t\t\t\t\t     only_input->clin_fp,\n+\t\t\t\t\t     out_name) < 0)\n+\t\t{\n+\t\t  ctf_err_warn (fp, 0, \"Cannot add intermediate files \"\n+\t\t\t\t\"to link: %s\", ctf_errmsg (ctf_errno (fp)));\n+\t\t  goto err_open_inputs;\n+\t\t}\n+\t      only_input->clin_arc = NULL;\n+\t      only_input->clin_fp = NULL;\n+\t      ctf_dynhash_remove (fp->ctf_link_inputs,\n+\t\t\t\t  only_input->clin_filename);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* This is a real CU many-to-one mapping: we must dedup the inputs into\n+\t a new output to be used in the final link phase.  */\n+\n+      if ((inputs = ctf_link_deduplicating_open_inputs (fp, in, ninputs,\n+\t\t\t\t\t\t\t&parents)) == NULL)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  goto err_inputs;\n+\t}\n+\n+      if ((out = ctf_create (&err)) == NULL)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"Cannot create per-CU CTF archive for %s: %s\",\n+\t\t       out_name, ctf_errmsg (err));\n+\t  ctf_set_errno (fp, err);\n+\t  goto err_inputs;\n+\t}\n+\n+      /* Share the atoms table to reduce memory usage.  */\n+      out->ctf_dedup_atoms = fp->ctf_dedup_atoms_alloc;\n+\n+      /* No ctf_imports at this stage: this per-CU dictionary has no parents.\n+\t Parent/child deduplication happens in the link's final pass.  However,\n+\t the cuname *is* important, as it is propagated into the final\n+\t dictionary.  */\n+      ctf_cuname_set (out, out_name);\n+\n+      if (ctf_dedup (out, inputs, ninputs, parents, 1) < 0)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"CU-mapped deduplication failed for %s: %s\",\n+\t\t       out_name, ctf_errmsg (ctf_errno (out)));\n+\t  goto err_inputs;\n+\t}\n+\n+      if ((outputs = ctf_dedup_emit (out, inputs, ninputs, parents,\n+\t\t\t\t     &noutputs, 1)) == NULL)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"CU-mapped deduplicating link type emission \"\n+\t\t\t\"failed for %s: %s\", out_name,\n+\t\t\tctf_errmsg (ctf_errno (out)));\n+\t  goto err_inputs;\n+\t}\n+      if (!ctf_assert (fp, noutputs == 1))\n+\tgoto err_inputs_outputs;\n+\n+      if (!(fp->ctf_link_flags & CTF_LINK_OMIT_VARIABLES_SECTION)\n+\t  && ctf_link_deduplicating_variables (out, inputs, ninputs, 1) < 0)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"CU-mapped deduplicating link variable \"\n+\t\t\t\"emission failed for %s: %s\", out_name,\n+\t\t\tctf_errmsg (ctf_errno (out)));\n+\t  goto err_inputs_outputs;\n+\t}\n+\n+      if (ctf_link_deduplicating_close_inputs (fp, in, inputs, ninputs) < 0)\n+\t{\n+\t  free (inputs);\n+\t  free (parents);\n+\t  goto err_outputs;\n+\t}\n+      free (inputs);\n+      free (parents);\n+\n+      /* Splice any errors or warnings created during this link back into the\n+\t dict that the caller knows about.  */\n+      ctf_list_splice (&fp->ctf_errs_warnings, &outputs[0]->ctf_errs_warnings);\n+\n+      /* This output now becomes an input to the next link phase, with a name\n+\t equal to the CU name.  We have to wrap it in an archive wrapper\n+\t first.  */\n+\n+      if ((in_arc = ctf_new_archive_internal (0, 0, NULL, outputs[0], NULL,\n+\t\t\t\t\t      NULL, &err)) == NULL)\n+\t{\n+\t  ctf_set_errno (fp, err);\n+\t  goto err_outputs;\n+\t}\n+\n+      if (ctf_link_add_ctf_internal (fp, in_arc, NULL,\n+\t\t\t\t     ctf_cuname (outputs[0])) < 0)\n+\t{\n+\t  ctf_err_warn (fp, 0, \"Cannot add intermediate files to link: %s\",\n+\t\t\tctf_errmsg (ctf_errno (fp)));\n+\t  goto err_outputs;\n+\t}\n+\n+      ctf_file_close (out);\n+      free (outputs);\n+      continue;\n+\n+    err_inputs_outputs:\n+      ctf_list_splice (&fp->ctf_errs_warnings, &outputs[0]->ctf_errs_warnings);\n+      ctf_file_close (outputs[0]);\n+      free (outputs);\n+    err_inputs:\n+      ctf_link_deduplicating_close_inputs (fp, in, inputs, ninputs);\n+      ctf_file_close (out);\n+      free (inputs);\n+      free (parents);\n+    err_open_inputs:\n+      ctf_next_destroy (i);\n+      return -1;\n+\n+    err_outputs:\n+      ctf_list_splice (&fp->ctf_errs_warnings, &outputs[0]->ctf_errs_warnings);\n+      ctf_file_close (outputs[0]);\n+      free (outputs);\n+      ctf_next_destroy (i);\n+      return -1;\t\t\t\t/* Errno is set for us.  */\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      ctf_err_warn (fp, 0, \"Iteration error in CU-mapped deduplicating \"\n+\t\t    \"link: %s\", ctf_errmsg (err));\n+      return ctf_set_errno (fp, err);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Do a deduplicating link using the ctf-dedup machinery.  */\n+static void\n+ctf_link_deduplicating (ctf_file_t *fp)\n+{\n+  size_t i;\n+  ctf_file_t **inputs, **outputs = NULL;\n+  ssize_t ninputs;\n+  uint32_t noutputs;\n+  uint32_t *parents;\n+\n+  if (ctf_dedup_atoms_init (fp) < 0)\n+    {\n+      ctf_err_warn (fp, 0, \"%s allocating CTF dedup atoms table\",\n+\t\t    ctf_errmsg (ctf_errno (fp)));\n+      return;\t\t\t\t\t/* Errno is set for us.  */\n+    }\n+\n+  if (fp->ctf_link_out_cu_mapping\n+      && (ctf_link_deduplicating_per_cu (fp) < 0))\n+    return;\t\t\t\t\t/* Errno is set for us.  */\n+\n+  if ((ninputs = ctf_link_deduplicating_count_inputs (fp, NULL, NULL)) < 0)\n+    return;\t\t\t\t\t/* Errno is set for us.  */\n+\n+  if ((inputs = ctf_link_deduplicating_open_inputs (fp, NULL, ninputs,\n+\t\t\t\t\t\t    &parents)) == NULL)\n+    return;\t\t\t\t\t/* Errno is set for us.  */\n+\n+  if (ninputs == 1 && ctf_cuname (inputs[0]) != NULL)\n+    ctf_cuname_set (fp, ctf_cuname (inputs[0]));\n+\n+  if (ctf_dedup (fp, inputs, ninputs, parents, 0) < 0)\n+    {\n+      ctf_err_warn (fp, 0, \"Deduplication failed for %s: %s\",\n+\t\t    ctf_link_input_name (fp), ctf_errmsg (ctf_errno (fp)));\n+      goto err;\n+    }\n+\n+  if ((outputs = ctf_dedup_emit (fp, inputs, ninputs, parents, &noutputs,\n+\t\t\t\t 0)) == NULL)\n+    {\n+      ctf_err_warn (fp, 0, \"Deduplicating link type emission failed \"\n+\t\t    \"for %s: %s\", ctf_link_input_name (fp),\n+\t\t    ctf_errmsg (ctf_errno (fp)));\n+      goto err;\n+    }\n+\n+  if (!ctf_assert (fp, outputs[0] == fp))\n+    goto err;\n+\n+  for (i = 0; i < noutputs; i++)\n+    {\n+      char *dynname;\n+\n+      /* We already have access to this one.  Close the duplicate.  */\n+      if (i == 0)\n+\t{\n+\t  ctf_file_close (outputs[0]);\n+\t  continue;\n+\t}\n+\n+      if ((dynname = strdup (ctf_cuname (outputs[i]))) == NULL)\n+\tgoto oom_one_output;\n+\n+      if (ctf_dynhash_insert (fp->ctf_link_outputs, dynname, outputs[i]) < 0)\n+\tgoto oom_one_output;\n+\n+      continue;\n+\n+    oom_one_output:\n+      ctf_err_warn (fp, 0, \"Out of memory allocating link outputs\");\n+      ctf_set_errno (fp, ENOMEM);\n+      free (dynname);\n+\n+      for (; i < noutputs; i++)\n+\tctf_file_close (outputs[i]);\n+      goto err;\n+    }\n+\n+  if (!(fp->ctf_link_flags & CTF_LINK_OMIT_VARIABLES_SECTION)\n+      && ctf_link_deduplicating_variables (fp, inputs, ninputs, 0) < 0)\n+    {\n+      ctf_err_warn (fp, 0, \"Deduplicating link variable emission failed for \"\n+\t\t    \"%s: %s\", ctf_link_input_name (fp),\n+\t\t    ctf_errmsg (ctf_errno (fp)));\n+      for (i = 1; i < noutputs; i++)\n+\tctf_file_close (outputs[i]);\n+      goto err;\n+    }\n+\n+  /* Now close all the inputs, including per-CU intermediates.  */\n+\n+  if (ctf_link_deduplicating_close_inputs (fp, NULL, inputs, ninputs) < 0)\n+    return;\t\t\t\t\t/* errno is set for us.  */\n+\n+  ninputs = 0;\t\t\t\t\t/* Prevent double-close.  */\n+  ctf_set_errno (fp, 0);\n+\n+  /* Fall through.  */\n+\n+ err:\n+  for (i = 0; i < (size_t) ninputs; i++)\n+    ctf_file_close (inputs[i]);\n+  free (inputs);\n+  free (parents);\n+  free (outputs);\n+  return;\n+}\n+\n /* Merge types and variable sections in all files added to the link\n    together.  All the added files are closed.  */\n int\n@@ -871,8 +1524,11 @@ ctf_link (ctf_file_t *fp, int flags)\n \t}\n     }\n \n-  ctf_dynhash_iter (fp->ctf_link_inputs, ctf_link_one_input_archive,\n-\t\t    &arg);\n+  if ((flags & CTF_LINK_NONDEDUP) || (getenv (\"LD_NO_CTF_DEDUP\")))\n+    ctf_dynhash_iter (fp->ctf_link_inputs, ctf_link_one_input_archive,\n+\t\t      &arg);\n+  else\n+    ctf_link_deduplicating (fp);\n \n   /* Discard the now-unnecessary mapping table data from all the outputs.  */\n   if (fp->ctf_link_type_mapping)"
    },
    {
      "sha": "a0338f4742ae2330c363a3b44be91aed54e1d428",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/662df3c3f1453f5c5262f3a345e9e438308c23e8/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=662df3c3f1453f5c5262f3a345e9e438308c23e8",
      "patch": "@@ -88,6 +88,26 @@ ctf_list_empty_p (ctf_list_t *lp)\n   return (lp->l_next == NULL && lp->l_prev == NULL);\n }\n \n+/* Splice one entire list onto the end of another one.  The existing list is\n+   emptied.  */\n+\n+void\n+ctf_list_splice (ctf_list_t *lp, ctf_list_t *append)\n+{\n+  if (ctf_list_empty_p (append))\n+    return;\n+\n+  if (lp->l_prev != NULL)\n+    lp->l_prev->l_next = append->l_next;\n+  else\n+    lp->l_next = append->l_next;\n+\n+  append->l_next->l_prev = lp->l_prev;\n+  lp->l_prev = append->l_prev;\n+  append->l_next = NULL;\n+  append->l_prev = NULL;\n+}\n+\n /* Convert a 32-bit ELF symbol into Elf64 and return a pointer to it.  */\n \n Elf64_Sym *"
    }
  ]
}