{
  "sha": "54b4dcc530f0a907d9121aba1a2631d7e3333a8f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTRiNGRjYzUzMGYwYTkwN2Q5MTIxYWJhMWEyNjMxZDdlMzMzM2E4Zg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-01-14T14:32:35Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-04-15T09:34:09Z"
    },
    "message": "gdb: refactor the initialization file lookup code\n\nIn preparation for the next patch, which adds startup files, this\ncommit refactors the code for looking up the initialization files so\nthat the code can be more easily reused in the next commit.\n\nThere should be no user visible changes after this commit.\n\ngdb/ChangeLog:\n\n\t* main.c (relocate_gdbinit_path_maybe_in_datadir): Rename to...\n\t(relocate_file_path_maybe_in_datadir): ...this.\n\t(class gdb_initfile_finder): New class.\n\t(get_init_files): Now uses gdb_initfile_finder.\n\t(print_gdb_help): Print 'None found' when there are no init files.",
    "tree": {
      "sha": "caf6d74b42656cf49f6e036271f381b3dda790ba",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/caf6d74b42656cf49f6e036271f381b3dda790ba"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/54b4dcc530f0a907d9121aba1a2631d7e3333a8f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/54b4dcc530f0a907d9121aba1a2631d7e3333a8f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/54b4dcc530f0a907d9121aba1a2631d7e3333a8f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/54b4dcc530f0a907d9121aba1a2631d7e3333a8f/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "985e026451640c880e13827454aa31b7a636d1bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/985e026451640c880e13827454aa31b7a636d1bc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/985e026451640c880e13827454aa31b7a636d1bc"
    }
  ],
  "stats": {
    "total": 195,
    "additions": 132,
    "deletions": 63
  },
  "files": [
    {
      "sha": "136b95d7cee64a008d7ba360eb5f0910eb23a3d3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/54b4dcc530f0a907d9121aba1a2631d7e3333a8f/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/54b4dcc530f0a907d9121aba1a2631d7e3333a8f/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=54b4dcc530f0a907d9121aba1a2631d7e3333a8f",
      "patch": "@@ -1,3 +1,11 @@\n+2021-04-15  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* main.c (relocate_gdbinit_path_maybe_in_datadir): Rename to...\n+\t(relocate_file_path_maybe_in_datadir): ...this.\n+\t(class gdb_initfile_finder): New class.\n+\t(get_init_files): Now uses gdb_initfile_finder.\n+\t(print_gdb_help): Print 'None found' when there are no init files.\n+\n 2021-04-14  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* dwarf2/read.c (inherit_abstract_dies): Keep a reference to the"
    },
    {
      "sha": "2ba39273d0700613d9024f87cb1d3b892ce4158c",
      "filename": "gdb/main.c",
      "status": "modified",
      "additions": 124,
      "deletions": 63,
      "changes": 187,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/54b4dcc530f0a907d9121aba1a2631d7e3333a8f/gdb/main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/54b4dcc530f0a907d9121aba1a2631d7e3333a8f/gdb/main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/main.c?ref=54b4dcc530f0a907d9121aba1a2631d7e3333a8f",
      "patch": "@@ -203,8 +203,8 @@ relocate_gdb_directory (const char *initial, bool relocatable)\n    otherwise.  */\n \n static std::string\n-relocate_gdbinit_path_maybe_in_datadir (const std::string &file,\n-\t\t\t\t\tbool relocatable)\n+relocate_file_path_maybe_in_datadir (const std::string &file,\n+\t\t\t\t     bool relocatable)\n {\n   size_t datadir_len = strlen (GDB_DATADIR);\n \n@@ -233,100 +233,157 @@ relocate_gdbinit_path_maybe_in_datadir (const std::string &file,\n     return relocated_path;\n }\n \n-/* Compute the locations of init files that GDB should source and\n-   return them in SYSTEM_GDBINIT, HOME_GDBINIT, LOCAL_GDBINIT.  If\n-   there is no system gdbinit (resp. home gdbinit and local gdbinit)\n-   to be loaded, then SYSTEM_GDBINIT (resp. HOME_GDBINIT and\n-   LOCAL_GDBINIT) is set to the empty string.  */\n-static void\n-get_init_files (std::vector<std::string> *system_gdbinit,\n-\t\tstd::string *home_gdbinit,\n-\t\tstd::string *local_gdbinit)\n+/* A class to wrap up the logic for finding the three different types of\n+   initialisation files GDB uses, system wide, home directory, and current\n+   working directory.  */\n+\n+class gdb_initfile_finder\n {\n-  static std::vector<std::string> sysgdbinit;\n-  static std::string homeinit;\n-  static std::string localinit;\n-  static int initialized = 0;\n+public:\n+  /* Constructor.  Finds initialisation files named FILENAME in the home\n+     directory or local (current working) directory.  System initialisation\n+     files are found in both SYSTEM_FILENAME and SYSTEM_DIRNAME if these\n+     are not nullptr (either or both can be).  The matching *_RELOCATABLE\n+     flag is passed through to RELOCATE_FILE_PATH_MAYBE_IN_DATADIR.\n+\n+     If FILENAME starts with a '.' then when looking in the home directory\n+     this first '.' can be ignored in some cases.  */\n+  explicit gdb_initfile_finder (const char *filename,\n+\t\t\t\tconst char *system_filename,\n+\t\t\t\tbool system_filename_relocatable,\n+\t\t\t\tconst char *system_dirname,\n+\t\t\t\tbool system_dirname_relocatable,\n+\t\t\t\tbool lookup_local_file)\n+  {\n+    struct stat s;\n \n-  if (!initialized)\n-    {\n-      struct stat homebuf, cwdbuf, s;\n+    if (system_filename != nullptr && system_filename[0] != '\\0')\n+      {\n+\tstd::string relocated_filename\n+\t  = relocate_file_path_maybe_in_datadir (system_filename,\n+\t\t\t\t\t\t system_filename_relocatable);\n+\tif (!relocated_filename.empty ()\n+\t    && stat (relocated_filename.c_str (), &s) == 0)\n+\t  m_system_files.push_back (relocated_filename);\n+      }\n \n-      if (SYSTEM_GDBINIT[0])\n-\t{\n-\t  std::string relocated_sysgdbinit\n-\t    = relocate_gdbinit_path_maybe_in_datadir\n-\t\t(SYSTEM_GDBINIT, SYSTEM_GDBINIT_RELOCATABLE);\n-\t  if (!relocated_sysgdbinit.empty ()\n-\t      && stat (relocated_sysgdbinit.c_str (), &s) == 0)\n-\t    sysgdbinit.push_back (relocated_sysgdbinit);\n-\t}\n-      if (SYSTEM_GDBINIT_DIR[0])\n-\t{\n-\t  std::string relocated_gdbinit_dir\n-\t    = relocate_gdbinit_path_maybe_in_datadir\n-\t\t(SYSTEM_GDBINIT_DIR, SYSTEM_GDBINIT_DIR_RELOCATABLE);\n-\t  if (!relocated_gdbinit_dir.empty ()) {\n-\t    gdb_dir_up dir (opendir (relocated_gdbinit_dir.c_str ()));\n+    if (system_dirname != nullptr && system_dirname[0] != '\\0')\n+      {\n+\tstd::string relocated_dirname\n+\t  = relocate_file_path_maybe_in_datadir (system_dirname,\n+\t\t\t\t\t\t system_dirname_relocatable);\n+\tif (!relocated_dirname.empty ())\n+\t  {\n+\t    gdb_dir_up dir (opendir (relocated_dirname.c_str ()));\n \t    if (dir != nullptr)\n \t      {\n \t\tstd::vector<std::string> files;\n-\t\tfor (;;)\n+\t\twhile (true)\n \t\t  {\n \t\t    struct dirent *ent = readdir (dir.get ());\n \t\t    if (ent == nullptr)\n \t\t      break;\n \t\t    std::string name (ent->d_name);\n \t\t    if (name == \".\" || name == \"..\")\n \t\t      continue;\n-\t\t    /* ent->d_type is not available on all systems (e.g. mingw,\n-\t\t       Solaris), so we have to call stat().  */\n-\t\t    std::string filename\n-\t\t      = relocated_gdbinit_dir + SLASH_STRING + name;\n-\t\t    if (stat (filename.c_str (), &s) != 0\n+\t\t    /* ent->d_type is not available on all systems\n+\t\t       (e.g. mingw, Solaris), so we have to call stat().  */\n+\t\t    std::string tmp_filename\n+\t\t      = relocated_dirname + SLASH_STRING + name;\n+\t\t    if (stat (tmp_filename.c_str (), &s) != 0\n \t\t\t|| !S_ISREG (s.st_mode))\n \t\t      continue;\n \t\t    const struct extension_language_defn *extlang\n-\t\t      = get_ext_lang_of_file (filename.c_str ());\n+\t\t      = get_ext_lang_of_file (tmp_filename.c_str ());\n \t\t    /* We effectively don't support \"set script-extension\n-\t\t       off/soft\", because we are loading system init files here,\n-\t\t       so it does not really make sense to depend on a\n-\t\t       setting.  */\n+\t\t       off/soft\", because we are loading system init files\n+\t\t       here, so it does not really make sense to depend on\n+\t\t       a setting.  */\n \t\t    if (extlang != nullptr && ext_lang_present_p (extlang))\n-\t\t      files.push_back (std::move (filename));\n+\t\t      files.push_back (std::move (tmp_filename));\n \t\t  }\n \t\tstd::sort (files.begin (), files.end ());\n-\t\tsysgdbinit.insert (sysgdbinit.end (),\n-\t\t\t\t   files.begin (), files.end ());\n+\t\tm_system_files.insert (m_system_files.end (),\n+\t\t\t\t       files.begin (), files.end ());\n \t      }\n \t  }\n-\t}\n+      }\n \n       /* If the .gdbinit file in the current directory is the same as\n \t the $HOME/.gdbinit file, it should not be sourced.  homebuf\n \t and cwdbuf are used in that purpose.  Make sure that the stats\n \t are zero in case one of them fails (this guarantees that they\n \t won't match if either exists).  */\n \n-      memset (&homebuf, 0, sizeof (struct stat));\n-      memset (&cwdbuf, 0, sizeof (struct stat));\n+    struct stat homebuf, cwdbuf;\n+    memset (&homebuf, 0, sizeof (struct stat));\n+    memset (&cwdbuf, 0, sizeof (struct stat));\n \n-      homeinit = find_gdb_home_config_file (GDBINIT, &homebuf);\n+    m_home_file = find_gdb_home_config_file (filename, &homebuf);\n \n-      if (stat (GDBINIT, &cwdbuf) == 0)\n-\t{\n-\t  if (homeinit.empty ()\n-\t      || memcmp ((char *) &homebuf, (char *) &cwdbuf,\n-\t\t\t sizeof (struct stat)))\n-\t    localinit = GDBINIT;\n-\t}\n+    if (lookup_local_file && stat (filename, &cwdbuf) == 0)\n+      {\n+\tif (m_home_file.empty ()\n+\t    || memcmp ((char *) &homebuf, (char *) &cwdbuf,\n+\t\t       sizeof (struct stat)))\n+\t  m_local_file = filename;\n+      }\n+  }\n \n-      initialized = 1;\n-    }\n+  DISABLE_COPY_AND_ASSIGN (gdb_initfile_finder);\n+\n+  /* Return a list of system initialisation files.  The list could be\n+     empty.  */\n+  const std::vector<std::string> &system_files () const\n+  { return m_system_files; }\n+\n+  /* Return the path to the home initialisation file.  The string can be\n+     empty if there is no such file.  */\n+  const std::string &home_file () const\n+  { return m_home_file; }\n+\n+  /* Return the path to the local initialisation file.  The string can be\n+     empty if there is no such file.  */\n+  const std::string &local_file () const\n+  { return m_local_file; }\n+\n+private:\n+\n+  /* Vector of all system init files in the order they should be processed.\n+     Could be empty.  */\n+  std::vector<std::string> m_system_files;\n+\n+  /* Initialization file from the home directory.  Could be the empty\n+     string if there is no such file found.  */\n+  std::string m_home_file;\n \n-  *system_gdbinit = sysgdbinit;\n-  *home_gdbinit = homeinit;\n-  *local_gdbinit = localinit;\n+  /* Initialization file from the current working directory.  Could be the\n+     empty string if there is no such file found.  */\n+  std::string m_local_file;\n+};\n+\n+/* Compute the locations of init files that GDB should source and return\n+   them in SYSTEM_GDBINIT, HOME_GDBINIT, LOCAL_GDBINIT.  The SYSTEM_GDBINIT\n+   can be returned as an empty vector, and HOME_GDBINIT and LOCAL_GDBINIT\n+   can be returned as empty strings if there is no init file of that\n+   type.  */\n+\n+static void\n+get_init_files (std::vector<std::string> *system_gdbinit,\n+\t\tstd::string *home_gdbinit,\n+\t\tstd::string *local_gdbinit)\n+{\n+  /* Cache the file lookup object so we only actually search for the files\n+     once.  */\n+  static gdb::optional<gdb_initfile_finder> init_files;\n+  if (!init_files.has_value ())\n+    init_files.emplace (GDBINIT, SYSTEM_GDBINIT, SYSTEM_GDBINIT_RELOCATABLE,\n+\t\t\tSYSTEM_GDBINIT_DIR, SYSTEM_GDBINIT_DIR_RELOCATABLE,\n+\t\t\ttrue);\n+\n+  *system_gdbinit = init_files->system_files ();\n+  *home_gdbinit = init_files->home_file ();\n+  *local_gdbinit = init_files->local_file ();\n }\n \n /* Start up the event loop.  This is the entry point to the event loop\n@@ -1375,6 +1432,10 @@ At startup, GDB reads the following init files and executes their commands:\\n\\\n     fprintf_unfiltered (stream, _(\"\\\n    * local init file (see also 'set auto-load local-gdbinit'): ./%s\\n\\\n \"), local_gdbinit.c_str ());\n+  if (system_gdbinit.empty () && home_gdbinit.empty ()\n+      && local_gdbinit.empty ())\n+    fprintf_unfiltered (stream, _(\"\\\n+   None found.\\n\"));\n   fputs_unfiltered (_(\"\\n\\\n For more information, type \\\"help\\\" from within GDB, or consult the\\n\\\n GDB manual (available as on-line info or a printed manual).\\n\\"
    }
  ]
}