{
  "sha": "28561a655942f8e2a70a3b64e867223a60aae7b1",
  "node_id": "C_kwDOANOeidoAKDI4NTYxYTY1NTk0MmY4ZTJhNzBhM2I2NGU4NjcyMjNhNjBhYWU3YjE",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-01T14:40:02Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-09T02:00:39Z"
    },
    "message": "gdb/remote.c: refactor pending fork status functions\n\nIn preparation for a following patch, refactor a few things that I did\nfind a bit awkward, and to make them a bit more reusable.\n\n - Pass an inferior to kill_new_fork_children instead of a pid.  That\n   allows iterating on only this inferior's threads and avoid further\n   filtering on the thread's pid.\n - Change thread_pending_fork_status to return a non-nullptr value only\n   if the thread does have a pending fork status.\n - Remove is_pending_fork_parent_thread, as one can just use\n   thread_pending_fork_status and check for nullptr.\n - Replace is_pending_fork_parent with is_fork_status, which just\n   returns if the given target_waitkind if a fork or a vfork.  Push\n   filtering on the pid to the callers, when it is necessary.\n\nChange-Id: I0764ccc684d40f054e39df6fa5458cc4c5d1cd7b",
    "tree": {
      "sha": "ef00a04a38f8a5ef566bb331578d69ce87b04f01",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ef00a04a38f8a5ef566bb331578d69ce87b04f01"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/28561a655942f8e2a70a3b64e867223a60aae7b1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28561a655942f8e2a70a3b64e867223a60aae7b1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/28561a655942f8e2a70a3b64e867223a60aae7b1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28561a655942f8e2a70a3b64e867223a60aae7b1/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a4543480c5e7879955c57e20ab4e8935961153b5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a4543480c5e7879955c57e20ab4e8935961153b5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a4543480c5e7879955c57e20ab4e8935961153b5"
    }
  ],
  "stats": {
    "total": 115,
    "additions": 53,
    "deletions": 62
  },
  "files": [
    {
      "sha": "d70acdc26c06e00e82e85a137acaaa75f2678d3e",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 53,
      "deletions": 62,
      "changes": 115,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28561a655942f8e2a70a3b64e867223a60aae7b1/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28561a655942f8e2a70a3b64e867223a60aae7b1/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=28561a655942f8e2a70a3b64e867223a60aae7b1",
      "patch": "@@ -776,7 +776,7 @@ class remote_target : public process_stratum_target\n   void remote_btrace_maybe_reopen ();\n \n   void remove_new_fork_children (threads_listing_context *context);\n-  void kill_new_fork_children (int pid);\n+  void kill_new_fork_children (inferior *inf);\n   void discard_pending_stop_replies (struct inferior *inf);\n   int stop_reply_queue_length ();\n \n@@ -5876,45 +5876,30 @@ remote_target::open_1 (const char *name, int from_tty, int extended_p)\n     rs->wait_forever_enabled_p = 1;\n }\n \n-/* Determine if THREAD_PTID is a pending fork parent thread.  ARG contains\n-   the pid of the process that owns the threads we want to check, or\n-   -1 if we want to check all threads.  */\n+/* Determine if WS represents a fork status.  */\n \n-static int\n-is_pending_fork_parent (const target_waitstatus &ws, int event_pid,\n-\t\t\tptid_t thread_ptid)\n+static bool\n+is_fork_status (target_waitkind kind)\n {\n-  if (ws.kind () == TARGET_WAITKIND_FORKED\n-      || ws.kind () == TARGET_WAITKIND_VFORKED)\n-    {\n-      if (event_pid == -1 || event_pid == thread_ptid.pid ())\n-\treturn 1;\n-    }\n-\n-  return 0;\n+  return (kind == TARGET_WAITKIND_FORKED\n+\t  || kind == TARGET_WAITKIND_VFORKED);\n }\n \n-/* Return the thread's pending status used to determine whether the\n-   thread is a fork parent stopped at a fork event.  */\n+/* Return THREAD's pending status if it is a pending fork parent, else\n+   return nullptr.  */\n \n-static const target_waitstatus &\n+static const target_waitstatus *\n thread_pending_fork_status (struct thread_info *thread)\n {\n-  if (thread->has_pending_waitstatus ())\n-    return thread->pending_waitstatus ();\n-  else\n-    return thread->pending_follow;\n-}\n+  const target_waitstatus &ws\n+    = (thread->has_pending_waitstatus ()\n+       ? thread->pending_waitstatus ()\n+       : thread->pending_follow);\n \n-/* Determine if THREAD is a pending fork parent thread.  */\n+  if (!is_fork_status (ws.kind ()))\n+    return nullptr;\n \n-static int\n-is_pending_fork_parent_thread (struct thread_info *thread)\n-{\n-  const target_waitstatus &ws = thread_pending_fork_status (thread);\n-  int pid = -1;\n-\n-  return is_pending_fork_parent (ws, pid, thread->ptid);\n+  return &ws;\n }\n \n /* Detach the specified process.  */\n@@ -6828,7 +6813,7 @@ remote_target::commit_resumed ()\n       /* If a thread is the parent of an unfollowed fork, then we\n \t can't do a global wildcard, as that would resume the fork\n \t child.  */\n-      if (is_pending_fork_parent_thread (tp))\n+      if (thread_pending_fork_status (tp) != nullptr)\n \tmay_global_wildcard_vcont = false;\n     }\n \n@@ -7303,17 +7288,18 @@ struct notif_client notif_client_stop =\n void\n remote_target::remove_new_fork_children (threads_listing_context *context)\n {\n-  int pid = -1;\n   struct notif_client *notif = &notif_client_stop;\n \n   /* For any threads stopped at a fork event, remove the corresponding\n      fork child threads from the CONTEXT list.  */\n   for (thread_info *thread : all_non_exited_threads (this))\n     {\n-      const target_waitstatus &ws = thread_pending_fork_status (thread);\n+      const target_waitstatus *ws = thread_pending_fork_status (thread);\n+\n+      if (ws == nullptr)\n+\tcontinue;\n \n-      if (is_pending_fork_parent (ws, pid, thread->ptid))\n-\tcontext->remove_thread (ws.child_ptid ());\n+      context->remove_thread (ws->child_ptid ());\n     }\n \n   /* Check for any pending fork events (not reported or processed yet)\n@@ -10066,45 +10052,48 @@ remote_target::getpkt_or_notif_sane (gdb::char_vector *buf, int forever,\n   return getpkt_or_notif_sane_1 (buf, forever, 1, is_notif);\n }\n \n-/* Kill any new fork children of process PID that haven't been\n+/* Kill any new fork children of inferior INF that haven't been\n    processed by follow_fork.  */\n \n void\n-remote_target::kill_new_fork_children (int pid)\n+remote_target::kill_new_fork_children (inferior *inf)\n {\n   remote_state *rs = get_remote_state ();\n   struct notif_client *notif = &notif_client_stop;\n \n-  /* Kill the fork child threads of any threads in process PID\n-     that are stopped at a fork event.  */\n-  for (thread_info *thread : all_non_exited_threads (this))\n+  /* Kill the fork child threads of any threads in inferior INF that are stopped\n+     at a fork event.  */\n+  for (thread_info *thread : inf->non_exited_threads ())\n     {\n-      const target_waitstatus &ws = thread->pending_follow;\n+      const target_waitstatus *ws = thread_pending_fork_status (thread);\n \n-      if (is_pending_fork_parent (ws, pid, thread->ptid))\n-\t{\n-\t  int child_pid = ws.child_ptid ().pid ();\n-\t  int res;\n+      if (ws == nullptr)\n+\tcontinue;\n \n-\t  res = remote_vkill (child_pid);\n-\t  if (res != 0)\n-\t    error (_(\"Can't kill fork child process %d\"), child_pid);\n-\t}\n+      int child_pid = ws->child_ptid ().pid ();\n+      int res = remote_vkill (child_pid);\n+\n+      if (res != 0)\n+\terror (_(\"Can't kill fork child process %d\"), child_pid);\n     }\n \n   /* Check for any pending fork events (not reported or processed yet)\n-     in process PID and kill those fork child threads as well.  */\n+     in inferior INF and kill those fork child threads as well.  */\n   remote_notif_get_pending_events (notif);\n   for (auto &event : rs->stop_reply_queue)\n-    if (is_pending_fork_parent (event->ws, pid, event->ptid))\n-      {\n-\tint child_pid = event->ws.child_ptid ().pid ();\n-\tint res;\n+    {\n+      if (event->ptid.pid () != inf->pid)\n+\tcontinue;\n \n-\tres = remote_vkill (child_pid);\n-\tif (res != 0)\n-\t  error (_(\"Can't kill fork child process %d\"), child_pid);\n-      }\n+      if (!is_fork_status (event->ws.kind ()))\n+\tcontinue;\n+\n+      int child_pid = event->ws.child_ptid ().pid ();\n+      int res = remote_vkill (child_pid);\n+\n+      if (res != 0)\n+\terror (_(\"Can't kill fork child process %d\"), child_pid);\n+    }\n }\n \n \f\n@@ -10114,18 +10103,20 @@ void\n remote_target::kill ()\n {\n   int res = -1;\n-  int pid = inferior_ptid.pid ();\n+  inferior *inf = find_inferior_pid (this, inferior_ptid.pid ());\n   struct remote_state *rs = get_remote_state ();\n \n+  gdb_assert (inf != nullptr);\n+\n   if (packet_support (PACKET_vKill) != PACKET_DISABLE)\n     {\n       /* If we're stopped while forking and we haven't followed yet,\n \t kill the child task.  We need to do this before killing the\n \t parent task because if this is a vfork then the parent will\n \t be sleeping.  */\n-      kill_new_fork_children (pid);\n+      kill_new_fork_children (inf);\n \n-      res = remote_vkill (pid);\n+      res = remote_vkill (inf->pid);\n       if (res == 0)\n \t{\n \t  target_mourn_inferior (inferior_ptid);"
    }
  ]
}