{
  "sha": "d758e62c0ecca0c26547cfe40aa1f32d6e8464b7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDc1OGU2MmMwZWNjYTBjMjY1NDdjZmU0MGFhMWYzMmQ2ZTg0NjRiNw==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-12-13T01:35:05Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-02-03T01:15:00Z"
    },
    "message": "Factor out after-stop event handling code from stop_all_threads\n\nThis moves the code handling an event out of wait_one to a separate\nfunction, to be used in another context in a following patch.\n\ngdb/ChangeLog:\n\n\t* infrun.c (handle_one): New function, factored out from ...\n\t(stop_all_threads): ... here.",
    "tree": {
      "sha": "a6ff84e19b8089548fee67abb16f7acd86940610",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a6ff84e19b8089548fee67abb16f7acd86940610"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7e9cf1fe361dda0d6f06daeaa95eb98234f50764",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7e9cf1fe361dda0d6f06daeaa95eb98234f50764",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7e9cf1fe361dda0d6f06daeaa95eb98234f50764"
    }
  ],
  "stats": {
    "total": 295,
    "additions": 157,
    "deletions": 138
  },
  "files": [
    {
      "sha": "920df3ec3125277e46c7d9315c5c255aaffbf150",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d758e62c0ecca0c26547cfe40aa1f32d6e8464b7",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-03  Pedro Alves  <pedro@palves.net>\n+\n+\t* infrun.c (handle_one): New function, factored out from ...\n+\t(stop_all_threads): ... here.\n+\n 2021-02-03  Pedro Alves  <pedro@palves.net>\n \n \t* remote.c (remote_notif_stop_ack): Don't error out on"
    },
    {
      "sha": "51d60f4962959b9d30f81a4e1da0afba9ed25507",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 152,
      "deletions": 138,
      "changes": 290,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d758e62c0ecca0c26547cfe40aa1f32d6e8464b7/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=d758e62c0ecca0c26547cfe40aa1f32d6e8464b7",
      "patch": "@@ -4560,6 +4560,156 @@ mark_non_executing_threads (process_stratum_target *target,\n   set_resumed (target, mark_ptid, false);\n }\n \n+/* Handle one event after stopping threads.  If the eventing thread\n+   reports back any interesting event, we leave it pending.  If the\n+   eventing thread was in the middle of a displaced step, we\n+   cancel/finish it.  Returns true if there are no resumed threads\n+   left in the target (thus there's no point in waiting further),\n+   false otherwise.  */\n+\n+static bool\n+handle_one (const wait_one_event &event)\n+{\n+  infrun_debug_printf\n+    (\"%s %s\", target_waitstatus_to_string (&event.ws).c_str (),\n+     target_pid_to_str (event.ptid).c_str ());\n+\n+  if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n+    {\n+      /* All resumed threads exited.  */\n+      return true;\n+    }\n+  else if (event.ws.kind == TARGET_WAITKIND_THREAD_EXITED\n+\t   || event.ws.kind == TARGET_WAITKIND_EXITED\n+\t   || event.ws.kind == TARGET_WAITKIND_SIGNALLED)\n+    {\n+      /* One thread/process exited/signalled.  */\n+\n+      thread_info *t = nullptr;\n+\n+      /* The target may have reported just a pid.  If so, try\n+\t the first non-exited thread.  */\n+      if (event.ptid.is_pid ())\n+\t{\n+\t  int pid  = event.ptid.pid ();\n+\t  inferior *inf = find_inferior_pid (event.target, pid);\n+\t  for (thread_info *tp : inf->non_exited_threads ())\n+\t    {\n+\t      t = tp;\n+\t      break;\n+\t    }\n+\n+\t  /* If there is no available thread, the event would\n+\t     have to be appended to a per-inferior event list,\n+\t     which does not exist (and if it did, we'd have\n+\t     to adjust run control command to be able to\n+\t     resume such an inferior).  We assert here instead\n+\t     of going into an infinite loop.  */\n+\t  gdb_assert (t != nullptr);\n+\n+\t  infrun_debug_printf\n+\t    (\"using %s\", target_pid_to_str (t->ptid).c_str ());\n+\t}\n+      else\n+\t{\n+\t  t = find_thread_ptid (event.target, event.ptid);\n+\t  /* Check if this is the first time we see this thread.\n+\t     Don't bother adding if it individually exited.  */\n+\t  if (t == nullptr\n+\t      && event.ws.kind != TARGET_WAITKIND_THREAD_EXITED)\n+\t    t = add_thread (event.target, event.ptid);\n+\t}\n+\n+      if (t != nullptr)\n+\t{\n+\t  /* Set the threads as non-executing to avoid\n+\t     another stop attempt on them.  */\n+\t  switch_to_thread_no_regs (t);\n+\t  mark_non_executing_threads (event.target, event.ptid,\n+\t\t\t\t      event.ws);\n+\t  save_waitstatus (t, &event.ws);\n+\t  t->stop_requested = false;\n+\t}\n+    }\n+  else\n+    {\n+      thread_info *t = find_thread_ptid (event.target, event.ptid);\n+      if (t == NULL)\n+\tt = add_thread (event.target, event.ptid);\n+\n+      t->stop_requested = 0;\n+      t->executing = 0;\n+      t->resumed = false;\n+      t->control.may_range_step = 0;\n+\n+      /* This may be the first time we see the inferior report\n+\t a stop.  */\n+      inferior *inf = find_inferior_ptid (event.target, event.ptid);\n+      if (inf->needs_setup)\n+\t{\n+\t  switch_to_thread_no_regs (t);\n+\t  setup_inferior (0);\n+\t}\n+\n+      if (event.ws.kind == TARGET_WAITKIND_STOPPED\n+\t  && event.ws.value.sig == GDB_SIGNAL_0)\n+\t{\n+\t  /* We caught the event that we intended to catch, so\n+\t     there's no event pending.  */\n+\t  t->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+\t  t->suspend.waitstatus_pending_p = 0;\n+\n+\t  if (displaced_step_finish (t, GDB_SIGNAL_0)\n+\t      == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n+\t    {\n+\t      /* Add it back to the step-over queue.  */\n+\t      infrun_debug_printf\n+\t\t(\"displaced-step of %s canceled\",\n+\t\t target_pid_to_str (t->ptid).c_str ());\n+\n+\t      t->control.trap_expected = 0;\n+\t      global_thread_step_over_chain_enqueue (t);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  enum gdb_signal sig;\n+\t  struct regcache *regcache;\n+\n+\t  infrun_debug_printf\n+\t    (\"target_wait %s, saving status for %d.%ld.%ld\",\n+\t     target_waitstatus_to_string (&event.ws).c_str (),\n+\t     t->ptid.pid (), t->ptid.lwp (), t->ptid.tid ());\n+\n+\t  /* Record for later.  */\n+\t  save_waitstatus (t, &event.ws);\n+\n+\t  sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n+\t\t ? event.ws.value.sig : GDB_SIGNAL_0);\n+\n+\t  if (displaced_step_finish (t, sig)\n+\t      == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n+\t    {\n+\t      /* Add it back to the step-over queue.  */\n+\t      t->control.trap_expected = 0;\n+\t      global_thread_step_over_chain_enqueue (t);\n+\t    }\n+\n+\t  regcache = get_thread_regcache (t);\n+\t  t->suspend.stop_pc = regcache_read_pc (regcache);\n+\n+\t  infrun_debug_printf (\"saved stop_pc=%s for %s \"\n+\t\t\t       \"(currently_stepping=%d)\",\n+\t\t\t       paddress (target_gdbarch (),\n+\t\t\t\t\t t->suspend.stop_pc),\n+\t\t\t       target_pid_to_str (t->ptid).c_str (),\n+\t\t\t       currently_stepping (t));\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* See infrun.h.  */\n \n void\n@@ -4673,144 +4823,8 @@ stop_all_threads (void)\n \t  for (int i = 0; i < waits_needed; i++)\n \t    {\n \t      wait_one_event event = wait_one ();\n-\n-\t      infrun_debug_printf\n-\t\t(\"%s %s\", target_waitstatus_to_string (&event.ws).c_str (),\n-\t\t target_pid_to_str (event.ptid).c_str ());\n-\n-\t      if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n-\t\t{\n-\t\t  /* All resumed threads exited.  */\n-\t\t  break;\n-\t\t}\n-\t      else if (event.ws.kind == TARGET_WAITKIND_THREAD_EXITED\n-\t\t       || event.ws.kind == TARGET_WAITKIND_EXITED\n-\t\t       || event.ws.kind == TARGET_WAITKIND_SIGNALLED)\n-\t\t{\n-\t\t  /* One thread/process exited/signalled.  */\n-\n-\t\t  thread_info *t = nullptr;\n-\n-\t\t  /* The target may have reported just a pid.  If so, try\n-\t\t     the first non-exited thread.  */\n-\t\t  if (event.ptid.is_pid ())\n-\t\t    {\n-\t\t      int pid  = event.ptid.pid ();\n-\t\t      inferior *inf = find_inferior_pid (event.target, pid);\n-\t\t      for (thread_info *tp : inf->non_exited_threads ())\n-\t\t\t{\n-\t\t\t  t = tp;\n-\t\t\t  break;\n-\t\t\t}\n-\n-\t\t      /* If there is no available thread, the event would\n-\t\t\t have to be appended to a per-inferior event list,\n-\t\t\t which does not exist (and if it did, we'd have\n-\t\t\t to adjust run control command to be able to\n-\t\t\t resume such an inferior).  We assert here instead\n-\t\t\t of going into an infinite loop.  */\n-\t\t      gdb_assert (t != nullptr);\n-\n-\t\t      infrun_debug_printf\n-\t\t\t(\"using %s\", target_pid_to_str (t->ptid).c_str ());\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      t = find_thread_ptid (event.target, event.ptid);\n-\t\t      /* Check if this is the first time we see this thread.\n-\t\t\t Don't bother adding if it individually exited.  */\n-\t\t      if (t == nullptr\n-\t\t\t  && event.ws.kind != TARGET_WAITKIND_THREAD_EXITED)\n-\t\t\tt = add_thread (event.target, event.ptid);\n-\t\t    }\n-\n-\t\t  if (t != nullptr)\n-\t\t    {\n-\t\t      /* Set the threads as non-executing to avoid\n-\t\t\t another stop attempt on them.  */\n-\t\t      switch_to_thread_no_regs (t);\n-\t\t      mark_non_executing_threads (event.target, event.ptid,\n-\t\t\t\t\t\t  event.ws);\n-\t\t      save_waitstatus (t, &event.ws);\n-\t\t      t->stop_requested = false;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  thread_info *t = find_thread_ptid (event.target, event.ptid);\n-\t\t  if (t == NULL)\n-\t\t    t = add_thread (event.target, event.ptid);\n-\n-\t\t  t->stop_requested = 0;\n-\t\t  t->executing = 0;\n-\t\t  t->resumed = false;\n-\t\t  t->control.may_range_step = 0;\n-\n-\t\t  /* This may be the first time we see the inferior report\n-\t\t     a stop.  */\n-\t\t  inferior *inf = find_inferior_ptid (event.target, event.ptid);\n-\t\t  if (inf->needs_setup)\n-\t\t    {\n-\t\t      switch_to_thread_no_regs (t);\n-\t\t      setup_inferior (0);\n-\t\t    }\n-\n-\t\t  if (event.ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t      && event.ws.value.sig == GDB_SIGNAL_0)\n-\t\t    {\n-\t\t      /* We caught the event that we intended to catch, so\n-\t\t\t there's no event pending.  */\n-\t\t      t->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n-\t\t      t->suspend.waitstatus_pending_p = 0;\n-\n-\t\t      if (displaced_step_finish (t, GDB_SIGNAL_0)\n-\t\t\t  == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n-\t\t\t{\n-\t\t\t  /* Add it back to the step-over queue.  */\n-\t\t\t  infrun_debug_printf\n-\t\t\t    (\"displaced-step of %s canceled: adding back to \"\n-\t\t\t     \"the step-over queue\",\n-\t\t\t      target_pid_to_str (t->ptid).c_str ());\n-\n-\t\t\t  t->control.trap_expected = 0;\n-\t\t\t  global_thread_step_over_chain_enqueue (t);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      enum gdb_signal sig;\n-\t\t      struct regcache *regcache;\n-\n-\t\t      infrun_debug_printf\n-\t\t\t(\"target_wait %s, saving status for %d.%ld.%ld\",\n-\t\t\t target_waitstatus_to_string (&event.ws).c_str (),\n-\t\t\t t->ptid.pid (), t->ptid.lwp (), t->ptid.tid ());\n-\n-\t\t      /* Record for later.  */\n-\t\t      save_waitstatus (t, &event.ws);\n-\n-\t\t      sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t\t     ? event.ws.value.sig : GDB_SIGNAL_0);\n-\n-\t\t      if (displaced_step_finish (t, sig)\n-\t\t\t  == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n-\t\t\t{\n-\t\t\t  /* Add it back to the step-over queue.  */\n-\t\t\t  t->control.trap_expected = 0;\n-\t\t\t  global_thread_step_over_chain_enqueue (t);\n-\t\t\t}\n-\n-\t\t      regcache = get_thread_regcache (t);\n-\t\t      t->suspend.stop_pc = regcache_read_pc (regcache);\n-\n-\t\t      infrun_debug_printf (\"saved stop_pc=%s for %s \"\n-\t\t\t\t\t   \"(currently_stepping=%d)\",\n-\t\t\t\t\t   paddress (target_gdbarch (),\n-\t\t\t\t\t\t     t->suspend.stop_pc),\n-\t\t\t\t\t   target_pid_to_str (t->ptid).c_str (),\n-\t\t\t\t\t   currently_stepping (t));\n-\t\t    }\n-\t\t}\n+\t      if (handle_one (event))\n+\t\tbreak;\n \t    }\n \t}\n     }"
    }
  ]
}