{
  "sha": "71a2349005e74e0d64554f5c88e3632f3ace167a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzFhMjM0OTAwNWU3NGUwZDY0NTU0ZjVjODhlMzYzMmYzYWNlMTY3YQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-06-16T02:14:38Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-13T00:46:53Z"
    },
    "message": "gdb: optimize selection of resumed thread with pending event\n\nConsider a case where many threads (thousands) keep hitting a breakpoint\nwhose condition evaluates to false.  random_pending_event_thread is\nresponsible for selecting a thread from an inferior among all that are\nresumed with a pending wait status.  It is currently implemented by\nwalking the inferior's thread list twice: once to count the number of\ncandidates and once to select a random one.\n\nSince we now maintain a per target list of resumed threads with pending\nevent, we can implement this more efficiently by walking that list and\nselecting the first thread that matches the criteria\n(random_pending_event_thread looks for an thread from a specific\ninferior, and possibly a filter ptid).  It will be faster especially in\nthe common case where there isn't any resumed thread with pending\nevent.  Currently, we have to iterate the thread list to figure this\nout.  With this patch, the list of resumed threads with pending event\nwill be empty, so it's quick to figure out.\n\nThe random selection is kept, but is moved to\nprocess_stratum_target::random_resumed_with_pending_wait_status.  The\nsame technique is used: do a first pass to count the number of\ncandidates, and do a second pass to select a random one.  But given that\nthe list of resumed threads with pending wait statuses will generally be\nshort, or at least shorter than the full thread list, it should be\nquicker.\n\nNote that this isn't completely true, in case there are multiple\ninferiors on the same target.  Imagine that inferior A has 10k resumed\nthreads with pending wait statuses, and random_pending_event_thread is\ncalled with inferior B.  We'll need to go through the list that contains\ninferior A's threads to realize that inferior B has no resumed threads\nwith pending wait status.  But I think that this is a corner /\npathological case.  And a possible fix for this situation would be to\nmake random_pending_event_thread work per-process-target, rather than\nper-inferior.\n\nChange-Id: I1b71d01beaa500a148b5b9797745103e13917325",
    "tree": {
      "sha": "d88f0b96bb7c360e70b713b4de6e66ac733c0382",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d88f0b96bb7c360e70b713b4de6e66ac733c0382"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/71a2349005e74e0d64554f5c88e3632f3ace167a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/71a2349005e74e0d64554f5c88e3632f3ace167a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/71a2349005e74e0d64554f5c88e3632f3ace167a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/71a2349005e74e0d64554f5c88e3632f3ace167a/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "273dadf2c20b93ef579367c42c255fcf4a3a2522",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/273dadf2c20b93ef579367c42c255fcf4a3a2522",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/273dadf2c20b93ef579367c42c255fcf4a3a2522"
    }
  ],
  "stats": {
    "total": 88,
    "additions": 59,
    "deletions": 29
  },
  "files": [
    {
      "sha": "93cb55e70c7eca3131bbb61d25de9efe6fda75f1",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 11,
      "deletions": 29,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/71a2349005e74e0d64554f5c88e3632f3ace167a/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/71a2349005e74e0d64554f5c88e3632f3ace167a/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=71a2349005e74e0d64554f5c88e3632f3ace167a",
      "patch": "@@ -3492,39 +3492,21 @@ print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,\n static struct thread_info *\n random_pending_event_thread (inferior *inf, ptid_t waiton_ptid)\n {\n-  int num_events = 0;\n+  process_stratum_target *proc_target = inf->process_target ();\n+  thread_info *thread\n+    = proc_target->random_resumed_with_pending_wait_status (inf, waiton_ptid);\n \n-  auto has_event = [&] (thread_info *tp)\n+  if (thread == nullptr)\n     {\n-      return (tp->ptid.matches (waiton_ptid)\n-\t      && tp->resumed ()\n-\t      && tp->has_pending_waitstatus ());\n-    };\n-\n-  /* First see how many events we have.  Count only resumed threads\n-     that have an event pending.  */\n-  for (thread_info *tp : inf->non_exited_threads ())\n-    if (has_event (tp))\n-      num_events++;\n-\n-  if (num_events == 0)\n-    return NULL;\n-\n-  /* Now randomly pick a thread out of those that have had events.  */\n-  int random_selector = (int) ((num_events * (double) rand ())\n-\t\t\t       / (RAND_MAX + 1.0));\n-\n-  if (num_events > 1)\n-    infrun_debug_printf (\"Found %d events, selecting #%d\",\n-\t\t\t num_events, random_selector);\n+      infrun_debug_printf (\"None found.\");\n+      return nullptr;\n+    }\n \n-  /* Select the Nth thread that has had an event.  */\n-  for (thread_info *tp : inf->non_exited_threads ())\n-    if (has_event (tp))\n-      if (random_selector-- == 0)\n-\treturn tp;\n+  infrun_debug_printf (\"Found %s.\", target_pid_to_str (thread->ptid).c_str ());\n+  gdb_assert (thread->resumed ());\n+  gdb_assert (thread->has_pending_waitstatus ());\n \n-  gdb_assert_not_reached (\"event thread not found\");\n+  return thread;\n }\n \n /* Wrapper for target_wait that first checks whether threads have"
    },
    {
      "sha": "7aeda79e04c39a9cb1a4654b0ecec9500fb94c84",
      "filename": "gdb/process-stratum-target.c",
      "status": "modified",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/71a2349005e74e0d64554f5c88e3632f3ace167a/gdb/process-stratum-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/71a2349005e74e0d64554f5c88e3632f3ace167a/gdb/process-stratum-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.c?ref=71a2349005e74e0d64554f5c88e3632f3ace167a",
      "patch": "@@ -20,6 +20,7 @@\n #include \"defs.h\"\n #include \"process-stratum-target.h\"\n #include \"inferior.h\"\n+#include <algorithm>\n \n process_stratum_target::~process_stratum_target ()\n {\n@@ -140,6 +141,48 @@ process_stratum_target::maybe_remove_resumed_with_pending_wait_status\n \n /* See process-stratum-target.h.  */\n \n+thread_info *\n+process_stratum_target::random_resumed_with_pending_wait_status\n+  (inferior *inf, ptid_t filter_ptid)\n+{\n+  auto matches = [inf, filter_ptid] (const thread_info &thread)\n+    {\n+      return thread.inf == inf && thread.ptid.matches (filter_ptid);\n+    };\n+\n+  /* First see how many matching events we have.  */\n+  const auto &l = m_resumed_with_pending_wait_status;\n+  unsigned int count = std::count_if (l.begin (), l.end (), matches);\n+\n+  if (count == 0)\n+    return nullptr;\n+\n+  /* Now randomly pick a thread out of those that match the criteria.  */\n+  int random_selector\n+    = (int) ((count * (double) rand ()) / (RAND_MAX + 1.0));\n+\n+  if (count > 1)\n+    infrun_debug_printf (\"Found %u events, selecting #%d\",\n+\t\t\t count, random_selector);\n+\n+  /* Select the Nth thread that matches.  */\n+  auto it = std::find_if (l.begin (), l.end (),\n+\t\t\t  [&random_selector, &matches]\n+\t\t\t  (const thread_info &thread)\n+    {\n+      if (!matches (thread))\n+\treturn false;\n+\n+      return random_selector-- == 0;\n+    });\n+\n+  gdb_assert (it != l.end ());\n+\n+  return &*it;\n+}\n+\n+/* See process-stratum-target.h.  */\n+\n std::set<process_stratum_target *>\n all_non_exited_process_targets ()\n {"
    },
    {
      "sha": "ed6907c2bd1f29aa7c6685248919608545cadc21",
      "filename": "gdb/process-stratum-target.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/71a2349005e74e0d64554f5c88e3632f3ace167a/gdb/process-stratum-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/71a2349005e74e0d64554f5c88e3632f3ace167a/gdb/process-stratum-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.h?ref=71a2349005e74e0d64554f5c88e3632f3ace167a",
      "patch": "@@ -93,6 +93,11 @@ class process_stratum_target : public target_ops\n   bool has_resumed_with_pending_wait_status () const\n   { return !m_resumed_with_pending_wait_status.empty (); }\n \n+  /* Return a random resumed thread with pending wait status belonging to INF\n+     and matching FILTER_PTID.  */\n+  thread_info *random_resumed_with_pending_wait_status\n+    (inferior *inf, ptid_t filter_ptid);\n+\n   /* The connection number.  Visible in \"info connections\".  */\n   int connection_number = 0;\n "
    }
  ]
}