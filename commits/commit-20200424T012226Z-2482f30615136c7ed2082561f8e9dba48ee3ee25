{
  "sha": "2482f30615136c7ed2082561f8e9dba48ee3ee25",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjQ4MmYzMDYxNTEzNmM3ZWQyMDgyNTYxZjhlOWRiYTQ4ZWUzZWUyNQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-04-24T00:21:38Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-04-24T01:22:26Z"
    },
    "message": "readelf: memory leaks in process_dynamic_section\n\nThis fixes some code that assumed only one PT_LOAD would contain\nDT_SYMTAB.  Which is normally the case, but fuzzers thoroughly mess\nwith object files.\n\n\t* readelf.c (get_num_dynamic_syms): Check for nbuckets and nchains\n\tnon-zero.\n\t(process_dynamic_section): Call get_num_dynamic_syms once rather\n\tthan in segment loop.  Break out of segment loop on a successful\n\tload of dynamic symbols.  Formatting.\n\t(process_object): Return error status from process_dynamic_section.",
    "tree": {
      "sha": "df3f56c4b291b8997174c1eceb7c8e0526b6babc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/df3f56c4b291b8997174c1eceb7c8e0526b6babc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2482f30615136c7ed2082561f8e9dba48ee3ee25",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2482f30615136c7ed2082561f8e9dba48ee3ee25",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2482f30615136c7ed2082561f8e9dba48ee3ee25",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2482f30615136c7ed2082561f8e9dba48ee3ee25/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5e5bbc7e7917e23068a1b0bba381d125b5c9c7c1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5e5bbc7e7917e23068a1b0bba381d125b5c9c7c1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5e5bbc7e7917e23068a1b0bba381d125b5c9c7c1"
    }
  ],
  "stats": {
    "total": 148,
    "additions": 82,
    "deletions": 66
  },
  "files": [
    {
      "sha": "ad3846a1c2877a50c51f40668d14fbbdf7f0c86b",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2482f30615136c7ed2082561f8e9dba48ee3ee25/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2482f30615136c7ed2082561f8e9dba48ee3ee25/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=2482f30615136c7ed2082561f8e9dba48ee3ee25",
      "patch": "@@ -1,3 +1,12 @@\n+2020-04-24  Alan Modra  <amodra@gmail.com>\n+\n+\t* readelf.c (get_num_dynamic_syms): Check for nbuckets and nchains\n+\tnon-zero.\n+\t(process_dynamic_section): Call get_num_dynamic_syms once rather\n+\tthan in segment loop.  Break out of segment loop on a successful\n+\tload of dynamic symbols.  Formatting.\n+\t(process_object): Return error status from process_dynamic_section.\n+\n 2020-04-23  Anton Kolesov  <anton.kolesov@synopsys.com>\n \n \t* elf-bfd.h (elfcore_write_arc_v2): Add prototype."
    },
    {
      "sha": "8e8ade8fbe0b74ebf3835573fbc57ab795c7859d",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 73,
      "deletions": 66,
      "changes": 139,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2482f30615136c7ed2082561f8e9dba48ee3ee25/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2482f30615136c7ed2082561f8e9dba48ee3ee25/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=2482f30615136c7ed2082561f8e9dba48ee3ee25",
      "patch": "@@ -9993,14 +9993,16 @@ get_num_dynamic_syms (Filedata * filedata)\n       filedata->nbuckets = byte_get (nb, hash_ent_size);\n       filedata->nchains = byte_get (nc, hash_ent_size);\n \n-      filedata->buckets = get_dynamic_data (filedata, filedata->nbuckets,\n-\t\t\t\t\t    hash_ent_size);\n-      filedata->chains  = get_dynamic_data (filedata, filedata->nchains,\n-\t\t\t\t\t    hash_ent_size);\n-\n-      if (filedata->buckets != NULL && filedata->chains != NULL)\n-\tnum_of_syms = filedata->nchains;\n+      if (filedata->nbuckets != 0 && filedata->nchains != 0)\n+\t{\n+\t  filedata->buckets = get_dynamic_data (filedata, filedata->nbuckets,\n+\t\t\t\t\t\thash_ent_size);\n+\t  filedata->chains  = get_dynamic_data (filedata, filedata->nchains,\n+\t\t\t\t\t\thash_ent_size);\n \n+\t  if (filedata->buckets != NULL && filedata->chains != NULL)\n+\t    num_of_syms = filedata->nchains;\n+\t}\n     no_hash:\n       if (num_of_syms == 0)\n \t{\n@@ -10243,6 +10245,8 @@ process_dynamic_section (Filedata * filedata)\n   /* Find the appropriate symbol table.  */\n   if (filedata->dynamic_symbols == NULL || do_histogram)\n     {\n+      unsigned long num_of_syms;\n+\n       for (entry = filedata->dynamic_section;\n \t   entry < filedata->dynamic_section + filedata->dynamic_nent;\n \t   ++entry)\n@@ -10262,64 +10266,65 @@ process_dynamic_section (Filedata * filedata)\n \t    filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n \t  }\n \n-      if (filedata->dynamic_info[DT_SYMTAB]\n+      num_of_syms = get_num_dynamic_syms (filedata);\n+\n+      if (num_of_syms != 0\n+\t  && filedata->dynamic_symbols == NULL\n+\t  && filedata->dynamic_info[DT_SYMTAB]\n \t  && filedata->dynamic_info[DT_SYMENT])\n \t{\n \t  Elf_Internal_Phdr *seg;\n-\t    bfd_vma vma = filedata->dynamic_info[DT_SYMTAB];\n+\t  bfd_vma vma = filedata->dynamic_info[DT_SYMTAB];\n \n-\t    if (! get_program_headers (filedata))\n-\t      {\n-\t\terror (_(\"Cannot interpret virtual addresses without program headers.\\n\"));\n-\t\treturn FALSE;\n-\t      }\n-\n-\t    for (seg = filedata->program_headers;\n-\t\t seg < filedata->program_headers + filedata->file_header.e_phnum;\n-\t\t ++seg)\n-\t      {\n-\t\tunsigned long num_of_syms;\n+\t  if (! get_program_headers (filedata))\n+\t    {\n+\t      error (_(\"Cannot interpret virtual addresses \"\n+\t\t       \"without program headers.\\n\"));\n+\t      return FALSE;\n+\t    }\n \n-\t\tif (seg->p_type != PT_LOAD)\n-\t\t  continue;\n+\t  for (seg = filedata->program_headers;\n+\t       seg < filedata->program_headers + filedata->file_header.e_phnum;\n+\t       ++seg)\n+\t    {\n+\t      if (seg->p_type != PT_LOAD)\n+\t\tcontinue;\n \n-\t\tif ((seg->p_offset + seg->p_filesz)\n-\t\t    > filedata->file_size)\n-\t\t  {\n-\t\t    /* See PR 21379 for a reproducer.  */\n-\t\t    error (_(\"Invalid PT_LOAD entry\\n\"));\n-\t\t    return FALSE;\n-\t\t  }\n+\t      if (seg->p_offset + seg->p_filesz > filedata->file_size)\n+\t\t{\n+\t\t  /* See PR 21379 for a reproducer.  */\n+\t\t  error (_(\"Invalid PT_LOAD entry\\n\"));\n+\t\t  return FALSE;\n+\t\t}\n \n-\t\tif (vma >= (seg->p_vaddr & -seg->p_align)\n-\t\t    && vma <= seg->p_vaddr + seg->p_filesz\n-\t\t    && (num_of_syms = get_num_dynamic_syms (filedata)) != 0\n-\t\t    && filedata->dynamic_symbols == NULL)\n-\t\t  {\n-\t\t    /* Since we do not know how big the symbol table is,\n-\t\t       we default to reading in up to the end of PT_LOAD\n-\t\t       segment and processing that.  This is overkill, I\n-\t\t       know, but it should work.  */\n-\t\t    Elf_Internal_Shdr section;\n-\t\t    section.sh_offset = (vma - seg->p_vaddr\n-\t\t\t\t\t + seg->p_offset);\n-\t\t    section.sh_size = (num_of_syms\n-\t\t\t\t       * filedata->dynamic_info[DT_SYMENT]);\n-\t\t    section.sh_entsize = filedata->dynamic_info[DT_SYMENT];\n-\t\t    section.sh_name = filedata->string_table_length;\n-\t\t    filedata->dynamic_symbols\n-\t\t      = GET_ELF_SYMBOLS (filedata, &section,\n-\t\t\t\t\t &filedata->num_dynamic_syms);\n-\t\t    if (filedata->dynamic_symbols == NULL\n-\t\t\t|| filedata->num_dynamic_syms != num_of_syms)\n-\t\t      {\n-\t\t\terror (_(\"Corrupt DT_SYMTAB dynamic entry\\n\"));\n-\t\t\treturn FALSE;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n+\t      if (vma >= (seg->p_vaddr & -seg->p_align)\n+\t\t  && vma < seg->p_vaddr + seg->p_filesz)\n+\t\t{\n+\t\t  /* Since we do not know how big the symbol table is,\n+\t\t     we default to reading in up to the end of PT_LOAD\n+\t\t     segment and processing that.  This is overkill, I\n+\t\t     know, but it should work.  */\n+\t\t  Elf_Internal_Shdr section;\n+\t\t  section.sh_offset = (vma - seg->p_vaddr\n+\t\t\t\t       + seg->p_offset);\n+\t\t  section.sh_size = (num_of_syms\n+\t\t\t\t     * filedata->dynamic_info[DT_SYMENT]);\n+\t\t  section.sh_entsize = filedata->dynamic_info[DT_SYMENT];\n+\t\t  section.sh_name = filedata->string_table_length;\n+\t\t  filedata->dynamic_symbols\n+\t\t    = GET_ELF_SYMBOLS (filedata, &section,\n+\t\t\t\t       &filedata->num_dynamic_syms);\n+\t\t  if (filedata->dynamic_symbols == NULL\n+\t\t      || filedata->num_dynamic_syms != num_of_syms)\n+\t\t    {\n+\t\t      error (_(\"Corrupt DT_SYMTAB dynamic entry\\n\"));\n+\t\t      return FALSE;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   /* Similarly find a string table.  */\n   if (filedata->dynamic_strings == NULL)\n@@ -10403,14 +10408,17 @@ process_dynamic_section (Filedata * filedata)\n \t  filedata->dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);\n \t  if (filedata->dynamic_syminfo == NULL)\n \t    {\n-\t      error (_(\"Out of memory allocating %lu byte for dynamic symbol info\\n\"),\n+\t      error (_(\"Out of memory allocating %lu bytes \"\n+\t\t       \"for dynamic symbol info\\n\"),\n \t\t     (unsigned long) syminsz);\n \t      return FALSE;\n \t    }\n \n-\t  filedata->dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);\n+\t  filedata->dynamic_syminfo_nent\n+\t    = syminsz / sizeof (Elf_External_Syminfo);\n \t  for (syminfo = filedata->dynamic_syminfo, extsym = extsyminfo;\n-\t       syminfo < filedata->dynamic_syminfo + filedata->dynamic_syminfo_nent;\n+\t       syminfo < (filedata->dynamic_syminfo\n+\t\t\t  + filedata->dynamic_syminfo_nent);\n \t       ++syminfo, ++extsym)\n \t    {\n \t      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);\n@@ -20120,7 +20128,7 @@ process_object (Filedata * filedata)\n {\n   bfd_boolean  have_separate_files;\n   unsigned int i;\n-  bfd_boolean res = TRUE;\n+  bfd_boolean res;\n \n   if (! get_file_header (filedata))\n     {\n@@ -20176,10 +20184,9 @@ process_object (Filedata * filedata)\n     /* Without loaded section groups we cannot process unwind.  */\n     do_unwind = FALSE;\n \n-  if (process_program_headers (filedata))\n-    process_dynamic_section (filedata);\n-  else\n-    res = FALSE;\n+  res = process_program_headers (filedata);\n+  if (res)\n+    res = process_dynamic_section (filedata);\n \n   if (! process_relocs (filedata))\n     res = FALSE;"
    }
  ]
}