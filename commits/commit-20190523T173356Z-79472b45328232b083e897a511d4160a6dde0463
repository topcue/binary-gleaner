{
  "sha": "79472b45328232b083e897a511d4160a6dde0463",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzk0NzJiNDUzMjgyMzJiMDgzZTg5N2E1MTFkNDE2MGE2ZGRlMDQ2Mw==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-05-23T17:04:36Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2019-05-23T17:33:56Z"
    },
    "message": "opcodes: add support for eBPF\n\nThis patch adds support for the Linux kernel eBPF architecture to the\nopcodes.  The port is based on CGEN.\n\nopcodes/ChangeLog:\n\n2019-05-23  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\n\t* configure.ac (SHARED_DEPENDENCIES): Add case for bfd_bpf_arch.\n\t* configure: Regenerated.\n\t* Makefile.am: Add rules for the files generated from cpu/bpf.cpu\n\tand cpu/bpf.opc.\n\t(HFILES): Add bpf-desc.h and bpf-opc.h.\n\t(TARGET_LIBOPCODES_CFILES): Add bpf-asm.c, bpf-desc.c, bpf-dis.c,\n\tbpf-ibld.c and bpf-opc.c.\n\t(BPF_DEPS): Define.\n\t* Makefile.in: Regenerated.\n\t* disassemble.c (ARCH_bpf): Define.\n\t(disassembler): Add case for bfd_arch_bpf.\n\t(disassemble_init_for_target): Likewise.\n\t(enum epbf_isa_attr): Define.\n\t* disassemble.h: extern print_insn_bpf.\n\t* bpf-asm.c: Generated.\n\t* bpf-opc.h: Likewise.\n\t* bpf-opc.c: Likewise.\n\t* bpf-ibld.c: Likewise.\n\t* bpf-dis.c: Likewise.\n\t* bpf-desc.h: Likewise.\n\t* bpf-desc.c: Likewise.",
    "tree": {
      "sha": "ff50820cf858918ae1115a0c6e6829633de3fffc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ff50820cf858918ae1115a0c6e6829633de3fffc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/79472b45328232b083e897a511d4160a6dde0463",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/79472b45328232b083e897a511d4160a6dde0463",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/79472b45328232b083e897a511d4160a6dde0463",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/79472b45328232b083e897a511d4160a6dde0463/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ea195bb04cc5c964126aeff0f87d7161a03ca926",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea195bb04cc5c964126aeff0f87d7161a03ca926",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ea195bb04cc5c964126aeff0f87d7161a03ca926"
    }
  ],
  "stats": {
    "total": 5840,
    "additions": 5837,
    "deletions": 3
  },
  "files": [
    {
      "sha": "7853ffac1408c399278ac3f4cde4a2be7b222d47",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -1,3 +1,27 @@\n+2019-05-23  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* configure.ac (SHARED_DEPENDENCIES): Add case for bfd_bpf_arch.\n+\t* configure: Regenerated.\n+\t* Makefile.am: Add rules for the files generated from cpu/bpf.cpu\n+\tand cpu/bpf.opc.\n+\t(HFILES): Add bpf-desc.h and bpf-opc.h.\n+\t(TARGET_LIBOPCODES_CFILES): Add bpf-asm.c, bpf-desc.c, bpf-dis.c,\n+\tbpf-ibld.c and bpf-opc.c.\n+\t(BPF_DEPS): Define.\n+\t* Makefile.in: Regenerated.\n+\t* disassemble.c (ARCH_bpf): Define.\n+\t(disassembler): Add case for bfd_arch_bpf.\n+\t(disassemble_init_for_target): Likewise.\n+\t(enum epbf_isa_attr): Define.\n+\t* disassemble.h: extern print_insn_bpf.\n+\t* bpf-asm.c: Generated.\n+\t* bpf-opc.h: Likewise.\n+\t* bpf-opc.c: Likewise.\n+\t* bpf-ibld.c: Likewise.\n+\t* bpf-dis.c: Likewise.\n+\t* bpf-desc.h: Likewise.\n+\t* bpf-desc.c: Likewise.\n+\n 2019-05-21  Sudakshina Das  <sudi.das@arm.com>\n \n \t* arm-dis.c (coprocessor_opcodes): New instructions for VMRS"
    },
    {
      "sha": "20a8a8d2c0d2eed6e7d087f1eff4d30250cf9b71",
      "filename": "opcodes/Makefile.am",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/Makefile.am?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -59,6 +59,7 @@ BUILD_LIB_DEPS = @BUILD_LIB_DEPS@\n # Header files.\n HFILES = \\\n \taarch64-asm.h aarch64-dis.h aarch64-opc.h aarch64-tbl.h \\\n+\tbpf-desc.h bpf-opc.h \\\n \tepiphany-desc.h epiphany-opc.h \\\n \tfr30-desc.h fr30-opc.h \\\n \tfrv-desc.h frv-opc.h \\\n@@ -117,6 +118,11 @@ TARGET_LIBOPCODES_CFILES = \\\n \td30v-dis.c \\\n \td30v-opc.c \\\n \tdlx-dis.c \\\n+\tbpf-asm.c \\\n+\tbpf-desc.c \\\n+\tbpf-dis.c \\\n+\tbpf-ibld.c \\\n+\tbpf-opc.c \\\n \tepiphany-asm.c \\\n \tepiphany-desc.c \\\n \tepiphany-dis.c \\\n@@ -370,6 +376,7 @@ CGENDEPS = \\\n CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16\n \n if CGEN_MAINT\n+BPF_DEPS = stamp-bpf\n EPIPHANY_DEPS = stamp-epiphany\n FR30_DEPS = stamp-fr30\n FRV_DEPS = stamp-frv\n@@ -384,6 +391,7 @@ OR1K_DEPS = stamp-or1k\n XC16X_DEPS = stamp-xc16x\n XSTORMY16_DEPS = stamp-xstormy16\n else\n+BPF_DEPS =\n EPIPHANY_DEPS =\n FR30_DEPS =\n FRV_DEPS =\n@@ -416,6 +424,15 @@ run-cgen-all:\n \n # For now, require developers to configure with --enable-cgen-maint.\n \n+$(srcdir)/bpf-desc.h $(srcdir)/bpf-desc.c $(srcdir)/bpf-opc.h \\\n+\t\t$(srcdir)/bpf-opc.c $(srcdir)/bpf-ibld.c \\\n+\t\t$(srcdir)/bpf-asm.c $(srcdir)/bpf-dis.c: $(BPF_DEPS)\n+\t@true\n+\n+stamp-bpf: $(CGENDEPS) $(CPUDIR)/bpf.cpu $(CPUDIR)/bpf.opc\n+\t$(MAKE) run-cgen arch=bpf prefix=bpf \\\n+\t\tarchfile=$(CPUDIR)/bpf.cpu opcfile=$(CPUDIR)/bpf.opc\n+\n $(srcdir)/epiphany-desc.h $(srcdir)/epiphany-desc.c $(srcdir)/epiphany-opc.h \\\n \t\t$(srcdir)/epiphany-opc.c $(srcdir)/epiphany-ibld.c \\\n \t\t$(srcdir)/epiphany-opinst.c $(srcdir)/epiphany-asm.c \\"
    },
    {
      "sha": "ee8b31153fbea481b44e189a2bf713acd58a0c75",
      "filename": "opcodes/Makefile.in",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/Makefile.in?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -408,6 +408,7 @@ pdfdir = @pdfdir@\n prefix = @prefix@\n program_transform_name = @program_transform_name@\n psdir = @psdir@\n+runstatedir = @runstatedir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n srcdir = @srcdir@\n@@ -448,6 +449,7 @@ BFD_H = ../bfd/bfd.h\n # Header files.\n HFILES = \\\n \taarch64-asm.h aarch64-dis.h aarch64-opc.h aarch64-tbl.h \\\n+\tbpf-desc.h bpf-opc.h \\\n \tepiphany-desc.h epiphany-opc.h \\\n \tfr30-desc.h fr30-opc.h \\\n \tfrv-desc.h frv-opc.h \\\n@@ -507,6 +509,11 @@ TARGET_LIBOPCODES_CFILES = \\\n \td30v-dis.c \\\n \td30v-opc.c \\\n \tdlx-dis.c \\\n+\tbpf-asm.c \\\n+\tbpf-desc.c \\\n+\tbpf-dis.c \\\n+\tbpf-ibld.c \\\n+\tbpf-opc.c \\\n \tepiphany-asm.c \\\n \tepiphany-desc.c \\\n \tepiphany-dis.c \\\n@@ -725,6 +732,8 @@ CGENDEPS = \\\n \tcgen-asm.in cgen-dis.in cgen-ibld.in\n \n CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16\n+@CGEN_MAINT_FALSE@BPF_DEPS = \n+@CGEN_MAINT_TRUE@BPF_DEPS = stamp-bpf\n @CGEN_MAINT_FALSE@EPIPHANY_DEPS = \n @CGEN_MAINT_TRUE@EPIPHANY_DEPS = stamp-epiphany\n @CGEN_MAINT_FALSE@FR30_DEPS = \n@@ -897,6 +906,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/arm-dis.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/avr-dis.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bfin-dis.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bpf-asm.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bpf-desc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bpf-dis.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bpf-ibld.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bpf-opc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cgen-asm.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cgen-bitset.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cgen-dis.Plo@am__quote@\n@@ -1398,6 +1412,15 @@ run-cgen-all:\n \n # For now, require developers to configure with --enable-cgen-maint.\n \n+$(srcdir)/bpf-desc.h $(srcdir)/bpf-desc.c $(srcdir)/bpf-opc.h \\\n+\t\t$(srcdir)/bpf-opc.c $(srcdir)/bpf-ibld.c \\\n+\t\t$(srcdir)/bpf-asm.c $(srcdir)/bpf-dis.c: $(BPF_DEPS)\n+\t@true\n+\n+stamp-bpf: $(CGENDEPS) $(CPUDIR)/bpf.cpu $(CPUDIR)/bpf.opc\n+\t$(MAKE) run-cgen arch=bpf prefix=bpf \\\n+\t\tarchfile=$(CPUDIR)/bpf.cpu opcfile=$(CPUDIR)/bpf.opc\n+\n $(srcdir)/epiphany-desc.h $(srcdir)/epiphany-desc.c $(srcdir)/epiphany-opc.h \\\n \t\t$(srcdir)/epiphany-opc.c $(srcdir)/epiphany-ibld.c \\\n \t\t$(srcdir)/epiphany-opinst.c $(srcdir)/epiphany-asm.c \\"
    },
    {
      "sha": "4332edcc5e08db4b837c63a55dcdac4493195451",
      "filename": "opcodes/bpf-asm.c",
      "status": "added",
      "additions": 590,
      "deletions": 0,
      "changes": 590,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-asm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-asm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-asm.c?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,590 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* Assembler interface for targets using CGEN. -*- C -*-\n+   CGEN: Cpu tools GENerator\n+\n+   THIS FILE IS MACHINE GENERATED WITH CGEN.\n+   - the resultant file is machine generated, cgen-asm.in isn't\n+\n+   Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+   This file is part of libopcodes.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+\n+/* ??? Eventually more and more of this stuff can go to cpu-independent files.\n+   Keep that in mind.  */\n+\n+#include \"sysdep.h\"\n+#include <stdio.h>\n+#include \"ansidecl.h\"\n+#include \"bfd.h\"\n+#include \"symcat.h\"\n+#include \"bpf-desc.h\"\n+#include \"bpf-opc.h\"\n+#include \"opintl.h\"\n+#include \"xregex.h\"\n+#include \"libiberty.h\"\n+#include \"safe-ctype.h\"\n+\n+#undef  min\n+#define min(a,b) ((a) < (b) ? (a) : (b))\n+#undef  max\n+#define max(a,b) ((a) > (b) ? (a) : (b))\n+\n+static const char * parse_insn_normal\n+  (CGEN_CPU_DESC, const CGEN_INSN *, const char **, CGEN_FIELDS *);\n+\f\n+/* -- assembler routines inserted here.  */\n+\n+/* -- asm.c */\n+\n+/* Parse a signed 64-bit immediate.  */\n+\n+static const char *\n+parse_imm64 (CGEN_CPU_DESC cd,\n+             const char **strp,\n+             int opindex,\n+             int64_t *valuep)\n+{\n+  bfd_vma value;\n+  enum cgen_parse_operand_result result;\n+  const char *errmsg;\n+\n+  errmsg = (* cd->parse_operand_fn)\n+    (cd, CGEN_PARSE_OPERAND_INTEGER, strp, opindex, BFD_RELOC_NONE,\n+     &result, &value);\n+  if (!errmsg)\n+    *valuep = value;\n+\n+  return errmsg;\n+}\n+\n+/* Endianness size operands are integer immediates whose values can be\n+   16, 32 or 64.  */\n+\n+static const char *\n+parse_endsize (CGEN_CPU_DESC cd,\n+               const char **strp,\n+               int opindex,\n+               unsigned long *valuep)\n+{\n+  const char *errmsg;\n+\n+  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);\n+  if (errmsg)\n+    return errmsg;\n+\n+  switch (*valuep)\n+    {\n+    case 16:\n+    case 32:\n+    case 64:\n+      break;\n+    default:\n+      return _(\"expected 16, 32 or 64 in\");\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Special check to ensure that the right instruction variant is used\n+   for the given endianness induced by the ISA selected in the CPU.\n+   See bpf.cpu for a discussion on how eBPF is really two instruction\n+   sets.  */\n+\n+int\n+bpf_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)\n+{\n+  CGEN_BITSET isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);\n+\n+  return cgen_bitset_intersect_p (&isas, cd->isas);\n+}\n+\n+\f\n+/* -- dis.c */\n+\n+const char * bpf_cgen_parse_operand\n+  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);\n+\n+/* Main entry point for operand parsing.\n+\n+   This function is basically just a big switch statement.  Earlier versions\n+   used tables to look up the function to use, but\n+   - if the table contains both assembler and disassembler functions then\n+     the disassembler contains much of the assembler and vice-versa,\n+   - there's a lot of inlining possibilities as things grow,\n+   - using a switch statement avoids the function call overhead.\n+\n+   This function could be moved into `parse_insn_normal', but keeping it\n+   separate makes clear the interface between `parse_insn_normal' and each of\n+   the handlers.  */\n+\n+const char *\n+bpf_cgen_parse_operand (CGEN_CPU_DESC cd,\n+\t\t\t   int opindex,\n+\t\t\t   const char ** strp,\n+\t\t\t   CGEN_FIELDS * fields)\n+{\n+  const char * errmsg = NULL;\n+  /* Used by scalar operands that still need to be parsed.  */\n+  long junk ATTRIBUTE_UNUSED;\n+\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      errmsg = cgen_parse_signed_integer (cd, strp, BPF_OPERAND_DISP16, (long *) (& fields->f_offset16));\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      errmsg = cgen_parse_signed_integer (cd, strp, BPF_OPERAND_DISP32, (long *) (& fields->f_imm32));\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      errmsg = cgen_parse_keyword (cd, strp, & bpf_cgen_opval_h_gpr, & fields->f_dstbe);\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      errmsg = cgen_parse_keyword (cd, strp, & bpf_cgen_opval_h_gpr, & fields->f_dstle);\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      errmsg = parse_endsize (cd, strp, BPF_OPERAND_ENDSIZE, (unsigned long *) (& fields->f_imm32));\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      errmsg = cgen_parse_signed_integer (cd, strp, BPF_OPERAND_IMM32, (long *) (& fields->f_imm32));\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      errmsg = parse_imm64 (cd, strp, BPF_OPERAND_IMM64, (int64_t *) (& fields->f_imm64));\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      errmsg = cgen_parse_signed_integer (cd, strp, BPF_OPERAND_OFFSET16, (long *) (& fields->f_offset16));\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      errmsg = cgen_parse_keyword (cd, strp, & bpf_cgen_opval_h_gpr, & fields->f_srcbe);\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      errmsg = cgen_parse_keyword (cd, strp, & bpf_cgen_opval_h_gpr, & fields->f_srcle);\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while parsing\"),\n+\t opindex);\n+      abort ();\n+  }\n+\n+  return errmsg;\n+}\n+\n+cgen_parse_fn * const bpf_cgen_parse_handlers[] =\n+{\n+  parse_insn_normal,\n+};\n+\n+void\n+bpf_cgen_init_asm (CGEN_CPU_DESC cd)\n+{\n+  bpf_cgen_init_opcode_table (cd);\n+  bpf_cgen_init_ibld_table (cd);\n+  cd->parse_handlers = & bpf_cgen_parse_handlers[0];\n+  cd->parse_operand = bpf_cgen_parse_operand;\n+#ifdef CGEN_ASM_INIT_HOOK\n+CGEN_ASM_INIT_HOOK\n+#endif\n+}\n+\n+\f\n+\n+/* Regex construction routine.\n+\n+   This translates an opcode syntax string into a regex string,\n+   by replacing any non-character syntax element (such as an\n+   opcode) with the pattern '.*'\n+\n+   It then compiles the regex and stores it in the opcode, for\n+   later use by bpf_cgen_assemble_insn\n+\n+   Returns NULL for success, an error message for failure.  */\n+\n+char *\n+bpf_cgen_build_insn_regex (CGEN_INSN *insn)\n+{\n+  CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);\n+  const char *mnem = CGEN_INSN_MNEMONIC (insn);\n+  char rxbuf[CGEN_MAX_RX_ELEMENTS];\n+  char *rx = rxbuf;\n+  const CGEN_SYNTAX_CHAR_TYPE *syn;\n+  int reg_err;\n+\n+  syn = CGEN_SYNTAX_STRING (CGEN_OPCODE_SYNTAX (opc));\n+\n+  /* Mnemonics come first in the syntax string.  */\n+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))\n+    return _(\"missing mnemonic in syntax string\");\n+  ++syn;\n+\n+  /* Generate a case sensitive regular expression that emulates case\n+     insensitive matching in the \"C\" locale.  We cannot generate a case\n+     insensitive regular expression because in Turkish locales, 'i' and 'I'\n+     are not equal modulo case conversion.  */\n+\n+  /* Copy the literal mnemonic out of the insn.  */\n+  for (; *mnem; mnem++)\n+    {\n+      char c = *mnem;\n+\n+      if (ISALPHA (c))\n+\t{\n+\t  *rx++ = '[';\n+\t  *rx++ = TOLOWER (c);\n+\t  *rx++ = TOUPPER (c);\n+\t  *rx++ = ']';\n+\t}\n+      else\n+\t*rx++ = c;\n+    }\n+\n+  /* Copy any remaining literals from the syntax string into the rx.  */\n+  for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)\n+    {\n+      if (CGEN_SYNTAX_CHAR_P (* syn))\n+\t{\n+\t  char c = CGEN_SYNTAX_CHAR (* syn);\n+\n+\t  switch (c)\n+\t    {\n+\t      /* Escape any regex metacharacters in the syntax.  */\n+\t    case '.': case '[': case '\\\\':\n+\t    case '*': case '^': case '$':\n+\n+#ifdef CGEN_ESCAPE_EXTENDED_REGEX\n+\t    case '?': case '{': case '}':\n+\t    case '(': case ')': case '*':\n+\t    case '|': case '+': case ']':\n+#endif\n+\t      *rx++ = '\\\\';\n+\t      *rx++ = c;\n+\t      break;\n+\n+\t    default:\n+\t      if (ISALPHA (c))\n+\t\t{\n+\t\t  *rx++ = '[';\n+\t\t  *rx++ = TOLOWER (c);\n+\t\t  *rx++ = TOUPPER (c);\n+\t\t  *rx++ = ']';\n+\t\t}\n+\t      else\n+\t\t*rx++ = c;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Replace non-syntax fields with globs.  */\n+\t  *rx++ = '.';\n+\t  *rx++ = '*';\n+\t}\n+    }\n+\n+  /* Trailing whitespace ok.  */\n+  * rx++ = '[';\n+  * rx++ = ' ';\n+  * rx++ = '\\t';\n+  * rx++ = ']';\n+  * rx++ = '*';\n+\n+  /* But anchor it after that.  */\n+  * rx++ = '$';\n+  * rx = '\\0';\n+\n+  CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));\n+  reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);\n+\n+  if (reg_err == 0)\n+    return NULL;\n+  else\n+    {\n+      static char msg[80];\n+\n+      regerror (reg_err, (regex_t *) CGEN_INSN_RX (insn), msg, 80);\n+      regfree ((regex_t *) CGEN_INSN_RX (insn));\n+      free (CGEN_INSN_RX (insn));\n+      (CGEN_INSN_RX (insn)) = NULL;\n+      return msg;\n+    }\n+}\n+\n+\f\n+/* Default insn parser.\n+\n+   The syntax string is scanned and operands are parsed and stored in FIELDS.\n+   Relocs are queued as we go via other callbacks.\n+\n+   ??? Note that this is currently an all-or-nothing parser.  If we fail to\n+   parse the instruction, we return 0 and the caller will start over from\n+   the beginning.  Backtracking will be necessary in parsing subexpressions,\n+   but that can be handled there.  Not handling backtracking here may get\n+   expensive in the case of the m68k.  Deal with later.\n+\n+   Returns NULL for success, an error message for failure.  */\n+\n+static const char *\n+parse_insn_normal (CGEN_CPU_DESC cd,\n+\t\t   const CGEN_INSN *insn,\n+\t\t   const char **strp,\n+\t\t   CGEN_FIELDS *fields)\n+{\n+  /* ??? Runtime added insns not handled yet.  */\n+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);\n+  const char *str = *strp;\n+  const char *errmsg;\n+  const char *p;\n+  const CGEN_SYNTAX_CHAR_TYPE * syn;\n+#ifdef CGEN_MNEMONIC_OPERANDS\n+  /* FIXME: wip */\n+  int past_opcode_p;\n+#endif\n+\n+  /* For now we assume the mnemonic is first (there are no leading operands).\n+     We can parse it without needing to set up operand parsing.\n+     GAS's input scrubber will ensure mnemonics are lowercase, but we may\n+     not be called from GAS.  */\n+  p = CGEN_INSN_MNEMONIC (insn);\n+  while (*p && TOLOWER (*p) == TOLOWER (*str))\n+    ++p, ++str;\n+\n+  if (* p)\n+    return _(\"unrecognized instruction\");\n+\n+#ifndef CGEN_MNEMONIC_OPERANDS\n+  if (* str && ! ISSPACE (* str))\n+    return _(\"unrecognized instruction\");\n+#endif\n+\n+  CGEN_INIT_PARSE (cd);\n+  cgen_init_parse_operand (cd);\n+#ifdef CGEN_MNEMONIC_OPERANDS\n+  past_opcode_p = 0;\n+#endif\n+\n+  /* We don't check for (*str != '\\0') here because we want to parse\n+     any trailing fake arguments in the syntax string.  */\n+  syn = CGEN_SYNTAX_STRING (syntax);\n+\n+  /* Mnemonics come first for now, ensure valid string.  */\n+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))\n+    abort ();\n+\n+  ++syn;\n+\n+  while (* syn != 0)\n+    {\n+      /* Non operand chars must match exactly.  */\n+      if (CGEN_SYNTAX_CHAR_P (* syn))\n+\t{\n+\t  /* FIXME: While we allow for non-GAS callers above, we assume the\n+\t     first char after the mnemonic part is a space.  */\n+\t  /* FIXME: We also take inappropriate advantage of the fact that\n+\t     GAS's input scrubber will remove extraneous blanks.  */\n+\t  if (TOLOWER (*str) == TOLOWER (CGEN_SYNTAX_CHAR (* syn)))\n+\t    {\n+#ifdef CGEN_MNEMONIC_OPERANDS\n+\t      if (CGEN_SYNTAX_CHAR(* syn) == ' ')\n+\t\tpast_opcode_p = 1;\n+#endif\n+\t      ++ syn;\n+\t      ++ str;\n+\t    }\n+\t  else if (*str)\n+\t    {\n+\t      /* Syntax char didn't match.  Can't be this insn.  */\n+\t      static char msg [80];\n+\n+\t      /* xgettext:c-format */\n+\t      sprintf (msg, _(\"syntax error (expected char `%c', found `%c')\"),\n+\t\t       CGEN_SYNTAX_CHAR(*syn), *str);\n+\t      return msg;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Ran out of input.  */\n+\t      static char msg [80];\n+\n+\t      /* xgettext:c-format */\n+\t      sprintf (msg, _(\"syntax error (expected char `%c', found end of instruction)\"),\n+\t\t       CGEN_SYNTAX_CHAR(*syn));\n+\t      return msg;\n+\t    }\n+\t  continue;\n+\t}\n+\n+#ifdef CGEN_MNEMONIC_OPERANDS\n+      (void) past_opcode_p;\n+#endif\n+      /* We have an operand of some sort.  */\n+      errmsg = cd->parse_operand (cd, CGEN_SYNTAX_FIELD (*syn), &str, fields);\n+      if (errmsg)\n+\treturn errmsg;\n+\n+      /* Done with this operand, continue with next one.  */\n+      ++ syn;\n+    }\n+\n+  /* If we're at the end of the syntax string, we're done.  */\n+  if (* syn == 0)\n+    {\n+      /* FIXME: For the moment we assume a valid `str' can only contain\n+\t blanks now.  IE: We needn't try again with a longer version of\n+\t the insn and it is assumed that longer versions of insns appear\n+\t before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */\n+      while (ISSPACE (* str))\n+\t++ str;\n+\n+      if (* str != '\\0')\n+\treturn _(\"junk at end of line\"); /* FIXME: would like to include `str' */\n+\n+      return NULL;\n+    }\n+\n+  /* We couldn't parse it.  */\n+  return _(\"unrecognized instruction\");\n+}\n+\f\n+/* Main entry point.\n+   This routine is called for each instruction to be assembled.\n+   STR points to the insn to be assembled.\n+   We assume all necessary tables have been initialized.\n+   The assembled instruction, less any fixups, is stored in BUF.\n+   Remember that if CGEN_INT_INSN_P then BUF is an int and thus the value\n+   still needs to be converted to target byte order, otherwise BUF is an array\n+   of bytes in target byte order.\n+   The result is a pointer to the insn's entry in the opcode table,\n+   or NULL if an error occured (an error message will have already been\n+   printed).\n+\n+   Note that when processing (non-alias) macro-insns,\n+   this function recurses.\n+\n+   ??? It's possible to make this cpu-independent.\n+   One would have to deal with a few minor things.\n+   At this point in time doing so would be more of a curiosity than useful\n+   [for example this file isn't _that_ big], but keeping the possibility in\n+   mind helps keep the design clean.  */\n+\n+const CGEN_INSN *\n+bpf_cgen_assemble_insn (CGEN_CPU_DESC cd,\n+\t\t\t   const char *str,\n+\t\t\t   CGEN_FIELDS *fields,\n+\t\t\t   CGEN_INSN_BYTES_PTR buf,\n+\t\t\t   char **errmsg)\n+{\n+  const char *start;\n+  CGEN_INSN_LIST *ilist;\n+  const char *parse_errmsg = NULL;\n+  const char *insert_errmsg = NULL;\n+  int recognized_mnemonic = 0;\n+\n+  /* Skip leading white space.  */\n+  while (ISSPACE (* str))\n+    ++ str;\n+\n+  /* The instructions are stored in hashed lists.\n+     Get the first in the list.  */\n+  ilist = CGEN_ASM_LOOKUP_INSN (cd, str);\n+\n+  /* Keep looking until we find a match.  */\n+  start = str;\n+  for ( ; ilist != NULL ; ilist = CGEN_ASM_NEXT_INSN (ilist))\n+    {\n+      const CGEN_INSN *insn = ilist->insn;\n+      recognized_mnemonic = 1;\n+\n+#ifdef CGEN_VALIDATE_INSN_SUPPORTED\n+      /* Not usually needed as unsupported opcodes\n+\t shouldn't be in the hash lists.  */\n+      /* Is this insn supported by the selected cpu?  */\n+      if (! bpf_cgen_insn_supported (cd, insn))\n+\tcontinue;\n+#endif\n+      /* If the RELAXED attribute is set, this is an insn that shouldn't be\n+\t chosen immediately.  Instead, it is used during assembler/linker\n+\t relaxation if possible.  */\n+      if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED) != 0)\n+\tcontinue;\n+\n+      str = start;\n+\n+      /* Skip this insn if str doesn't look right lexically.  */\n+      if (CGEN_INSN_RX (insn) != NULL &&\n+\t  regexec ((regex_t *) CGEN_INSN_RX (insn), str, 0, NULL, 0) == REG_NOMATCH)\n+\tcontinue;\n+\n+      /* Allow parse/insert handlers to obtain length of insn.  */\n+      CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);\n+\n+      parse_errmsg = CGEN_PARSE_FN (cd, insn) (cd, insn, & str, fields);\n+      if (parse_errmsg != NULL)\n+\tcontinue;\n+\n+      /* ??? 0 is passed for `pc'.  */\n+      insert_errmsg = CGEN_INSERT_FN (cd, insn) (cd, insn, fields, buf,\n+\t\t\t\t\t\t (bfd_vma) 0);\n+      if (insert_errmsg != NULL)\n+        continue;\n+\n+      /* It is up to the caller to actually output the insn and any\n+         queued relocs.  */\n+      return insn;\n+    }\n+\n+  {\n+    static char errbuf[150];\n+    const char *tmp_errmsg;\n+#ifdef CGEN_VERBOSE_ASSEMBLER_ERRORS\n+#define be_verbose 1\n+#else\n+#define be_verbose 0\n+#endif\n+\n+    if (be_verbose)\n+      {\n+\t/* If requesting verbose error messages, use insert_errmsg.\n+\t   Failing that, use parse_errmsg.  */\n+\ttmp_errmsg = (insert_errmsg ? insert_errmsg :\n+\t\t      parse_errmsg ? parse_errmsg :\n+\t\t      recognized_mnemonic ?\n+\t\t      _(\"unrecognized form of instruction\") :\n+\t\t      _(\"unrecognized instruction\"));\n+\n+\tif (strlen (start) > 50)\n+\t  /* xgettext:c-format */\n+\t  sprintf (errbuf, \"%s `%.50s...'\", tmp_errmsg, start);\n+\telse\n+\t  /* xgettext:c-format */\n+\t  sprintf (errbuf, \"%s `%.50s'\", tmp_errmsg, start);\n+      }\n+    else\n+      {\n+\tif (strlen (start) > 50)\n+\t  /* xgettext:c-format */\n+\t  sprintf (errbuf, _(\"bad instruction `%.50s...'\"), start);\n+\telse\n+\t  /* xgettext:c-format */\n+\t  sprintf (errbuf, _(\"bad instruction `%.50s'\"), start);\n+      }\n+\n+    *errmsg = errbuf;\n+    return NULL;\n+  }\n+}"
    },
    {
      "sha": "4c94723baff8938775f946a9d4888a6100ac6d10",
      "filename": "opcodes/bpf-desc.c",
      "status": "added",
      "additions": 1638,
      "deletions": 0,
      "changes": 1638,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-desc.c?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,1638 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* CPU data for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+This file is part of the GNU Binutils and/or GDB, the GNU debugger.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#include \"sysdep.h\"\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include \"ansidecl.h\"\n+#include \"bfd.h\"\n+#include \"symcat.h\"\n+#include \"bpf-desc.h\"\n+#include \"bpf-opc.h\"\n+#include \"opintl.h\"\n+#include \"libiberty.h\"\n+#include \"xregex.h\"\n+\n+/* Attributes.  */\n+\n+static const CGEN_ATTR_ENTRY bool_attr[] =\n+{\n+  { \"#f\", 0 },\n+  { \"#t\", 1 },\n+  { 0, 0 }\n+};\n+\n+static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =\n+{\n+  { \"base\", MACH_BASE },\n+  { \"bpf\", MACH_BPF },\n+  { \"max\", MACH_MAX },\n+  { 0, 0 }\n+};\n+\n+static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =\n+{\n+  { \"ebpfle\", ISA_EBPFLE },\n+  { \"ebpfbe\", ISA_EBPFBE },\n+  { \"max\", ISA_MAX },\n+  { 0, 0 }\n+};\n+\n+const CGEN_ATTR_TABLE bpf_cgen_ifield_attr_table[] =\n+{\n+  { \"MACH\", & MACH_attr[0], & MACH_attr[0] },\n+  { \"ISA\", & ISA_attr[0], & ISA_attr[0] },\n+  { \"VIRTUAL\", &bool_attr[0], &bool_attr[0] },\n+  { \"PCREL-ADDR\", &bool_attr[0], &bool_attr[0] },\n+  { \"ABS-ADDR\", &bool_attr[0], &bool_attr[0] },\n+  { \"RESERVED\", &bool_attr[0], &bool_attr[0] },\n+  { \"SIGN-OPT\", &bool_attr[0], &bool_attr[0] },\n+  { \"SIGNED\", &bool_attr[0], &bool_attr[0] },\n+  { 0, 0, 0 }\n+};\n+\n+const CGEN_ATTR_TABLE bpf_cgen_hardware_attr_table[] =\n+{\n+  { \"MACH\", & MACH_attr[0], & MACH_attr[0] },\n+  { \"ISA\", & ISA_attr[0], & ISA_attr[0] },\n+  { \"VIRTUAL\", &bool_attr[0], &bool_attr[0] },\n+  { \"CACHE-ADDR\", &bool_attr[0], &bool_attr[0] },\n+  { \"PC\", &bool_attr[0], &bool_attr[0] },\n+  { \"PROFILE\", &bool_attr[0], &bool_attr[0] },\n+  { 0, 0, 0 }\n+};\n+\n+const CGEN_ATTR_TABLE bpf_cgen_operand_attr_table[] =\n+{\n+  { \"MACH\", & MACH_attr[0], & MACH_attr[0] },\n+  { \"ISA\", & ISA_attr[0], & ISA_attr[0] },\n+  { \"VIRTUAL\", &bool_attr[0], &bool_attr[0] },\n+  { \"PCREL-ADDR\", &bool_attr[0], &bool_attr[0] },\n+  { \"ABS-ADDR\", &bool_attr[0], &bool_attr[0] },\n+  { \"SIGN-OPT\", &bool_attr[0], &bool_attr[0] },\n+  { \"SIGNED\", &bool_attr[0], &bool_attr[0] },\n+  { \"NEGATIVE\", &bool_attr[0], &bool_attr[0] },\n+  { \"RELAX\", &bool_attr[0], &bool_attr[0] },\n+  { \"SEM-ONLY\", &bool_attr[0], &bool_attr[0] },\n+  { 0, 0, 0 }\n+};\n+\n+const CGEN_ATTR_TABLE bpf_cgen_insn_attr_table[] =\n+{\n+  { \"MACH\", & MACH_attr[0], & MACH_attr[0] },\n+  { \"ISA\", & ISA_attr[0], & ISA_attr[0] },\n+  { \"ALIAS\", &bool_attr[0], &bool_attr[0] },\n+  { \"VIRTUAL\", &bool_attr[0], &bool_attr[0] },\n+  { \"UNCOND-CTI\", &bool_attr[0], &bool_attr[0] },\n+  { \"COND-CTI\", &bool_attr[0], &bool_attr[0] },\n+  { \"SKIP-CTI\", &bool_attr[0], &bool_attr[0] },\n+  { \"DELAY-SLOT\", &bool_attr[0], &bool_attr[0] },\n+  { \"RELAXABLE\", &bool_attr[0], &bool_attr[0] },\n+  { \"RELAXED\", &bool_attr[0], &bool_attr[0] },\n+  { \"NO-DIS\", &bool_attr[0], &bool_attr[0] },\n+  { \"PBB\", &bool_attr[0], &bool_attr[0] },\n+  { 0, 0, 0 }\n+};\n+\n+/* Instruction set variants.  */\n+\n+static const CGEN_ISA bpf_cgen_isa_table[] = {\n+  { \"ebpfle\", 64, 8, 64, 128 },\n+  { \"ebpfbe\", 64, 8, 64, 128 },\n+  { 0, 0, 0, 0, 0 }\n+};\n+\n+/* Machine variants.  */\n+\n+static const CGEN_MACH bpf_cgen_mach_table[] = {\n+  { \"bpf\", \"bpf\", MACH_BPF, 0 },\n+  { 0, 0, 0, 0 }\n+};\n+\n+static CGEN_KEYWORD_ENTRY bpf_cgen_opval_h_gpr_entries[] =\n+{\n+  { \"%a\", 0, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r1\", 1, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r2\", 2, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r3\", 3, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r4\", 4, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r5\", 5, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%ctx\", 6, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r7\", 7, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r8\", 8, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r9\", 9, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%fp\", 10, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r0\", 0, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r6\", 6, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r10\", 10, {0, {{{0, 0}}}}, 0, 0 }\n+};\n+\n+CGEN_KEYWORD bpf_cgen_opval_h_gpr =\n+{\n+  & bpf_cgen_opval_h_gpr_entries[0],\n+  14,\n+  0, 0, 0, 0, \"\"\n+};\n+\n+\n+/* The hardware table.  */\n+\n+#define A(a) (1 << CGEN_HW_##a)\n+\n+const CGEN_HW_ENTRY bpf_cgen_hw_table[] =\n+{\n+  { \"h-memory\", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-sint\", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-uint\", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-addr\", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-iaddr\", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-gpr\", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & bpf_cgen_opval_h_gpr, { 0, { { { (1<<MACH_BPF), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { \"h-pc\", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } },\n+  { \"h-sint64\", HW_H_SINT64, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n+  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } }\n+};\n+\n+#undef A\n+\n+\n+/* The instruction field table.  */\n+\n+#define A(a) (1 << CGEN_IFLD_##a)\n+\n+const CGEN_IFLD bpf_cgen_ifld_table[] =\n+{\n+  { BPF_F_NIL, \"f-nil\", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_ANYOF, \"f-anyof\", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_OP_CODE, \"f-op-code\", 0, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_OP_SRC, \"f-op-src\", 0, 8, 3, 1, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_OP_CLASS, \"f-op-class\", 0, 8, 2, 3, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_OP_MODE, \"f-op-mode\", 0, 8, 7, 3, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_OP_SIZE, \"f-op-size\", 0, 8, 4, 2, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_DSTLE, \"f-dstle\", 8, 8, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n+  { BPF_F_SRCLE, \"f-srcle\", 8, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n+  { BPF_F_DSTBE, \"f-dstbe\", 8, 8, 7, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n+  { BPF_F_SRCBE, \"f-srcbe\", 8, 8, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n+  { BPF_F_REGS, \"f-regs\", 8, 8, 7, 8, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_OFFSET16, \"f-offset16\", 16, 16, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_IMM32, \"f-imm32\", 32, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_IMM64_A, \"f-imm64-a\", 32, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_IMM64_B, \"f-imm64-b\", 64, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_IMM64_C, \"f-imm64-c\", 96, 32, 31, 32, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { BPF_F_IMM64, \"f-imm64\", 0, 0, 0, 0,{ 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } }\n+};\n+\n+#undef A\n+\n+\n+\n+/* multi ifield declarations */\n+\n+const CGEN_MAYBE_MULTI_IFLD BPF_F_IMM64_MULTI_IFIELD [];\n+\n+\n+/* multi ifield definitions */\n+\n+const CGEN_MAYBE_MULTI_IFLD BPF_F_IMM64_MULTI_IFIELD [] =\n+{\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM64_A] } },\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM64_B] } },\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM64_C] } },\n+    { 0, { (const PTR) 0 } }\n+};\n+\n+/* The operand table.  */\n+\n+#define A(a) (1 << CGEN_OPERAND_##a)\n+#define OPERAND(op) BPF_OPERAND_##op\n+\n+const CGEN_OPERAND bpf_cgen_operand_table[] =\n+{\n+/* pc: program counter */\n+  { \"pc\", BPF_OPERAND_PC, HW_H_PC, 0, 0,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_NIL] } },\n+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* dstle: destination register */\n+  { \"dstle\", BPF_OPERAND_DSTLE, HW_H_GPR, 3, 4,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_DSTLE] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n+/* srcle: source register */\n+  { \"srcle\", BPF_OPERAND_SRCLE, HW_H_GPR, 7, 4,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_SRCLE] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }  },\n+/* dstbe: destination register */\n+  { \"dstbe\", BPF_OPERAND_DSTBE, HW_H_GPR, 7, 4,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_DSTBE] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n+/* srcbe: source register */\n+  { \"srcbe\", BPF_OPERAND_SRCBE, HW_H_GPR, 3, 4,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_SRCBE] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }  },\n+/* disp16: 16-bit PC-relative address */\n+  { \"disp16\", BPF_OPERAND_DISP16, HW_H_SINT, 15, 16,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_OFFSET16] } },\n+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* disp32: 32-bit PC-relative address */\n+  { \"disp32\", BPF_OPERAND_DISP32, HW_H_SINT, 31, 32,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM32] } },\n+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* imm32: 32-bit immediate */\n+  { \"imm32\", BPF_OPERAND_IMM32, HW_H_SINT, 31, 32,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM32] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* offset16: 16-bit offset */\n+  { \"offset16\", BPF_OPERAND_OFFSET16, HW_H_SINT, 15, 16,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_OFFSET16] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* imm64: 64-bit immediate */\n+  { \"imm64\", BPF_OPERAND_IMM64, HW_H_SINT64, 31, 96,\n+    { 3, { (const PTR) &BPF_F_IMM64_MULTI_IFIELD[0] } },\n+    { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* endsize: endianness size immediate: 16, 32 or 64 */\n+  { \"endsize\", BPF_OPERAND_ENDSIZE, HW_H_UINT, 31, 32,\n+    { 0, { (const PTR) &bpf_cgen_ifld_table[BPF_F_IMM32] } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }  },\n+/* sentinel */\n+  { 0, 0, 0, 0, 0,\n+    { 0, { (const PTR) 0 } },\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } }\n+};\n+\n+#undef A\n+\n+\n+/* The instruction table.  */\n+\n+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))\n+#define A(a) (1 << CGEN_INSN_##a)\n+\n+static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n+{\n+  /* Special null first entry.\n+     A `num' value of zero is thus invalid.\n+     Also, the special `invalid' insn resides here.  */\n+  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } },\n+/* add $dstle,$imm32 */\n+  {\n+    BPF_INSN_ADDILE, \"addile\", \"add\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* add $dstle,$srcle */\n+  {\n+    BPF_INSN_ADDRLE, \"addrle\", \"add\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* add32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_ADD32ILE, \"add32ile\", \"add32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* add32 $dstle,$srcle */\n+  {\n+    BPF_INSN_ADD32RLE, \"add32rle\", \"add32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* sub $dstle,$imm32 */\n+  {\n+    BPF_INSN_SUBILE, \"subile\", \"sub\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* sub $dstle,$srcle */\n+  {\n+    BPF_INSN_SUBRLE, \"subrle\", \"sub\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* sub32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_SUB32ILE, \"sub32ile\", \"sub32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* sub32 $dstle,$srcle */\n+  {\n+    BPF_INSN_SUB32RLE, \"sub32rle\", \"sub32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mul $dstle,$imm32 */\n+  {\n+    BPF_INSN_MULILE, \"mulile\", \"mul\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mul $dstle,$srcle */\n+  {\n+    BPF_INSN_MULRLE, \"mulrle\", \"mul\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mul32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_MUL32ILE, \"mul32ile\", \"mul32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mul32 $dstle,$srcle */\n+  {\n+    BPF_INSN_MUL32RLE, \"mul32rle\", \"mul32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* div $dstle,$imm32 */\n+  {\n+    BPF_INSN_DIVILE, \"divile\", \"div\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* div $dstle,$srcle */\n+  {\n+    BPF_INSN_DIVRLE, \"divrle\", \"div\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* div32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_DIV32ILE, \"div32ile\", \"div32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* div32 $dstle,$srcle */\n+  {\n+    BPF_INSN_DIV32RLE, \"div32rle\", \"div32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* or $dstle,$imm32 */\n+  {\n+    BPF_INSN_ORILE, \"orile\", \"or\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* or $dstle,$srcle */\n+  {\n+    BPF_INSN_ORRLE, \"orrle\", \"or\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* or32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_OR32ILE, \"or32ile\", \"or32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* or32 $dstle,$srcle */\n+  {\n+    BPF_INSN_OR32RLE, \"or32rle\", \"or32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* and $dstle,$imm32 */\n+  {\n+    BPF_INSN_ANDILE, \"andile\", \"and\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* and $dstle,$srcle */\n+  {\n+    BPF_INSN_ANDRLE, \"andrle\", \"and\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* and32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_AND32ILE, \"and32ile\", \"and32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* and32 $dstle,$srcle */\n+  {\n+    BPF_INSN_AND32RLE, \"and32rle\", \"and32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* lsh $dstle,$imm32 */\n+  {\n+    BPF_INSN_LSHILE, \"lshile\", \"lsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* lsh $dstle,$srcle */\n+  {\n+    BPF_INSN_LSHRLE, \"lshrle\", \"lsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* lsh32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_LSH32ILE, \"lsh32ile\", \"lsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* lsh32 $dstle,$srcle */\n+  {\n+    BPF_INSN_LSH32RLE, \"lsh32rle\", \"lsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* rsh $dstle,$imm32 */\n+  {\n+    BPF_INSN_RSHILE, \"rshile\", \"rsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* rsh $dstle,$srcle */\n+  {\n+    BPF_INSN_RSHRLE, \"rshrle\", \"rsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* rsh32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_RSH32ILE, \"rsh32ile\", \"rsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* rsh32 $dstle,$srcle */\n+  {\n+    BPF_INSN_RSH32RLE, \"rsh32rle\", \"rsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mod $dstle,$imm32 */\n+  {\n+    BPF_INSN_MODILE, \"modile\", \"mod\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mod $dstle,$srcle */\n+  {\n+    BPF_INSN_MODRLE, \"modrle\", \"mod\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mod32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_MOD32ILE, \"mod32ile\", \"mod32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mod32 $dstle,$srcle */\n+  {\n+    BPF_INSN_MOD32RLE, \"mod32rle\", \"mod32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* xor $dstle,$imm32 */\n+  {\n+    BPF_INSN_XORILE, \"xorile\", \"xor\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* xor $dstle,$srcle */\n+  {\n+    BPF_INSN_XORRLE, \"xorrle\", \"xor\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* xor32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_XOR32ILE, \"xor32ile\", \"xor32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* xor32 $dstle,$srcle */\n+  {\n+    BPF_INSN_XOR32RLE, \"xor32rle\", \"xor32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov $dstle,$imm32 */\n+  {\n+    BPF_INSN_MOVILE, \"movile\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov $dstle,$srcle */\n+  {\n+    BPF_INSN_MOVRLE, \"movrle\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_MOV32ILE, \"mov32ile\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov32 $dstle,$srcle */\n+  {\n+    BPF_INSN_MOV32RLE, \"mov32rle\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* arsh $dstle,$imm32 */\n+  {\n+    BPF_INSN_ARSHILE, \"arshile\", \"arsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* arsh $dstle,$srcle */\n+  {\n+    BPF_INSN_ARSHRLE, \"arshrle\", \"arsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* arsh32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_ARSH32ILE, \"arsh32ile\", \"arsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* arsh32 $dstle,$srcle */\n+  {\n+    BPF_INSN_ARSH32RLE, \"arsh32rle\", \"arsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* neg $dstle */\n+  {\n+    BPF_INSN_NEGLE, \"negle\", \"neg\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* neg32 $dstle */\n+  {\n+    BPF_INSN_NEG32LE, \"neg32le\", \"neg32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* add $dstbe,$imm32 */\n+  {\n+    BPF_INSN_ADDIBE, \"addibe\", \"add\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* add $dstbe,$srcbe */\n+  {\n+    BPF_INSN_ADDRBE, \"addrbe\", \"add\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* add32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_ADD32IBE, \"add32ibe\", \"add32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* add32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_ADD32RBE, \"add32rbe\", \"add32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* sub $dstbe,$imm32 */\n+  {\n+    BPF_INSN_SUBIBE, \"subibe\", \"sub\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* sub $dstbe,$srcbe */\n+  {\n+    BPF_INSN_SUBRBE, \"subrbe\", \"sub\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* sub32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_SUB32IBE, \"sub32ibe\", \"sub32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* sub32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_SUB32RBE, \"sub32rbe\", \"sub32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mul $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MULIBE, \"mulibe\", \"mul\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mul $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MULRBE, \"mulrbe\", \"mul\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mul32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MUL32IBE, \"mul32ibe\", \"mul32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mul32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MUL32RBE, \"mul32rbe\", \"mul32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* div $dstbe,$imm32 */\n+  {\n+    BPF_INSN_DIVIBE, \"divibe\", \"div\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* div $dstbe,$srcbe */\n+  {\n+    BPF_INSN_DIVRBE, \"divrbe\", \"div\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* div32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_DIV32IBE, \"div32ibe\", \"div32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* div32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_DIV32RBE, \"div32rbe\", \"div32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* or $dstbe,$imm32 */\n+  {\n+    BPF_INSN_ORIBE, \"oribe\", \"or\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* or $dstbe,$srcbe */\n+  {\n+    BPF_INSN_ORRBE, \"orrbe\", \"or\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* or32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_OR32IBE, \"or32ibe\", \"or32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* or32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_OR32RBE, \"or32rbe\", \"or32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* and $dstbe,$imm32 */\n+  {\n+    BPF_INSN_ANDIBE, \"andibe\", \"and\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* and $dstbe,$srcbe */\n+  {\n+    BPF_INSN_ANDRBE, \"andrbe\", \"and\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* and32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_AND32IBE, \"and32ibe\", \"and32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* and32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_AND32RBE, \"and32rbe\", \"and32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* lsh $dstbe,$imm32 */\n+  {\n+    BPF_INSN_LSHIBE, \"lshibe\", \"lsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* lsh $dstbe,$srcbe */\n+  {\n+    BPF_INSN_LSHRBE, \"lshrbe\", \"lsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* lsh32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_LSH32IBE, \"lsh32ibe\", \"lsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* lsh32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_LSH32RBE, \"lsh32rbe\", \"lsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* rsh $dstbe,$imm32 */\n+  {\n+    BPF_INSN_RSHIBE, \"rshibe\", \"rsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* rsh $dstbe,$srcbe */\n+  {\n+    BPF_INSN_RSHRBE, \"rshrbe\", \"rsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* rsh32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_RSH32IBE, \"rsh32ibe\", \"rsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* rsh32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_RSH32RBE, \"rsh32rbe\", \"rsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mod $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MODIBE, \"modibe\", \"mod\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mod $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MODRBE, \"modrbe\", \"mod\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mod32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MOD32IBE, \"mod32ibe\", \"mod32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mod32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MOD32RBE, \"mod32rbe\", \"mod32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* xor $dstbe,$imm32 */\n+  {\n+    BPF_INSN_XORIBE, \"xoribe\", \"xor\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* xor $dstbe,$srcbe */\n+  {\n+    BPF_INSN_XORRBE, \"xorrbe\", \"xor\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* xor32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_XOR32IBE, \"xor32ibe\", \"xor32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* xor32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_XOR32RBE, \"xor32rbe\", \"xor32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MOVIBE, \"movibe\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MOVRBE, \"movrbe\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MOV32IBE, \"mov32ibe\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MOV32RBE, \"mov32rbe\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* arsh $dstbe,$imm32 */\n+  {\n+    BPF_INSN_ARSHIBE, \"arshibe\", \"arsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* arsh $dstbe,$srcbe */\n+  {\n+    BPF_INSN_ARSHRBE, \"arshrbe\", \"arsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* arsh32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_ARSH32IBE, \"arsh32ibe\", \"arsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* arsh32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_ARSH32RBE, \"arsh32rbe\", \"arsh32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* neg $dstbe */\n+  {\n+    BPF_INSN_NEGBE, \"negbe\", \"neg\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* neg32 $dstbe */\n+  {\n+    BPF_INSN_NEG32BE, \"neg32be\", \"neg32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* endle $dstle,$endsize */\n+  {\n+    BPF_INSN_ENDLELE, \"endlele\", \"endle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* endbe $dstle,$endsize */\n+  {\n+    BPF_INSN_ENDBELE, \"endbele\", \"endbe\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* endle $dstbe,$endsize */\n+  {\n+    BPF_INSN_ENDLEBE, \"endlebe\", \"endle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* endbe $dstbe,$endsize */\n+  {\n+    BPF_INSN_ENDBEBE, \"endbebe\", \"endbe\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* lddw $dstle,$imm64 */\n+  {\n+    BPF_INSN_LDDWLE, \"lddwle\", \"lddw\", 128,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* lddw $dstbe,$imm64 */\n+  {\n+    BPF_INSN_LDDWBE, \"lddwbe\", \"lddw\", 128,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldabsw $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDABSWLE, \"ldabswle\", \"ldabsw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldabsh $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDABSHLE, \"ldabshle\", \"ldabsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldabsb $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDABSBLE, \"ldabsble\", \"ldabsb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldabsdw $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDABSDWLE, \"ldabsdwle\", \"ldabsdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldindw $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDINDWLE, \"ldindwle\", \"ldindw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldindh $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDINDHLE, \"ldindhle\", \"ldindh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldindb $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDINDBLE, \"ldindble\", \"ldindb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldinddw $dstle,$srcle,$imm32 */\n+  {\n+    BPF_INSN_LDINDDWLE, \"ldinddwle\", \"ldinddw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldabsw $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDABSWBE, \"ldabswbe\", \"ldabsw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldabsh $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDABSHBE, \"ldabshbe\", \"ldabsh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldabsb $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDABSBBE, \"ldabsbbe\", \"ldabsb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldabsdw $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDABSDWBE, \"ldabsdwbe\", \"ldabsdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldindw $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDINDWBE, \"ldindwbe\", \"ldindw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldindh $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDINDHBE, \"ldindhbe\", \"ldindh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldindb $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDINDBBE, \"ldindbbe\", \"ldindb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldinddw $dstbe,$srcbe,$imm32 */\n+  {\n+    BPF_INSN_LDINDDWBE, \"ldinddwbe\", \"ldinddw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldxw $dstle,[$srcle+$offset16] */\n+  {\n+    BPF_INSN_LDXWLE, \"ldxwle\", \"ldxw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldxh $dstle,[$srcle+$offset16] */\n+  {\n+    BPF_INSN_LDXHLE, \"ldxhle\", \"ldxh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldxb $dstle,[$srcle+$offset16] */\n+  {\n+    BPF_INSN_LDXBLE, \"ldxble\", \"ldxb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldxdw $dstle,[$srcle+$offset16] */\n+  {\n+    BPF_INSN_LDXDWLE, \"ldxdwle\", \"ldxdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stxw [$dstle+$offset16],$srcle */\n+  {\n+    BPF_INSN_STXWLE, \"stxwle\", \"stxw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stxh [$dstle+$offset16],$srcle */\n+  {\n+    BPF_INSN_STXHLE, \"stxhle\", \"stxh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stxb [$dstle+$offset16],$srcle */\n+  {\n+    BPF_INSN_STXBLE, \"stxble\", \"stxb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stxdw [$dstle+$offset16],$srcle */\n+  {\n+    BPF_INSN_STXDWLE, \"stxdwle\", \"stxdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* ldxw $dstbe,[$srcbe+$offset16] */\n+  {\n+    BPF_INSN_LDXWBE, \"ldxwbe\", \"ldxw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldxh $dstbe,[$srcbe+$offset16] */\n+  {\n+    BPF_INSN_LDXHBE, \"ldxhbe\", \"ldxh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldxb $dstbe,[$srcbe+$offset16] */\n+  {\n+    BPF_INSN_LDXBBE, \"ldxbbe\", \"ldxb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ldxdw $dstbe,[$srcbe+$offset16] */\n+  {\n+    BPF_INSN_LDXDWBE, \"ldxdwbe\", \"ldxdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stxw [$dstbe+$offset16],$srcbe */\n+  {\n+    BPF_INSN_STXWBE, \"stxwbe\", \"stxw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stxh [$dstbe+$offset16],$srcbe */\n+  {\n+    BPF_INSN_STXHBE, \"stxhbe\", \"stxh\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stxb [$dstbe+$offset16],$srcbe */\n+  {\n+    BPF_INSN_STXBBE, \"stxbbe\", \"stxb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stxdw [$dstbe+$offset16],$srcbe */\n+  {\n+    BPF_INSN_STXDWBE, \"stxdwbe\", \"stxdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stb [$dstle+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STBLE, \"stble\", \"stb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* sth [$dstle+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STHLE, \"sthle\", \"sth\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stw [$dstle+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STWLE, \"stwle\", \"stw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stdw [$dstle+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STDWLE, \"stdwle\", \"stdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* stb [$dstbe+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STBBE, \"stbbe\", \"stb\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* sth [$dstbe+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STHBE, \"sthbe\", \"sth\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stw [$dstbe+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STWBE, \"stwbe\", \"stw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* stdw [$dstbe+$offset16],$imm32 */\n+  {\n+    BPF_INSN_STDWBE, \"stdwbe\", \"stdw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jeq $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JEQILE, \"jeqile\", \"jeq\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jeq $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JEQRLE, \"jeqrle\", \"jeq\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jgt $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JGTILE, \"jgtile\", \"jgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jgt $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JGTRLE, \"jgtrle\", \"jgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jge $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JGEILE, \"jgeile\", \"jge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jge $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JGERLE, \"jgerle\", \"jge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jlt $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JLTILE, \"jltile\", \"jlt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jlt $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JLTRLE, \"jltrle\", \"jlt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jle $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JLEILE, \"jleile\", \"jle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jle $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JLERLE, \"jlerle\", \"jle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jset $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSETILE, \"jsetile\", \"jset\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jset $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JSETRLE, \"jsetrle\", \"jset\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jne $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JNEILE, \"jneile\", \"jne\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jne $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JNERLE, \"jnerle\", \"jne\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jsgt $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSGTILE, \"jsgtile\", \"jsgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jsgt $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JSGTRLE, \"jsgtrle\", \"jsgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jsge $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSGEILE, \"jsgeile\", \"jsge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jsge $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JSGERLE, \"jsgerle\", \"jsge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jslt $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSLTILE, \"jsltile\", \"jslt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jslt $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JSLTRLE, \"jsltrle\", \"jslt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jsle $dstle,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSLEILE, \"jsleile\", \"jsle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jsle $dstle,$srcle,$disp16 */\n+  {\n+    BPF_INSN_JSLERLE, \"jslerle\", \"jsle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* jeq $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JEQIBE, \"jeqibe\", \"jeq\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jeq $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JEQRBE, \"jeqrbe\", \"jeq\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jgt $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JGTIBE, \"jgtibe\", \"jgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jgt $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JGTRBE, \"jgtrbe\", \"jgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jge $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JGEIBE, \"jgeibe\", \"jge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jge $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JGERBE, \"jgerbe\", \"jge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jlt $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JLTIBE, \"jltibe\", \"jlt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jlt $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JLTRBE, \"jltrbe\", \"jlt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jle $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JLEIBE, \"jleibe\", \"jle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jle $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JLERBE, \"jlerbe\", \"jle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jset $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSETIBE, \"jsetibe\", \"jset\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jset $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JSETRBE, \"jsetrbe\", \"jset\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jne $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JNEIBE, \"jneibe\", \"jne\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jne $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JNERBE, \"jnerbe\", \"jne\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jsgt $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSGTIBE, \"jsgtibe\", \"jsgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jsgt $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JSGTRBE, \"jsgtrbe\", \"jsgt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jsge $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSGEIBE, \"jsgeibe\", \"jsge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jsge $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JSGERBE, \"jsgerbe\", \"jsge\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jslt $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSLTIBE, \"jsltibe\", \"jslt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jslt $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JSLTRBE, \"jsltrbe\", \"jslt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jsle $dstbe,$imm32,$disp16 */\n+  {\n+    BPF_INSN_JSLEIBE, \"jsleibe\", \"jsle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* jsle $dstbe,$srcbe,$disp16 */\n+  {\n+    BPF_INSN_JSLERBE, \"jslerbe\", \"jsle\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ja $disp16 */\n+  {\n+    BPF_INSN_JA, \"ja\", \"ja\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+  },\n+/* call $disp32 */\n+  {\n+    BPF_INSN_CALL, \"call\", \"call\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+  },\n+/* exit */\n+  {\n+    BPF_INSN_EXIT, \"exit\", \"exit\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+  },\n+/* xadddw [$dstle+$offset16],$srcle */\n+  {\n+    BPF_INSN_XADDDWLE, \"xadddwle\", \"xadddw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* xaddw [$dstle+$offset16],$srcle */\n+  {\n+    BPF_INSN_XADDWLE, \"xaddwle\", \"xaddw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* xadddw [$dstbe+$offset16],$srcbe */\n+  {\n+    BPF_INSN_XADDDWBE, \"xadddwbe\", \"xadddw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* xaddw [$dstbe+$offset16],$srcbe */\n+  {\n+    BPF_INSN_XADDWBE, \"xaddwbe\", \"xaddw\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+};\n+\n+#undef OP\n+#undef A\n+\n+/* Initialize anything needed to be done once, before any cpu_open call.  */\n+\n+static void\n+init_tables (void)\n+{\n+}\n+\n+#ifndef opcodes_error_handler\n+#define opcodes_error_handler(...) \\\n+  fprintf (stderr, __VA_ARGS__); fputc ('\\n', stderr)\n+#endif\n+\n+static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);\n+static void build_hw_table      (CGEN_CPU_TABLE *);\n+static void build_ifield_table  (CGEN_CPU_TABLE *);\n+static void build_operand_table (CGEN_CPU_TABLE *);\n+static void build_insn_table    (CGEN_CPU_TABLE *);\n+static void bpf_cgen_rebuild_tables (CGEN_CPU_TABLE *);\n+\n+/* Subroutine of bpf_cgen_cpu_open to look up a mach via its bfd name.  */\n+\n+static const CGEN_MACH *\n+lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)\n+{\n+  while (table->name)\n+    {\n+      if (strcmp (name, table->bfd_name) == 0)\n+\treturn table;\n+      ++table;\n+    }\n+  return NULL;\n+}\n+\n+/* Subroutine of bpf_cgen_cpu_open to build the hardware table.  */\n+\n+static void\n+build_hw_table (CGEN_CPU_TABLE *cd)\n+{\n+  int i;\n+  int machs = cd->machs;\n+  const CGEN_HW_ENTRY *init = & bpf_cgen_hw_table[0];\n+  /* MAX_HW is only an upper bound on the number of selected entries.\n+     However each entry is indexed by it's enum so there can be holes in\n+     the table.  */\n+  const CGEN_HW_ENTRY **selected =\n+    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));\n+\n+  cd->hw_table.init_entries = init;\n+  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);\n+  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));\n+  /* ??? For now we just use machs to determine which ones we want.  */\n+  for (i = 0; init[i].name != NULL; ++i)\n+    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)\n+\t& machs)\n+      selected[init[i].type] = &init[i];\n+  cd->hw_table.entries = selected;\n+  cd->hw_table.num_entries = MAX_HW;\n+}\n+\n+/* Subroutine of bpf_cgen_cpu_open to build the hardware table.  */\n+\n+static void\n+build_ifield_table (CGEN_CPU_TABLE *cd)\n+{\n+  cd->ifld_table = & bpf_cgen_ifld_table[0];\n+}\n+\n+/* Subroutine of bpf_cgen_cpu_open to build the hardware table.  */\n+\n+static void\n+build_operand_table (CGEN_CPU_TABLE *cd)\n+{\n+  int i;\n+  int machs = cd->machs;\n+  const CGEN_OPERAND *init = & bpf_cgen_operand_table[0];\n+  /* MAX_OPERANDS is only an upper bound on the number of selected entries.\n+     However each entry is indexed by it's enum so there can be holes in\n+     the table.  */\n+  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));\n+\n+  cd->operand_table.init_entries = init;\n+  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);\n+  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));\n+  /* ??? For now we just use mach to determine which ones we want.  */\n+  for (i = 0; init[i].name != NULL; ++i)\n+    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)\n+\t& machs)\n+      selected[init[i].type] = &init[i];\n+  cd->operand_table.entries = selected;\n+  cd->operand_table.num_entries = MAX_OPERANDS;\n+}\n+\n+/* Subroutine of bpf_cgen_cpu_open to build the hardware table.\n+   ??? This could leave out insns not supported by the specified mach/isa,\n+   but that would cause errors like \"foo only supported by bar\" to become\n+   \"unknown insn\", so for now we include all insns and require the app to\n+   do the checking later.\n+   ??? On the other hand, parsing of such insns may require their hardware or\n+   operand elements to be in the table [which they mightn't be].  */\n+\n+static void\n+build_insn_table (CGEN_CPU_TABLE *cd)\n+{\n+  int i;\n+  const CGEN_IBASE *ib = & bpf_cgen_insn_table[0];\n+  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));\n+\n+  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));\n+  for (i = 0; i < MAX_INSNS; ++i)\n+    insns[i].base = &ib[i];\n+  cd->insn_table.init_entries = insns;\n+  cd->insn_table.entry_size = sizeof (CGEN_IBASE);\n+  cd->insn_table.num_init_entries = MAX_INSNS;\n+}\n+\n+/* Subroutine of bpf_cgen_cpu_open to rebuild the tables.  */\n+\n+static void\n+bpf_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n+{\n+  int i;\n+  CGEN_BITSET *isas = cd->isas;\n+  unsigned int machs = cd->machs;\n+\n+  cd->int_insn_p = CGEN_INT_INSN_P;\n+\n+  /* Data derived from the isa spec.  */\n+#define UNSET (CGEN_SIZE_UNKNOWN + 1)\n+  cd->default_insn_bitsize = UNSET;\n+  cd->base_insn_bitsize = UNSET;\n+  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */\n+  cd->max_insn_bitsize = 0;\n+  for (i = 0; i < MAX_ISAS; ++i)\n+    if (cgen_bitset_contains (isas, i))\n+      {\n+\tconst CGEN_ISA *isa = & bpf_cgen_isa_table[i];\n+\n+\t/* Default insn sizes of all selected isas must be\n+\t   equal or we set the result to 0, meaning \"unknown\".  */\n+\tif (cd->default_insn_bitsize == UNSET)\n+\t  cd->default_insn_bitsize = isa->default_insn_bitsize;\n+\telse if (isa->default_insn_bitsize == cd->default_insn_bitsize)\n+\t  ; /* This is ok.  */\n+\telse\n+\t  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;\n+\n+\t/* Base insn sizes of all selected isas must be equal\n+\t   or we set the result to 0, meaning \"unknown\".  */\n+\tif (cd->base_insn_bitsize == UNSET)\n+\t  cd->base_insn_bitsize = isa->base_insn_bitsize;\n+\telse if (isa->base_insn_bitsize == cd->base_insn_bitsize)\n+\t  ; /* This is ok.  */\n+\telse\n+\t  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;\n+\n+\t/* Set min,max insn sizes.  */\n+\tif (isa->min_insn_bitsize < cd->min_insn_bitsize)\n+\t  cd->min_insn_bitsize = isa->min_insn_bitsize;\n+\tif (isa->max_insn_bitsize > cd->max_insn_bitsize)\n+\t  cd->max_insn_bitsize = isa->max_insn_bitsize;\n+      }\n+\n+  /* Data derived from the mach spec.  */\n+  for (i = 0; i < MAX_MACHS; ++i)\n+    if (((1 << i) & machs) != 0)\n+      {\n+\tconst CGEN_MACH *mach = & bpf_cgen_mach_table[i];\n+\n+\tif (mach->insn_chunk_bitsize != 0)\n+\t{\n+\t  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)\n+\t    {\n+\t      opcodes_error_handler\n+\t\t(/* xgettext:c-format */\n+\t\t _(\"internal error: bpf_cgen_rebuild_tables: \"\n+\t\t   \"conflicting insn-chunk-bitsize values: `%d' vs. `%d'\"),\n+\t\t cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);\n+\t      abort ();\n+\t    }\n+\n+ \t  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;\n+\t}\n+      }\n+\n+  /* Determine which hw elements are used by MACH.  */\n+  build_hw_table (cd);\n+\n+  /* Build the ifield table.  */\n+  build_ifield_table (cd);\n+\n+  /* Determine which operands are used by MACH/ISA.  */\n+  build_operand_table (cd);\n+\n+  /* Build the instruction table.  */\n+  build_insn_table (cd);\n+}\n+\n+/* Initialize a cpu table and return a descriptor.\n+   It's much like opening a file, and must be the first function called.\n+   The arguments are a set of (type/value) pairs, terminated with\n+   CGEN_CPU_OPEN_END.\n+\n+   Currently supported values:\n+   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr\n+   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n+   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n+   CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_END:     terminates arguments\n+\n+   ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n+   precluded.  */\n+\n+CGEN_CPU_DESC\n+bpf_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n+{\n+  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));\n+  static int init_p;\n+  CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n+  unsigned int machs = 0; /* 0 = \"unspecified\" */\n+  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  va_list ap;\n+\n+  if (! init_p)\n+    {\n+      init_tables ();\n+      init_p = 1;\n+    }\n+\n+  memset (cd, 0, sizeof (*cd));\n+\n+  va_start (ap, arg_type);\n+  while (arg_type != CGEN_CPU_OPEN_END)\n+    {\n+      switch (arg_type)\n+\t{\n+\tcase CGEN_CPU_OPEN_ISAS :\n+\t  isas = va_arg (ap, CGEN_BITSET *);\n+\t  break;\n+\tcase CGEN_CPU_OPEN_MACHS :\n+\t  machs = va_arg (ap, unsigned int);\n+\t  break;\n+\tcase CGEN_CPU_OPEN_BFDMACH :\n+\t  {\n+\t    const char *name = va_arg (ap, const char *);\n+\t    const CGEN_MACH *mach =\n+\t      lookup_mach_via_bfd_name (bpf_cgen_mach_table, name);\n+\n+\t    if (mach != NULL)\n+\t      machs |= 1 << mach->num;\n+\t    break;\n+\t  }\n+\tcase CGEN_CPU_OPEN_ENDIAN :\n+\t  endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n+\tdefault :\n+\t  opcodes_error_handler\n+\t    (/* xgettext:c-format */\n+\t     _(\"internal error: bpf_cgen_cpu_open: \"\n+\t       \"unsupported argument `%d'\"),\n+\t     arg_type);\n+\t  abort (); /* ??? return NULL? */\n+\t}\n+      arg_type = va_arg (ap, enum cgen_cpu_open_arg);\n+    }\n+  va_end (ap);\n+\n+  /* Mach unspecified means \"all\".  */\n+  if (machs == 0)\n+    machs = (1 << MAX_MACHS) - 1;\n+  /* Base mach is always selected.  */\n+  machs |= 1;\n+  if (endian == CGEN_ENDIAN_UNKNOWN)\n+    {\n+      /* ??? If target has only one, could have a default.  */\n+      opcodes_error_handler\n+\t(/* xgettext:c-format */\n+\t _(\"internal error: bpf_cgen_cpu_open: no endianness specified\"));\n+      abort ();\n+    }\n+\n+  cd->isas = cgen_bitset_copy (isas);\n+  cd->machs = machs;\n+  cd->endian = endian;\n+  /* FIXME: for the sparc case we can determine insn-endianness statically.\n+     The worry here is where both data and insn endian can be independently\n+     chosen, in which case this function will need another argument.\n+     Actually, will want to allow for more arguments in the future anyway.  */\n+  cd->insn_endian = endian;\n+\n+  /* Table (re)builder.  */\n+  cd->rebuild_tables = bpf_cgen_rebuild_tables;\n+  bpf_cgen_rebuild_tables (cd);\n+\n+  /* Default to not allowing signed overflow.  */\n+  cd->signed_overflow_ok_p = 0;\n+\n+  return (CGEN_CPU_DESC) cd;\n+}\n+\n+/* Cover fn to bpf_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.\n+   MACH_NAME is the bfd name of the mach.  */\n+\n+CGEN_CPU_DESC\n+bpf_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)\n+{\n+  return bpf_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,\n+\t\t\t       CGEN_CPU_OPEN_ENDIAN, endian,\n+\t\t\t       CGEN_CPU_OPEN_END);\n+}\n+\n+/* Close a cpu table.\n+   ??? This can live in a machine independent file, but there's currently\n+   no place to put this file (there's no libcgen).  libopcodes is the wrong\n+   place as some simulator ports use this but they don't use libopcodes.  */\n+\n+void\n+bpf_cgen_cpu_close (CGEN_CPU_DESC cd)\n+{\n+  unsigned int i;\n+  const CGEN_INSN *insns;\n+\n+  if (cd->macro_insn_table.init_entries)\n+    {\n+      insns = cd->macro_insn_table.init_entries;\n+      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)\n+\tif (CGEN_INSN_RX ((insns)))\n+\t  regfree (CGEN_INSN_RX (insns));\n+    }\n+\n+  if (cd->insn_table.init_entries)\n+    {\n+      insns = cd->insn_table.init_entries;\n+      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)\n+\tif (CGEN_INSN_RX (insns))\n+\t  regfree (CGEN_INSN_RX (insns));\n+    }\n+\n+  if (cd->macro_insn_table.init_entries)\n+    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);\n+\n+  if (cd->insn_table.init_entries)\n+    free ((CGEN_INSN *) cd->insn_table.init_entries);\n+\n+  if (cd->hw_table.entries)\n+    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);\n+\n+  if (cd->operand_table.entries)\n+    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);\n+\n+  free (cd);\n+}\n+"
    },
    {
      "sha": "5293517953fcc911a814f25890a0801ec3b199d5",
      "filename": "opcodes/bpf-desc.h",
      "status": "added",
      "additions": 266,
      "deletions": 0,
      "changes": 266,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-desc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-desc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-desc.h?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,266 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* CPU data header for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+This file is part of the GNU Binutils and/or GDB, the GNU debugger.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef BPF_CPU_H\n+#define BPF_CPU_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CGEN_ARCH bpf\n+\n+/* Given symbol S, return bpf_cgen_<S>.  */\n+#define CGEN_SYM(s) bpf##_cgen_##s\n+\n+\n+/* Selected cpu families.  */\n+#define HAVE_CPU_BPFBF\n+\n+#define CGEN_INSN_LSB0_P 1\n+\n+/* Minimum size of any insn (in bytes).  */\n+#define CGEN_MIN_INSN_SIZE 8\n+\n+/* Maximum size of any insn (in bytes).  */\n+#define CGEN_MAX_INSN_SIZE 16\n+\n+#define CGEN_INT_INSN_P 0\n+\n+/* Maximum number of syntax elements in an instruction.  */\n+#define CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS 16\n+\n+/* CGEN_MNEMONIC_OPERANDS is defined if mnemonics have operands.\n+   e.g. In \"b,a foo\" the \",a\" is an operand.  If mnemonics have operands\n+   we can't hash on everything up to the space.  */\n+#define CGEN_MNEMONIC_OPERANDS\n+\n+/* Maximum number of fields in an instruction.  */\n+#define CGEN_ACTUAL_MAX_IFMT_OPERANDS 7\n+\n+/* Enums.  */\n+\n+/* Enum declaration for eBPF instruction codes.  */\n+typedef enum insn_op_code_alu {\n+  OP_CODE_ADD = 0, OP_CODE_SUB = 1, OP_CODE_MUL = 2, OP_CODE_DIV = 3\n+ , OP_CODE_OR = 4, OP_CODE_AND = 5, OP_CODE_LSH = 6, OP_CODE_RSH = 7\n+ , OP_CODE_NEG = 8, OP_CODE_MOD = 9, OP_CODE_XOR = 10, OP_CODE_MOV = 11\n+ , OP_CODE_ARSH = 12, OP_CODE_END = 13, OP_CODE_JA = 0, OP_CODE_JEQ = 1\n+ , OP_CODE_JGT = 2, OP_CODE_JGE = 3, OP_CODE_JSET = 4, OP_CODE_JNE = 5\n+ , OP_CODE_JSGT = 6, OP_CODE_JSGE = 7, OP_CODE_CALL = 8, OP_CODE_EXIT = 9\n+ , OP_CODE_JLT = 10, OP_CODE_JLE = 11, OP_CODE_JSLT = 12, OP_CODE_JSLE = 13\n+} INSN_OP_CODE_ALU;\n+\n+/* Enum declaration for eBPF instruction source.  */\n+typedef enum insn_op_src {\n+  OP_SRC_K, OP_SRC_X\n+} INSN_OP_SRC;\n+\n+/* Enum declaration for eBPF instruction class.  */\n+typedef enum insn_op_class {\n+  OP_CLASS_LD = 0, OP_CLASS_LDX = 1, OP_CLASS_ST = 2, OP_CLASS_STX = 3\n+ , OP_CLASS_ALU = 4, OP_CLASS_JMP = 5, OP_CLASS_ALU64 = 7\n+} INSN_OP_CLASS;\n+\n+/* Enum declaration for eBPF load/store instruction modes.  */\n+typedef enum insn_op_mode {\n+  OP_MODE_IMM = 0, OP_MODE_ABS = 1, OP_MODE_IND = 2, OP_MODE_MEM = 3\n+ , OP_MODE_XADD = 6\n+} INSN_OP_MODE;\n+\n+/* Enum declaration for eBPF load/store instruction sizes.  */\n+typedef enum insn_op_size {\n+  OP_SIZE_W, OP_SIZE_H, OP_SIZE_B, OP_SIZE_DW\n+} INSN_OP_SIZE;\n+\n+/* Attributes.  */\n+\n+/* Enum declaration for machine type selection.  */\n+typedef enum mach_attr {\n+  MACH_BASE, MACH_BPF, MACH_MAX\n+} MACH_ATTR;\n+\n+/* Enum declaration for instruction set selection.  */\n+typedef enum isa_attr {\n+  ISA_EBPFLE, ISA_EBPFBE, ISA_MAX\n+} ISA_ATTR;\n+\n+/* Number of architecture variants.  */\n+#define MAX_ISAS  ((int) ISA_MAX)\n+#define MAX_MACHS ((int) MACH_MAX)\n+\n+/* Ifield support.  */\n+\n+/* Ifield attribute indices.  */\n+\n+/* Enum declaration for cgen_ifld attrs.  */\n+typedef enum cgen_ifld_attr {\n+  CGEN_IFLD_VIRTUAL, CGEN_IFLD_PCREL_ADDR, CGEN_IFLD_ABS_ADDR, CGEN_IFLD_RESERVED\n+ , CGEN_IFLD_SIGN_OPT, CGEN_IFLD_SIGNED, CGEN_IFLD_END_BOOLS, CGEN_IFLD_START_NBOOLS = 31\n+ , CGEN_IFLD_MACH, CGEN_IFLD_ISA, CGEN_IFLD_END_NBOOLS\n+} CGEN_IFLD_ATTR;\n+\n+/* Number of non-boolean elements in cgen_ifld_attr.  */\n+#define CGEN_IFLD_NBOOL_ATTRS (CGEN_IFLD_END_NBOOLS - CGEN_IFLD_START_NBOOLS - 1)\n+\n+/* cgen_ifld attribute accessor macros.  */\n+#define CGEN_ATTR_CGEN_IFLD_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_MACH-CGEN_IFLD_START_NBOOLS-1].nonbitset)\n+#define CGEN_ATTR_CGEN_IFLD_ISA_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_ISA-CGEN_IFLD_START_NBOOLS-1].bitset)\n+#define CGEN_ATTR_CGEN_IFLD_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_VIRTUAL)) != 0)\n+#define CGEN_ATTR_CGEN_IFLD_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_PCREL_ADDR)) != 0)\n+#define CGEN_ATTR_CGEN_IFLD_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_ABS_ADDR)) != 0)\n+#define CGEN_ATTR_CGEN_IFLD_RESERVED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_RESERVED)) != 0)\n+#define CGEN_ATTR_CGEN_IFLD_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGN_OPT)) != 0)\n+#define CGEN_ATTR_CGEN_IFLD_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGNED)) != 0)\n+\n+/* Enum declaration for bpf ifield types.  */\n+typedef enum ifield_type {\n+  BPF_F_NIL, BPF_F_ANYOF, BPF_F_OP_CODE, BPF_F_OP_SRC\n+ , BPF_F_OP_CLASS, BPF_F_OP_MODE, BPF_F_OP_SIZE, BPF_F_DSTLE\n+ , BPF_F_SRCLE, BPF_F_DSTBE, BPF_F_SRCBE, BPF_F_REGS\n+ , BPF_F_OFFSET16, BPF_F_IMM32, BPF_F_IMM64_A, BPF_F_IMM64_B\n+ , BPF_F_IMM64_C, BPF_F_IMM64, BPF_F_MAX\n+} IFIELD_TYPE;\n+\n+#define MAX_IFLD ((int) BPF_F_MAX)\n+\n+/* Hardware attribute indices.  */\n+\n+/* Enum declaration for cgen_hw attrs.  */\n+typedef enum cgen_hw_attr {\n+  CGEN_HW_VIRTUAL, CGEN_HW_CACHE_ADDR, CGEN_HW_PC, CGEN_HW_PROFILE\n+ , CGEN_HW_END_BOOLS, CGEN_HW_START_NBOOLS = 31, CGEN_HW_MACH, CGEN_HW_ISA\n+ , CGEN_HW_END_NBOOLS\n+} CGEN_HW_ATTR;\n+\n+/* Number of non-boolean elements in cgen_hw_attr.  */\n+#define CGEN_HW_NBOOL_ATTRS (CGEN_HW_END_NBOOLS - CGEN_HW_START_NBOOLS - 1)\n+\n+/* cgen_hw attribute accessor macros.  */\n+#define CGEN_ATTR_CGEN_HW_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_MACH-CGEN_HW_START_NBOOLS-1].nonbitset)\n+#define CGEN_ATTR_CGEN_HW_ISA_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_ISA-CGEN_HW_START_NBOOLS-1].bitset)\n+#define CGEN_ATTR_CGEN_HW_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_VIRTUAL)) != 0)\n+#define CGEN_ATTR_CGEN_HW_CACHE_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_CACHE_ADDR)) != 0)\n+#define CGEN_ATTR_CGEN_HW_PC_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PC)) != 0)\n+#define CGEN_ATTR_CGEN_HW_PROFILE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PROFILE)) != 0)\n+\n+/* Enum declaration for bpf hardware types.  */\n+typedef enum cgen_hw_type {\n+  HW_H_MEMORY, HW_H_SINT, HW_H_UINT, HW_H_ADDR\n+ , HW_H_IADDR, HW_H_GPR, HW_H_PC, HW_H_SINT64\n+ , HW_MAX\n+} CGEN_HW_TYPE;\n+\n+#define MAX_HW ((int) HW_MAX)\n+\n+/* Operand attribute indices.  */\n+\n+/* Enum declaration for cgen_operand attrs.  */\n+typedef enum cgen_operand_attr {\n+  CGEN_OPERAND_VIRTUAL, CGEN_OPERAND_PCREL_ADDR, CGEN_OPERAND_ABS_ADDR, CGEN_OPERAND_SIGN_OPT\n+ , CGEN_OPERAND_SIGNED, CGEN_OPERAND_NEGATIVE, CGEN_OPERAND_RELAX, CGEN_OPERAND_SEM_ONLY\n+ , CGEN_OPERAND_END_BOOLS, CGEN_OPERAND_START_NBOOLS = 31, CGEN_OPERAND_MACH, CGEN_OPERAND_ISA\n+ , CGEN_OPERAND_END_NBOOLS\n+} CGEN_OPERAND_ATTR;\n+\n+/* Number of non-boolean elements in cgen_operand_attr.  */\n+#define CGEN_OPERAND_NBOOL_ATTRS (CGEN_OPERAND_END_NBOOLS - CGEN_OPERAND_START_NBOOLS - 1)\n+\n+/* cgen_operand attribute accessor macros.  */\n+#define CGEN_ATTR_CGEN_OPERAND_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_MACH-CGEN_OPERAND_START_NBOOLS-1].nonbitset)\n+#define CGEN_ATTR_CGEN_OPERAND_ISA_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_ISA-CGEN_OPERAND_START_NBOOLS-1].bitset)\n+#define CGEN_ATTR_CGEN_OPERAND_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_VIRTUAL)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_PCREL_ADDR)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_ABS_ADDR)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGN_OPT)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGNED)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_NEGATIVE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_NEGATIVE)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_RELAX_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_RELAX)) != 0)\n+#define CGEN_ATTR_CGEN_OPERAND_SEM_ONLY_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SEM_ONLY)) != 0)\n+\n+/* Enum declaration for bpf operand types.  */\n+typedef enum cgen_operand_type {\n+  BPF_OPERAND_PC, BPF_OPERAND_DSTLE, BPF_OPERAND_SRCLE, BPF_OPERAND_DSTBE\n+ , BPF_OPERAND_SRCBE, BPF_OPERAND_DISP16, BPF_OPERAND_DISP32, BPF_OPERAND_IMM32\n+ , BPF_OPERAND_OFFSET16, BPF_OPERAND_IMM64, BPF_OPERAND_ENDSIZE, BPF_OPERAND_MAX\n+} CGEN_OPERAND_TYPE;\n+\n+/* Number of operands types.  */\n+#define MAX_OPERANDS 11\n+\n+/* Maximum number of operands referenced by any insn.  */\n+#define MAX_OPERAND_INSTANCES 8\n+\n+/* Insn attribute indices.  */\n+\n+/* Enum declaration for cgen_insn attrs.  */\n+typedef enum cgen_insn_attr {\n+  CGEN_INSN_ALIAS, CGEN_INSN_VIRTUAL, CGEN_INSN_UNCOND_CTI, CGEN_INSN_COND_CTI\n+ , CGEN_INSN_SKIP_CTI, CGEN_INSN_DELAY_SLOT, CGEN_INSN_RELAXABLE, CGEN_INSN_RELAXED\n+ , CGEN_INSN_NO_DIS, CGEN_INSN_PBB, CGEN_INSN_END_BOOLS, CGEN_INSN_START_NBOOLS = 31\n+ , CGEN_INSN_MACH, CGEN_INSN_ISA, CGEN_INSN_END_NBOOLS\n+} CGEN_INSN_ATTR;\n+\n+/* Number of non-boolean elements in cgen_insn_attr.  */\n+#define CGEN_INSN_NBOOL_ATTRS (CGEN_INSN_END_NBOOLS - CGEN_INSN_START_NBOOLS - 1)\n+\n+/* cgen_insn attribute accessor macros.  */\n+#define CGEN_ATTR_CGEN_INSN_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_MACH-CGEN_INSN_START_NBOOLS-1].nonbitset)\n+#define CGEN_ATTR_CGEN_INSN_ISA_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_ISA-CGEN_INSN_START_NBOOLS-1].bitset)\n+#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_ALIAS)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_VIRTUAL)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_UNCOND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_UNCOND_CTI)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_COND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_COND_CTI)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_SKIP_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_SKIP_CTI)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_DELAY_SLOT)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXABLE)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_RELAXED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXED)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_NO_DIS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NO_DIS)) != 0)\n+#define CGEN_ATTR_CGEN_INSN_PBB_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_PBB)) != 0)\n+\n+/* cgen.h uses things we just defined.  */\n+#include \"opcode/cgen.h\"\n+\n+extern const struct cgen_ifld bpf_cgen_ifld_table[];\n+\n+/* Attributes.  */\n+extern const CGEN_ATTR_TABLE bpf_cgen_hardware_attr_table[];\n+extern const CGEN_ATTR_TABLE bpf_cgen_ifield_attr_table[];\n+extern const CGEN_ATTR_TABLE bpf_cgen_operand_attr_table[];\n+extern const CGEN_ATTR_TABLE bpf_cgen_insn_attr_table[];\n+\n+/* Hardware decls.  */\n+\n+extern CGEN_KEYWORD bpf_cgen_opval_h_gpr;\n+\n+extern const CGEN_HW_ENTRY bpf_cgen_hw_table[];\n+\n+\n+\n+   #ifdef __cplusplus\n+   }\n+   #endif\n+\n+#endif /* BPF_CPU_H */"
    },
    {
      "sha": "c48bce85e6434a2e0e8aff7f11a955a820e5e8b2",
      "filename": "opcodes/bpf-dis.c",
      "status": "added",
      "additions": 624,
      "deletions": 0,
      "changes": 624,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-dis.c?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,624 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* Disassembler interface for targets using CGEN. -*- C -*-\n+   CGEN: Cpu tools GENerator\n+\n+   THIS FILE IS MACHINE GENERATED WITH CGEN.\n+   - the resultant file is machine generated, cgen-dis.in isn't\n+\n+   Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+   This file is part of libopcodes.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+/* ??? Eventually more and more of this stuff can go to cpu-independent files.\n+   Keep that in mind.  */\n+\n+#include \"sysdep.h\"\n+#include <stdio.h>\n+#include \"ansidecl.h\"\n+#include \"disassemble.h\"\n+#include \"bfd.h\"\n+#include \"symcat.h\"\n+#include \"libiberty.h\"\n+#include \"bpf-desc.h\"\n+#include \"bpf-opc.h\"\n+#include \"opintl.h\"\n+\n+/* Default text to print if an instruction isn't recognized.  */\n+#define UNKNOWN_INSN_MSG _(\"*unknown*\")\n+\n+static void print_normal\n+  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);\n+static void print_address\n+  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;\n+static void print_keyword\n+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;\n+static void print_insn_normal\n+  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);\n+static int print_insn\n+  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);\n+static int default_print_insn\n+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;\n+static int read_insn\n+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,\n+   unsigned long *);\n+\f\n+/* -- disassembler routines inserted here.  */\n+\n+/* -- dis.c */\n+\n+/* We need to customize the disassembler a bit:\n+   - Use 8 bytes per line by default.\n+*/\n+\n+#define CGEN_PRINT_INSN bpf_print_insn\n+\n+static int\n+bpf_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)\n+{\n+  bfd_byte buf[CGEN_MAX_INSN_SIZE];\n+  int buflen;\n+  int status;\n+\n+  info->bytes_per_chunk = 1;\n+  info->bytes_per_line = 8;\n+\n+  /* Attempt to read the base part of the insn.  */\n+  buflen = cd->base_insn_bitsize / 8;\n+  status = (*info->read_memory_func) (pc, buf, buflen, info);\n+\n+  /* Try again with the minimum part, if min < base.  */\n+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))\n+    {\n+      buflen = cd->min_insn_bitsize / 8;\n+      status = (*info->read_memory_func) (pc, buf, buflen, info);\n+    }\n+\n+  if (status != 0)\n+    {\n+      (*info->memory_error_func) (status, pc, info);\n+      return -1;\n+    }\n+\n+  return print_insn (cd, pc, info, buf, buflen);\n+}\n+\n+/* Signed immediates should be printed in hexadecimal.  */\n+\n+static void\n+print_immediate (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+                 void *dis_info,\n+                 int64_t value,\n+                 unsigned int attrs ATTRIBUTE_UNUSED,\n+                 bfd_vma pc ATTRIBUTE_UNUSED,\n+                 int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+\n+  if (value <= 9)\n+    (*info->fprintf_func) (info->stream, \"%\" PRId64, value);\n+  else\n+    (*info->fprintf_func) (info->stream, \"%#\" PRIx64, value);\n+\n+  /* This is to avoid -Wunused-function for print_normal.  */\n+  if (0)\n+    print_normal (cd, dis_info, value, attrs, pc, length);\n+}\n+\n+/* Endianness bit sizes should be printed in decimal.  */\n+\n+static void\n+print_endsize (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+               void *dis_info,\n+               unsigned long value,\n+               unsigned int attrs ATTRIBUTE_UNUSED,\n+               bfd_vma pc ATTRIBUTE_UNUSED,\n+               int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+  (*info->fprintf_func) (info->stream, \"%lu\", value);\n+}\n+\n+\f\n+/* -- */\n+\n+void bpf_cgen_print_operand\n+  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);\n+\n+/* Main entry point for printing operands.\n+   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement\n+   of dis-asm.h on cgen.h.\n+\n+   This function is basically just a big switch statement.  Earlier versions\n+   used tables to look up the function to use, but\n+   - if the table contains both assembler and disassembler functions then\n+     the disassembler contains much of the assembler and vice-versa,\n+   - there's a lot of inlining possibilities as things grow,\n+   - using a switch statement avoids the function call overhead.\n+\n+   This function could be moved into `print_insn_normal', but keeping it\n+   separate makes clear the interface between `print_insn_normal' and each of\n+   the handlers.  */\n+\n+void\n+bpf_cgen_print_operand (CGEN_CPU_DESC cd,\n+\t\t\t   int opindex,\n+\t\t\t   void * xinfo,\n+\t\t\t   CGEN_FIELDS *fields,\n+\t\t\t   void const *attrs ATTRIBUTE_UNUSED,\n+\t\t\t   bfd_vma pc,\n+\t\t\t   int length)\n+{\n+  disassemble_info *info = (disassemble_info *) xinfo;\n+\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      print_normal (cd, info, fields->f_offset16, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      print_normal (cd, info, fields->f_imm32, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      print_keyword (cd, info, & bpf_cgen_opval_h_gpr, fields->f_dstbe, 0);\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      print_keyword (cd, info, & bpf_cgen_opval_h_gpr, fields->f_dstle, 0);\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      print_endsize (cd, info, fields->f_imm32, 0, pc, length);\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      print_immediate (cd, info, fields->f_imm32, 0|(1<<CGEN_OPERAND_SIGNED), pc, length);\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      print_immediate (cd, info, fields->f_imm64, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      print_immediate (cd, info, fields->f_offset16, 0|(1<<CGEN_OPERAND_SIGNED), pc, length);\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      print_keyword (cd, info, & bpf_cgen_opval_h_gpr, fields->f_srcbe, 0);\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      print_keyword (cd, info, & bpf_cgen_opval_h_gpr, fields->f_srcle, 0);\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while printing insn\"),\n+\t opindex);\n+      abort ();\n+  }\n+}\n+\n+cgen_print_fn * const bpf_cgen_print_handlers[] =\n+{\n+  print_insn_normal,\n+};\n+\n+\n+void\n+bpf_cgen_init_dis (CGEN_CPU_DESC cd)\n+{\n+  bpf_cgen_init_opcode_table (cd);\n+  bpf_cgen_init_ibld_table (cd);\n+  cd->print_handlers = & bpf_cgen_print_handlers[0];\n+  cd->print_operand = bpf_cgen_print_operand;\n+}\n+\n+\f\n+/* Default print handler.  */\n+\n+static void\n+print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t      void *dis_info,\n+\t      long value,\n+\t      unsigned int attrs,\n+\t      bfd_vma pc ATTRIBUTE_UNUSED,\n+\t      int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+\n+  /* Print the operand as directed by the attributes.  */\n+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))\n+    ; /* nothing to do */\n+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))\n+    (*info->fprintf_func) (info->stream, \"%ld\", value);\n+  else\n+    (*info->fprintf_func) (info->stream, \"0x%lx\", value);\n+}\n+\n+/* Default address handler.  */\n+\n+static void\n+print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t       void *dis_info,\n+\t       bfd_vma value,\n+\t       unsigned int attrs,\n+\t       bfd_vma pc ATTRIBUTE_UNUSED,\n+\t       int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+\n+  /* Print the operand as directed by the attributes.  */\n+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))\n+    ; /* Nothing to do.  */\n+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))\n+    (*info->print_address_func) (value, info);\n+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))\n+    (*info->print_address_func) (value, info);\n+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))\n+    (*info->fprintf_func) (info->stream, \"%ld\", (long) value);\n+  else\n+    (*info->fprintf_func) (info->stream, \"0x%lx\", (long) value);\n+}\n+\n+/* Keyword print handler.  */\n+\n+static void\n+print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t       void *dis_info,\n+\t       CGEN_KEYWORD *keyword_table,\n+\t       long value,\n+\t       unsigned int attrs ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+  const CGEN_KEYWORD_ENTRY *ke;\n+\n+  ke = cgen_keyword_lookup_value (keyword_table, value);\n+  if (ke != NULL)\n+    (*info->fprintf_func) (info->stream, \"%s\", ke->name);\n+  else\n+    (*info->fprintf_func) (info->stream, \"???\");\n+}\n+\f\n+/* Default insn printer.\n+\n+   DIS_INFO is defined as `void *' so the disassembler needn't know anything\n+   about disassemble_info.  */\n+\n+static void\n+print_insn_normal (CGEN_CPU_DESC cd,\n+\t\t   void *dis_info,\n+\t\t   const CGEN_INSN *insn,\n+\t\t   CGEN_FIELDS *fields,\n+\t\t   bfd_vma pc,\n+\t\t   int length)\n+{\n+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);\n+  disassemble_info *info = (disassemble_info *) dis_info;\n+  const CGEN_SYNTAX_CHAR_TYPE *syn;\n+\n+  CGEN_INIT_PRINT (cd);\n+\n+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)\n+    {\n+      if (CGEN_SYNTAX_MNEMONIC_P (*syn))\n+\t{\n+\t  (*info->fprintf_func) (info->stream, \"%s\", CGEN_INSN_MNEMONIC (insn));\n+\t  continue;\n+\t}\n+      if (CGEN_SYNTAX_CHAR_P (*syn))\n+\t{\n+\t  (*info->fprintf_func) (info->stream, \"%c\", CGEN_SYNTAX_CHAR (*syn));\n+\t  continue;\n+\t}\n+\n+      /* We have an operand.  */\n+      bpf_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,\n+\t\t\t\t fields, CGEN_INSN_ATTRS (insn), pc, length);\n+    }\n+}\n+\f\n+/* Subroutine of print_insn. Reads an insn into the given buffers and updates\n+   the extract info.\n+   Returns 0 if all is well, non-zero otherwise.  */\n+\n+static int\n+read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t   bfd_vma pc,\n+\t   disassemble_info *info,\n+\t   bfd_byte *buf,\n+\t   int buflen,\n+\t   CGEN_EXTRACT_INFO *ex_info,\n+\t   unsigned long *insn_value)\n+{\n+  int status = (*info->read_memory_func) (pc, buf, buflen, info);\n+\n+  if (status != 0)\n+    {\n+      (*info->memory_error_func) (status, pc, info);\n+      return -1;\n+    }\n+\n+  ex_info->dis_info = info;\n+  ex_info->valid = (1 << buflen) - 1;\n+  ex_info->insn_bytes = buf;\n+\n+  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);\n+  return 0;\n+}\n+\n+/* Utility to print an insn.\n+   BUF is the base part of the insn, target byte order, BUFLEN bytes long.\n+   The result is the size of the insn in bytes or zero for an unknown insn\n+   or -1 if an error occurs fetching data (memory_error_func will have\n+   been called).  */\n+\n+static int\n+print_insn (CGEN_CPU_DESC cd,\n+\t    bfd_vma pc,\n+\t    disassemble_info *info,\n+\t    bfd_byte *buf,\n+\t    unsigned int buflen)\n+{\n+  CGEN_INSN_INT insn_value;\n+  const CGEN_INSN_LIST *insn_list;\n+  CGEN_EXTRACT_INFO ex_info;\n+  int basesize;\n+\n+  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */\n+  basesize = cd->base_insn_bitsize < buflen * 8 ?\n+                                     cd->base_insn_bitsize : buflen * 8;\n+  insn_value = cgen_get_insn_value (cd, buf, basesize);\n+\n+\n+  /* Fill in ex_info fields like read_insn would.  Don't actually call\n+     read_insn, since the incoming buffer is already read (and possibly\n+     modified a la m32r).  */\n+  ex_info.valid = (1 << buflen) - 1;\n+  ex_info.dis_info = info;\n+  ex_info.insn_bytes = buf;\n+\n+  /* The instructions are stored in hash lists.\n+     Pick the first one and keep trying until we find the right one.  */\n+\n+  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);\n+  while (insn_list != NULL)\n+    {\n+      const CGEN_INSN *insn = insn_list->insn;\n+      CGEN_FIELDS fields;\n+      int length;\n+      unsigned long insn_value_cropped;\n+\n+#ifdef CGEN_VALIDATE_INSN_SUPPORTED\n+      /* Not needed as insn shouldn't be in hash lists if not supported.  */\n+      /* Supported by this cpu?  */\n+      if (! bpf_cgen_insn_supported (cd, insn))\n+        {\n+          insn_list = CGEN_DIS_NEXT_INSN (insn_list);\n+\t  continue;\n+        }\n+#endif\n+\n+      /* Basic bit mask must be correct.  */\n+      /* ??? May wish to allow target to defer this check until the extract\n+\t handler.  */\n+\n+      /* Base size may exceed this instruction's size.  Extract the\n+         relevant part from the buffer. */\n+      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&\n+\t  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))\n+\tinsn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),\n+\t\t\t\t\t   info->endian == BFD_ENDIAN_BIG);\n+      else\n+\tinsn_value_cropped = insn_value;\n+\n+      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))\n+\t  == CGEN_INSN_BASE_VALUE (insn))\n+\t{\n+\t  /* Printing is handled in two passes.  The first pass parses the\n+\t     machine insn and extracts the fields.  The second pass prints\n+\t     them.  */\n+\n+\t  /* Make sure the entire insn is loaded into insn_value, if it\n+\t     can fit.  */\n+\t  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&\n+\t      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))\n+\t    {\n+\t      unsigned long full_insn_value;\n+\t      int rc = read_insn (cd, pc, info, buf,\n+\t\t\t\t  CGEN_INSN_BITSIZE (insn) / 8,\n+\t\t\t\t  & ex_info, & full_insn_value);\n+\t      if (rc != 0)\n+\t\treturn rc;\n+\t      length = CGEN_EXTRACT_FN (cd, insn)\n+\t\t(cd, insn, &ex_info, full_insn_value, &fields, pc);\n+\t    }\n+\t  else\n+\t    length = CGEN_EXTRACT_FN (cd, insn)\n+\t      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);\n+\n+\t  /* Length < 0 -> error.  */\n+\t  if (length < 0)\n+\t    return length;\n+\t  if (length > 0)\n+\t    {\n+\t      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);\n+\t      /* Length is in bits, result is in bytes.  */\n+\t      return length / 8;\n+\t    }\n+\t}\n+\n+      insn_list = CGEN_DIS_NEXT_INSN (insn_list);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Default value for CGEN_PRINT_INSN.\n+   The result is the size of the insn in bytes or zero for an unknown insn\n+   or -1 if an error occured fetching bytes.  */\n+\n+#ifndef CGEN_PRINT_INSN\n+#define CGEN_PRINT_INSN default_print_insn\n+#endif\n+\n+static int\n+default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)\n+{\n+  bfd_byte buf[CGEN_MAX_INSN_SIZE];\n+  int buflen;\n+  int status;\n+\n+  /* Attempt to read the base part of the insn.  */\n+  buflen = cd->base_insn_bitsize / 8;\n+  status = (*info->read_memory_func) (pc, buf, buflen, info);\n+\n+  /* Try again with the minimum part, if min < base.  */\n+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))\n+    {\n+      buflen = cd->min_insn_bitsize / 8;\n+      status = (*info->read_memory_func) (pc, buf, buflen, info);\n+    }\n+\n+  if (status != 0)\n+    {\n+      (*info->memory_error_func) (status, pc, info);\n+      return -1;\n+    }\n+\n+  return print_insn (cd, pc, info, buf, buflen);\n+}\n+\n+/* Main entry point.\n+   Print one instruction from PC on INFO->STREAM.\n+   Return the size of the instruction (in bytes).  */\n+\n+typedef struct cpu_desc_list\n+{\n+  struct cpu_desc_list *next;\n+  CGEN_BITSET *isa;\n+  int mach;\n+  int endian;\n+  CGEN_CPU_DESC cd;\n+} cpu_desc_list;\n+\n+int\n+print_insn_bpf (bfd_vma pc, disassemble_info *info)\n+{\n+  static cpu_desc_list *cd_list = 0;\n+  cpu_desc_list *cl = 0;\n+  static CGEN_CPU_DESC cd = 0;\n+  static CGEN_BITSET *prev_isa;\n+  static int prev_mach;\n+  static int prev_endian;\n+  int length;\n+  CGEN_BITSET *isa;\n+  int mach;\n+  int endian = (info->endian == BFD_ENDIAN_BIG\n+\t\t? CGEN_ENDIAN_BIG\n+\t\t: CGEN_ENDIAN_LITTLE);\n+  enum bfd_architecture arch;\n+\n+  /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n+#ifndef CGEN_BFD_ARCH\n+#define CGEN_BFD_ARCH bfd_arch_bpf\n+#endif\n+  arch = info->arch;\n+  if (arch == bfd_arch_unknown)\n+    arch = CGEN_BFD_ARCH;\n+\n+  /* There's no standard way to compute the machine or isa number\n+     so we leave it to the target.  */\n+#ifdef CGEN_COMPUTE_MACH\n+  mach = CGEN_COMPUTE_MACH (info);\n+#else\n+  mach = info->mach;\n+#endif\n+\n+#ifdef CGEN_COMPUTE_ISA\n+  {\n+    static CGEN_BITSET *permanent_isa;\n+\n+    if (!permanent_isa)\n+      permanent_isa = cgen_bitset_create (MAX_ISAS);\n+    isa = permanent_isa;\n+    cgen_bitset_clear (isa);\n+    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));\n+  }\n+#else\n+  isa = info->insn_sets;\n+#endif\n+\n+  /* If we've switched cpu's, try to find a handle we've used before */\n+  if (cd\n+      && (cgen_bitset_compare (isa, prev_isa) != 0\n+\t  || mach != prev_mach\n+\t  || endian != prev_endian))\n+    {\n+      cd = 0;\n+      for (cl = cd_list; cl; cl = cl->next)\n+\t{\n+\t  if (cgen_bitset_compare (cl->isa, isa) == 0 &&\n+\t      cl->mach == mach &&\n+\t      cl->endian == endian)\n+\t    {\n+\t      cd = cl->cd;\n+ \t      prev_isa = cd->isas;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* If we haven't initialized yet, initialize the opcode table.  */\n+  if (! cd)\n+    {\n+      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);\n+      const char *mach_name;\n+\n+      if (!arch_type)\n+\tabort ();\n+      mach_name = arch_type->printable_name;\n+\n+      prev_isa = cgen_bitset_copy (isa);\n+      prev_mach = mach;\n+      prev_endian = endian;\n+      cd = bpf_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n+\t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n+\t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+\t\t\t\t CGEN_CPU_OPEN_END);\n+      if (!cd)\n+\tabort ();\n+\n+      /* Save this away for future reference.  */\n+      cl = xmalloc (sizeof (struct cpu_desc_list));\n+      cl->cd = cd;\n+      cl->isa = prev_isa;\n+      cl->mach = mach;\n+      cl->endian = endian;\n+      cl->next = cd_list;\n+      cd_list = cl;\n+\n+      bpf_cgen_init_dis (cd);\n+    }\n+\n+  /* We try to have as much common code as possible.\n+     But at this point some targets need to take over.  */\n+  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,\n+     but if not possible try to move this hook elsewhere rather than\n+     have two hooks.  */\n+  length = CGEN_PRINT_INSN (cd, pc, info);\n+  if (length > 0)\n+    return length;\n+  if (length < 0)\n+    return -1;\n+\n+  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);\n+  return cd->default_insn_bitsize / 8;\n+}"
    },
    {
      "sha": "b14c28b43bc2af1d96026b84d87aa17d93f1c05e",
      "filename": "opcodes/bpf-ibld.c",
      "status": "added",
      "additions": 956,
      "deletions": 0,
      "changes": 956,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-ibld.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-ibld.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-ibld.c?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,956 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* Instruction building/extraction support for bpf. -*- C -*-\n+\n+   THIS FILE IS MACHINE GENERATED WITH CGEN: Cpu tools GENerator.\n+   - the resultant file is machine generated, cgen-ibld.in isn't\n+\n+   Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+   This file is part of libopcodes.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+/* ??? Eventually more and more of this stuff can go to cpu-independent files.\n+   Keep that in mind.  */\n+\n+#include \"sysdep.h\"\n+#include <stdio.h>\n+#include \"ansidecl.h\"\n+#include \"dis-asm.h\"\n+#include \"bfd.h\"\n+#include \"symcat.h\"\n+#include \"bpf-desc.h\"\n+#include \"bpf-opc.h\"\n+#include \"cgen/basic-modes.h\"\n+#include \"opintl.h\"\n+#include \"safe-ctype.h\"\n+\n+#undef  min\n+#define min(a,b) ((a) < (b) ? (a) : (b))\n+#undef  max\n+#define max(a,b) ((a) > (b) ? (a) : (b))\n+\n+/* Used by the ifield rtx function.  */\n+#define FLD(f) (fields->f)\n+\n+static const char * insert_normal\n+  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,\n+   unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);\n+static const char * insert_insn_normal\n+  (CGEN_CPU_DESC, const CGEN_INSN *,\n+   CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);\n+static int extract_normal\n+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,\n+   unsigned int, unsigned int, unsigned int, unsigned int,\n+   unsigned int, unsigned int, bfd_vma, long *);\n+static int extract_insn_normal\n+  (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,\n+   CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);\n+#if CGEN_INT_INSN_P\n+static void put_insn_int_value\n+  (CGEN_CPU_DESC, CGEN_INSN_BYTES_PTR, int, int, CGEN_INSN_INT);\n+#endif\n+#if ! CGEN_INT_INSN_P\n+static CGEN_INLINE void insert_1\n+  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);\n+static CGEN_INLINE int fill_cache\n+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);\n+static CGEN_INLINE long extract_1\n+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);\n+#endif\n+\f\n+/* Operand insertion.  */\n+\n+#if ! CGEN_INT_INSN_P\n+\n+/* Subroutine of insert_normal.  */\n+\n+static CGEN_INLINE void\n+insert_1 (CGEN_CPU_DESC cd,\n+\t  unsigned long value,\n+\t  int start,\n+\t  int length,\n+\t  int word_length,\n+\t  unsigned char *bufp)\n+{\n+  unsigned long x,mask;\n+  int shift;\n+\n+  x = cgen_get_insn_value (cd, bufp, word_length);\n+\n+  /* Written this way to avoid undefined behaviour.  */\n+  mask = (((1L << (length - 1)) - 1) << 1) | 1;\n+  if (CGEN_INSN_LSB0_P)\n+    shift = (start + 1) - length;\n+  else\n+    shift = (word_length - (start + length));\n+  x = (x & ~(mask << shift)) | ((value & mask) << shift);\n+\n+  cgen_put_insn_value (cd, bufp, word_length, (bfd_vma) x);\n+}\n+\n+#endif /* ! CGEN_INT_INSN_P */\n+\n+/* Default insertion routine.\n+\n+   ATTRS is a mask of the boolean attributes.\n+   WORD_OFFSET is the offset in bits from the start of the insn of the value.\n+   WORD_LENGTH is the length of the word in bits in which the value resides.\n+   START is the starting bit number in the word, architecture origin.\n+   LENGTH is the length of VALUE in bits.\n+   TOTAL_LENGTH is the total length of the insn in bits.\n+\n+   The result is an error message or NULL if success.  */\n+\n+/* ??? This duplicates functionality with bfd's howto table and\n+   bfd_install_relocation.  */\n+/* ??? This doesn't handle bfd_vma's.  Create another function when\n+   necessary.  */\n+\n+static const char *\n+insert_normal (CGEN_CPU_DESC cd,\n+\t       long value,\n+\t       unsigned int attrs,\n+\t       unsigned int word_offset,\n+\t       unsigned int start,\n+\t       unsigned int length,\n+\t       unsigned int word_length,\n+\t       unsigned int total_length,\n+\t       CGEN_INSN_BYTES_PTR buffer)\n+{\n+  static char errbuf[100];\n+  /* Written this way to avoid undefined behaviour.  */\n+  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;\n+\n+  /* If LENGTH is zero, this operand doesn't contribute to the value.  */\n+  if (length == 0)\n+    return NULL;\n+\n+  if (word_length > 8 * sizeof (CGEN_INSN_INT))\n+    abort ();\n+\n+  /* For architectures with insns smaller than the base-insn-bitsize,\n+     word_length may be too big.  */\n+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)\n+    {\n+      if (word_offset == 0\n+\t  && word_length > total_length)\n+\tword_length = total_length;\n+    }\n+\n+  /* Ensure VALUE will fit.  */\n+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))\n+    {\n+      long minval = - (1L << (length - 1));\n+      unsigned long maxval = mask;\n+\n+      if ((value > 0 && (unsigned long) value > maxval)\n+\t  || value < minval)\n+\t{\n+\t  /* xgettext:c-format */\n+\t  sprintf (errbuf,\n+\t\t   _(\"operand out of range (%ld not between %ld and %lu)\"),\n+\t\t   value, minval, maxval);\n+\t  return errbuf;\n+\t}\n+    }\n+  else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))\n+    {\n+      unsigned long maxval = mask;\n+      unsigned long val = (unsigned long) value;\n+\n+      /* For hosts with a word size > 32 check to see if value has been sign\n+\t extended beyond 32 bits.  If so then ignore these higher sign bits\n+\t as the user is attempting to store a 32-bit signed value into an\n+\t unsigned 32-bit field which is allowed.  */\n+      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))\n+\tval &= 0xFFFFFFFF;\n+\n+      if (val > maxval)\n+\t{\n+\t  /* xgettext:c-format */\n+\t  sprintf (errbuf,\n+\t\t   _(\"operand out of range (0x%lx not between 0 and 0x%lx)\"),\n+\t\t   val, maxval);\n+\t  return errbuf;\n+\t}\n+    }\n+  else\n+    {\n+      if (! cgen_signed_overflow_ok_p (cd))\n+\t{\n+\t  long minval = - (1L << (length - 1));\n+\t  long maxval =   (1L << (length - 1)) - 1;\n+\n+\t  if (value < minval || value > maxval)\n+\t    {\n+\t      sprintf\n+\t\t/* xgettext:c-format */\n+\t\t(errbuf, _(\"operand out of range (%ld not between %ld and %ld)\"),\n+\t\t value, minval, maxval);\n+\t      return errbuf;\n+\t    }\n+\t}\n+    }\n+\n+#if CGEN_INT_INSN_P\n+\n+  {\n+    int shift_within_word, shift_to_word, shift;\n+\n+    /* How to shift the value to BIT0 of the word.  */\n+    shift_to_word = total_length - (word_offset + word_length);\n+\n+    /* How to shift the value to the field within the word.  */\n+    if (CGEN_INSN_LSB0_P)\n+      shift_within_word = start + 1 - length;\n+    else\n+      shift_within_word = word_length - start - length;\n+\n+    /* The total SHIFT, then mask in the value.  */\n+    shift = shift_to_word + shift_within_word;\n+    *buffer = (*buffer & ~(mask << shift)) | ((value & mask) << shift);\n+  }\n+\n+#else /* ! CGEN_INT_INSN_P */\n+\n+  {\n+    unsigned char *bufp = (unsigned char *) buffer + word_offset / 8;\n+\n+    insert_1 (cd, value, start, length, word_length, bufp);\n+  }\n+\n+#endif /* ! CGEN_INT_INSN_P */\n+\n+  return NULL;\n+}\n+\n+/* Default insn builder (insert handler).\n+   The instruction is recorded in CGEN_INT_INSN_P byte order (meaning\n+   that if CGEN_INSN_BYTES_PTR is an int * and thus, the value is\n+   recorded in host byte order, otherwise BUFFER is an array of bytes\n+   and the value is recorded in target byte order).\n+   The result is an error message or NULL if success.  */\n+\n+static const char *\n+insert_insn_normal (CGEN_CPU_DESC cd,\n+\t\t    const CGEN_INSN * insn,\n+\t\t    CGEN_FIELDS * fields,\n+\t\t    CGEN_INSN_BYTES_PTR buffer,\n+\t\t    bfd_vma pc)\n+{\n+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);\n+  unsigned long value;\n+  const CGEN_SYNTAX_CHAR_TYPE * syn;\n+\n+  CGEN_INIT_INSERT (cd);\n+  value = CGEN_INSN_BASE_VALUE (insn);\n+\n+  /* If we're recording insns as numbers (rather than a string of bytes),\n+     target byte order handling is deferred until later.  */\n+\n+#if CGEN_INT_INSN_P\n+\n+  put_insn_int_value (cd, buffer, cd->base_insn_bitsize,\n+\t\t      CGEN_FIELDS_BITSIZE (fields), value);\n+\n+#else\n+\n+  cgen_put_insn_value (cd, buffer, min ((unsigned) cd->base_insn_bitsize,\n+\t\t\t\t\t(unsigned) CGEN_FIELDS_BITSIZE (fields)),\n+\t\t       value);\n+\n+#endif /* ! CGEN_INT_INSN_P */\n+\n+  /* ??? It would be better to scan the format's fields.\n+     Still need to be able to insert a value based on the operand though;\n+     e.g. storing a branch displacement that got resolved later.\n+     Needs more thought first.  */\n+\n+  for (syn = CGEN_SYNTAX_STRING (syntax); * syn; ++ syn)\n+    {\n+      const char *errmsg;\n+\n+      if (CGEN_SYNTAX_CHAR_P (* syn))\n+\tcontinue;\n+\n+      errmsg = (* cd->insert_operand) (cd, CGEN_SYNTAX_FIELD (*syn),\n+\t\t\t\t       fields, buffer, pc);\n+      if (errmsg)\n+\treturn errmsg;\n+    }\n+\n+  return NULL;\n+}\n+\n+#if CGEN_INT_INSN_P\n+/* Cover function to store an insn value into an integral insn.  Must go here\n+   because it needs <prefix>-desc.h for CGEN_INT_INSN_P.  */\n+\n+static void\n+put_insn_int_value (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t\t    CGEN_INSN_BYTES_PTR buf,\n+\t\t    int length,\n+\t\t    int insn_length,\n+\t\t    CGEN_INSN_INT value)\n+{\n+  /* For architectures with insns smaller than the base-insn-bitsize,\n+     length may be too big.  */\n+  if (length > insn_length)\n+    *buf = value;\n+  else\n+    {\n+      int shift = insn_length - length;\n+      /* Written this way to avoid undefined behaviour.  */\n+      CGEN_INSN_INT mask = (((1L << (length - 1)) - 1) << 1) | 1;\n+\n+      *buf = (*buf & ~(mask << shift)) | ((value & mask) << shift);\n+    }\n+}\n+#endif\n+\f\n+/* Operand extraction.  */\n+\n+#if ! CGEN_INT_INSN_P\n+\n+/* Subroutine of extract_normal.\n+   Ensure sufficient bytes are cached in EX_INFO.\n+   OFFSET is the offset in bytes from the start of the insn of the value.\n+   BYTES is the length of the needed value.\n+   Returns 1 for success, 0 for failure.  */\n+\n+static CGEN_INLINE int\n+fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t    CGEN_EXTRACT_INFO *ex_info,\n+\t    int offset,\n+\t    int bytes,\n+\t    bfd_vma pc)\n+{\n+  /* It's doubtful that the middle part has already been fetched so\n+     we don't optimize that case.  kiss.  */\n+  unsigned int mask;\n+  disassemble_info *info = (disassemble_info *) ex_info->dis_info;\n+\n+  /* First do a quick check.  */\n+  mask = (1 << bytes) - 1;\n+  if (((ex_info->valid >> offset) & mask) == mask)\n+    return 1;\n+\n+  /* Search for the first byte we need to read.  */\n+  for (mask = 1 << offset; bytes > 0; --bytes, ++offset, mask <<= 1)\n+    if (! (mask & ex_info->valid))\n+      break;\n+\n+  if (bytes)\n+    {\n+      int status;\n+\n+      pc += offset;\n+      status = (*info->read_memory_func)\n+\t(pc, ex_info->insn_bytes + offset, bytes, info);\n+\n+      if (status != 0)\n+\t{\n+\t  (*info->memory_error_func) (status, pc, info);\n+\t  return 0;\n+\t}\n+\n+      ex_info->valid |= ((1 << bytes) - 1) << offset;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Subroutine of extract_normal.  */\n+\n+static CGEN_INLINE long\n+extract_1 (CGEN_CPU_DESC cd,\n+\t   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,\n+\t   int start,\n+\t   int length,\n+\t   int word_length,\n+\t   unsigned char *bufp,\n+\t   bfd_vma pc ATTRIBUTE_UNUSED)\n+{\n+  unsigned long x;\n+  int shift;\n+\n+  x = cgen_get_insn_value (cd, bufp, word_length);\n+\n+  if (CGEN_INSN_LSB0_P)\n+    shift = (start + 1) - length;\n+  else\n+    shift = (word_length - (start + length));\n+  return x >> shift;\n+}\n+\n+#endif /* ! CGEN_INT_INSN_P */\n+\n+/* Default extraction routine.\n+\n+   INSN_VALUE is the first base_insn_bitsize bits of the insn in host order,\n+   or sometimes less for cases like the m32r where the base insn size is 32\n+   but some insns are 16 bits.\n+   ATTRS is a mask of the boolean attributes.  We only need `SIGNED',\n+   but for generality we take a bitmask of all of them.\n+   WORD_OFFSET is the offset in bits from the start of the insn of the value.\n+   WORD_LENGTH is the length of the word in bits in which the value resides.\n+   START is the starting bit number in the word, architecture origin.\n+   LENGTH is the length of VALUE in bits.\n+   TOTAL_LENGTH is the total length of the insn in bits.\n+\n+   Returns 1 for success, 0 for failure.  */\n+\n+/* ??? The return code isn't properly used.  wip.  */\n+\n+/* ??? This doesn't handle bfd_vma's.  Create another function when\n+   necessary.  */\n+\n+static int\n+extract_normal (CGEN_CPU_DESC cd,\n+#if ! CGEN_INT_INSN_P\n+\t\tCGEN_EXTRACT_INFO *ex_info,\n+#else\n+\t\tCGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,\n+#endif\n+\t\tCGEN_INSN_INT insn_value,\n+\t\tunsigned int attrs,\n+\t\tunsigned int word_offset,\n+\t\tunsigned int start,\n+\t\tunsigned int length,\n+\t\tunsigned int word_length,\n+\t\tunsigned int total_length,\n+#if ! CGEN_INT_INSN_P\n+\t\tbfd_vma pc,\n+#else\n+\t\tbfd_vma pc ATTRIBUTE_UNUSED,\n+#endif\n+\t\tlong *valuep)\n+{\n+  long value, mask;\n+\n+  /* If LENGTH is zero, this operand doesn't contribute to the value\n+     so give it a standard value of zero.  */\n+  if (length == 0)\n+    {\n+      *valuep = 0;\n+      return 1;\n+    }\n+\n+  if (word_length > 8 * sizeof (CGEN_INSN_INT))\n+    abort ();\n+\n+  /* For architectures with insns smaller than the insn-base-bitsize,\n+     word_length may be too big.  */\n+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)\n+    {\n+      if (word_offset + word_length > total_length)\n+\tword_length = total_length - word_offset;\n+    }\n+\n+  /* Does the value reside in INSN_VALUE, and at the right alignment?  */\n+\n+  if (CGEN_INT_INSN_P || (word_offset == 0 && word_length == total_length))\n+    {\n+      if (CGEN_INSN_LSB0_P)\n+\tvalue = insn_value >> ((word_offset + start + 1) - length);\n+      else\n+\tvalue = insn_value >> (total_length - ( word_offset + start + length));\n+    }\n+\n+#if ! CGEN_INT_INSN_P\n+\n+  else\n+    {\n+      unsigned char *bufp = ex_info->insn_bytes + word_offset / 8;\n+\n+      if (word_length > 8 * sizeof (CGEN_INSN_INT))\n+\tabort ();\n+\n+      if (fill_cache (cd, ex_info, word_offset / 8, word_length / 8, pc) == 0)\n+\treturn 0;\n+\n+      value = extract_1 (cd, ex_info, start, length, word_length, bufp, pc);\n+    }\n+\n+#endif /* ! CGEN_INT_INSN_P */\n+\n+  /* Written this way to avoid undefined behaviour.  */\n+  mask = (((1L << (length - 1)) - 1) << 1) | 1;\n+\n+  value &= mask;\n+  /* sign extend? */\n+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED)\n+      && (value & (1L << (length - 1))))\n+    value |= ~mask;\n+\n+  *valuep = value;\n+\n+  return 1;\n+}\n+\n+/* Default insn extractor.\n+\n+   INSN_VALUE is the first base_insn_bitsize bits, translated to host order.\n+   The extracted fields are stored in FIELDS.\n+   EX_INFO is used to handle reading variable length insns.\n+   Return the length of the insn in bits, or 0 if no match,\n+   or -1 if an error occurs fetching data (memory_error_func will have\n+   been called).  */\n+\n+static int\n+extract_insn_normal (CGEN_CPU_DESC cd,\n+\t\t     const CGEN_INSN *insn,\n+\t\t     CGEN_EXTRACT_INFO *ex_info,\n+\t\t     CGEN_INSN_INT insn_value,\n+\t\t     CGEN_FIELDS *fields,\n+\t\t     bfd_vma pc)\n+{\n+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);\n+  const CGEN_SYNTAX_CHAR_TYPE *syn;\n+\n+  CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);\n+\n+  CGEN_INIT_EXTRACT (cd);\n+\n+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)\n+    {\n+      int length;\n+\n+      if (CGEN_SYNTAX_CHAR_P (*syn))\n+\tcontinue;\n+\n+      length = (* cd->extract_operand) (cd, CGEN_SYNTAX_FIELD (*syn),\n+\t\t\t\t\tex_info, insn_value, fields, pc);\n+      if (length <= 0)\n+\treturn length;\n+    }\n+\n+  /* We recognized and successfully extracted this insn.  */\n+  return CGEN_INSN_BITSIZE (insn);\n+}\n+\f\n+/* Machine generated code added here.  */\n+\n+const char * bpf_cgen_insert_operand\n+  (CGEN_CPU_DESC, int, CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);\n+\n+/* Main entry point for operand insertion.\n+\n+   This function is basically just a big switch statement.  Earlier versions\n+   used tables to look up the function to use, but\n+   - if the table contains both assembler and disassembler functions then\n+     the disassembler contains much of the assembler and vice-versa,\n+   - there's a lot of inlining possibilities as things grow,\n+   - using a switch statement avoids the function call overhead.\n+\n+   This function could be moved into `parse_insn_normal', but keeping it\n+   separate makes clear the interface between `parse_insn_normal' and each of\n+   the handlers.  It's also needed by GAS to insert operands that couldn't be\n+   resolved during parsing.  */\n+\n+const char *\n+bpf_cgen_insert_operand (CGEN_CPU_DESC cd,\n+\t\t\t     int opindex,\n+\t\t\t     CGEN_FIELDS * fields,\n+\t\t\t     CGEN_INSN_BYTES_PTR buffer,\n+\t\t\t     bfd_vma pc ATTRIBUTE_UNUSED)\n+{\n+  const char * errmsg = NULL;\n+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);\n+\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      errmsg = insert_normal (cd, fields->f_offset16, 0|(1<<CGEN_IFLD_SIGNED), 16, 15, 16, 16, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      errmsg = insert_normal (cd, fields->f_imm32, 0|(1<<CGEN_IFLD_SIGNED), 32, 31, 32, 32, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      errmsg = insert_normal (cd, fields->f_dstbe, 0, 8, 7, 4, 8, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      errmsg = insert_normal (cd, fields->f_dstle, 0, 8, 3, 4, 8, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      errmsg = insert_normal (cd, fields->f_imm32, 0|(1<<CGEN_IFLD_SIGNED), 32, 31, 32, 32, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      errmsg = insert_normal (cd, fields->f_imm32, 0|(1<<CGEN_IFLD_SIGNED), 32, 31, 32, 32, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      {\n+{\n+  FLD (f_imm64_b) = 0;\n+  FLD (f_imm64_c) = ((UDI) (FLD (f_imm64)) >> (32));\n+  FLD (f_imm64_a) = ((FLD (f_imm64)) & (MAKEDI (0, 0xffffffff)));\n+}\n+        errmsg = insert_normal (cd, fields->f_imm64_a, 0, 32, 31, 32, 32, total_length, buffer);\n+        if (errmsg)\n+          break;\n+        errmsg = insert_normal (cd, fields->f_imm64_b, 0, 64, 31, 32, 32, total_length, buffer);\n+        if (errmsg)\n+          break;\n+        errmsg = insert_normal (cd, fields->f_imm64_c, 0, 96, 31, 32, 32, total_length, buffer);\n+        if (errmsg)\n+          break;\n+      }\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      errmsg = insert_normal (cd, fields->f_offset16, 0|(1<<CGEN_IFLD_SIGNED), 16, 15, 16, 16, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      errmsg = insert_normal (cd, fields->f_srcbe, 0, 8, 3, 4, 8, total_length, buffer);\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      errmsg = insert_normal (cd, fields->f_srcle, 0, 8, 7, 4, 8, total_length, buffer);\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while building insn\"),\n+\t opindex);\n+      abort ();\n+  }\n+\n+  return errmsg;\n+}\n+\n+int bpf_cgen_extract_operand\n+  (CGEN_CPU_DESC, int, CGEN_EXTRACT_INFO *, CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);\n+\n+/* Main entry point for operand extraction.\n+   The result is <= 0 for error, >0 for success.\n+   ??? Actual values aren't well defined right now.\n+\n+   This function is basically just a big switch statement.  Earlier versions\n+   used tables to look up the function to use, but\n+   - if the table contains both assembler and disassembler functions then\n+     the disassembler contains much of the assembler and vice-versa,\n+   - there's a lot of inlining possibilities as things grow,\n+   - using a switch statement avoids the function call overhead.\n+\n+   This function could be moved into `print_insn_normal', but keeping it\n+   separate makes clear the interface between `print_insn_normal' and each of\n+   the handlers.  */\n+\n+int\n+bpf_cgen_extract_operand (CGEN_CPU_DESC cd,\n+\t\t\t     int opindex,\n+\t\t\t     CGEN_EXTRACT_INFO *ex_info,\n+\t\t\t     CGEN_INSN_INT insn_value,\n+\t\t\t     CGEN_FIELDS * fields,\n+\t\t\t     bfd_vma pc)\n+{\n+  /* Assume success (for those operands that are nops).  */\n+  int length = 1;\n+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);\n+\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 16, 15, 16, 16, total_length, pc, & fields->f_offset16);\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 31, 32, 32, total_length, pc, & fields->f_imm32);\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      length = extract_normal (cd, ex_info, insn_value, 0, 8, 7, 4, 8, total_length, pc, & fields->f_dstbe);\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      length = extract_normal (cd, ex_info, insn_value, 0, 8, 3, 4, 8, total_length, pc, & fields->f_dstle);\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 31, 32, 32, total_length, pc, & fields->f_imm32);\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 32, 31, 32, 32, total_length, pc, & fields->f_imm32);\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      {\n+        length = extract_normal (cd, ex_info, insn_value, 0, 32, 31, 32, 32, total_length, pc, & fields->f_imm64_a);\n+        if (length <= 0) break;\n+        length = extract_normal (cd, ex_info, insn_value, 0, 64, 31, 32, 32, total_length, pc, & fields->f_imm64_b);\n+        if (length <= 0) break;\n+        length = extract_normal (cd, ex_info, insn_value, 0, 96, 31, 32, 32, total_length, pc, & fields->f_imm64_c);\n+        if (length <= 0) break;\n+{\n+  FLD (f_imm64) = ((((((DI) (UINT) (FLD (f_imm64_c)))) << (32))) | (((DI) (UINT) (FLD (f_imm64_a)))));\n+}\n+      }\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 16, 15, 16, 16, total_length, pc, & fields->f_offset16);\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      length = extract_normal (cd, ex_info, insn_value, 0, 8, 3, 4, 8, total_length, pc, & fields->f_srcbe);\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      length = extract_normal (cd, ex_info, insn_value, 0, 8, 7, 4, 8, total_length, pc, & fields->f_srcle);\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while decoding insn\"),\n+\t opindex);\n+      abort ();\n+    }\n+\n+  return length;\n+}\n+\n+cgen_insert_fn * const bpf_cgen_insert_handlers[] =\n+{\n+  insert_insn_normal,\n+};\n+\n+cgen_extract_fn * const bpf_cgen_extract_handlers[] =\n+{\n+  extract_insn_normal,\n+};\n+\n+int bpf_cgen_get_int_operand     (CGEN_CPU_DESC, int, const CGEN_FIELDS *);\n+bfd_vma bpf_cgen_get_vma_operand (CGEN_CPU_DESC, int, const CGEN_FIELDS *);\n+\n+/* Getting values from cgen_fields is handled by a collection of functions.\n+   They are distinguished by the type of the VALUE argument they return.\n+   TODO: floating point, inlining support, remove cases where result type\n+   not appropriate.  */\n+\n+int\n+bpf_cgen_get_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t\t\t     int opindex,\n+\t\t\t     const CGEN_FIELDS * fields)\n+{\n+  int value;\n+\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      value = fields->f_offset16;\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      value = fields->f_imm32;\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      value = fields->f_dstbe;\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      value = fields->f_dstle;\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      value = fields->f_imm32;\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      value = fields->f_imm32;\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      value = fields->f_imm64;\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      value = fields->f_offset16;\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      value = fields->f_srcbe;\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      value = fields->f_srcle;\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while getting int operand\"),\n+\t opindex);\n+      abort ();\n+  }\n+\n+  return value;\n+}\n+\n+bfd_vma\n+bpf_cgen_get_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t\t\t     int opindex,\n+\t\t\t     const CGEN_FIELDS * fields)\n+{\n+  bfd_vma value;\n+\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      value = fields->f_offset16;\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      value = fields->f_imm32;\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      value = fields->f_dstbe;\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      value = fields->f_dstle;\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      value = fields->f_imm32;\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      value = fields->f_imm32;\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      value = fields->f_imm64;\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      value = fields->f_offset16;\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      value = fields->f_srcbe;\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      value = fields->f_srcle;\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while getting vma operand\"),\n+\t opindex);\n+      abort ();\n+  }\n+\n+  return value;\n+}\n+\n+void bpf_cgen_set_int_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, int);\n+void bpf_cgen_set_vma_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, bfd_vma);\n+\n+/* Stuffing values in cgen_fields is handled by a collection of functions.\n+   They are distinguished by the type of the VALUE argument they accept.\n+   TODO: floating point, inlining support, remove cases where argument type\n+   not appropriate.  */\n+\n+void\n+bpf_cgen_set_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t\t\t     int opindex,\n+\t\t\t     CGEN_FIELDS * fields,\n+\t\t\t     int value)\n+{\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      fields->f_offset16 = value;\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      fields->f_imm32 = value;\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      fields->f_dstbe = value;\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      fields->f_dstle = value;\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      fields->f_imm32 = value;\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      fields->f_imm32 = value;\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      fields->f_imm64 = value;\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      fields->f_offset16 = value;\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      fields->f_srcbe = value;\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      fields->f_srcle = value;\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while setting int operand\"),\n+\t opindex);\n+      abort ();\n+  }\n+}\n+\n+void\n+bpf_cgen_set_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t\t\t     int opindex,\n+\t\t\t     CGEN_FIELDS * fields,\n+\t\t\t     bfd_vma value)\n+{\n+  switch (opindex)\n+    {\n+    case BPF_OPERAND_DISP16 :\n+      fields->f_offset16 = value;\n+      break;\n+    case BPF_OPERAND_DISP32 :\n+      fields->f_imm32 = value;\n+      break;\n+    case BPF_OPERAND_DSTBE :\n+      fields->f_dstbe = value;\n+      break;\n+    case BPF_OPERAND_DSTLE :\n+      fields->f_dstle = value;\n+      break;\n+    case BPF_OPERAND_ENDSIZE :\n+      fields->f_imm32 = value;\n+      break;\n+    case BPF_OPERAND_IMM32 :\n+      fields->f_imm32 = value;\n+      break;\n+    case BPF_OPERAND_IMM64 :\n+      fields->f_imm64 = value;\n+      break;\n+    case BPF_OPERAND_OFFSET16 :\n+      fields->f_offset16 = value;\n+      break;\n+    case BPF_OPERAND_SRCBE :\n+      fields->f_srcbe = value;\n+      break;\n+    case BPF_OPERAND_SRCLE :\n+      fields->f_srcle = value;\n+      break;\n+\n+    default :\n+      /* xgettext:c-format */\n+      opcodes_error_handler\n+\t(_(\"internal error: unrecognized field %d while setting vma operand\"),\n+\t opindex);\n+      abort ();\n+  }\n+}\n+\n+/* Function to call before using the instruction builder tables.  */\n+\n+void\n+bpf_cgen_init_ibld_table (CGEN_CPU_DESC cd)\n+{\n+  cd->insert_handlers = & bpf_cgen_insert_handlers[0];\n+  cd->extract_handlers = & bpf_cgen_extract_handlers[0];\n+\n+  cd->insert_operand = bpf_cgen_insert_operand;\n+  cd->extract_operand = bpf_cgen_extract_operand;\n+\n+  cd->get_int_operand = bpf_cgen_get_int_operand;\n+  cd->set_int_operand = bpf_cgen_set_int_operand;\n+  cd->get_vma_operand = bpf_cgen_get_vma_operand;\n+  cd->set_vma_operand = bpf_cgen_set_vma_operand;\n+}"
    },
    {
      "sha": "bb00ba8b58e847b316f30b30254f16ff5defe1ef",
      "filename": "opcodes/bpf-opc.c",
      "status": "added",
      "additions": 1495,
      "deletions": 0,
      "changes": 1495,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-opc.c?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,1495 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* Instruction opcode table for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+This file is part of the GNU Binutils and/or GDB, the GNU debugger.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#include \"sysdep.h\"\n+#include \"ansidecl.h\"\n+#include \"bfd.h\"\n+#include \"symcat.h\"\n+#include \"bpf-desc.h\"\n+#include \"bpf-opc.h\"\n+#include \"libiberty.h\"\n+\n+/* -- opc.c */\n+\f\n+/* -- asm.c */\n+/* The hash functions are recorded here to help keep assembler code out of\n+   the disassembler and vice versa.  */\n+\n+static int asm_hash_insn_p        (const CGEN_INSN *);\n+static unsigned int asm_hash_insn (const char *);\n+static int dis_hash_insn_p        (const CGEN_INSN *);\n+static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT);\n+\n+/* Instruction formats.  */\n+\n+#define F(f) & bpf_cgen_ifld_table[BPF_##f]\n+static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {\n+  0, 0, 0x0, { { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_addile ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_CODE) }, { F (F_DSTLE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_addrle ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_CODE) }, { F (F_DSTLE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_negle ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_CODE) }, { F (F_DSTLE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_addibe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_addrbe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_negbe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_endlele ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_CODE) }, { F (F_DSTLE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_endlebe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_lddwle ATTRIBUTE_UNUSED = {\n+  8, 128, 0xff, { { F (F_IMM64) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_DSTLE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_lddwbe ATTRIBUTE_UNUSED = {\n+  8, 128, 0xff, { { F (F_IMM64) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_SRCBE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_ldabswle ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_DSTLE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_ldabswbe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_SRCBE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_ldxwle ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_DSTLE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_ldxwbe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_SRCBE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_stble ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_DSTLE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_stbbe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_MODE) }, { F (F_OP_SIZE) }, { F (F_SRCBE) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_jeqile ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_CODE) }, { F (F_DSTLE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_jeqrle ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_SRCLE) }, { F (F_OP_CODE) }, { F (F_DSTLE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_jeqibe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_jeqrbe ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_ja ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_REGS) }, { F (F_OP_CODE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_call ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_REGS) }, { F (F_OP_CODE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+static const CGEN_IFMT ifmt_exit ATTRIBUTE_UNUSED = {\n+  8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_REGS) }, { F (F_OP_CODE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n+};\n+\n+#undef F\n+\n+#define A(a) (1 << CGEN_INSN_##a)\n+#define OPERAND(op) BPF_OPERAND_##op\n+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */\n+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))\n+\n+/* The instruction table.  */\n+\n+static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n+{\n+  /* Special null first entry.\n+     A `num' value of zero is thus invalid.\n+     Also, the special `invalid' insn resides here.  */\n+  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},\n+/* add $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x7 }\n+  },\n+/* add $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xf }\n+  },\n+/* add32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x4 }\n+  },\n+/* add32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xc }\n+  },\n+/* sub $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x17 }\n+  },\n+/* sub $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x1f }\n+  },\n+/* sub32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x14 }\n+  },\n+/* sub32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x1c }\n+  },\n+/* mul $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x27 }\n+  },\n+/* mul $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x2f }\n+  },\n+/* mul32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x24 }\n+  },\n+/* mul32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x2c }\n+  },\n+/* div $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x37 }\n+  },\n+/* div $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x3f }\n+  },\n+/* div32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x34 }\n+  },\n+/* div32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x3c }\n+  },\n+/* or $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x47 }\n+  },\n+/* or $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x4f }\n+  },\n+/* or32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x44 }\n+  },\n+/* or32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x4c }\n+  },\n+/* and $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x57 }\n+  },\n+/* and $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x5f }\n+  },\n+/* and32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x54 }\n+  },\n+/* and32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x5c }\n+  },\n+/* lsh $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x67 }\n+  },\n+/* lsh $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x6f }\n+  },\n+/* lsh32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x64 }\n+  },\n+/* lsh32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x6c }\n+  },\n+/* rsh $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x77 }\n+  },\n+/* rsh $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x7f }\n+  },\n+/* rsh32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x74 }\n+  },\n+/* rsh32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x7c }\n+  },\n+/* mod $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x97 }\n+  },\n+/* mod $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x9f }\n+  },\n+/* mod32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0x94 }\n+  },\n+/* mod32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0x9c }\n+  },\n+/* xor $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xa7 }\n+  },\n+/* xor $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xaf }\n+  },\n+/* xor32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xa4 }\n+  },\n+/* xor32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xac }\n+  },\n+/* mov $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xb7 }\n+  },\n+/* mov $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xbf }\n+  },\n+/* mov32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xb4 }\n+  },\n+/* mov32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xbc }\n+  },\n+/* arsh $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xc7 }\n+  },\n+/* arsh $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xcf }\n+  },\n+/* arsh32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xc4 }\n+  },\n+/* arsh32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xcc }\n+  },\n+/* neg $dstle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), 0 } },\n+    & ifmt_negle, { 0x8f }\n+  },\n+/* neg32 $dstle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), 0 } },\n+    & ifmt_negle, { 0x8c }\n+  },\n+/* add $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x7 }\n+  },\n+/* add $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xf }\n+  },\n+/* add32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x4 }\n+  },\n+/* add32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xc }\n+  },\n+/* sub $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x17 }\n+  },\n+/* sub $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x1f }\n+  },\n+/* sub32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x14 }\n+  },\n+/* sub32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x1c }\n+  },\n+/* mul $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x27 }\n+  },\n+/* mul $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x2f }\n+  },\n+/* mul32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x24 }\n+  },\n+/* mul32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x2c }\n+  },\n+/* div $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x37 }\n+  },\n+/* div $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x3f }\n+  },\n+/* div32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x34 }\n+  },\n+/* div32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x3c }\n+  },\n+/* or $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x47 }\n+  },\n+/* or $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x4f }\n+  },\n+/* or32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x44 }\n+  },\n+/* or32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x4c }\n+  },\n+/* and $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x57 }\n+  },\n+/* and $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x5f }\n+  },\n+/* and32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x54 }\n+  },\n+/* and32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x5c }\n+  },\n+/* lsh $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x67 }\n+  },\n+/* lsh $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x6f }\n+  },\n+/* lsh32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x64 }\n+  },\n+/* lsh32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x6c }\n+  },\n+/* rsh $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x77 }\n+  },\n+/* rsh $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x7f }\n+  },\n+/* rsh32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x74 }\n+  },\n+/* rsh32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x7c }\n+  },\n+/* mod $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x97 }\n+  },\n+/* mod $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x9f }\n+  },\n+/* mod32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0x94 }\n+  },\n+/* mod32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0x9c }\n+  },\n+/* xor $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xa7 }\n+  },\n+/* xor $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xaf }\n+  },\n+/* xor32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xa4 }\n+  },\n+/* xor32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xac }\n+  },\n+/* mov $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xb7 }\n+  },\n+/* mov $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xbf }\n+  },\n+/* mov32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xb4 }\n+  },\n+/* mov32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xbc }\n+  },\n+/* arsh $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xc7 }\n+  },\n+/* arsh $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xcf }\n+  },\n+/* arsh32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xc4 }\n+  },\n+/* arsh32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xcc }\n+  },\n+/* neg $dstbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), 0 } },\n+    & ifmt_negbe, { 0x8f }\n+  },\n+/* neg32 $dstbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), 0 } },\n+    & ifmt_negbe, { 0x8c }\n+  },\n+/* endle $dstle,$endsize */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (ENDSIZE), 0 } },\n+    & ifmt_endlele, { 0xd4 }\n+  },\n+/* endbe $dstle,$endsize */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (ENDSIZE), 0 } },\n+    & ifmt_endlele, { 0xdc }\n+  },\n+/* endle $dstbe,$endsize */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (ENDSIZE), 0 } },\n+    & ifmt_endlebe, { 0xd4 }\n+  },\n+/* endbe $dstbe,$endsize */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (ENDSIZE), 0 } },\n+    & ifmt_endlebe, { 0xdc }\n+  },\n+/* lddw $dstle,$imm64 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM64), 0 } },\n+    & ifmt_lddwle, { 0x18 }\n+  },\n+/* lddw $dstbe,$imm64 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM64), 0 } },\n+    & ifmt_lddwbe, { 0x18 }\n+  },\n+/* ldabsw $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x20 }\n+  },\n+/* ldabsh $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x28 }\n+  },\n+/* ldabsb $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x30 }\n+  },\n+/* ldabsdw $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x38 }\n+  },\n+/* ldindw $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x40 }\n+  },\n+/* ldindh $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x48 }\n+  },\n+/* ldindb $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x50 }\n+  },\n+/* ldinddw $dstle,$srcle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswle, { 0x58 }\n+  },\n+/* ldabsw $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x20 }\n+  },\n+/* ldabsh $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x28 }\n+  },\n+/* ldabsb $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x30 }\n+  },\n+/* ldabsdw $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x38 }\n+  },\n+/* ldindw $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x40 }\n+  },\n+/* ldindh $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x48 }\n+  },\n+/* ldindb $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x50 }\n+  },\n+/* ldinddw $dstbe,$srcbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (IMM32), 0 } },\n+    & ifmt_ldabswbe, { 0x58 }\n+  },\n+/* ldxw $dstle,[$srcle+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', '[', OP (SRCLE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwle, { 0x61 }\n+  },\n+/* ldxh $dstle,[$srcle+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', '[', OP (SRCLE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwle, { 0x69 }\n+  },\n+/* ldxb $dstle,[$srcle+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', '[', OP (SRCLE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwle, { 0x71 }\n+  },\n+/* ldxdw $dstle,[$srcle+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', '[', OP (SRCLE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwle, { 0x79 }\n+  },\n+/* stxw [$dstle+$offset16],$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (SRCLE), 0 } },\n+    & ifmt_ldxwle, { 0x63 }\n+  },\n+/* stxh [$dstle+$offset16],$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (SRCLE), 0 } },\n+    & ifmt_ldxwle, { 0x6b }\n+  },\n+/* stxb [$dstle+$offset16],$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (SRCLE), 0 } },\n+    & ifmt_ldxwle, { 0x73 }\n+  },\n+/* stxdw [$dstle+$offset16],$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (SRCLE), 0 } },\n+    & ifmt_ldxwle, { 0x7b }\n+  },\n+/* ldxw $dstbe,[$srcbe+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', '[', OP (SRCBE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwbe, { 0x61 }\n+  },\n+/* ldxh $dstbe,[$srcbe+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', '[', OP (SRCBE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwbe, { 0x69 }\n+  },\n+/* ldxb $dstbe,[$srcbe+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', '[', OP (SRCBE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwbe, { 0x71 }\n+  },\n+/* ldxdw $dstbe,[$srcbe+$offset16] */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', '[', OP (SRCBE), '+', OP (OFFSET16), ']', 0 } },\n+    & ifmt_ldxwbe, { 0x79 }\n+  },\n+/* stxw [$dstbe+$offset16],$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n+    & ifmt_ldxwbe, { 0x63 }\n+  },\n+/* stxh [$dstbe+$offset16],$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n+    & ifmt_ldxwbe, { 0x6b }\n+  },\n+/* stxb [$dstbe+$offset16],$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n+    & ifmt_ldxwbe, { 0x73 }\n+  },\n+/* stxdw [$dstbe+$offset16],$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n+    & ifmt_ldxwbe, { 0x7b }\n+  },\n+/* stb [$dstle+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stble, { 0x72 }\n+  },\n+/* sth [$dstle+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stble, { 0x6a }\n+  },\n+/* stw [$dstle+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stble, { 0x62 }\n+  },\n+/* stdw [$dstle+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stble, { 0x7a }\n+  },\n+/* stb [$dstbe+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stbbe, { 0x72 }\n+  },\n+/* sth [$dstbe+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stbbe, { 0x6a }\n+  },\n+/* stw [$dstbe+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stbbe, { 0x62 }\n+  },\n+/* stdw [$dstbe+$offset16],$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (IMM32), 0 } },\n+    & ifmt_stbbe, { 0x7a }\n+  },\n+/* jeq $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x15 }\n+  },\n+/* jeq $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x1d }\n+  },\n+/* jgt $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x25 }\n+  },\n+/* jgt $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x2d }\n+  },\n+/* jge $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x35 }\n+  },\n+/* jge $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x3d }\n+  },\n+/* jlt $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0xa5 }\n+  },\n+/* jlt $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0xad }\n+  },\n+/* jle $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0xb5 }\n+  },\n+/* jle $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0xbd }\n+  },\n+/* jset $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x45 }\n+  },\n+/* jset $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x4d }\n+  },\n+/* jne $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x55 }\n+  },\n+/* jne $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x5d }\n+  },\n+/* jsgt $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x65 }\n+  },\n+/* jsgt $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x6d }\n+  },\n+/* jsge $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0x75 }\n+  },\n+/* jsge $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0x7d }\n+  },\n+/* jslt $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0xc5 }\n+  },\n+/* jslt $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0xcd }\n+  },\n+/* jsle $dstle,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqile, { 0xd5 }\n+  },\n+/* jsle $dstle,$srcle,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrle, { 0xdd }\n+  },\n+/* jeq $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x15 }\n+  },\n+/* jeq $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x1d }\n+  },\n+/* jgt $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x25 }\n+  },\n+/* jgt $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x2d }\n+  },\n+/* jge $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x35 }\n+  },\n+/* jge $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x3d }\n+  },\n+/* jlt $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0xa5 }\n+  },\n+/* jlt $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0xad }\n+  },\n+/* jle $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0xb5 }\n+  },\n+/* jle $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0xbd }\n+  },\n+/* jset $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x45 }\n+  },\n+/* jset $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x4d }\n+  },\n+/* jne $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x55 }\n+  },\n+/* jne $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x5d }\n+  },\n+/* jsgt $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x65 }\n+  },\n+/* jsgt $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x6d }\n+  },\n+/* jsge $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0x75 }\n+  },\n+/* jsge $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0x7d }\n+  },\n+/* jslt $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0xc5 }\n+  },\n+/* jslt $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0xcd }\n+  },\n+/* jsle $dstbe,$imm32,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqibe, { 0xd5 }\n+  },\n+/* jsle $dstbe,$srcbe,$disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n+    & ifmt_jeqrbe, { 0xdd }\n+  },\n+/* ja $disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DISP16), 0 } },\n+    & ifmt_ja, { 0x5 }\n+  },\n+/* call $disp32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DISP32), 0 } },\n+    & ifmt_call, { 0x85 }\n+  },\n+/* exit */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, 0 } },\n+    & ifmt_exit, { 0x95 }\n+  },\n+/* xadddw [$dstle+$offset16],$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (SRCLE), 0 } },\n+    & ifmt_ldxwle, { 0xdb }\n+  },\n+/* xaddw [$dstle+$offset16],$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTLE), '+', OP (OFFSET16), ']', ',', OP (SRCLE), 0 } },\n+    & ifmt_ldxwle, { 0xc3 }\n+  },\n+/* xadddw [$dstbe+$offset16],$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n+    & ifmt_ldxwbe, { 0xdb }\n+  },\n+/* xaddw [$dstbe+$offset16],$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n+    & ifmt_ldxwbe, { 0xc3 }\n+  },\n+};\n+\n+#undef A\n+#undef OPERAND\n+#undef MNEM\n+#undef OP\n+\n+/* Formats for ALIAS macro-insns.  */\n+\n+#define F(f) & bpf_cgen_ifld_table[BPF_##f]\n+#undef F\n+\n+/* Each non-simple macro entry points to an array of expansion possibilities.  */\n+\n+#define A(a) (1 << CGEN_INSN_##a)\n+#define OPERAND(op) BPF_OPERAND_##op\n+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */\n+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))\n+\n+/* The macro instruction table.  */\n+\n+static const CGEN_IBASE bpf_cgen_macro_insn_table[] =\n+{\n+};\n+\n+/* The macro instruction opcode table.  */\n+\n+static const CGEN_OPCODE bpf_cgen_macro_insn_opcode_table[] =\n+{\n+};\n+\n+#undef A\n+#undef OPERAND\n+#undef MNEM\n+#undef OP\n+\n+#ifndef CGEN_ASM_HASH_P\n+#define CGEN_ASM_HASH_P(insn) 1\n+#endif\n+\n+#ifndef CGEN_DIS_HASH_P\n+#define CGEN_DIS_HASH_P(insn) 1\n+#endif\n+\n+/* Return non-zero if INSN is to be added to the hash table.\n+   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */\n+\n+static int\n+asm_hash_insn_p (const CGEN_INSN *insn ATTRIBUTE_UNUSED)\n+{\n+  return CGEN_ASM_HASH_P (insn);\n+}\n+\n+static int\n+dis_hash_insn_p (const CGEN_INSN *insn)\n+{\n+  /* If building the hash table and the NO-DIS attribute is present,\n+     ignore.  */\n+  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))\n+    return 0;\n+  return CGEN_DIS_HASH_P (insn);\n+}\n+\n+#ifndef CGEN_ASM_HASH\n+#define CGEN_ASM_HASH_SIZE 127\n+#ifdef CGEN_MNEMONIC_OPERANDS\n+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)\n+#else\n+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/\n+#endif\n+#endif\n+\n+/* It doesn't make much sense to provide a default here,\n+   but while this is under development we do.\n+   BUFFER is a pointer to the bytes of the insn, target order.\n+   VALUE is the first base_insn_bitsize bits as an int in host order.  */\n+\n+#ifndef CGEN_DIS_HASH\n+#define CGEN_DIS_HASH_SIZE 256\n+#define CGEN_DIS_HASH(buf, value) (*(unsigned char *) (buf))\n+#endif\n+\n+/* The result is the hash value of the insn.\n+   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */\n+\n+static unsigned int\n+asm_hash_insn (const char *mnem)\n+{\n+  return CGEN_ASM_HASH (mnem);\n+}\n+\n+/* BUF is a pointer to the bytes of the insn, target order.\n+   VALUE is the first base_insn_bitsize bits as an int in host order.  */\n+\n+static unsigned int\n+dis_hash_insn (const char *buf ATTRIBUTE_UNUSED,\n+\t\t     CGEN_INSN_INT value ATTRIBUTE_UNUSED)\n+{\n+  return CGEN_DIS_HASH (buf, value);\n+}\n+\n+/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */\n+\n+static void\n+set_fields_bitsize (CGEN_FIELDS *fields, int size)\n+{\n+  CGEN_FIELDS_BITSIZE (fields) = size;\n+}\n+\n+/* Function to call before using the operand instance table.\n+   This plugs the opcode entries and macro instructions into the cpu table.  */\n+\n+void\n+bpf_cgen_init_opcode_table (CGEN_CPU_DESC cd)\n+{\n+  int i;\n+  int num_macros = (sizeof (bpf_cgen_macro_insn_table) /\n+\t\t    sizeof (bpf_cgen_macro_insn_table[0]));\n+  const CGEN_IBASE *ib = & bpf_cgen_macro_insn_table[0];\n+  const CGEN_OPCODE *oc = & bpf_cgen_macro_insn_opcode_table[0];\n+  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));\n+\n+  /* This test has been added to avoid a warning generated\n+     if memset is called with a third argument of value zero.  */\n+  if (num_macros >= 1)\n+    memset (insns, 0, num_macros * sizeof (CGEN_INSN));\n+  for (i = 0; i < num_macros; ++i)\n+    {\n+      insns[i].base = &ib[i];\n+      insns[i].opcode = &oc[i];\n+      bpf_cgen_build_insn_regex (& insns[i]);\n+    }\n+  cd->macro_insn_table.init_entries = insns;\n+  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);\n+  cd->macro_insn_table.num_init_entries = num_macros;\n+\n+  oc = & bpf_cgen_insn_opcode_table[0];\n+  insns = (CGEN_INSN *) cd->insn_table.init_entries;\n+  for (i = 0; i < MAX_INSNS; ++i)\n+    {\n+      insns[i].opcode = &oc[i];\n+      bpf_cgen_build_insn_regex (& insns[i]);\n+    }\n+\n+  cd->sizeof_fields = sizeof (CGEN_FIELDS);\n+  cd->set_fields_bitsize = set_fields_bitsize;\n+\n+  cd->asm_hash_p = asm_hash_insn_p;\n+  cd->asm_hash = asm_hash_insn;\n+  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;\n+\n+  cd->dis_hash_p = dis_hash_insn_p;\n+  cd->dis_hash = dis_hash_insn;\n+  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;\n+}"
    },
    {
      "sha": "b989d7f03107a5b2cbd23a79fd9b5e09c30dd067",
      "filename": "opcodes/bpf-opc.h",
      "status": "added",
      "additions": 151,
      "deletions": 0,
      "changes": 151,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/bpf-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-opc.h?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -0,0 +1,151 @@\n+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */\n+/* Instruction opcode header for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2019 Free Software Foundation, Inc.\n+\n+This file is part of the GNU Binutils and/or GDB, the GNU debugger.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef BPF_OPC_H\n+#define BPF_OPC_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* -- opc.h */\n+\n+#undef CGEN_DIS_HASH_SIZE\n+#define CGEN_DIS_HASH_SIZE 1\n+\n+#undef CGEN_DIS_HASH\n+#define CGEN_DIS_HASH(buffer, value) 0\n+\n+/* Allows reason codes to be output when assembler errors occur.  */\n+#define CGEN_VERBOSE_ASSEMBLER_ERRORS\n+\n+#define CGEN_VALIDATE_INSN_SUPPORTED\n+extern int bpf_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);\n+\n+\f\n+/* -- opc.c */\n+/* Enum declaration for bpf instruction types.  */\n+typedef enum cgen_insn_type {\n+  BPF_INSN_INVALID, BPF_INSN_ADDILE, BPF_INSN_ADDRLE, BPF_INSN_ADD32ILE\n+ , BPF_INSN_ADD32RLE, BPF_INSN_SUBILE, BPF_INSN_SUBRLE, BPF_INSN_SUB32ILE\n+ , BPF_INSN_SUB32RLE, BPF_INSN_MULILE, BPF_INSN_MULRLE, BPF_INSN_MUL32ILE\n+ , BPF_INSN_MUL32RLE, BPF_INSN_DIVILE, BPF_INSN_DIVRLE, BPF_INSN_DIV32ILE\n+ , BPF_INSN_DIV32RLE, BPF_INSN_ORILE, BPF_INSN_ORRLE, BPF_INSN_OR32ILE\n+ , BPF_INSN_OR32RLE, BPF_INSN_ANDILE, BPF_INSN_ANDRLE, BPF_INSN_AND32ILE\n+ , BPF_INSN_AND32RLE, BPF_INSN_LSHILE, BPF_INSN_LSHRLE, BPF_INSN_LSH32ILE\n+ , BPF_INSN_LSH32RLE, BPF_INSN_RSHILE, BPF_INSN_RSHRLE, BPF_INSN_RSH32ILE\n+ , BPF_INSN_RSH32RLE, BPF_INSN_MODILE, BPF_INSN_MODRLE, BPF_INSN_MOD32ILE\n+ , BPF_INSN_MOD32RLE, BPF_INSN_XORILE, BPF_INSN_XORRLE, BPF_INSN_XOR32ILE\n+ , BPF_INSN_XOR32RLE, BPF_INSN_MOVILE, BPF_INSN_MOVRLE, BPF_INSN_MOV32ILE\n+ , BPF_INSN_MOV32RLE, BPF_INSN_ARSHILE, BPF_INSN_ARSHRLE, BPF_INSN_ARSH32ILE\n+ , BPF_INSN_ARSH32RLE, BPF_INSN_NEGLE, BPF_INSN_NEG32LE, BPF_INSN_ADDIBE\n+ , BPF_INSN_ADDRBE, BPF_INSN_ADD32IBE, BPF_INSN_ADD32RBE, BPF_INSN_SUBIBE\n+ , BPF_INSN_SUBRBE, BPF_INSN_SUB32IBE, BPF_INSN_SUB32RBE, BPF_INSN_MULIBE\n+ , BPF_INSN_MULRBE, BPF_INSN_MUL32IBE, BPF_INSN_MUL32RBE, BPF_INSN_DIVIBE\n+ , BPF_INSN_DIVRBE, BPF_INSN_DIV32IBE, BPF_INSN_DIV32RBE, BPF_INSN_ORIBE\n+ , BPF_INSN_ORRBE, BPF_INSN_OR32IBE, BPF_INSN_OR32RBE, BPF_INSN_ANDIBE\n+ , BPF_INSN_ANDRBE, BPF_INSN_AND32IBE, BPF_INSN_AND32RBE, BPF_INSN_LSHIBE\n+ , BPF_INSN_LSHRBE, BPF_INSN_LSH32IBE, BPF_INSN_LSH32RBE, BPF_INSN_RSHIBE\n+ , BPF_INSN_RSHRBE, BPF_INSN_RSH32IBE, BPF_INSN_RSH32RBE, BPF_INSN_MODIBE\n+ , BPF_INSN_MODRBE, BPF_INSN_MOD32IBE, BPF_INSN_MOD32RBE, BPF_INSN_XORIBE\n+ , BPF_INSN_XORRBE, BPF_INSN_XOR32IBE, BPF_INSN_XOR32RBE, BPF_INSN_MOVIBE\n+ , BPF_INSN_MOVRBE, BPF_INSN_MOV32IBE, BPF_INSN_MOV32RBE, BPF_INSN_ARSHIBE\n+ , BPF_INSN_ARSHRBE, BPF_INSN_ARSH32IBE, BPF_INSN_ARSH32RBE, BPF_INSN_NEGBE\n+ , BPF_INSN_NEG32BE, BPF_INSN_ENDLELE, BPF_INSN_ENDBELE, BPF_INSN_ENDLEBE\n+ , BPF_INSN_ENDBEBE, BPF_INSN_LDDWLE, BPF_INSN_LDDWBE, BPF_INSN_LDABSWLE\n+ , BPF_INSN_LDABSHLE, BPF_INSN_LDABSBLE, BPF_INSN_LDABSDWLE, BPF_INSN_LDINDWLE\n+ , BPF_INSN_LDINDHLE, BPF_INSN_LDINDBLE, BPF_INSN_LDINDDWLE, BPF_INSN_LDABSWBE\n+ , BPF_INSN_LDABSHBE, BPF_INSN_LDABSBBE, BPF_INSN_LDABSDWBE, BPF_INSN_LDINDWBE\n+ , BPF_INSN_LDINDHBE, BPF_INSN_LDINDBBE, BPF_INSN_LDINDDWBE, BPF_INSN_LDXWLE\n+ , BPF_INSN_LDXHLE, BPF_INSN_LDXBLE, BPF_INSN_LDXDWLE, BPF_INSN_STXWLE\n+ , BPF_INSN_STXHLE, BPF_INSN_STXBLE, BPF_INSN_STXDWLE, BPF_INSN_LDXWBE\n+ , BPF_INSN_LDXHBE, BPF_INSN_LDXBBE, BPF_INSN_LDXDWBE, BPF_INSN_STXWBE\n+ , BPF_INSN_STXHBE, BPF_INSN_STXBBE, BPF_INSN_STXDWBE, BPF_INSN_STBLE\n+ , BPF_INSN_STHLE, BPF_INSN_STWLE, BPF_INSN_STDWLE, BPF_INSN_STBBE\n+ , BPF_INSN_STHBE, BPF_INSN_STWBE, BPF_INSN_STDWBE, BPF_INSN_JEQILE\n+ , BPF_INSN_JEQRLE, BPF_INSN_JGTILE, BPF_INSN_JGTRLE, BPF_INSN_JGEILE\n+ , BPF_INSN_JGERLE, BPF_INSN_JLTILE, BPF_INSN_JLTRLE, BPF_INSN_JLEILE\n+ , BPF_INSN_JLERLE, BPF_INSN_JSETILE, BPF_INSN_JSETRLE, BPF_INSN_JNEILE\n+ , BPF_INSN_JNERLE, BPF_INSN_JSGTILE, BPF_INSN_JSGTRLE, BPF_INSN_JSGEILE\n+ , BPF_INSN_JSGERLE, BPF_INSN_JSLTILE, BPF_INSN_JSLTRLE, BPF_INSN_JSLEILE\n+ , BPF_INSN_JSLERLE, BPF_INSN_JEQIBE, BPF_INSN_JEQRBE, BPF_INSN_JGTIBE\n+ , BPF_INSN_JGTRBE, BPF_INSN_JGEIBE, BPF_INSN_JGERBE, BPF_INSN_JLTIBE\n+ , BPF_INSN_JLTRBE, BPF_INSN_JLEIBE, BPF_INSN_JLERBE, BPF_INSN_JSETIBE\n+ , BPF_INSN_JSETRBE, BPF_INSN_JNEIBE, BPF_INSN_JNERBE, BPF_INSN_JSGTIBE\n+ , BPF_INSN_JSGTRBE, BPF_INSN_JSGEIBE, BPF_INSN_JSGERBE, BPF_INSN_JSLTIBE\n+ , BPF_INSN_JSLTRBE, BPF_INSN_JSLEIBE, BPF_INSN_JSLERBE, BPF_INSN_JA\n+ , BPF_INSN_CALL, BPF_INSN_EXIT, BPF_INSN_XADDDWLE, BPF_INSN_XADDWLE\n+ , BPF_INSN_XADDDWBE, BPF_INSN_XADDWBE\n+} CGEN_INSN_TYPE;\n+\n+/* Index of `invalid' insn place holder.  */\n+#define CGEN_INSN_INVALID BPF_INSN_INVALID\n+\n+/* Total number of insns in table.  */\n+#define MAX_INSNS ((int) BPF_INSN_XADDWBE + 1)\n+\n+/* This struct records data prior to insertion or after extraction.  */\n+struct cgen_fields\n+{\n+  int length;\n+  long f_nil;\n+  long f_anyof;\n+  long f_op_code;\n+  long f_op_src;\n+  long f_op_class;\n+  long f_op_mode;\n+  long f_op_size;\n+  long f_dstle;\n+  long f_srcle;\n+  long f_dstbe;\n+  long f_srcbe;\n+  long f_regs;\n+  long f_offset16;\n+  long f_imm32;\n+  long f_imm64_a;\n+  long f_imm64_b;\n+  long f_imm64_c;\n+  int64_t f_imm64;\n+};\n+\n+#define CGEN_INIT_PARSE(od) \\\n+{\\\n+}\n+#define CGEN_INIT_INSERT(od) \\\n+{\\\n+}\n+#define CGEN_INIT_EXTRACT(od) \\\n+{\\\n+}\n+#define CGEN_INIT_PRINT(od) \\\n+{\\\n+}\n+\n+\n+   #ifdef __cplusplus\n+   }\n+   #endif\n+\n+#endif /* BPF_OPC_H */"
    },
    {
      "sha": "3b99d9786b58e85d1b9601820e3ac60ae4fca256",
      "filename": "opcodes/configure",
      "status": "modified",
      "additions": 16,
      "deletions": 3,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/configure?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -769,6 +769,7 @@ infodir\n docdir\n oldincludedir\n includedir\n+runstatedir\n localstatedir\n sharedstatedir\n sysconfdir\n@@ -854,6 +855,7 @@ datadir='${datarootdir}'\n sysconfdir='${prefix}/etc'\n sharedstatedir='${prefix}/com'\n localstatedir='${prefix}/var'\n+runstatedir='${localstatedir}/run'\n includedir='${prefix}/include'\n oldincludedir='/usr/include'\n docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\n@@ -1106,6 +1108,15 @@ do\n   | -silent | --silent | --silen | --sile | --sil)\n     silent=yes ;;\n \n+  -runstatedir | --runstatedir | --runstatedi | --runstated \\\n+  | --runstate | --runstat | --runsta | --runst | --runs \\\n+  | --run | --ru | --r)\n+    ac_prev=runstatedir ;;\n+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \\\n+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \\\n+  | --run=* | --ru=* | --r=*)\n+    runstatedir=$ac_optarg ;;\n+\n   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n     ac_prev=sbindir ;;\n   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n@@ -1243,7 +1254,7 @@ fi\n for ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n \t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n \t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n-\t\tlibdir localedir mandir\n+\t\tlibdir localedir mandir runstatedir\n do\n   eval ac_val=\\$$ac_var\n   # Remove trailing slashes.\n@@ -1396,6 +1407,7 @@ Fine tuning of the installation directories:\n   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]\n   --libdir=DIR            object code libraries [EPREFIX/lib]\n   --includedir=DIR        C header files [PREFIX/include]\n   --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n@@ -11439,7 +11451,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11442 \"configure\"\n+#line 11454 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11545,7 +11557,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11548 \"configure\"\n+#line 11560 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12949,6 +12961,7 @@ if test x${all_targets} = xfalse ; then\n \tbfd_xtensa_arch)\tta=\"$ta xtensa-dis.lo\" ;;\n \tbfd_z80_arch)\t\tta=\"$ta z80-dis.lo\" ;;\n \tbfd_z8k_arch)\t\tta=\"$ta z8k-dis.lo\" ;;\n+\tbfd_bpf_arch)\t\tta=\"$ta bpf-asm.lo bpf-desc.lo bpf-dis.lo bpf-ibld.lo bpf-opc.lo\" using_cgen=yes ;;\n \n \t\"\")\t\t\t;;\n \t*)\t\tas_fn_error $? \"*** unknown target architecture $arch\" \"$LINENO\" 5 ;;"
    },
    {
      "sha": "500c701a62ba7514a31defb2b0eb08e0ba76e0e2",
      "filename": "opcodes/configure.ac",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/configure.ac?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -340,6 +340,7 @@ if test x${all_targets} = xfalse ; then\n \tbfd_xtensa_arch)\tta=\"$ta xtensa-dis.lo\" ;;\n \tbfd_z80_arch)\t\tta=\"$ta z80-dis.lo\" ;;\n \tbfd_z8k_arch)\t\tta=\"$ta z8k-dis.lo\" ;;\n+\tbfd_bpf_arch)\t\tta=\"$ta bpf-asm.lo bpf-desc.lo bpf-dis.lo bpf-ibld.lo bpf-opc.lo\" using_cgen=yes ;;\n \n \t\"\")\t\t\t;;\n \t*)\t\tAC_MSG_ERROR(*** unknown target architecture $arch) ;;"
    },
    {
      "sha": "aef2fd8644b34afe737ec0670c307dd85f291fd2",
      "filename": "opcodes/disassemble.c",
      "status": "modified",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/disassemble.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/disassemble.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/disassemble.c?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -37,6 +37,7 @@\n #define ARCH_d10v\n #define ARCH_d30v\n #define ARCH_dlx\n+#define ARCH_bpf\n #define ARCH_epiphany\n #define ARCH_fr30\n #define ARCH_frv\n@@ -106,6 +107,23 @@\n #include \"m32c-desc.h\"\n #endif\n \n+#ifdef ARCH_bpf\n+/* XXX this should be including bpf-desc.h instead of this hackery,\n+   but at the moment it is not possible to include several CGEN\n+   generated *-desc.h files simultaneously.  To be fixed in\n+   CGEN...  */\n+\n+# ifdef ARCH_m32c\n+enum epbf_isa_attr\n+{\n+ ISA_EBPFLE, ISA_EBPFBE, ISA_EBPFMAX\n+};\n+# else\n+#  include \"bpf-desc.h\"\n+#  define ISA_EBPFMAX ISA_MAX\n+# endif\n+#endif /* ARCH_bpf */\n+\n disassembler_ftype\n disassembler (enum bfd_architecture a,\n \t      bfd_boolean big ATTRIBUTE_UNUSED,\n@@ -224,6 +242,11 @@ disassembler (enum bfd_architecture a,\n       disassemble = print_insn_ip2k;\n       break;\n #endif\n+#ifdef ARCH_bpf\n+    case bfd_arch_bpf:\n+      disassemble = print_insn_bpf;\n+      break;\n+#endif\n #ifdef ARCH_epiphany\n     case bfd_arch_epiphany:\n       disassemble = print_insn_epiphany;\n@@ -641,6 +664,18 @@ disassemble_init_for_target (struct disassemble_info * info)\n \t}\n       break;\n #endif\n+#ifdef ARCH_bpf\n+    case bfd_arch_bpf:\n+      if (!info->insn_sets)\n+        {\n+          info->insn_sets = cgen_bitset_create (ISA_EBPFMAX);\n+          if (info->endian == BFD_ENDIAN_BIG)\n+            cgen_bitset_set (info->insn_sets, ISA_EBPFBE);\n+          else\n+            cgen_bitset_set (info->insn_sets, ISA_EBPFLE);\n+        }\n+      break;\n+#endif\n #ifdef ARCH_pru\n     case bfd_arch_pru:\n       info->disassembler_needs_relocs = TRUE;"
    },
    {
      "sha": "ceb2814fe66cc4b7451d735230ace4aeb0d4acd2",
      "filename": "opcodes/disassemble.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79472b45328232b083e897a511d4160a6dde0463/opcodes/disassemble.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79472b45328232b083e897a511d4160a6dde0463/opcodes/disassemble.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/disassemble.h?ref=79472b45328232b083e897a511d4160a6dde0463",
      "patch": "@@ -36,6 +36,7 @@ extern int print_insn_csky\t\t(bfd_vma, disassemble_info *);\n extern int print_insn_d10v\t\t(bfd_vma, disassemble_info *);\n extern int print_insn_d30v\t\t(bfd_vma, disassemble_info *);\n extern int print_insn_dlx\t\t(bfd_vma, disassemble_info *);\n+extern int print_insn_bpf\t\t(bfd_vma, disassemble_info *);\n extern int print_insn_epiphany\t\t(bfd_vma, disassemble_info *);\n extern int print_insn_fr30\t\t(bfd_vma, disassemble_info *);\n extern int print_insn_frv\t\t(bfd_vma, disassemble_info *);"
    }
  ]
}