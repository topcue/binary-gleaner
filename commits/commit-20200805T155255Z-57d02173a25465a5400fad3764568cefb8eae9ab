{
  "sha": "57d02173a25465a5400fad3764568cefb8eae9ab",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTdkMDIxNzNhMjU0NjVhNTQwMGZhZDM3NjQ1NjhjZWZiOGVhZTlhYg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-08-05T15:52:55Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-08-05T15:52:55Z"
    },
    "message": "Fix variant part regressions with older Rust compiler\n\nOlder Rust compilers used special field names, rather than DWARF\nfeatures, to express the variant parts of Rust enums.  This is handled\nin gdb through a quirk recognizer that rewrites the types.\n\nTom de Vries pointed out in PR rust/26197 that the variant part\nrewrite regressed this code.  This patch fixes the problems:\n\n* Univariant enums were not handled properly.  Now we simply call\n  alloc_rust_variant for these as well.\n\n* There was an off-by-one error in the handling of ordinary enums.\n\n* Ordinary enums should have the size of their member types reset to\n  match the size of the enclosing enum.  (It's not clear to me if this\n  is truly necessary, but it placates a test, and this is just legacy\n  handling in any case.)\n\nTested with Rust 1.12.0, 1.14.0, 1.19.0, 1.36.0, and 1.45.0 on x86-64\nFedora 32.  There were some unrelated failures with 1.14.0 and 1.19,0;\nbut considering that these are fairly old releases, I don't plan to\nlook into them unless someone complains.\n\nNote that this patch will not fix all the issues in the PR.  In that\nPR, Tom is using a somewhat unusual build of Rust -- in particular it\nuses an older (pre-DWARF variant part) LLVM with a newer Rust.  I\nbelieve this compiler doesn't correctly implement the old-style name\nfallback; the details are in the bug.\n\ngdb/ChangeLog\n2020-08-05  Tom Tromey  <tromey@adacore.com>\n\n\tPR rust/26197:\n\t* dwarf2/read.c (alloc_rust_variant): Handle univariant case.\n\t(quirk_rust_enum): Call alloc_rust_variant for univariant case.\n\tFix off-by-one and type size errors in ordinary case.",
    "tree": {
      "sha": "bd831e59218b4bbbcd9cbd1c730d56233c00e577",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bd831e59218b4bbbcd9cbd1c730d56233c00e577"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/57d02173a25465a5400fad3764568cefb8eae9ab",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/57d02173a25465a5400fad3764568cefb8eae9ab",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/57d02173a25465a5400fad3764568cefb8eae9ab",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/57d02173a25465a5400fad3764568cefb8eae9ab/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e8a387fb5f91cdb9674f19703c0e7bfbaf895a84",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e8a387fb5f91cdb9674f19703c0e7bfbaf895a84",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e8a387fb5f91cdb9674f19703c0e7bfbaf895a84"
    }
  ],
  "stats": {
    "total": 39,
    "additions": 30,
    "deletions": 9
  },
  "files": [
    {
      "sha": "fc4fe7cdaac2ecba3b875d3e7428fa360e5b943a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57d02173a25465a5400fad3764568cefb8eae9ab/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57d02173a25465a5400fad3764568cefb8eae9ab/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=57d02173a25465a5400fad3764568cefb8eae9ab",
      "patch": "@@ -1,3 +1,10 @@\n+2020-08-05  Tom Tromey  <tromey@adacore.com>\n+\n+\tPR rust/26197:\n+\t* dwarf2/read.c (alloc_rust_variant): Handle univariant case.\n+\t(quirk_rust_enum): Call alloc_rust_variant for univariant case.\n+\tFix off-by-one and type size errors in ordinary case.\n+\n 2020-08-05  Tom de Vries  <tdevries@suse.de>\n \n \t* gdbtypes.c (type_not_allocated, type_not_associated): Use"
    },
    {
      "sha": "cf3a42ac3ea2b46dd42cc8a908353e94e6f4da9f",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 23,
      "deletions": 9,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57d02173a25465a5400fad3764568cefb8eae9ab/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57d02173a25465a5400fad3764568cefb8eae9ab/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=57d02173a25465a5400fad3764568cefb8eae9ab",
      "patch": "@@ -9416,7 +9416,8 @@ rust_fully_qualify (struct obstack *obstack, const char *p1, const char *p2)\n /* A helper that allocates a variant part to attach to a Rust enum\n    type.  OBSTACK is where the results should be allocated.  TYPE is\n    the type we're processing.  DISCRIMINANT_INDEX is the index of the\n-   discriminant.  It must be the index of one of the fields of TYPE.\n+   discriminant.  It must be the index of one of the fields of TYPE,\n+   or -1 to mean there is no discriminant (univariant enum).\n    DEFAULT_INDEX is the index of the default field; or -1 if there is\n    no default.  RANGES is indexed by \"effective\" field number (the\n    field index, but omitting the discriminant and default fields) and\n@@ -9429,15 +9430,17 @@ alloc_rust_variant (struct obstack *obstack, struct type *type,\n \t\t    int discriminant_index, int default_index,\n \t\t    gdb::array_view<discriminant_range> ranges)\n {\n-  /* When DISCRIMINANT_INDEX == -1, we have a univariant enum.  Those\n-     must be handled by the caller.  */\n-  gdb_assert (discriminant_index >= 0\n-\t      && discriminant_index < type->num_fields ());\n+  /* When DISCRIMINANT_INDEX == -1, we have a univariant enum.  */\n+  gdb_assert (discriminant_index == -1\n+\t      || (discriminant_index >= 0\n+\t\t  && discriminant_index < type->num_fields ()));\n   gdb_assert (default_index == -1\n \t      || (default_index >= 0 && default_index < type->num_fields ()));\n \n   /* We have one variant for each non-discriminant field.  */\n-  int n_variants = type->num_fields () - 1;\n+  int n_variants = type->num_fields ();\n+  if (discriminant_index != -1)\n+    --n_variants;\n \n   variant *variants = new (obstack) variant[n_variants];\n   int var_idx = 0;\n@@ -9466,7 +9469,12 @@ alloc_rust_variant (struct obstack *obstack, struct type *type,\n \n   variant_part *part = new (obstack) variant_part;\n   part->discriminant_index = discriminant_index;\n-  part->is_unsigned = TYPE_UNSIGNED (type->field (discriminant_index).type ());\n+  /* If there is no discriminant, then whether it is signed is of no\n+     consequence.  */\n+  part->is_unsigned\n+    = (discriminant_index == -1\n+       ? false\n+       : TYPE_UNSIGNED (type->field (discriminant_index).type ()));\n   part->variants = gdb::array_view<variant> (variants, n_variants);\n \n   void *storage = obstack_alloc (obstack, sizeof (gdb::array_view<variant_part>));\n@@ -9594,6 +9602,8 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       field_type->set_name\n \t(rust_fully_qualify (&objfile->objfile_obstack,\n \t\t\t     type->name (), variant_name));\n+\n+      alloc_rust_variant (&objfile->objfile_obstack, type, -1, 0, {});\n     }\n   else\n     {\n@@ -9682,10 +9692,14 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t  auto iter = discriminant_map.find (variant_name);\n \t  if (iter != discriminant_map.end ())\n \t    {\n-\t      ranges[i].low = iter->second;\n-\t      ranges[i].high = iter->second;\n+\t      ranges[i - 1].low = iter->second;\n+\t      ranges[i - 1].high = iter->second;\n \t    }\n \n+\t  /* In Rust, each element should have the size of the\n+\t     enclosing enum.  */\n+\t  TYPE_LENGTH (type->field (i).type ()) = TYPE_LENGTH (type);\n+\n \t  /* Remove the discriminant field, if it exists.  */\n \t  struct type *sub_type = type->field (i).type ();\n \t  if (sub_type->num_fields () > 0)"
    }
  ]
}