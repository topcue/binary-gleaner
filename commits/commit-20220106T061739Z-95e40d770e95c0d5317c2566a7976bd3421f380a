{
  "sha": "95e40d770e95c0d5317c2566a7976bd3421f380a",
  "node_id": "C_kwDOANOeidoAKDk1ZTQwZDc3MGU5NWMwZDUzMTdjMjU2NmE3OTc2YmQzNDIxZjM4MGE",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-06T07:42:00Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:39Z"
    },
    "message": "sim: ppc: migrate to standard uintXX_t types\n\nDrop the sim-specific unsignedXX types and move to the standard uintXX_t\ntypes that C11 provides.",
    "tree": {
      "sha": "ee409c8b3279492f88f1b3b5e675e86d254b899d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ee409c8b3279492f88f1b3b5e675e86d254b899d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/95e40d770e95c0d5317c2566a7976bd3421f380a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/95e40d770e95c0d5317c2566a7976bd3421f380a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/95e40d770e95c0d5317c2566a7976bd3421f380a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/95e40d770e95c0d5317c2566a7976bd3421f380a/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e4c803f5bb08e946f0550260b39f71eff0192262",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e4c803f5bb08e946f0550260b39f71eff0192262",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e4c803f5bb08e946f0550260b39f71eff0192262"
    }
  ],
  "stats": {
    "total": 2675,
    "additions": 1332,
    "deletions": 1343
  },
  "files": [
    {
      "sha": "63fe95a53d513a6054b334187c9b6a6858ac7895",
      "filename": "sim/ppc/altivec.igen",
      "status": "modified",
      "additions": 202,
      "deletions": 202,
      "changes": 404,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/altivec.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/altivec.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/altivec.igen?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -27,16 +27,16 @@\n \n :cache:av:::VS:VS:\n :cache:av::vreg *:vS:VS:(cpu_registers(processor)->altivec.vr + VS)\n-:cache:av::unsigned32:VS_BITMASK:VS:(1 << VS)\n+:cache:av::uint32_t:VS_BITMASK:VS:(1 << VS)\n :cache:av:::VA:VA:\n :cache:av::vreg *:vA:VA:(cpu_registers(processor)->altivec.vr + VA)\n-:cache:av::unsigned32:VA_BITMASK:VA:(1 << VA)\n+:cache:av::uint32_t:VA_BITMASK:VA:(1 << VA)\n :cache:av:::VB:VB:\n :cache:av::vreg *:vB:VB:(cpu_registers(processor)->altivec.vr + VB)\n-:cache:av::unsigned32:VB_BITMASK:VB:(1 << VB)\n+:cache:av::uint32_t:VB_BITMASK:VB:(1 << VB)\n :cache:av:::VC:VC:\n :cache:av::vreg *:vC:VC:(cpu_registers(processor)->altivec.vr + VC)\n-:cache:av::unsigned32:VC_BITMASK:VC:(1 << VC)\n+:cache:av::uint32_t:VC_BITMASK:VC:(1 << VC)\n \n # Flags for model.h\n ::model-macro:::\n@@ -77,7 +77,7 @@\n \t\t} while (0)\n \n # Trace waiting for AltiVec registers to become available\n-void::model-static::model_trace_altivec_busy_p:model_data *model_ptr, unsigned32 vr_busy\n+void::model-static::model_trace_altivec_busy_p:model_data *model_ptr, uint32_t vr_busy\n \tint i;\n \tif (vr_busy) {\n \t  vr_busy &= model_ptr->vr_busy;\n@@ -91,7 +91,7 @@ void::model-static::model_trace_altivec_busy_p:model_data *model_ptr, unsigned32\n \t  TRACE(trace_model, (\"Waiting for VSCR\\n\"));\n \n # Trace making AltiVec registers busy\n-void::model-static::model_trace_altivec_make_busy:model_data *model_ptr, unsigned32 vr_mask, unsigned32 cr_mask\n+void::model-static::model_trace_altivec_make_busy:model_data *model_ptr, uint32_t vr_mask, uint32_t cr_mask\n \tint i;\n \tif (vr_mask) {\n \t  for(i = 0; i < 32; i++) {\n@@ -109,9 +109,9 @@ void::model-static::model_trace_altivec_make_busy:model_data *model_ptr, unsigne\n \t}\n \n # Schedule an AltiVec instruction that takes integer input registers and produces output registers\n-void::model-function::ppc_insn_int_vr:itable_index index, model_data *model_ptr, const unsigned32 out_mask, const unsigned32 in_mask, const unsigned32 out_vmask, const unsigned32 in_vmask\n-\tconst unsigned32 int_mask = out_mask | in_mask;\n-\tconst unsigned32 vr_mask = out_vmask | in_vmask;\n+void::model-function::ppc_insn_int_vr:itable_index index, model_data *model_ptr, const uint32_t out_mask, const uint32_t in_mask, const uint32_t out_vmask, const uint32_t in_vmask\n+\tconst uint32_t int_mask = out_mask | in_mask;\n+\tconst uint32_t vr_mask = out_vmask | in_vmask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->int_busy & int_mask) != 0 || (model_ptr->vr_busy & vr_mask)) {\n@@ -146,8 +146,8 @@ void::model-function::ppc_insn_int_vr:itable_index index, model_data *model_ptr,\n \t}\n \n # Schedule an AltiVec instruction that takes vector input registers and produces vector output registers\n-void::model-function::ppc_insn_vr:itable_index index, model_data *model_ptr, const unsigned32 out_vmask, const unsigned32 in_vmask\n-\tconst unsigned32 vr_mask = out_vmask | in_vmask;\n+void::model-function::ppc_insn_vr:itable_index index, model_data *model_ptr, const uint32_t out_vmask, const uint32_t in_vmask\n+\tconst uint32_t vr_mask = out_vmask | in_vmask;\n \tmodel_busy *busy_ptr;\n \n \tif (model_ptr->vr_busy & vr_mask) {\n@@ -174,8 +174,8 @@ void::model-function::ppc_insn_vr:itable_index index, model_data *model_ptr, con\n \t}\n \n # Schedule an AltiVec instruction that takes vector input registers and produces vector output registers, touches CR\n-void::model-function::ppc_insn_vr_cr:itable_index index, model_data *model_ptr, const unsigned32 out_vmask, const unsigned32 in_vmask, const unsigned32 cr_mask\n-\tconst unsigned32 vr_mask = out_vmask | in_vmask;\n+void::model-function::ppc_insn_vr_cr:itable_index index, model_data *model_ptr, const uint32_t out_vmask, const uint32_t in_vmask, const uint32_t cr_mask\n+\tconst uint32_t vr_mask = out_vmask | in_vmask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->vr_busy & vr_mask) || (model_ptr->cr_fpscr_busy & cr_mask)) {\n@@ -208,8 +208,8 @@ void::model-function::ppc_insn_vr_cr:itable_index index, model_data *model_ptr,\n \t  model_trace_altivec_make_busy(model_ptr, vr_mask, cr_mask);\n \n # Schedule an AltiVec instruction that takes vector input registers and produces vector output registers, touches VSCR\n-void::model-function::ppc_insn_vr_vscr:itable_index index, model_data *model_ptr, const unsigned32 out_vmask, const unsigned32 in_vmask\n-\tconst unsigned32 vr_mask = out_vmask | in_vmask;\n+void::model-function::ppc_insn_vr_vscr:itable_index index, model_data *model_ptr, const uint32_t out_vmask, const uint32_t in_vmask\n+\tconst uint32_t vr_mask = out_vmask | in_vmask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->vr_busy & vr_mask) != 0 || model_ptr->vscr_busy != 0) {\n@@ -237,7 +237,7 @@ void::model-function::ppc_insn_vr_vscr:itable_index index, model_data *model_ptr\n \t  model_trace_altivec_make_busy(model_ptr, vr_mask, 0);\n \n # Schedule an MFVSCR instruction that VSCR input register and produces an AltiVec output register\n-void::model-function::ppc_insn_from_vscr:itable_index index, model_data *model_ptr, const unsigned32 vr_mask\n+void::model-function::ppc_insn_from_vscr:itable_index index, model_data *model_ptr, const uint32_t vr_mask\n \tmodel_busy *busy_ptr;\n \n \twhile ((model_ptr->vr_busy & vr_mask) != 0 || model_ptr->vscr_busy != 0) {\n@@ -259,7 +259,7 @@ void::model-function::ppc_insn_from_vscr:itable_index index, model_data *model_p\n \t  model_trace_altivec_make_busy(model_ptr, vr_mask, 0);\n \n # Schedule an MTVSCR instruction that one AltiVec input register and produces a vscr output register\n-void::model-function::ppc_insn_to_vscr:itable_index index, model_data *model_ptr, const unsigned32 vr_mask\n+void::model-function::ppc_insn_to_vscr:itable_index index, model_data *model_ptr, const uint32_t vr_mask\n \tmodel_busy *busy_ptr;\n \n \twhile ((model_ptr->vr_busy & vr_mask) != 0 || model_ptr->vscr_busy != 0) {\n@@ -278,8 +278,8 @@ void::model-function::ppc_insn_to_vscr:itable_index index, model_data *model_ptr\n \n # The follow are AltiVec saturate operations\n \n-signed8::model-function::altivec_signed_saturate_8:signed16 val, int *sat\n-\t  signed8 rv;\n+int8_t::model-function::altivec_signed_saturate_8:int16_t val, int *sat\n+\t  int8_t rv;\n \t  if (val > 127) {\n \t    rv = 127;\n \t    *sat = 1;\n@@ -292,8 +292,8 @@ signed8::model-function::altivec_signed_saturate_8:signed16 val, int *sat\n \t  }\n \t  return rv;\n \n-signed16::model-function::altivec_signed_saturate_16:signed32 val, int *sat\n-\t  signed16 rv;\n+int16_t::model-function::altivec_signed_saturate_16:int32_t val, int *sat\n+\t  int16_t rv;\n \t  if (val > 32767) {\n \t    rv = 32767;\n \t    *sat = 1;\n@@ -306,8 +306,8 @@ signed16::model-function::altivec_signed_saturate_16:signed32 val, int *sat\n \t  }\n \t  return rv;\n \n-signed32::model-function::altivec_signed_saturate_32:signed64 val, int *sat\n-\t  signed32 rv;\n+int32_t::model-function::altivec_signed_saturate_32:int64_t val, int *sat\n+\t  int32_t rv;\n \t  if (val > 2147483647) {\n \t    rv = 2147483647;\n \t    *sat = 1;\n@@ -320,8 +320,8 @@ signed32::model-function::altivec_signed_saturate_32:signed64 val, int *sat\n \t  }\n \t  return rv;\n \n-unsigned8::model-function::altivec_unsigned_saturate_8:signed16 val, int *sat\n-\t  unsigned8 rv;\n+uint8_t::model-function::altivec_unsigned_saturate_8:int16_t val, int *sat\n+\t  uint8_t rv;\n \t  if (val > 255) {\n \t    rv = 255;\n \t    *sat = 1;\n@@ -334,8 +334,8 @@ unsigned8::model-function::altivec_unsigned_saturate_8:signed16 val, int *sat\n \t  }\n \t  return rv;\n \n-unsigned16::model-function::altivec_unsigned_saturate_16:signed32 val, int *sat\n-\t  unsigned16 rv;\n+uint16_t::model-function::altivec_unsigned_saturate_16:int32_t val, int *sat\n+\t  uint16_t rv;\n \t  if (val > 65535) {\n \t    rv = 65535;\n \t    *sat = 1;\n@@ -348,8 +348,8 @@ unsigned16::model-function::altivec_unsigned_saturate_16:signed32 val, int *sat\n \t  }\n \t  return rv;\n \n-unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n-\t  unsigned32 rv;\n+uint32_t::model-function::altivec_unsigned_saturate_32:int64_t val, int *sat\n+\t  uint32_t rv;\n \t  if (val > 4294967295LL) {\n \t    rv = 4294967295LL;\n \t    *sat = 1;\n@@ -573,17 +573,17 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n #\n \n 0.4,6.VS,11.VA,16.VB,21.384:VX:av:vaddcuw %VD, %VA, %VB:Vector Add Carryout Unsigned Word\n-\tunsigned64 temp;\n+\tuint64_t temp;\n \tint i;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (unsigned64)(*vA).w[i] + (unsigned64)(*vB).w[i];\n+\t  temp = (uint64_t)(*vA).w[i] + (uint64_t)(*vB).w[i];\n \t  (*vS).w[i] = temp >> 32;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.10:VX:av:vaddfp %VD, %VA, %VB:Vector Add Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu a, b, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&a, (*vA).w[i]);\n@@ -596,9 +596,9 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \t\n 0.4,6.VS,11.VA,16.VB,21.768:VX:av:vaddsbs %VD, %VA, %VB:Vector Add Signed Byte Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tfor (i = 0; i < 16; i++) {\n-\t  temp = (signed16)(signed8)(*vA).b[i] + (signed16)(signed8)(*vB).b[i];\n+\t  temp = (int16_t)(int8_t)(*vA).b[i] + (int16_t)(int8_t)(*vB).b[i];\n \t  (*vS).b[i] = altivec_signed_saturate_8(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -607,10 +607,10 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.832:VX:av:vaddshs %VD, %VA, %VB:Vector Add Signed Half Word Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp, a, b;\n+\tint32_t temp, a, b;\n \tfor (i = 0; i < 8; i++) {\n-\t  a = (signed32)(signed16)(*vA).h[i];\n-\t  b = (signed32)(signed16)(*vB).h[i];\n+\t  a = (int32_t)(int16_t)(*vA).h[i];\n+\t  b = (int32_t)(int16_t)(*vB).h[i];\n \t  temp = a + b;\n \t  (*vS).h[i] = altivec_signed_saturate_16(temp, &tempsat);\n \t  sat |= tempsat;\n@@ -620,9 +620,9 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.896:VX:av:vaddsws %VD, %VA, %VB:Vector Add Signed Word Saturate\n \tint i, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (signed64)(signed32)(*vA).w[i] + (signed64)(signed32)(*vB).w[i];\n+\t  temp = (int64_t)(int32_t)(*vA).w[i] + (int64_t)(int32_t)(*vB).w[i];\n \t  (*vS).w[i] = altivec_signed_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -637,10 +637,10 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.512:VX:av:vaddubs %VD, %VA, %VB:Vector Add Unsigned Byte Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 16; i++) {\n-\t  temp = (signed16)(unsigned8)(*vA).b[i] + (signed16)(unsigned8)(*vB).b[i];\n+\t  temp = (int16_t)(uint8_t)(*vA).b[i] + (int16_t)(uint8_t)(*vB).b[i];\n \t  (*vS).b[i] = altivec_unsigned_saturate_8(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -655,9 +655,9 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.576:VX:av:vadduhs %VD, %VA, %VB:Vector Add Unsigned Half Word Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp;\n+\tint32_t temp;\n \tfor (i = 0; i < 8; i++) {\n-\t  temp = (signed32)(unsigned16)(*vA).h[i] + (signed32)(unsigned16)(*vB).h[i];\n+\t  temp = (int32_t)(uint16_t)(*vA).h[i] + (int32_t)(uint16_t)(*vB).h[i];\n \t  (*vS).h[i] = altivec_unsigned_saturate_16(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -672,9 +672,9 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.640:VX:av:vadduws %VD, %VA, %VB:Vector Add Unsigned Word Saturate\n \tint i, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (signed64)(unsigned32)(*vA).w[i] + (signed64)(unsigned32)(*vB).w[i];\n+\t  temp = (int64_t)(uint32_t)(*vA).w[i] + (int64_t)(uint32_t)(*vB).w[i];\n \t  (*vS).w[i] = altivec_unsigned_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -704,40 +704,40 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1282:VX:av:vavgsb %VD, %VA, %VB:Vector Average Signed Byte\n \tint i;\n-\tsigned16 temp, a, b;\n+\tint16_t temp, a, b;\n \tfor (i = 0; i < 16; i++) {\n-\t  a = (signed16)(signed8)(*vA).b[i];\n-\t  b = (signed16)(signed8)(*vB).b[i];\n+\t  a = (int16_t)(int8_t)(*vA).b[i];\n+\t  b = (int16_t)(int8_t)(*vB).b[i];\n \t  temp = a + b + 1;\n \t  (*vS).b[i] = (temp >> 1) & 0xff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.1346:VX:av:vavgsh %VD, %VA, %VB:Vector Average Signed Half Word\n \tint i;\n-\tsigned32 temp, a, b;\n+\tint32_t temp, a, b;\n \tfor (i = 0; i < 8; i++) {\n-\t  a = (signed32)(signed16)(*vA).h[i];\n-\t  b = (signed32)(signed16)(*vB).h[i];\n+\t  a = (int32_t)(int16_t)(*vA).h[i];\n+\t  b = (int32_t)(int16_t)(*vB).h[i];\n \t  temp = a + b + 1;\n \t  (*vS).h[i] = (temp >> 1) & 0xffff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.1410:VX:av:vavgsw %VD, %VA, %VB:Vector Average Signed Word\n \tint i;\n-\tsigned64 temp, a, b;\n+\tint64_t temp, a, b;\n \tfor (i = 0; i < 4; i++) {\n-\t  a = (signed64)(signed32)(*vA).w[i];\n-\t  b = (signed64)(signed32)(*vB).w[i];\n+\t  a = (int64_t)(int32_t)(*vA).w[i];\n+\t  b = (int64_t)(int32_t)(*vB).w[i];\n \t  temp = a + b + 1;\n \t  (*vS).w[i] = (temp >> 1) & 0xffffffff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.1026:VX:av:vavgub %VD, %VA, %VB:Vector Average Unsigned Byte\n \tint i;\n-\tunsigned16 temp, a, b;\n+\tuint16_t temp, a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -748,7 +748,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1090:VX:av:vavguh %VD, %VA, %VB:Vector Average Unsigned Half Word\n \tint i;\n-\tunsigned32 temp, a, b;\n+\tuint32_t temp, a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -759,7 +759,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1154:VX:av:vavguw %VD, %VA, %VB:Vector Average Unsigned Word\n \tint i;\n-\tunsigned64 temp, a, b;\n+\tuint64_t temp, a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -774,7 +774,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.UIMM,16.VB,21.842:VX:av:vcfsx %VD, %VB, %UIMM:Vector Convert From Signed Fixed-Point Word\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu b, div, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&b, (*vB).w[i]);\n@@ -787,7 +787,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.UIMM,16.VB,21.778:VX:av:vcfux %VD, %VA, %UIMM:Vector Convert From Unsigned Fixed-Point Word\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu b, d, div;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&b, (*vB).w[i]);\n@@ -896,7 +896,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.RC,22.774:VXR:av:vcmpgtsbx %VD, %VA, %VB:Vector Compare Greater-Than Signed Byte\n \tint i;\n-\tsigned8 a, b;\n+\tint8_t a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -911,7 +911,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.RC,22.838:VXR:av:vcmpgtshx %VD, %VA, %VB:Vector Compare Greater-Than Signed Half Word\n \tint i;\n-\tsigned16 a, b;\n+\tint16_t a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -926,7 +926,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.RC,22.902:VXR:av:vcmpgtswx %VD, %VA, %VB:Vector Compare Greater-Than Signed Word\n \tint i;\n-\tsigned32 a, b;\n+\tint32_t a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -941,7 +941,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.RC,22.518:VXR:av:vcmpgtubx %VD, %VA, %VB:Vector Compare Greater-Than Unsigned Byte\n \tint i;\n-\tunsigned8 a, b;\n+\tuint8_t a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -956,7 +956,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.RC,22.582:VXR:av:vcmpgtuhx %VD, %VA, %VB:Vector Compare Greater-Than Unsigned Half Word\n \tint i;\n-\tunsigned16 a, b;\n+\tuint16_t a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -971,7 +971,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.RC,22.646:VXR:av:vcmpgtuwx %VD, %VA, %VB:Vector Compare Greater-Than Unsigned Word\n \tint i;\n-\tunsigned32 a, b;\n+\tuint32_t a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -990,7 +990,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.UIMM,16.VB,21.970:VX:av:vctsxs %VD, %VB, %UIMM:Vector Convert to Signed Fixed-Point Word Saturate\n \tint i, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tsim_fpu a, b, m;\n \tsat = 0;\n \tfor (i = 0; i < 4; i++) {\n@@ -1006,7 +1006,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.UIMM,16.VB,21.906:VX:av:vctuxs %VD, %VB, %UIMM:Vector Convert to Unsigned Fixed-Point Word Saturate\n \tint i, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tsim_fpu a, b, m;\n \tsat = 0;\n \tfor (i = 0; i < 4; i++) {\n@@ -1026,8 +1026,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.394:VX:av:vexptefp %VD, %VB:Vector 2 Raised to the Exponent Estimate Floating Point\n \tint i;\n-\tunsigned32 f;\n-\tsigned32 bi;\n+\tuint32_t f;\n+\tint32_t bi;\n \tsim_fpu b, d;\n \tfor (i = 0; i < 4; i++) {\n \t  /*HACK!*/\n@@ -1042,7 +1042,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.458:VX:av:vlogefp %VD, %VB:Vector Log2 Estimate Floating Point\n \tint i;\n-\tunsigned32 c, u, f;\n+\tuint32_t c, u, f;\n \tsim_fpu b, cfpu, d;\n \tfor (i = 0; i < 4; i++) {\n \t  /*HACK!*/\n@@ -1063,7 +1063,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.46:VAX:av:vmaddfp %VD, %VA, %VB, %VC:Vector Multiply Add Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu a, b, c, d, e;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&a, (*vA).w[i]);\n@@ -1083,7 +1083,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1034:VX:av:vmaxfp %VD, %VA, %VB:Vector Maximum Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu a, b, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&a, (*vA).w[i]);\n@@ -1096,7 +1096,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.258:VX:av:vmaxsb %VD, %VA, %VB:Vector Maximum Signed Byte\n \tint i;\n-\tsigned8 a, b;\n+\tint8_t a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -1109,7 +1109,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.322:VX:av:vmaxsh %VD, %VA, %VB:Vector Maximum Signed Half Word\n \tint i;\n-\tsigned16 a, b;\n+\tint16_t a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -1122,7 +1122,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.386:VX:av:vmaxsw %VD, %VA, %VB:Vector Maximum Signed Word\n \tint i;\n-\tsigned32 a, b;\n+\tint32_t a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -1135,7 +1135,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.2:VX:av:vmaxub %VD, %VA, %VB:Vector Maximum Unsigned Byte\n \tint i;\n-\tunsigned8 a, b;\n+\tuint8_t a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -1148,7 +1148,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.66:VX:av:vmaxus %VD, %VA, %VB:Vector Maximum Unsigned Half Word\n \tint i;\n-\tunsigned16 a, b;\n+\tuint16_t a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -1161,7 +1161,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.130:VX:av:vmaxuw %VD, %VA, %VB:Vector Maximum Unsigned Word\n \tint i;\n-\tunsigned32 a, b;\n+\tuint32_t a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -1179,13 +1179,13 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.32:VAX:av:vmhaddshs %VD, %VA, %VB, %VC:Vector Multiple High and Add Signed Half Word Saturate\n \tint i, sat, tempsat;\n-\tsigned16 a, b;\n-\tsigned32 prod, temp, c;\n+\tint16_t a, b;\n+\tint32_t prod, temp, c;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n-\t  c = (signed32)(signed16)(*vC).h[i];\n-\t  prod = (signed32)a * (signed32)b;\n+\t  c = (int32_t)(int16_t)(*vC).h[i];\n+\t  prod = (int32_t)a * (int32_t)b;\n \t  temp = (prod >> 15) + c;\n \t  (*vS).h[i] = altivec_signed_saturate_16(temp, &tempsat);\n \t  sat |= tempsat;\n@@ -1195,13 +1195,13 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.33:VAX:av:vmhraddshs %VD, %VA, %VB, %VC:Vector Multiple High Round and Add Signed Half Word Saturate\n \tint i, sat, tempsat;\n-\tsigned16 a, b;\n-\tsigned32 prod, temp, c;\n+\tint16_t a, b;\n+\tint32_t prod, temp, c;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n-\t  c = (signed32)(signed16)(*vC).h[i];\n-\t  prod = (signed32)a * (signed32)b;\n+\t  c = (int32_t)(int16_t)(*vC).h[i];\n+\t  prod = (int32_t)a * (int32_t)b;\n \t  prod += 0x4000;\n \t  temp = (prod >> 15) + c;\n \t  (*vS).h[i] = altivec_signed_saturate_16(temp, &tempsat);\n@@ -1217,7 +1217,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1098:VX:av:vminfp %VD, %VA, %VB:Vector Minimum Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu a, b, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&a, (*vA).w[i]);\n@@ -1230,7 +1230,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.770:VX:av:vminsb %VD, %VA, %VB:Vector Minimum Signed Byte\n \tint i;\n-\tsigned8 a, b;\n+\tint8_t a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -1243,7 +1243,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.834:VX:av:vminsh %VD, %VA, %VB:Vector Minimum Signed Half Word\n \tint i;\n-\tsigned16 a, b;\n+\tint16_t a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -1256,7 +1256,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.898:VX:av:vminsw %VD, %VA, %VB:Vector Minimum Signed Word\n \tint i;\n-\tsigned32 a, b;\n+\tint32_t a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -1269,7 +1269,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.514:VX:av:vminub %VD, %VA, %VB:Vector Minimum Unsigned Byte\n \tint i;\n-\tunsigned8 a, b;\n+\tuint8_t a, b;\n \tfor (i = 0; i < 16; i++) {\n \t  a = (*vA).b[i];\n \t  b = (*vB).b[i];\n@@ -1282,7 +1282,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.578:VX:av:vminuh %VD, %VA, %VB:Vector Minimum Unsigned Half Word\n \tint i;\n-\tunsigned16 a, b;\n+\tuint16_t a, b;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n@@ -1295,7 +1295,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.642:VX:av:vminuw %VD, %VA, %VB:Vector Minimum Unsigned Word\n \tint i;\n-\tunsigned32 a, b;\n+\tuint32_t a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).w[i];\n \t  b = (*vB).w[i];\n@@ -1313,13 +1313,13 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.34:VAX:av:vmladduhm %VD, %VA, %VB, %VC:Vector Multiply Low and Add Unsigned Half Word Modulo\n \tint i;\n-\tunsigned16 a, b, c;\n-\tunsigned32 prod;\n+\tuint16_t a, b, c;\n+\tuint32_t prod;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).h[i];\n \t  b = (*vB).h[i];\n \t  c = (*vC).h[i];\n-\t  prod = (unsigned32)a * (unsigned32)b;\n+\t  prod = (uint32_t)a * (uint32_t)b;\n \t  (*vS).h[i] = (prod + c) & 0xffff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK | VC_BITMASK);\n@@ -1384,29 +1384,29 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.37:VAX:av:vmsummbm %VD, %VA, %VB, %VC:Vector Multiply Sum Mixed-Sign Byte Modulo\n \tint i, j;\n-\tsigned32 temp;\n-\tsigned16 prod, a;\n-\tunsigned16 b;\n+\tint32_t temp;\n+\tint16_t prod, a;\n+\tuint16_t b;\n \tfor (i = 0; i < 4; i++) {\n \t  temp = (*vC).w[i];\n \t  for (j = 0; j < 4; j++) {\n-\t    a = (signed16)(signed8)(*vA).b[i*4+j]; \n+\t    a = (int16_t)(int8_t)(*vA).b[i*4+j]; \n \t    b = (*vB).b[i*4+j];\n \t    prod = a * b;\n-\t    temp += (signed32)prod;\n+\t    temp += (int32_t)prod;\n \t  }\n \t  (*vS).w[i] = temp;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK | VC_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.40:VAX:av:vmsumshm %VD, %VA, %VB, %VC:Vector Multiply Sum Signed Half Word Modulo\n \tint i, j;\n-\tsigned32 temp, prod, a, b;\n+\tint32_t temp, prod, a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  temp = (*vC).w[i];\n \t  for (j = 0; j < 2; j++) {\n-\t    a = (signed32)(signed16)(*vA).h[i*2+j]; \n-\t    b = (signed32)(signed16)(*vB).h[i*2+j];\n+\t    a = (int32_t)(int16_t)(*vA).h[i*2+j]; \n+\t    b = (int32_t)(int16_t)(*vB).h[i*2+j];\n \t    prod = a * b;\n \t    temp += prod;\n \t  }\n@@ -1416,16 +1416,16 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.41:VAX:av:vmsumshs %VD, %VA, %VB, %VC:Vector Multiply Sum Signed Half Word Saturate\n \tint i, j, sat, tempsat;\n-\tsigned64 temp;\n-\tsigned32 prod, a, b;\n+\tint64_t temp;\n+\tint32_t prod, a, b;\n \tsat = 0;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (signed64)(signed32)(*vC).w[i];\n+\t  temp = (int64_t)(int32_t)(*vC).w[i];\n \t  for (j = 0; j < 2; j++) {\n-\t    a = (signed32)(signed16)(*vA).h[i*2+j]; \n-\t    b = (signed32)(signed16)(*vB).h[i*2+j];\n+\t    a = (int32_t)(int16_t)(*vA).h[i*2+j]; \n+\t    b = (int32_t)(int16_t)(*vB).h[i*2+j];\n \t    prod = a * b;\n-\t    temp += (signed64)prod;\n+\t    temp += (int64_t)prod;\n \t  }\n \t  (*vS).w[i] = altivec_signed_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n@@ -1435,8 +1435,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.36:VAX:av:vmsumubm %VD, %VA, %VB, %VC:Vector Multiply Sum Unsigned Byte Modulo\n \tint i, j;\n-\tunsigned32 temp;\n-\tunsigned16 prod, a, b;\n+\tuint32_t temp;\n+\tuint16_t prod, a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  temp = (*vC).w[i];\n \t  for (j = 0; j < 4; j++) {\n@@ -1451,7 +1451,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.38:VAX:av:vmsumuhm %VD, %VA, %VB, %VC:Vector Multiply Sum Unsigned Half Word Modulo\n \tint i, j;\n-\tunsigned32 temp, prod, a, b;\n+\tuint32_t temp, prod, a, b;\n \tfor (i = 0; i < 4; i++) {\n \t  temp = (*vC).w[i];\n \t  for (j = 0; j < 2; j++) {\n@@ -1466,7 +1466,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.39:VAX:av:vmsumuhs %VD, %VA, %VB, %VC:Vector Multiply Sum Unsigned Half Word Saturate\n \tint i, j, sat, tempsat;\n-\tunsigned32 temp, prod, a, b;\n+\tuint32_t temp, prod, a, b;\n \tsat = 0;\n \tfor (i = 0; i < 4; i++) {\n \t  temp = (*vC).w[i];\n@@ -1489,8 +1489,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.776:VX:av:vmulesb %VD, %VA, %VB:Vector Multiply Even Signed Byte\n \tint i;\n-\tsigned8 a, b;\n-\tsigned16 prod;\n+\tint8_t a, b;\n+\tint16_t prod;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).b[AV_BINDEX(i*2)]; \n \t  b = (*vB).b[AV_BINDEX(i*2)];\n@@ -1501,8 +1501,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.840:VX:av:vmulesh %VD, %VA, %VB:Vector Multiply Even Signed Half Word\n \tint i;\n-\tsigned16 a, b;\n-\tsigned32 prod;\n+\tint16_t a, b;\n+\tint32_t prod;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).h[AV_HINDEX(i*2)]; \n \t  b = (*vB).h[AV_HINDEX(i*2)];\n@@ -1513,8 +1513,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.520:VX:av:vmuleub %VD, %VA, %VB:Vector Multiply Even Unsigned Byte\n \tint i;\n-\tunsigned8 a, b;\n-\tunsigned16 prod;\n+\tuint8_t a, b;\n+\tuint16_t prod;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).b[AV_BINDEX(i*2)]; \n \t  b = (*vB).b[AV_BINDEX(i*2)];\n@@ -1525,8 +1525,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.584:VX:av:vmuleuh %VD, %VA, %VB:Vector Multiply Even Unsigned Half Word\n \tint i;\n-\tunsigned16 a, b;\n-\tunsigned32 prod;\n+\tuint16_t a, b;\n+\tuint32_t prod;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).h[AV_HINDEX(i*2)]; \n \t  b = (*vB).h[AV_HINDEX(i*2)];\n@@ -1537,8 +1537,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.264:VX:av:vmulosb %VD, %VA, %VB:Vector Multiply Odd Signed Byte\n \tint i;\n-\tsigned8 a, b;\n-\tsigned16 prod;\n+\tint8_t a, b;\n+\tint16_t prod;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).b[AV_BINDEX((i*2)+1)]; \n \t  b = (*vB).b[AV_BINDEX((i*2)+1)];\n@@ -1549,8 +1549,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.328:VX:av:vmulosh %VD, %VA, %VB:Vector Multiply Odd Signed Half Word\n \tint i;\n-\tsigned16 a, b;\n-\tsigned32 prod;\n+\tint16_t a, b;\n+\tint32_t prod;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).h[AV_HINDEX((i*2)+1)]; \n \t  b = (*vB).h[AV_HINDEX((i*2)+1)];\n@@ -1561,8 +1561,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.8:VX:av:vmuloub %VD, %VA, %VB:Vector Multiply Odd Unsigned Byte\n \tint i;\n-\tunsigned8 a, b;\n-\tunsigned16 prod;\n+\tuint8_t a, b;\n+\tuint16_t prod;\n \tfor (i = 0; i < 8; i++) {\n \t  a = (*vA).b[AV_BINDEX((i*2)+1)]; \n \t  b = (*vB).b[AV_BINDEX((i*2)+1)];\n@@ -1573,8 +1573,8 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.72:VX:av:vmulouh %VD, %VA, %VB:Vector Multiply Odd Unsigned Half Word\n \tint i;\n-\tunsigned16 a, b;\n-\tunsigned32 prod;\n+\tuint16_t a, b;\n+\tuint32_t prod;\n \tfor (i = 0; i < 4; i++) {\n \t  a = (*vA).h[AV_HINDEX((i*2)+1)]; \n \t  b = (*vB).h[AV_HINDEX((i*2)+1)];\n@@ -1590,7 +1590,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.47:VX:av:vnmsubfp %VD, %VA, %VB, %VC:Vector Negative Multiply-Subtract Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu a, b, c, d, i1, i2;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&a, (*vA).w[i]);\n@@ -1667,7 +1667,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.398:VX:av:vpkshss %VD, %VA, %VB:Vector Pack Signed Half Word Signed Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 16; i++) {\n \t  if (i < 8)\n@@ -1682,7 +1682,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.270:VX:av:vpkshus %VD, %VA, %VB:Vector Pack Signed Half Word Unsigned Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 16; i++) {\n \t  if (i < 8)\n@@ -1697,7 +1697,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.462:VX:av:vpkswss %VD, %VA, %VB:Vector Pack Signed Word Signed Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp;\n+\tint32_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 8; i++) {\n \t  if (i < 4)\n@@ -1712,7 +1712,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.334:VX:av:vpkswus %VD, %VA, %VB:Vector Pack Signed Word Unsigned Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp;\n+\tint32_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 8; i++) {\n \t  if (i < 4)\n@@ -1736,14 +1736,14 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.142:VX:av:vpkuhus %VD, %VA, %VB:Vector Pack Unsigned Half Word Unsigned Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 16; i++) {\n \t  if (i < 8)\n \t    temp = (*vA).h[AV_HINDEX(i)];\n \t  else\n \t    temp = (*vB).h[AV_HINDEX(i-8)];\n-\t  /* force positive in signed16, ok as we'll toss the bit away anyway */\n+\t  /* force positive in int16_t, ok as we'll toss the bit away anyway */\n \t  temp &= ~0x8000;\n \t  (*vS).b[AV_BINDEX(i)] = altivec_unsigned_saturate_8(temp, &tempsat);\n \t  sat |= tempsat;\n@@ -1762,14 +1762,14 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.206:VX:av:vpkuwus %VD, %VA, %VB:Vector Pack Unsigned Word Unsigned Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp;\n+\tint32_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 8; i++) {\n \t  if (i < 4)\n \t    temp = (*vA).w[i];\n \t  else\n \t    temp = (*vB).w[i-4];\n-\t  /* force positive in signed32, ok as we'll toss the bit away anyway */\n+\t  /* force positive in int32_t, ok as we'll toss the bit away anyway */\n \t  temp &= ~0x80000000;\n \t  (*vS).h[AV_HINDEX(i)] = altivec_unsigned_saturate_16(temp, &tempsat);\n \t  sat |= tempsat;\n@@ -1784,7 +1784,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.266:VX:av:vrefp %VD, %VB:Vector Reciprocal Estimate Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu op, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&op, (*vB).w[i]);\n@@ -1796,7 +1796,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.330:VX:av:vrsqrtefp %VD, %VB:Vector Reciprocal Square Root Estimate Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu op, i1, one, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&op, (*vB).w[i]);\n@@ -1814,7 +1814,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.714:VX:av:vrfim %VD, %VB:Vector Round to Floating-Point Integer towards Minus Infinity\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu op;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&op, (*vB).w[i]);\n@@ -1826,7 +1826,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.522:VX:av:vrfin %VD, %VB:Vector Round to Floating-Point Integer Nearest\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu op;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&op, (*vB).w[i]);\n@@ -1838,7 +1838,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.650:VX:av:vrfip %VD, %VB:Vector Round to Floating-Point Integer towards Plus Infinity\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu op;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&op, (*vB).w[i]);\n@@ -1850,7 +1850,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.586:VX:av:vrfiz %VD, %VB:Vector Round to Floating-Point Integer towards Zero\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu op;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&op, (*vB).w[i]);\n@@ -1867,27 +1867,27 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.4:VX:av:vrlb %VD, %VA, %VB:Vector Rotate Left Integer Byte\n \tint i;\n-\tunsigned16 temp;\n+\tuint16_t temp;\n \tfor (i = 0; i < 16; i++) {\n-\t  temp = (unsigned16)(*vA).b[i] << (((*vB).b[i]) & 7);\n+\t  temp = (uint16_t)(*vA).b[i] << (((*vB).b[i]) & 7);\n \t  (*vS).b[i] = (temp & 0xff) | ((temp >> 8) & 0xff);\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.68:VX:av:vrlh %VD, %VA, %VB:Vector Rotate Left Integer Half Word\n \tint i;\n-\tunsigned32 temp;\n+\tuint32_t temp;\n \tfor (i = 0; i < 8; i++) {\n-\t  temp = (unsigned32)(*vA).h[i] << (((*vB).h[i]) & 0xf);\n+\t  temp = (uint32_t)(*vA).h[i] << (((*vB).h[i]) & 0xf);\n \t  (*vS).h[i] = (temp & 0xffff) | ((temp >> 16) & 0xffff);\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.132:VX:av:vrlw %VD, %VA, %VB:Vector Rotate Left Integer Word\n \tint i;\n-\tunsigned64 temp;\n+\tuint64_t temp;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (unsigned64)(*vA).w[i] << (((*vB).w[i]) & 0x1f);\n+\t  temp = (uint64_t)(*vA).w[i] << (((*vB).w[i]) & 0x1f);\n \t  (*vS).w[i] = (temp & 0xffffffff) | ((temp >> 32) & 0xffffffff);\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n@@ -1899,7 +1899,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.VC,26.42:VAX:av:vsel %VD, %VA, %VB, %VC:Vector Conditional Select\n \tint i;\n-\tunsigned32 c;\n+\tuint32_t c;\n \tfor (i = 0; i < 4; i++) {\n \t  c = (*vC).w[i];\n \t  (*vS).w[i] = ((*vB).w[i] & c) | ((*vA).w[i] & ~c);\n@@ -1978,23 +1978,23 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.UIMM,16.VB,21.524:VX:av:vspltb %VD, %VB, %UIMM:Vector Splat Byte\n \tint i;\n-\tunsigned8 b;\n+\tuint8_t b;\n \tb = (*vB).b[AV_BINDEX(UIMM & 0xf)];\n \tfor (i = 0; i < 16; i++)\n \t  (*vS).b[i] = b;\n \tPPC_INSN_VR(VS_BITMASK, VB_BITMASK);\n \n 0.4,6.VS,11.UIMM,16.VB,21.588:VX:av:vsplth %VD, %VB, %UIMM:Vector Splat Half Word\n \tint i;\n-\tunsigned16 h;\n+\tuint16_t h;\n \th = (*vB).h[AV_HINDEX(UIMM & 0x7)];\n \tfor (i = 0; i < 8; i++)\n \t  (*vS).h[i] = h;\n \tPPC_INSN_VR(VS_BITMASK, VB_BITMASK);\n \n 0.4,6.VS,11.SIMM,16.0,21.780:VX:av:vspltisb %VD, %SIMM:Vector Splat Immediate Signed Byte\n \tint i;\n-\tsigned8 b = SIMM;\n+\tint8_t b = SIMM;\n \t/* manual 5-bit signed extension */\n \tif (b & 0x10)\n \t  b -= 0x20;\n@@ -2004,7 +2004,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.SIMM,16.0,21.844:VX:av:vspltish %VD, %SIMM:Vector Splat Immediate Signed Half Word\n \tint i;\n-\tsigned16 h = SIMM;\n+\tint16_t h = SIMM;\n \t/* manual 5-bit signed extension */\n \tif (h & 0x10)\n \t  h -= 0x20;\n@@ -2014,7 +2014,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.SIMM,16.0,21.908:VX:av:vspltisw %VD, %SIMM:Vector Splat Immediate Signed Word\n \tint i;\n-\tsigned32 w = SIMM;\n+\tint32_t w = SIMM;\n \t/* manual 5-bit signed extension */\n \tif (w & 0x10)\n \t  w -= 0x20;\n@@ -2024,7 +2024,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.UIMM,16.VB,21.652:VX:av:vspltw %VD, %VB, %UIMM:Vector Splat Word\n \tint i;\n-\tunsigned32 w;\n+\tuint32_t w;\n \tw = (*vB).w[UIMM & 0x3];\n \tfor (i = 0; i < 4; i++)\n \t  (*vS).w[i] = w;\n@@ -2052,30 +2052,30 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.772:VX:av:vsrab %VD, %VA, %VB:Vector Shift Right Algebraic Byte\n \tint i, sh;\n-\tsigned16 a;\n+\tint16_t a;\n \tfor (i = 0; i < 16; i++) {\n \t  sh = ((*vB).b[i]) & 7;\n-\t  a = (signed16)(signed8)(*vA).b[i];\n+\t  a = (int16_t)(int8_t)(*vA).b[i];\n \t  (*vS).b[i] = (a >> sh) & 0xff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.836:VX:av:vsrah %VD, %VA, %VB:Vector Shift Right Algebraic Half Word\n \tint i, sh;\n-\tsigned32 a;\n+\tint32_t a;\n \tfor (i = 0; i < 8; i++) {\n \t  sh = ((*vB).h[i]) & 0xf;\n-\t  a = (signed32)(signed16)(*vA).h[i];\n+\t  a = (int32_t)(int16_t)(*vA).h[i];\n \t  (*vS).h[i] = (a >> sh) & 0xffff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.900:VX:av:vsraw %VD, %VA, %VB:Vector Shift Right Algebraic Word\n \tint i, sh;\n-\tsigned64 a;\n+\tint64_t a;\n \tfor (i = 0; i < 4; i++) {\n \t  sh = ((*vB).w[i]) & 0xf;\n-\t  a = (signed64)(signed32)(*vA).w[i];\n+\t  a = (int64_t)(int32_t)(*vA).w[i];\n \t  (*vS).w[i] = (a >> sh) & 0xffffffff;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n@@ -2125,18 +2125,18 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1408:VX:av:vsubcuw %VD, %VA, %VB:Vector Subtract Carryout Unsigned Word\n \tint i;\n-\tsigned64 temp, a, b;\n+\tint64_t temp, a, b;\n \tfor (i = 0; i < 4; i++) {\n-\t  a = (signed64)(unsigned32)(*vA).w[i];\n-\t  b = (signed64)(unsigned32)(*vB).w[i];\n+\t  a = (int64_t)(uint32_t)(*vA).w[i];\n+\t  b = (int64_t)(uint32_t)(*vB).w[i];\n \t  temp = a - b;\n \t  (*vS).w[i] = ~(temp >> 32) & 1;\n \t}\n \tPPC_INSN_VR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.74:VX:av:vsubfp %VD, %VA, %VB:Vector Subtract Floating Point\n \tint i;\n-\tunsigned32 f;\n+\tuint32_t f;\n \tsim_fpu a, b, d;\n \tfor (i = 0; i < 4; i++) {\n \t  sim_fpu_32to (&a, (*vA).w[i]);\n@@ -2149,10 +2149,10 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1792:VX:av:vsubsbs %VD, %VA, %VB:Vector Subtract Signed Byte Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 16; i++) {\n-\t  temp = (signed16)(signed8)(*vA).b[i] - (signed16)(signed8)(*vB).b[i];\n+\t  temp = (int16_t)(int8_t)(*vA).b[i] - (int16_t)(int8_t)(*vB).b[i];\n \t  (*vS).b[i] = altivec_signed_saturate_8(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2161,10 +2161,10 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1856:VX:av:vsubshs %VD, %VA, %VB:Vector Subtract Signed Half Word Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp;\n+\tint32_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 8; i++) {\n-\t  temp = (signed32)(signed16)(*vA).h[i] - (signed32)(signed16)(*vB).h[i];\n+\t  temp = (int32_t)(int16_t)(*vA).h[i] - (int32_t)(int16_t)(*vB).h[i];\n \t  (*vS).h[i] = altivec_signed_saturate_16(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2173,10 +2173,10 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1920:VX:av:vsubsws %VD, %VA, %VB:Vector Subtract Signed Word Saturate\n \tint i, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (signed64)(signed32)(*vA).w[i] - (signed64)(signed32)(*vB).w[i];\n+\t  temp = (int64_t)(int32_t)(*vA).w[i] - (int64_t)(int32_t)(*vB).w[i];\n \t  (*vS).w[i] = altivec_signed_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2191,10 +2191,10 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1536:VX:av:vsububs %VD, %VA, %VB:Vector Subtract Unsigned Byte Saturate\n \tint i, sat, tempsat;\n-\tsigned16 temp;\n+\tint16_t temp;\n \tsat = 0;\n \tfor (i = 0; i < 16; i++) {\n-\t  temp = (signed16)(unsigned8)(*vA).b[i] - (signed16)(unsigned8)(*vB).b[i];\n+\t  temp = (int16_t)(uint8_t)(*vA).b[i] - (int16_t)(uint8_t)(*vB).b[i];\n \t  (*vS).b[i] = altivec_unsigned_saturate_8(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2209,9 +2209,9 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1600:VX:av:vsubuhs %VD, %VA, %VB:Vector Subtract Unsigned Half Word Saturate\n \tint i, sat, tempsat;\n-\tsigned32 temp;\n+\tint32_t temp;\n \tfor (i = 0; i < 8; i++) {\n-\t  temp = (signed32)(unsigned16)(*vA).h[i] - (signed32)(unsigned16)(*vB).h[i];\n+\t  temp = (int32_t)(uint16_t)(*vA).h[i] - (int32_t)(uint16_t)(*vB).h[i];\n \t  (*vS).h[i] = altivec_unsigned_saturate_16(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2226,9 +2226,9 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1664:VX:av:vsubuws %VD, %VA, %VB:Vector Subtract Unsigned Word Saturate\n \tint i, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tfor (i = 0; i < 4; i++) {\n-\t  temp = (signed64)(unsigned32)(*vA).w[i] - (signed64)(unsigned32)(*vB).w[i];\n+\t  temp = (int64_t)(uint32_t)(*vA).w[i] - (int64_t)(uint32_t)(*vB).w[i];\n \t  (*vS).w[i] = altivec_unsigned_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2242,21 +2242,21 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1928:VX:av:vsumsws %VD, %VA, %VB:Vector Sum Across Signed Word Saturate\n \tint i, sat;\n-\tsigned64 temp;\n-\ttemp = (signed64)(signed32)(*vB).w[3];\n+\tint64_t temp;\n+\ttemp = (int64_t)(int32_t)(*vB).w[3];\n \tfor (i = 0; i < 4; i++)\n-\t  temp += (signed64)(signed32)(*vA).w[i];\n+\t  temp += (int64_t)(int32_t)(*vA).w[i];\n \t(*vS).w[3] = altivec_signed_saturate_32(temp, &sat);\n \t(*vS).w[0] = (*vS).w[1] = (*vS).w[2] = 0;\n \tALTIVEC_SET_SAT(sat);\n \tPPC_INSN_VR_VSCR(VS_BITMASK, VA_BITMASK | VB_BITMASK);\n \n 0.4,6.VS,11.VA,16.VB,21.1672:VX:av:vsum2sws %VD, %VA, %VB:Vector Sum Across Partial (1/2) Signed Word Saturate\n \tint i, j, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tfor (j = 0; j < 4; j += 2) {\n-\t  temp = (signed64)(signed32)(*vB).w[j+1];\n-\t  temp += (signed64)(signed32)(*vA).w[j] + (signed64)(signed32)(*vA).w[j+1];\n+\t  temp = (int64_t)(int32_t)(*vB).w[j+1];\n+\t  temp += (int64_t)(int32_t)(*vA).w[j] + (int64_t)(int32_t)(*vA).w[j+1];\n \t  (*vS).w[j+1] = altivec_signed_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2266,11 +2266,11 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1800:VX:av:vsum4sbs %VD, %VA, %VB:Vector Sum Across Partial (1/4) Signed Byte Saturate\n \tint i, j, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tfor (j = 0; j < 4; j++) {\n-\t  temp = (signed64)(signed32)(*vB).w[j];\n+\t  temp = (int64_t)(int32_t)(*vB).w[j];\n \t  for (i = 0; i < 4; i++)\n-\t    temp += (signed64)(signed8)(*vA).b[i+(j*4)];\n+\t    temp += (int64_t)(int8_t)(*vA).b[i+(j*4)];\n \t  (*vS).w[j] = altivec_signed_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2279,11 +2279,11 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1608:VX:av:vsum4shs %VD, %VA, %VB:Vector Sum Across Partial (1/4) Signed Half Word Saturate\n \tint i, j, sat, tempsat;\n-\tsigned64 temp;\n+\tint64_t temp;\n \tfor (j = 0; j < 4; j++) {\n-\t  temp = (signed64)(signed32)(*vB).w[j];\n+\t  temp = (int64_t)(int32_t)(*vB).w[j];\n \t  for (i = 0; i < 2; i++)\n-\t    temp += (signed64)(signed16)(*vA).h[i+(j*2)];\n+\t    temp += (int64_t)(int16_t)(*vA).h[i+(j*2)];\n \t  (*vS).w[j] = altivec_signed_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n \t}\n@@ -2292,12 +2292,12 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.VA,16.VB,21.1544:VX:av:vsum4ubs %VD, %VA, %VB:Vector Sum Across Partial (1/4) Unsigned Byte Saturate\n \tint i, j, sat, tempsat;\n-\tsigned64 utemp;\n-\tsigned64 temp;\n+\tint64_t utemp;\n+\tint64_t temp;\n \tfor (j = 0; j < 4; j++) {\n-\t  utemp = (signed64)(unsigned32)(*vB).w[j];\n+\t  utemp = (int64_t)(uint32_t)(*vB).w[j];\n \t  for (i = 0; i < 4; i++)\n-\t    utemp += (signed64)(unsigned16)(*vA).b[i+(j*4)];\n+\t    utemp += (int64_t)(uint16_t)(*vA).b[i+(j*4)];\n \t  temp = utemp;\n \t  (*vS).w[j] = altivec_unsigned_saturate_32(temp, &tempsat);\n \t  sat |= tempsat;\n@@ -2312,7 +2312,7 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n \n 0.4,6.VS,11.0,16.VB,21.846:VX:av:vupkhpx %VD, %VB:Vector Unpack High Pixel16\n \tint i;\n-\tunsigned16 h;\n+\tuint16_t h;\n \tfor (i = 0; i < 4; i++) {\n \t  h = (*vB).h[AV_HINDEX(i)];\n \t  (*vS).w[i] = ((h & 0x8000) ? 0xff000000 : 0)\n@@ -2325,18 +2325,18 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n 0.4,6.VS,11.0,16.VB,21.526:VX:av:vupkhsb %VD, %VB:Vector Unpack High Signed Byte\n \tint i;\n \tfor (i = 0; i < 8; i++)\n-\t  (*vS).h[AV_HINDEX(i)] = (signed16)(signed8)(*vB).b[AV_BINDEX(i)];\n+\t  (*vS).h[AV_HINDEX(i)] = (int16_t)(int8_t)(*vB).b[AV_BINDEX(i)];\n \tPPC_INSN_VR(VS_BITMASK, VB_BITMASK);\n \n 0.4,6.VS,11.0,16.VB,21.590:VX:av:vupkhsh %VD, %VB:Vector Unpack High Signed Half Word\n \tint i;\n \tfor (i = 0; i < 4; i++)\n-\t  (*vS).w[i] = (signed32)(signed16)(*vB).h[AV_HINDEX(i)];\n+\t  (*vS).w[i] = (int32_t)(int16_t)(*vB).h[AV_HINDEX(i)];\n \tPPC_INSN_VR(VS_BITMASK, VB_BITMASK);\n \n 0.4,6.VS,11.0,16.VB,21.974:VX:av:vupklpx %VD, %VB:Vector Unpack Low Pixel16\n \tint i;\n-\tunsigned16 h;\n+\tuint16_t h;\n \tfor (i = 0; i < 4; i++) {\n \t  h = (*vB).h[AV_HINDEX(i + 4)];\n \t  (*vS).w[i] = ((h & 0x8000) ? 0xff000000 : 0)\n@@ -2349,11 +2349,11 @@ unsigned32::model-function::altivec_unsigned_saturate_32:signed64 val, int *sat\n 0.4,6.VS,11.0,16.VB,21.654:VX:av:vupklsb %VD, %VB:Vector Unpack Low Signed Byte\n \tint i;\n \tfor (i = 0; i < 8; i++)\n-\t  (*vS).h[AV_HINDEX(i)] = (signed16)(signed8)(*vB).b[AV_BINDEX(i + 8)];\n+\t  (*vS).h[AV_HINDEX(i)] = (int16_t)(int8_t)(*vB).b[AV_BINDEX(i + 8)];\n \tPPC_INSN_VR(VS_BITMASK, VB_BITMASK);\n \n 0.4,6.VS,11.0,16.VB,21.718:VX:av:vupklsh %VD, %VB:Vector Unpack Low Signed Half Word\n \tint i;\n \tfor (i = 0; i < 4; i++)\n-\t  (*vS).w[i] = (signed32)(signed16)(*vB).h[AV_HINDEX(i + 4)];\n+\t  (*vS).w[i] = (int32_t)(int16_t)(*vB).h[AV_HINDEX(i + 4)];\n \tPPC_INSN_VR(VS_BITMASK, VB_BITMASK);"
    },
    {
      "sha": "8e6a2db8ecc8ac26e235c95b0fbe2659764b113f",
      "filename": "sim/ppc/altivec_registers.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/altivec_registers.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/altivec_registers.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/altivec_registers.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -24,12 +24,12 @@\n    entities.  */\n typedef union\n {\n-  unsigned8 b[16];\n-  unsigned16 h[8];\n-  unsigned32 w[4];\n+  uint8_t b[16];\n+  uint16_t h[8];\n+  uint32_t w[4];\n } vreg;\n \n-typedef unsigned32 vscreg;\n+typedef uint32_t vscreg;\n \n struct altivec_regs {\n   /* AltiVec Registers */"
    },
    {
      "sha": "bf2f8f0d6e907f799e051db9a96b0911ebc993d9",
      "filename": "sim/ppc/bits.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/bits.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/bits.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/bits.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -24,8 +24,8 @@\n #include \"basics.h\"\n \n INLINE_BITS\\\n-(unsigned64)\n-LSMASKED64 (unsigned64 word,\n+(uint64_t)\n+LSMASKED64 (uint64_t word,\n \t    int start,\n \t    int stop)\n {\n@@ -34,8 +34,8 @@ LSMASKED64 (unsigned64 word,\n }\n \n INLINE_BITS\\\n-(unsigned64)\n-LSEXTRACTED64 (unsigned64 val,\n+(uint64_t)\n+LSEXTRACTED64 (uint64_t val,\n \t       int start,\n \t       int stop)\n {\n@@ -45,17 +45,17 @@ LSEXTRACTED64 (unsigned64 val,\n }\n  \n INLINE_BITS\\\n-(unsigned32)\n-MASKED32(unsigned32 word,\n+(uint32_t)\n+MASKED32(uint32_t word,\n \t unsigned start,\n \t unsigned stop)\n {\n   return (word & MASK32(start, stop));\n }\n \n INLINE_BITS\\\n-(unsigned64)\n-MASKED64(unsigned64 word,\n+(uint64_t)\n+MASKED64(uint64_t word,\n \t unsigned start,\n \t unsigned stop)\n {\n@@ -112,8 +112,8 @@ INSERTED(unsigned_word word,\n \n \n INLINE_BITS\\\n-(unsigned32)\n-ROTL32(unsigned32 val,\n+(uint32_t)\n+ROTL32(uint32_t val,\n        long shift)\n {\n   ASSERT(shift >= 0 && shift <= 32);\n@@ -122,8 +122,8 @@ ROTL32(unsigned32 val,\n \n \n INLINE_BITS\\\n-(unsigned64)\n-ROTL64(unsigned64 val,\n+(uint64_t)\n+ROTL64(uint64_t val,\n        long shift)\n {\n   ASSERT(shift >= 0 && shift <= 64);"
    },
    {
      "sha": "d08f8d59e64671f41afd64e793caf2a10ebc6ce1",
      "filename": "sim/ppc/bits.h",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/bits.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/bits.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/bits.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -108,7 +108,7 @@\n \n /* multi bit mask */\n #define _MASKn(WIDTH, START, STOP) \\\n-(((((unsigned##WIDTH)0) - 1) \\\n+(((((uint##WIDTH##_t)0) - 1) \\\n   >> (WIDTH - ((STOP) - (START) + 1))) \\\n  << (WIDTH - 1 - (STOP)))\n \n@@ -151,14 +151,14 @@\n /* mask the required bits, leaving them in place */\n \n INLINE_BITS\\\n-(unsigned32) MASKED32\n-(unsigned32 word,\n+(uint32_t) MASKED32\n+(uint32_t word,\n  unsigned start,\n  unsigned stop);\n \n INLINE_BITS\\\n-(unsigned64) MASKED64\n-(unsigned64 word,\n+(uint64_t) MASKED64\n+(uint64_t word,\n  unsigned start,\n  unsigned stop);\n \n@@ -169,8 +169,8 @@ INLINE_BITS\\\n  unsigned stop);\n \n INLINE_BITS\\\n-(unsigned64) LSMASKED64\n-(unsigned64 word,\n+(uint64_t) LSMASKED64\n+(uint64_t word,\n  int first,\n   int last);\n \n@@ -191,19 +191,19 @@ INLINE_BITS\\\n  unsigned stop);\n \n INLINE_BITS\\\n-(unsigned64) LSEXTRACTED64\n-(unsigned64 val,\n+(uint64_t) LSEXTRACTED64\n+(uint64_t val,\n  int start,\n  int stop);\n \n /* move a single bit around */\n /* NB: the wierdness (N>O?N-O:0) is to stop a warning from GCC */\n #define _SHUFFLEDn(N, WORD, OLD, NEW) \\\n ((OLD) < (NEW) \\\n- ? (((unsigned##N)(WORD) \\\n+ ? (((uint##N##_t)(WORD) \\\n      >> (((NEW) > (OLD)) ? ((NEW) - (OLD)) : 0)) \\\n     & MASK32((NEW), (NEW))) \\\n- : (((unsigned##N)(WORD) \\\n+ : (((uint##N##_t)(WORD) \\\n      << (((OLD) > (NEW)) ? ((OLD) - (NEW)) : 0)) \\\n     & MASK32((NEW), (NEW))))\n \n@@ -229,7 +229,7 @@ INLINE_BITS\\\n \n /* depending on MODE return a 64bit or 32bit (sign extended) value */\n #if (WITH_TARGET_WORD_BITSIZE == 64)\n-#define EXTENDED(X)     ((signed64)(signed32)(X))\n+#define EXTENDED(X)     ((int64_t)(int32_t)(X))\n #else\n #define EXTENDED(X)     (X)\n #endif\n@@ -270,13 +270,13 @@ do { \\\n (((VAL) << (SHIFT)) | ((VAL) >> ((N)-(SHIFT))))\n \n INLINE_BITS\\\n-(unsigned32) ROTL32\n-(unsigned32 val,\n+(uint32_t) ROTL32\n+(uint32_t val,\n  long shift);\n \n INLINE_BITS\\\n-(unsigned64) ROTL64\n-(unsigned64 val,\n+(uint64_t) ROTL64\n+(uint64_t val,\n  long shift);\n \n "
    },
    {
      "sha": "1b3eeef8b53c97307f5fb0ec3b557ae892d6c04a",
      "filename": "sim/ppc/corefile.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/corefile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/corefile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/corefile.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -227,7 +227,7 @@ core_attach(core *memory,\n   if (attach == attach_raw_memory) {\n     /* Padd out the raw buffer to ensure that ADDR starts on a\n        correctly aligned boundary */\n-    int padding = (addr % sizeof (unsigned64));\n+    int padding = (addr % sizeof (uint64_t));\n     free_buffer = zalloc(nr_bytes + padding);\n     buffer = (char*)free_buffer + padding;\n   }"
    },
    {
      "sha": "b89be03648b980a9a8a13d845ca0f8108f75782e",
      "filename": "sim/ppc/cpu.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/cpu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/cpu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/cpu.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -68,8 +68,8 @@ struct _cpu {\n   memory_reservation reservation;\n \n   /* offset from event time to this cpu's idea of the local time */\n-  signed64 time_base_local_time;\n-  signed64 decrementer_local_time;\n+  int64_t time_base_local_time;\n+  int64_t decrementer_local_time;\n   event_entry_tag decrementer_event;\n \n };\n@@ -229,7 +229,7 @@ cpu_error(cpu *processor,\n /* The processors local concept of time */\n \n INLINE_CPU\\\n-(signed64)\n+(int64_t)\n cpu_get_time_base(cpu *processor)\n {\n   return (event_queue_time(processor->events)\n@@ -239,14 +239,14 @@ cpu_get_time_base(cpu *processor)\n INLINE_CPU\\\n (void)\n cpu_set_time_base(cpu *processor,\n-\t\t  signed64 time_base)\n+\t\t  int64_t time_base)\n {\n   processor->time_base_local_time = (event_queue_time(processor->events)\n \t\t\t\t     - time_base);\n }\n \n INLINE_CPU\\\n-(signed32)\n+(int32_t)\n cpu_get_decrementer(cpu *processor)\n {\n   return (processor->decrementer_local_time\n@@ -265,9 +265,9 @@ cpu_decrement_event(void *data)\n INLINE_CPU\\\n (void)\n cpu_set_decrementer(cpu *processor,\n-\t\t    signed32 decrementer)\n+\t\t    int32_t decrementer)\n {\n-  signed64 old_decrementer = cpu_get_decrementer(processor);\n+  int64_t old_decrementer = cpu_get_decrementer(processor);\n   event_queue_deschedule(processor->events, processor->decrementer_event);\n   processor->decrementer_event = NULL;\n   processor->decrementer_local_time = (event_queue_time(processor->events)"
    },
    {
      "sha": "c7a087112710bf31b0c7f8f9e22348dbe3aaa8ae",
      "filename": "sim/ppc/cpu.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/cpu.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/cpu.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/cpu.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -120,22 +120,22 @@ EXTERN_CPU\\\n /* The processors local concept of time */\n \n INLINE_CPU\\\n-(signed64) cpu_get_time_base\n+(int64_t) cpu_get_time_base\n (cpu *processor);\n \n INLINE_CPU\\\n (void) cpu_set_time_base\n (cpu *processor,\n- signed64 time_base);\n+ int64_t time_base);\n \n INLINE_CPU\\\n-(signed32) cpu_get_decrementer\n+(int32_t) cpu_get_decrementer\n (cpu *processor);\n \n INLINE_CPU\\\n (void) cpu_set_decrementer\n (cpu *processor,\n- signed32 decrementer);\n+ int32_t decrementer);\n \n \n #if WITH_IDECODE_CACHE_SIZE"
    },
    {
      "sha": "4537e89b38dcf08e13958f4c41f74ae275e469cf",
      "filename": "sim/ppc/device.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/device.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/device.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/device.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -989,7 +989,7 @@ device_add_boolean_property(device *me,\n                             const char *property,\n                             int boolean)\n {\n-  signed32 new_boolean = (boolean ? -1 : 0);\n+  int32_t new_boolean = (boolean ? -1 : 0);\n   device_add_property(me, property, boolean_property,\n                       &new_boolean, sizeof(new_boolean),\n                       &new_boolean, sizeof(new_boolean),\n@@ -1879,7 +1879,7 @@ device_instance_to_external(device_instance *instance)\n INLINE_DEVICE\\\n (event_entry_tag)\n device_event_queue_schedule(device *me,\n-\t\t\t    signed64 delta_time,\n+\t\t\t    int64_t delta_time,\n \t\t\t    device_event_handler *handler,\n \t\t\t    void *data)\n {\n@@ -1899,7 +1899,7 @@ device_event_queue_deschedule(device *me,\n }\n \n INLINE_DEVICE\\\n-(signed64)\n+(int64_t)\n device_event_queue_time(device *me)\n {\n   return event_queue_time(psim_event_queue(me->system));"
    },
    {
      "sha": "bd5390951608eaea081671dea245dafcecbebc6b",
      "filename": "sim/ppc/device.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/device.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/device.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/device.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -780,7 +780,7 @@ typedef void device_event_handler(void *data);\n INLINE_DEVICE\\\n (event_entry_tag) device_event_queue_schedule\n (device *me,\n- signed64 delta_time,\n+ int64_t delta_time,\n  device_event_handler *handler,\n  void *data);\n \n@@ -790,7 +790,7 @@ INLINE_DEVICE\\\n  event_entry_tag event_to_remove);\n \n INLINE_DEVICE\\\n-(signed64) device_event_queue_time\n+(int64_t) device_event_queue_time\n (device *me);\n \n #endif /* _DEVICE_H_ */"
    },
    {
      "sha": "d52c4d27fc04e18b230b260018987a085a7188ac",
      "filename": "sim/ppc/double.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/double.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/double.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/double.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -24,16 +24,16 @@\n #include \"basics.h\"\n #include \"ansidecls.h\"\n \n-#define SFtype unsigned32\n-#define DFtype unsigned64\n+#define SFtype uint32_t\n+#define DFtype uint64_t\n \n-#define HItype signed16\n-#define SItype signed32\n-#define DItype signed64\n+#define HItype int16_t\n+#define SItype int32_t\n+#define DItype int64_t\n \n-#define UHItype unsigned16\n-#define USItype unsigned32\n-#define UDItype unsigned64\n+#define UHItype uint16_t\n+#define USItype uint32_t\n+#define UDItype uint64_t\n \n \n #define US_SOFTWARE_GOFAST"
    },
    {
      "sha": "dce18655a8e22a3509b59dd86ec4d57c2a2fd90d",
      "filename": "sim/ppc/e500.igen",
      "status": "modified",
      "additions": 637,
      "deletions": 637,
      "changes": 1274,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/e500.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/e500.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/e500.igen?ref=95e40d770e95c0d5317c2566a7976bd3421f380a"
    },
    {
      "sha": "1a27bb189e85f35047da3ae454d2ee9a1b78eb68",
      "filename": "sim/ppc/e500_expression.h",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/e500_expression.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/e500_expression.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/e500_expression.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -28,7 +28,7 @@\n #define EV_SET_REG4_ACC(sh, sl, h0, h1, h2, h3) do { \\\n \t(sh) = (((h0) & 0xffff) << 16) | ((h1) & 0xffff); \\\n \t(sl) = (((h2) & 0xffff) << 16) | ((h3) & 0xffff); \\\n-\tACC = ((unsigned64)(sh) << 32) | (sl & 0xffffffff); \\\n+\tACC = ((uint64_t)(sh) << 32) | (sl & 0xffffffff); \\\n } while (0)\n \n #define EV_SET_REG2(sh, sl, dh, dl) do { \\\n@@ -38,15 +38,15 @@\n #define EV_SET_REG2_ACC(sh, sl, dh, dl) do { \\\n \t(sh) = (dh) & 0xffffffff; \\\n \t(sl) = (dl) & 0xffffffff; \\\n-\tACC = ((unsigned64)(sh) << 32) | ((sl) & 0xffffffff); \\\n+\tACC = ((uint64_t)(sh) << 32) | ((sl) & 0xffffffff); \\\n } while (0)\n \n #define EV_SET_REG1(sh, sl, d) do { \\\n-\t(sh) = ((unsigned64)(d) >> 32) & 0xffffffff; \\\n+\t(sh) = ((uint64_t)(d) >> 32) & 0xffffffff; \\\n \t(sl) = (d) & 0xffffffff; \\\n } while (0)\n #define EV_SET_REG1_ACC(sh, sl, d) do { \\\n-\t(sh) = ((unsigned64)(d) >> 32) & 0xffffffff; \\\n+\t(sh) = ((uint64_t)(d) >> 32) & 0xffffffff; \\\n \t(sl) = (d) & 0xffffffff; \\\n \tACC = (d); \\\n } while (0)\n@@ -56,12 +56,12 @@\n } while (0)\n \n /* get the low or high half word of a word */\n-#define EV_LOHALF(x)\t((unsigned32)(x) & 0xffff)\n-#define EV_HIHALF(x)\t(((unsigned32)(x) >> 16) & 0xffff)\n+#define EV_LOHALF(x)\t((uint32_t)(x) & 0xffff)\n+#define EV_HIHALF(x)\t(((uint32_t)(x) >> 16) & 0xffff)\n \n /* partially visible accumulator accessors */\n #define EV_SET_ACC(rh, rl) \\\n-\tACC = ((unsigned64)(rh) << 32) | ((rl) & 0xffffffff)\n+\tACC = ((uint64_t)(rh) << 32) | ((rl) & 0xffffffff)\n \n #define EV_ACCLOW\t(ACC & 0xffffffff)\n #define EV_ACCHIGH\t((ACC >> 32) & 0xffffffff)\n@@ -86,11 +86,11 @@\n \t\t| (((x) & 0x8000) >> 15)\n \n /* saturation helpers */\n-#define EV_MUL16_SSF(a,b)\t((signed64)((signed32)(signed16)(a) * (signed32)(signed16)(b)) << 1)\n+#define EV_MUL16_SSF(a,b)\t((int64_t)((int32_t)(int16_t)(a) * (int32_t)(int16_t)(b)) << 1)\n /* this one loses the top sign bit; be careful */\n-#define EV_MUL32_SSF(a,b)\t(((signed64)(signed32)(a) * (signed64)(signed32)(b)) << 1)\n-#define EV_SAT_P_S32(x)\t\t((((signed64)(x)) < -0x80000000LL) || (((signed64)(x)) > 0x7fffffffLL))\n-#define EV_SAT_P_U32(x)\t\t((((signed64)(x)) < -0LL) || (((signed64)(x)) > 0xffffffffLL))\n+#define EV_MUL32_SSF(a,b)\t(((int64_t)(int32_t)(a) * (int64_t)(int32_t)(b)) << 1)\n+#define EV_SAT_P_S32(x)\t\t((((int64_t)(x)) < -0x80000000LL) || (((int64_t)(x)) > 0x7fffffffLL))\n+#define EV_SAT_P_U32(x)\t\t((((int64_t)(x)) < -0LL) || (((int64_t)(x)) > 0xffffffffLL))\n \n #define EV_SATURATE(flag, sat_val, val) \\\n \t((flag) ? (sat_val) : (val))\n@@ -116,7 +116,7 @@\n   EV_SET_SPEFSCR(SPREG(spr_spefscr) | (s))\n \n #define EV_SET_SPEFSCR_OV(l,h) do { \\\n-\tunsigned32 _sPefScR = SPREG(spr_spefscr); \\\n+\tuint32_t _sPefScR = SPREG(spr_spefscr); \\\n \tif (l) \\\n \t  _sPefScR |= spefscr_ov | spefscr_sov; \\\n \telse \\"
    },
    {
      "sha": "d02bcc9ff352296dbe0052a98f4f2cf1c4cc4383",
      "filename": "sim/ppc/e500_registers.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/e500_registers.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/e500_registers.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/e500_registers.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -22,7 +22,7 @@\n \n /* e500 accumulator.  */\n \n-typedef unsigned64 accreg;\n+typedef uint64_t accreg;\n \n enum {\n   msr_e500_spu_enable = BIT(38)\n@@ -81,4 +81,4 @@ struct e500_regs {\n    We need to cast the gpr value to an unsigned type so that it\n    doesn't get sign-extended when it's or-ed with a 64-bit value; that\n    would wipe out the upper 32 bits of the register's value.  */\n-#define EVR(N)\t\t((((unsigned64)GPRH(N)) << 32) | (unsigned32) GPR(N))\n+#define EVR(N)\t\t((((uint64_t)GPRH(N)) << 32) | (uint32_t) GPR(N))"
    },
    {
      "sha": "a72a34e85287baafdcebd3fe796d92d5f886468e",
      "filename": "sim/ppc/emul_chirp.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_chirp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_chirp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/emul_chirp.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -1381,7 +1381,7 @@ chirp_emul_milliseconds(os_emul_data *data,\n     /*out*/\n     unsigned_cell ms;\n   } args;\n-  unsigned64 time;\n+  uint64_t time;\n   /* read in the arguments */\n   if (chirp_read_t2h_args(&args, sizeof(args), 1, 1, data, processor, cia))\n     return -1;\n@@ -1465,12 +1465,12 @@ static chirp_services services[] = {\n \n \n typedef struct _chirp_note_desc {\n-  signed32 real_mode;\n-  signed32 real_base;\n-  signed32 real_size;\n-  signed32 virt_base;\n-  signed32 virt_size;\n-  signed32 load_base;\n+  int32_t real_mode;\n+  int32_t real_base;\n+  int32_t real_size;\n+  int32_t virt_base;\n+  int32_t virt_size;\n+  int32_t load_base;\n } chirp_note_desc;\n \n typedef enum {\n@@ -1484,9 +1484,9 @@ typedef struct _chirp_note {\n } chirp_note;\n \n typedef struct _chirp_note_head {\n-  unsigned32 namesz;\n-  unsigned32 descsz;\n-  unsigned32 type;\n+  uint32_t namesz;\n+  uint32_t descsz;\n+  uint32_t type;\n } chirp_note_head;\n \n static void\n@@ -1519,7 +1519,7 @@ map_over_chirp_note(bfd *image,\n       printf_filtered(\"chirp: note name (%s) not `PowerPC'\\n\", name);\n     }\n     /* check the size */\n-    if (head.descsz == sizeof(note->desc) - sizeof(signed32)) {\n+    if (head.descsz == sizeof(note->desc) - sizeof(int32_t)) {\n       sim_io_printf_filtered(\"chirp: note descriptor missing load-base\\n\");\n     }\n     else if (head.descsz != sizeof(note->desc)) {\n@@ -1543,7 +1543,7 @@ map_over_chirp_note(bfd *image,\n     if (head.descsz == sizeof(note->desc))\n       note->desc.load_base = bfd_get_32(image, (void*)&note->desc.load_base);\n     else\n-      note->desc.load_base = (signed32)-1;\n+      note->desc.load_base = (int32_t)-1;\n   }\n }\n \n@@ -1648,7 +1648,7 @@ emul_chirp_create(device *root,\n \n   /* resolve real-base */\n   if (note.found == note_correct\n-      && note.desc.real_base != (signed32)-1)\n+      && note.desc.real_base != (int32_t)-1)\n     chirp->real_base = note.desc.real_base;\n   else if (tree_find_property(root, \"/options/real-base\") != NULL)\n     chirp->real_base = tree_find_integer_property(root, \"/options/real-base\");\n@@ -1664,7 +1664,7 @@ emul_chirp_create(device *root,\n \n   /* resolve real-size */\n   if (note.found == note_correct\n-      && note.desc.real_size != (signed32)-1\n+      && note.desc.real_size != (int32_t)-1\n       && note.desc.real_size != 0\n       && chirp->real_size > note.desc.real_size)\n     error(\"chirp: insufficient physical memory for firmware\\n\");\n@@ -1697,7 +1697,7 @@ emul_chirp_create(device *root,\n   /* resolve virt-size */\n   chirp->virt_size = chirp->real_size;\n   if (note.found == note_correct\n-     && note.desc.virt_size != (signed32)-1\n+     && note.desc.virt_size != (int32_t)-1\n       && note.desc.virt_size != 0\n       && !chirp->real_mode\n       && chirp->virt_size > note.desc.virt_size)\n@@ -1712,7 +1712,7 @@ emul_chirp_create(device *root,\n \n   /* resolve load-base */\n   if (note.found == note_correct\n-      && note.desc.load_base != (signed32)-1)\n+      && note.desc.load_base != (int32_t)-1)\n     chirp->load_base = note.desc.load_base;\n   else if (tree_find_property(root, \"/options/load-base\") != NULL)\n     chirp->load_base = tree_find_integer_property(root, \"/options/load-base\");"
    },
    {
      "sha": "031973008fa1936434e2dd0b6364951d99738654",
      "filename": "sim/ppc/emul_generic.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_generic.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_generic.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/emul_generic.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -58,12 +58,12 @@ emul_syscall_exit(emul_syscall *emul,\n }\n \n \n-INLINE_EMUL_GENERIC unsigned64\n+INLINE_EMUL_GENERIC uint64_t\n emul_read_gpr64(cpu *processor,\n \t\tint g)\n {\n-  unsigned32 hi;\n-  unsigned32 lo;\n+  uint32_t hi;\n+  uint32_t lo;\n   if (CURRENT_TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) {\n     hi = cpu_registers(processor)->gpr[g];\n     lo = cpu_registers(processor)->gpr[g+1];\n@@ -79,10 +79,10 @@ emul_read_gpr64(cpu *processor,\n INLINE_EMUL_GENERIC void\n emul_write_gpr64(cpu *processor,\n \t\t int g,\n-\t\t unsigned64 val)\n+\t\t uint64_t val)\n {\n-  unsigned32 hi = EXTRACTED64(val, 0, 31);\n-  unsigned32 lo = EXTRACTED64(val, 32, 63);\n+  uint32_t hi = EXTRACTED64(val, 0, 31);\n+  uint32_t lo = EXTRACTED64(val, 32, 63);\n   if (CURRENT_TARGET_BYTE_ORDER == BFD_ENDIAN_BIG) {\n     cpu_registers(processor)->gpr[g] = hi;\n     cpu_registers(processor)->gpr[g+1] = lo;"
    },
    {
      "sha": "81fcb51019a266017b2658fecd13fd8ef59f6cf9",
      "filename": "sim/ppc/emul_generic.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_generic.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_generic.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/emul_generic.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -111,14 +111,14 @@ INLINE_EMUL_GENERIC void emul_do_system_call\n  unsigned_word cia);\n \n \n-INLINE_EMUL_GENERIC unsigned64 emul_read_gpr64\n+INLINE_EMUL_GENERIC uint64_t emul_read_gpr64\n (cpu *processor,\n  int g);\n \n INLINE_EMUL_GENERIC void emul_write_gpr64\n (cpu *processor,\n  int g,\n- unsigned64 val);\n+ uint64_t val);\n \n INLINE_EMUL_GENERIC void emul_write_status\n (cpu *processor,"
    },
    {
      "sha": "57691d4befcd3bb0e3225c66f006b4c0d11376ac",
      "filename": "sim/ppc/emul_unix.c",
      "status": "modified",
      "additions": 77,
      "deletions": 77,
      "changes": 154,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_unix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/emul_unix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/emul_unix.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -150,13 +150,13 @@ struct _os_emul_data {\n \n /* Structures that are common agmonst the UNIX varients */\n struct unix_timeval {\n-  signed32 tv_sec;\t\t/* seconds */\n-  signed32 tv_usec;\t\t/* microseconds */\n+  int32_t tv_sec;\t\t/* seconds */\n+  int32_t tv_usec;\t\t/* microseconds */\n };\n \n struct unix_timezone {\n-  signed32 tz_minuteswest;\t/* minutes west of Greenwich */\n-  signed32 tz_dsttime;\t\t/* type of dst correction */\n+  int32_t tz_minuteswest;\t/* minutes west of Greenwich */\n+  int32_t tz_dsttime;\t\t/* type of dst correction */\n };\n \n #define\tUNIX_RUSAGE_SELF\t0\n@@ -166,20 +166,20 @@ struct unix_timezone {\n struct\tunix_rusage {\n \tstruct unix_timeval ru_utime;\t/* user time used */\n \tstruct unix_timeval ru_stime;\t/* system time used */\n-\tsigned32 ru_maxrss;\t\t/* maximum resident set size */\n-\tsigned32 ru_ixrss;\t\t/* integral shared memory size */\n-\tsigned32 ru_idrss;\t\t/* integral unshared data size */\n-\tsigned32 ru_isrss;\t\t/* integral unshared stack size */\n-\tsigned32 ru_minflt;\t\t/* any page faults not requiring I/O */\n-\tsigned32 ru_majflt;\t\t/* any page faults requiring I/O */\n-\tsigned32 ru_nswap;\t\t/* swaps */\n-\tsigned32 ru_inblock;\t\t/* block input operations */\n-\tsigned32 ru_oublock;\t\t/* block output operations */\n-\tsigned32 ru_msgsnd;\t\t/* messages sent */\n-\tsigned32 ru_msgrcv;\t\t/* messages received */\n-\tsigned32 ru_nsignals;\t\t/* signals received */\n-\tsigned32 ru_nvcsw;\t\t/* voluntary context switches */\n-\tsigned32 ru_nivcsw;\t\t/* involuntary \" */\n+\tint32_t ru_maxrss;\t\t/* maximum resident set size */\n+\tint32_t ru_ixrss;\t\t/* integral shared memory size */\n+\tint32_t ru_idrss;\t\t/* integral unshared data size */\n+\tint32_t ru_isrss;\t\t/* integral unshared stack size */\n+\tint32_t ru_minflt;\t\t/* any page faults not requiring I/O */\n+\tint32_t ru_majflt;\t\t/* any page faults requiring I/O */\n+\tint32_t ru_nswap;\t\t/* swaps */\n+\tint32_t ru_inblock;\t\t/* block input operations */\n+\tint32_t ru_oublock;\t\t/* block output operations */\n+\tint32_t ru_msgsnd;\t\t/* messages sent */\n+\tint32_t ru_msgrcv;\t\t/* messages received */\n+\tint32_t ru_nsignals;\t\t/* signals received */\n+\tint32_t ru_nvcsw;\t\t/* voluntary context switches */\n+\tint32_t ru_nivcsw;\t\t/* involuntary \" */\n };\n \n \n@@ -1051,15 +1051,15 @@ emul_unix_create(device *root,\n \n /* Solaris specific implementation */\n \n-typedef\tsigned32\tsolaris_uid_t;\n-typedef\tsigned32\tsolaris_gid_t;\n-typedef signed32\tsolaris_off_t;\n-typedef signed32\tsolaris_pid_t;\n-typedef signed32\tsolaris_time_t;\n-typedef unsigned32\tsolaris_dev_t;\n-typedef unsigned32\tsolaris_ino_t;\n-typedef unsigned32\tsolaris_mode_t;\n-typedef\tunsigned32\tsolaris_nlink_t;\n+typedef\tint32_t\tsolaris_uid_t;\n+typedef\tint32_t\tsolaris_gid_t;\n+typedef int32_t\tsolaris_off_t;\n+typedef int32_t\tsolaris_pid_t;\n+typedef int32_t\tsolaris_time_t;\n+typedef uint32_t\tsolaris_dev_t;\n+typedef uint32_t\tsolaris_ino_t;\n+typedef uint32_t\tsolaris_mode_t;\n+typedef\tuint32_t\tsolaris_nlink_t;\n \n #ifdef HAVE_SYS_STAT_H\n #define\tSOLARIS_ST_FSTYPSZ 16\t\t/* array size for file system type name */\n@@ -1071,23 +1071,23 @@ typedef\tunsigned32\tsolaris_nlink_t;\n \n struct solaris_stat {\n   solaris_dev_t\t\tst_dev;\n-  signed32\t\tst_pad1[3];\t/* reserved for network id */\n+  int32_t\t\tst_pad1[3];\t/* reserved for network id */\n   solaris_ino_t\t\tst_ino;\n   solaris_mode_t\tst_mode;\n   solaris_nlink_t \tst_nlink;\n   solaris_uid_t \tst_uid;\n   solaris_gid_t \tst_gid;\n   solaris_dev_t\t\tst_rdev;\n-  signed32\t\tst_pad2[2];\n+  int32_t\t\tst_pad2[2];\n   solaris_off_t\t\tst_size;\n-  signed32\t\tst_pad3;\t/* future off_t expansion */\n+  int32_t\t\tst_pad3;\t/* future off_t expansion */\n   struct unix_timeval\tst_atim;\n   struct unix_timeval\tst_mtim;\n   struct unix_timeval\tst_ctim;\n-  signed32\t\tst_blksize;\n-  signed32\t\tst_blocks;\n+  int32_t\t\tst_blksize;\n+  int32_t\t\tst_blocks;\n   char\t\t\tst_fstype[SOLARIS_ST_FSTYPSZ];\n-  signed32\t\tst_pad4[8];\t/* expansion area */\n+  int32_t\t\tst_pad4[8];\t/* expansion area */\n };\n \n /* Convert from host stat structure to solaris stat structure */\n@@ -1264,12 +1264,12 @@ do_solaris_fstat(os_emul_data *emul,\n /* Convert to/from host termio structure */\n \n struct solaris_termio {\n-\tunsigned16\tc_iflag;\t\t/* input modes */\n-\tunsigned16\tc_oflag;\t\t/* output modes */\n-\tunsigned16\tc_cflag;\t\t/* control modes */\n-\tunsigned16\tc_lflag;\t\t/* line discipline modes */\n-\tunsigned8\tc_line;\t\t\t/* line discipline */\n-\tunsigned8\tc_cc[SOLARIS_NCC];\t/* control chars */\n+\tuint16_t\tc_iflag;\t\t/* input modes */\n+\tuint16_t\tc_oflag;\t\t/* output modes */\n+\tuint16_t\tc_cflag;\t\t/* control modes */\n+\tuint16_t\tc_lflag;\t\t/* line discipline modes */\n+\tuint8_t\tc_line;\t\t\t/* line discipline */\n+\tuint8_t\tc_cc[SOLARIS_NCC];\t/* control chars */\n };\n \n STATIC_INLINE_EMUL_UNIX void\n@@ -1339,9 +1339,9 @@ convert_to_solaris_termio(unsigned_word addr,\n #ifdef HAVE_TERMIOS_STRUCTURE\n /* Convert to/from host termios structure */\n \n-typedef unsigned32 solaris_tcflag_t;\n-typedef unsigned8  solaris_cc_t;\n-typedef unsigned32 solaris_speed_t;\n+typedef uint32_t solaris_tcflag_t;\n+typedef uint8_t  solaris_cc_t;\n+typedef uint32_t solaris_speed_t;\n \n struct solaris_termios {\n   solaris_tcflag_t\tc_iflag;\n@@ -2002,20 +2002,20 @@ const os_emul emul_solaris = {\n \n /* Linux specific implementation */\n \n-typedef unsigned32\tlinux_dev_t;\n-typedef unsigned32\tlinux_ino_t;\n-typedef unsigned32\tlinux_mode_t;\n-typedef unsigned16\tlinux_nlink_t;\n-typedef signed32\tlinux_off_t;\n-typedef signed32\tlinux_pid_t;\n-typedef unsigned32\tlinux_uid_t;\n-typedef unsigned32\tlinux_gid_t;\n-typedef unsigned32\tlinux_size_t;\n-typedef signed32\tlinux_ssize_t;\n-typedef signed32\tlinux_ptrdiff_t;\n-typedef signed32\tlinux_time_t;\n-typedef signed32\tlinux_clock_t;\n-typedef signed32\tlinux_daddr_t;\n+typedef uint32_t\tlinux_dev_t;\n+typedef uint32_t\tlinux_ino_t;\n+typedef uint32_t\tlinux_mode_t;\n+typedef uint16_t\tlinux_nlink_t;\n+typedef int32_t\tlinux_off_t;\n+typedef int32_t\tlinux_pid_t;\n+typedef uint32_t\tlinux_uid_t;\n+typedef uint32_t\tlinux_gid_t;\n+typedef uint32_t\tlinux_size_t;\n+typedef int32_t\tlinux_ssize_t;\n+typedef int32_t\tlinux_ptrdiff_t;\n+typedef int32_t\tlinux_time_t;\n+typedef int32_t\tlinux_clock_t;\n+typedef int32_t\tlinux_daddr_t;\n \n #ifdef HAVE_SYS_STAT_H\n /* For the PowerPC, don't both with the 'old' stat structure, since there\n@@ -2030,16 +2030,16 @@ struct linux_stat {\n \tlinux_gid_t \tst_gid;\n \tlinux_dev_t\tst_rdev;\n \tlinux_off_t\tst_size;\n-\tunsigned32  \tst_blksize;\n-\tunsigned32  \tst_blocks;\n-\tunsigned32  \tst_atimx;\t/* don't use st_{a,c,m}time, that might a macro */\n-\tunsigned32  \t__unused1;\t/* defined by the host's stat.h */\n-\tunsigned32  \tst_mtimx;\n-\tunsigned32  \t__unused2;\n-\tunsigned32  \tst_ctimx;\n-\tunsigned32  \t__unused3;\n-\tunsigned32  \t__unused4;\n-\tunsigned32  \t__unused5;\n+\tuint32_t  \tst_blksize;\n+\tuint32_t  \tst_blocks;\n+\tuint32_t  \tst_atimx;\t/* don't use st_{a,c,m}time, that might a macro */\n+\tuint32_t  \t__unused1;\t/* defined by the host's stat.h */\n+\tuint32_t  \tst_mtimx;\n+\tuint32_t  \t__unused2;\n+\tuint32_t  \tst_ctimx;\n+\tuint32_t  \t__unused3;\n+\tuint32_t  \t__unused4;\n+\tuint32_t  \t__unused5;\n };\n \n /* Convert from host stat structure to solaris stat structure */\n@@ -2237,12 +2237,12 @@ do_linux_fstat(os_emul_data *emul,\n /* Convert to/from host termio structure */\n \n struct linux_termio {\n-\tunsigned16\tc_iflag;\t\t/* input modes */\n-\tunsigned16\tc_oflag;\t\t/* output modes */\n-\tunsigned16\tc_cflag;\t\t/* control modes */\n-\tunsigned16\tc_lflag;\t\t/* line discipline modes */\n-\tunsigned8\tc_line;\t\t\t/* line discipline */\n-\tunsigned8\tc_cc[LINUX_NCC];\t/* control chars */\n+\tuint16_t\tc_iflag;\t\t/* input modes */\n+\tuint16_t\tc_oflag;\t\t/* output modes */\n+\tuint16_t\tc_cflag;\t\t/* control modes */\n+\tuint16_t\tc_lflag;\t\t/* line discipline modes */\n+\tuint8_t\tc_line;\t\t\t/* line discipline */\n+\tuint8_t\tc_cc[LINUX_NCC];\t/* control chars */\n };\n \n STATIC_INLINE_EMUL_UNIX void\n@@ -2319,9 +2319,9 @@ convert_to_linux_termio(unsigned_word addr,\n #ifdef HAVE_TERMIOS_STRUCTURE\n /* Convert to/from host termios structure */\n \n-typedef unsigned32 linux_tcflag_t;\n-typedef unsigned8  linux_cc_t;\n-typedef unsigned32 linux_speed_t;\n+typedef uint32_t linux_tcflag_t;\n+typedef uint8_t  linux_cc_t;\n+typedef uint32_t linux_speed_t;\n \n struct linux_termios {\n   linux_tcflag_t\tc_iflag;\n@@ -2330,8 +2330,8 @@ struct linux_termios {\n   linux_tcflag_t\tc_lflag;\n   linux_cc_t\t\tc_cc[LINUX_NCCS];\n   linux_cc_t\t\tc_line;\n-  signed32\t\tc_ispeed;\n-  signed32\t\tc_ospeed;\n+  int32_t\t\tc_ispeed;\n+  int32_t\t\tc_ospeed;\n };\n \n STATIC_INLINE_EMUL_UNIX void"
    },
    {
      "sha": "f281e973329be8ee971d9d9291d225e25cdca5d3",
      "filename": "sim/ppc/events.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/events.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/events.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/events.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -55,7 +55,7 @@ typedef struct _event_entry event_entry;\n struct _event_entry {\n   void *data;\n   event_handler *handler;\n-  signed64 time_of_event;  \n+  int64_t time_of_event;  \n   event_entry *next;\n };\n \n@@ -64,8 +64,8 @@ struct _event_queue {\n   event_entry *queue;\n   event_entry *volatile held;\n   event_entry *volatile *volatile held_end;\n-  signed64 time_of_event;\n-  signed64 time_from_event;\n+  int64_t time_of_event;\n+  int64_t time_from_event;\n };\n \n \n@@ -142,7 +142,7 @@ event_queue_init(event_queue *queue)\n }\n \n INLINE_EVENTS\\\n-(signed64)\n+(int64_t)\n event_queue_time(event_queue *queue)\n {\n   return queue->time_of_event - queue->time_from_event;\n@@ -152,7 +152,7 @@ STATIC_INLINE_EVENTS\\\n (void)\n update_time_from_event(event_queue *events)\n {\n-  signed64 current_time = event_queue_time(events);\n+  int64_t current_time = event_queue_time(events);\n   if (events->queue != NULL) {\n     events->time_from_event = (events->queue->time_of_event - current_time);\n     events->time_of_event = events->queue->time_of_event;\n@@ -186,11 +186,11 @@ STATIC_INLINE_EVENTS\\\n (void)\n insert_event_entry(event_queue *events,\n \t\t   event_entry *new_event,\n-\t\t   signed64 delta)\n+\t\t   int64_t delta)\n {\n   event_entry *curr;\n   event_entry **prev;\n-  signed64 time_of_event;\n+  int64_t time_of_event;\n \n   if (delta < 0)\n     error(\"what is past is past!\\n\");\n@@ -221,7 +221,7 @@ insert_event_entry(event_queue *events,\n INLINE_EVENTS\\\n (event_entry_tag)\n event_queue_schedule(event_queue *events,\n-\t\t     signed64 delta_time,\n+\t\t     int64_t delta_time,\n \t\t     event_handler *handler,\n \t\t     void *data)\n {\n@@ -242,7 +242,7 @@ event_queue_schedule(event_queue *events,\n INLINE_EVENTS\\\n (event_entry_tag)\n event_queue_schedule_after_signal(event_queue *events,\n-\t\t\t\t  signed64 delta_time,\n+\t\t\t\t  int64_t delta_time,\n \t\t\t\t  event_handler *handler,\n \t\t\t\t  void *data)\n {\n@@ -323,7 +323,7 @@ INLINE_EVENTS\\\n (int)\n event_queue_tick(event_queue *events)\n {\n-  signed64 time_from_event;\n+  int64_t time_from_event;\n \n   /* we should only be here when the previous tick has been fully processed */\n   ASSERT(!events->processing);\n@@ -372,7 +372,7 @@ INLINE_EVENTS\\\n (void)\n event_queue_process(event_queue *events)\n {\n-  signed64 event_time = event_queue_time(events);\n+  int64_t event_time = event_queue_time(events);\n \n   ASSERT((events->time_from_event == -1 && events->queue != NULL)\n \t || events->processing); /* something to do */"
    },
    {
      "sha": "2a78d6ff00ff67037af71e31556937c6045769f7",
      "filename": "sim/ppc/events.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/events.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/events.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/events.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -40,14 +40,14 @@ INLINE_EVENTS\\\n INLINE_EVENTS\\\n (event_entry_tag) event_queue_schedule\n (event_queue *queue,\n- signed64 delta_time,\n+ int64_t delta_time,\n  event_handler *handler,\n  void *data);\n \n INLINE_EVENTS\\\n (event_entry_tag) event_queue_schedule_after_signal\n (event_queue *queue,\n- signed64 delta_time,\n+ int64_t delta_time,\n  event_handler *handler,\n  void *data);\n \n@@ -72,7 +72,7 @@ INLINE_EVENTS\\\n /* local concept of time */\n \n INLINE_EVENTS\\\n-(signed64) event_queue_time\n+(int64_t) event_queue_time\n (event_queue *queue);\n \n #endif /* _EVENTS_H_ */"
    },
    {
      "sha": "3a825202784da07f0993398a81c7d9e536783c4f",
      "filename": "sim/ppc/hw_disk.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_disk.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_disk.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_disk.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -412,9 +412,9 @@ hw_disk_instance_seek(device_instance *instance,\n static int\n hw_disk_max_transfer(device_instance *instance,\n \t\t     int n_stack_args,\n-\t\t     unsigned32 stack_args[/*n_stack_args*/],\n+\t\t     uint32_t stack_args[/*n_stack_args*/],\n \t\t     int n_stack_returns,\n-\t\t     unsigned32 stack_returns[/*n_stack_returns*/])\n+\t\t     uint32_t stack_returns[/*n_stack_returns*/])\n {\n   device *me = device_instance_device(instance);\n   if ((n_stack_args != 0)\n@@ -439,9 +439,9 @@ hw_disk_max_transfer(device_instance *instance,\n static int\n hw_disk_block_size(device_instance *instance,\n \t\t   int n_stack_args,\n-\t\t   unsigned32 stack_args[/*n_stack_args*/],\n+\t\t   uint32_t stack_args[/*n_stack_args*/],\n \t\t   int n_stack_returns,\n-\t\t   unsigned32 stack_returns[/*n_stack_returns*/])\n+\t\t   uint32_t stack_returns[/*n_stack_returns*/])\n {\n   device *me = device_instance_device(instance);\n   if ((n_stack_args != 0)\n@@ -466,9 +466,9 @@ hw_disk_block_size(device_instance *instance,\n static int\n hw_disk_nr_blocks(device_instance *instance,\n \t\t  int n_stack_args,\n-\t\t  unsigned32 stack_args[/*n_stack_args*/],\n+\t\t  uint32_t stack_args[/*n_stack_args*/],\n \t\t  int n_stack_returns,\n-\t\t  unsigned32 stack_returns[/*n_stack_returns*/])\n+\t\t  uint32_t stack_returns[/*n_stack_returns*/])\n {\n   device *me = device_instance_device(instance);\n   if ((n_stack_args != 0)"
    },
    {
      "sha": "2bbcd77773d1293b7fea19ef183257bf7af320d6",
      "filename": "sim/ppc/hw_eeprom.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_eeprom.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_eeprom.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_eeprom.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -178,33 +178,33 @@ state2a(hw_eeprom_states state)\n typedef struct _hw_eeprom_device {\n   /* general */\n   hw_eeprom_states state;\n-  unsigned8 *memory;\n+  uint8_t *memory;\n   unsigned sizeof_memory;\n   unsigned erase_delay;\n-  signed64 program_start_time;\n-  signed64 program_finish_time;\n-  unsigned8 manufacture_code;\n-  unsigned8 device_code;\n-  unsigned8 toggle_bit;\n+  int64_t program_start_time;\n+  int64_t program_finish_time;\n+  uint8_t manufacture_code;\n+  uint8_t device_code;\n+  uint8_t toggle_bit;\n   /* initialization */\n   const char *input_file_name;\n   const char *output_file_name;\n   /* for sector and sector programming */\n   hw_eeprom_states sector_state;\n-  unsigned8 *sectors;\n+  uint8_t *sectors;\n   unsigned nr_sectors;\n   unsigned sizeof_sector;\n   unsigned sector_start_delay;\n   unsigned sector_start_time;\n   /* byte and byte programming */\n   unsigned byte_write_delay;\n   unsigned_word byte_program_address;\n-  unsigned8 byte_program_byte;\n+  uint8_t byte_program_byte;\n } hw_eeprom_device;\n \n typedef struct _hw_eeprom_reg_spec {\n-  unsigned32 base;\n-  unsigned32 size;\n+  uint32_t base;\n+  uint32_t size;\n } hw_eeprom_reg_spec;\n \n static void\n@@ -275,7 +275,7 @@ static void\n invalid_write(device *me,\n \t      hw_eeprom_states state,\n \t      unsigned_word address,\n-\t      unsigned8 data,\n+\t      uint8_t data,\n \t      const char *reason)\n {\n   DTRACE(eeprom, (\"Invalid write of 0x%lx to 0x%lx while in state %s (%s)\\n\",\n@@ -312,9 +312,9 @@ static void\n start_programming_byte(device *me,\n \t\t       hw_eeprom_device *eeprom,\n \t\t       unsigned_word address,\n-\t\t       unsigned8 new_byte)\n+\t\t       uint8_t new_byte)\n {\n-  unsigned8 old_byte = eeprom->memory[address];\n+  uint8_t old_byte = eeprom->memory[address];\n   DTRACE(eeprom, (\"start-programing-byte - address 0x%lx, new 0x%lx, old 0x%lx\\n\",\n \t\t  (unsigned long)address,\n \t\t  (unsigned long)new_byte,\n@@ -415,15 +415,15 @@ finish_erasing_sector(device *me,\n \n /* eeprom reads */\n \n-static unsigned8\n+static uint8_t\n toggle(hw_eeprom_device *eeprom,\n-       unsigned8 byte)\n+       uint8_t byte)\n {\n   eeprom->toggle_bit = eeprom->toggle_bit ^ 0x40; /* le-bit 6 */\n   return eeprom->toggle_bit ^ byte;\n }\n \n-static unsigned8\n+static uint8_t\n read_byte(device *me,\n \t  hw_eeprom_device *eeprom,\n \t  unsigned_word address)\n@@ -519,8 +519,8 @@ hw_eeprom_io_read_buffer(device *me,\n   int i;\n   for (i = 0; i < nr_bytes; i++) {\n     unsigned_word address = (addr + i) % eeprom->sizeof_memory;\n-    unsigned8 byte = read_byte(me, eeprom, address);\n-    ((unsigned8*)dest)[i] = byte;\n+    uint8_t byte = read_byte(me, eeprom, address);\n+    ((uint8_t*)dest)[i] = byte;\n   }\n   return nr_bytes;\n }\n@@ -532,7 +532,7 @@ static void\n write_byte(device *me,\n \t   hw_eeprom_device *eeprom,\n \t   unsigned_word address,\n-\t   unsigned8 data)\n+\t   uint8_t data)\n {\n   /* may need multiple transitions to process a write */\n   while (1) {\n@@ -709,7 +709,7 @@ hw_eeprom_io_write_buffer(device *me,\n   int i;\n   for (i = 0; i < nr_bytes; i++) {\n     unsigned_word address = (addr + i) % eeprom->sizeof_memory;\n-    unsigned8 byte = ((unsigned8*)source)[i];\n+    uint8_t byte = ((uint8_t*)source)[i];\n     write_byte(me, eeprom, address, byte);\n   }\n   return nr_bytes;\n@@ -741,7 +741,7 @@ hw_eeprom_instance_read(device_instance *instance,\n   if (data->eeprom->state != read_reset)\n     DITRACE(eeprom, (\"eeprom not idle during instance read\\n\"));\n   for (i = 0; i < len; i++) {\n-    ((unsigned8*)buf)[i] = data->eeprom->memory[data->pos];\n+    ((uint8_t*)buf)[i] = data->eeprom->memory[data->pos];\n     data->pos = (data->pos + 1) % data->eeprom->sizeof_memory;\n   }\n   return len;\n@@ -757,7 +757,7 @@ hw_eeprom_instance_write(device_instance *instance,\n   if (data->eeprom->state != read_reset)\n     DITRACE(eeprom, (\"eeprom not idle during instance write\\n\"));\n   for (i = 0; i < len; i++) {\n-    data->eeprom->memory[data->pos] = ((unsigned8*)buf)[i];\n+    data->eeprom->memory[data->pos] = ((uint8_t*)buf)[i];\n     data->pos = (data->pos + 1) % data->eeprom->sizeof_memory;\n   }\n   dump_eeprom(data->me, data->eeprom);"
    },
    {
      "sha": "ce098341c82d77f802425b03dcce59fbdd06fc56",
      "filename": "sim/ppc/hw_htab.c",
      "status": "modified",
      "additions": 33,
      "deletions": 33,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_htab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_htab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_htab.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -204,8 +204,8 @@\n \n static void\n htab_decode_hash_table(device *me,\n-\t\t       unsigned32 *htaborg,\n-\t\t       unsigned32 *htabmask)\n+\t\t       uint32_t *htaborg,\n+\t\t       uint32_t *htabmask)\n {\n   unsigned_word htab_ra;\n   unsigned htab_nr_bytes;\n@@ -242,27 +242,27 @@ htab_decode_hash_table(device *me,\n static void\n htab_map_page(device *me,\n \t      unsigned_word ra,\n-\t      unsigned64 va,\n+\t      uint64_t va,\n \t      unsigned wimg,\n \t      unsigned pp,\n-\t      unsigned32 htaborg,\n-\t      unsigned32 htabmask)\n+\t      uint32_t htaborg,\n+\t      uint32_t htabmask)\n {\n   /* keep everything left shifted so that the numbering is easier */\n-  unsigned64 vpn = va << 12;\n-  unsigned32 vsid = INSERTED32(EXTRACTED64(vpn, 0, 23), 0, 23);\n-  unsigned32 vpage = INSERTED32(EXTRACTED64(vpn, 24, 39), 0, 15);\n-  unsigned32 hash = INSERTED32(EXTRACTED32(vsid, 5, 23)\n+  uint64_t vpn = va << 12;\n+  uint32_t vsid = INSERTED32(EXTRACTED64(vpn, 0, 23), 0, 23);\n+  uint32_t vpage = INSERTED32(EXTRACTED64(vpn, 24, 39), 0, 15);\n+  uint32_t hash = INSERTED32(EXTRACTED32(vsid, 5, 23)\n \t\t\t       ^ EXTRACTED32(vpage, 0, 15),\n \t\t\t       7, 31-6);\n   int h;\n   for (h = 0; h < 2; h++) {\n-    unsigned32 pteg = (htaborg | (hash & htabmask));\n+    uint32_t pteg = (htaborg | (hash & htabmask));\n     int pti;\n     for (pti = 0; pti < 8; pti++) {\n-      unsigned32 pte = pteg + 8 * pti;\n-      unsigned32 current_target_pte0;\n-      unsigned32 current_pte0;\n+      uint32_t pte = pteg + 8 * pti;\n+      uint32_t current_target_pte0;\n+      uint32_t current_pte0;\n       if (device_dma_read_buffer(device_parent(me),\n \t\t\t\t &current_target_pte0,\n \t\t\t\t 0, /*space*/\n@@ -273,9 +273,9 @@ htab_map_page(device *me,\n       if (MASKED32(current_pte0, 0, 0)) {\n \t/* full pte, check it isn't already mapping the same virtual\n            address */\n-\tunsigned32 curr_vsid = INSERTED32(EXTRACTED32(current_pte0, 1, 24), 0, 23);\n-\tunsigned32 curr_api = INSERTED32(EXTRACTED32(current_pte0, 26, 31), 0, 5);\n-\tunsigned32 curr_h = EXTRACTED32(current_pte0, 25, 25);\n+\tuint32_t curr_vsid = INSERTED32(EXTRACTED32(current_pte0, 1, 24), 0, 23);\n+\tuint32_t curr_api = INSERTED32(EXTRACTED32(current_pte0, 26, 31), 0, 5);\n+\tuint32_t curr_h = EXTRACTED32(current_pte0, 25, 25);\n \tif (curr_h == h\n \t    && curr_vsid == vsid\n \t    && curr_api == MASKED32(vpage, 0, 5))\n@@ -292,15 +292,15 @@ htab_map_page(device *me,\n       }\n       else {\n \t/* empty pte fill it */\n-\tunsigned32 pte0 = (MASK32(0, 0)\n+\tuint32_t pte0 = (MASK32(0, 0)\n \t\t\t   | INSERTED32(EXTRACTED32(vsid, 0, 23), 1, 24)\n \t\t\t   | INSERTED32(h, 25, 25)\n \t\t\t   | INSERTED32(EXTRACTED32(vpage, 0, 5), 26, 31));\n-\tunsigned32 target_pte0 = H2T_4(pte0);\n-\tunsigned32 pte1 = (INSERTED32(EXTRACTED32(ra, 0, 19), 0, 19)\n+\tuint32_t target_pte0 = H2T_4(pte0);\n+\tuint32_t pte1 = (INSERTED32(EXTRACTED32(ra, 0, 19), 0, 19)\n \t\t\t   | INSERTED32(wimg, 25, 28)\n \t\t\t   | INSERTED32(pp, 30, 31));\n-\tunsigned32 target_pte1 = H2T_4(pte1);\n+\tuint32_t target_pte1 = H2T_4(pte1);\n \tif (device_dma_write_buffer(device_parent(me),\n \t\t\t\t    &target_pte0,\n \t\t\t\t    0, /*space*/\n@@ -339,8 +339,8 @@ claim_memory(device *me,\n \t     unsigned_word ra,\n \t     unsigned_word size)\n {\n-  unsigned32 args[3];\n-  unsigned32 results[1];\n+  uint32_t args[3];\n+  uint32_t results[1];\n   int status;\n   args[0] = 0; /* alignment */\n   args[1] = size;\n@@ -355,15 +355,15 @@ static void\n htab_map_region(device *me,\n \t\tdevice_instance *memory,\n \t\tunsigned_word pte_ra,\n-\t\tunsigned64 pte_va,\n+\t\tuint64_t pte_va,\n \t\tunsigned nr_bytes,\n \t\tunsigned wimg,\n \t\tunsigned pp,\n-\t\tunsigned32 htaborg,\n-\t\tunsigned32 htabmask)\n+\t\tuint32_t htaborg,\n+\t\tuint32_t htabmask)\n {\n   unsigned_word ra;\n-  unsigned64 va;\n+  uint64_t va;\n   /* claim the memory */\n   if (memory != NULL)\n     claim_memory(me, memory, pte_ra, nr_bytes);\n@@ -499,8 +499,8 @@ htab_map_binary(device *me,\n \t\tunsigned wimg,\n \t\tunsigned pp,\n \t\tconst char *file_name,\n-\t\tunsigned32 htaborg,\n-\t\tunsigned32 htabmask)\n+\t\tuint32_t htaborg,\n+\t\tuint32_t htabmask)\n {\n   htab_binary_sizes sizes;\n   bfd *image;\n@@ -615,8 +615,8 @@ htab_init_data_callback(device *me)\n \n   /* for the pte, do all the real work */\n   if (strcmp(device_name(me), \"pte\") == 0) {\n-    unsigned32 htaborg;\n-    unsigned32 htabmask;\n+    uint32_t htaborg;\n+    uint32_t htabmask;\n \n     htab_decode_hash_table(me, &htaborg, &htabmask);\n \n@@ -626,7 +626,7 @@ htab_init_data_callback(device *me)\n       unsigned pte_pp = device_find_integer_property(me, \"pp\");\n       const char *file_name = device_find_string_property(me, \"file-name\");\n       if (device_find_property(me, \"real-address\") != NULL) {\n-\tunsigned32 pte_ra = device_find_integer_property(me, \"real-address\");\n+\tuint32_t pte_ra = device_find_integer_property(me, \"real-address\");\n \tDTRACE(htab, (\"pte - ra=0x%lx, wimg=%ld, pp=%ld, file-name=%s\\n\",\n \t\t      (unsigned long)pte_ra,\n \t\t      (unsigned long)pte_wimg,\n@@ -646,8 +646,8 @@ htab_init_data_callback(device *me)\n     }\n     else {\n       /* handle a normal mapping definition */\n-      unsigned64 pte_va = 0;\n-      unsigned32 pte_ra = device_find_integer_property(me, \"real-address\");\n+      uint64_t pte_va = 0;\n+      uint32_t pte_ra = device_find_integer_property(me, \"real-address\");\n       unsigned pte_nr_bytes = device_find_integer_property(me, \"nr-bytes\");\n       unsigned pte_wimg = device_find_integer_property(me, \"wimg\");\n       unsigned pte_pp = device_find_integer_property(me, \"pp\");"
    },
    {
      "sha": "af61eeccab6f720f545c6ea9b1ece9401e643577",
      "filename": "sim/ppc/hw_ide.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_ide.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_ide.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_ide.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -224,8 +224,8 @@ typedef struct _ide_drive {\n typedef struct _ide_controller {\n   int nr;\n   ide_states state;\n-  unsigned8 reg[nr_ide_registers];\n-  unsigned8 fifo[nr_fifo_entries];\n+  uint8_t reg[nr_ide_registers];\n+  uint8_t fifo[nr_fifo_entries];\n   int fifo_pos;\n   int fifo_size;\n   ide_drive *current_drive;\n@@ -235,7 +235,7 @@ typedef struct _ide_controller {\n   device *me;\n   event_entry_tag event_tag;\n   int is_interrupting;\n-  signed64 ready_delay;\n+  int64_t ready_delay;\n } ide_controller;\n \n \n@@ -488,7 +488,7 @@ do_command(device *me,\n   }\n }\n \n-static unsigned8\n+static uint8_t\n get_status(device *me,\n \t   ide_controller *controller)\n {\n@@ -744,11 +744,11 @@ hw_ide_io_read_buffer(device *me,\n     do_fifo_read(me, controller, dest, nr_bytes);\n     break;\n   case ide_status_reg:\n-    *(unsigned8*)dest = get_status(me, controller);\n+    *(uint8_t*)dest = get_status(me, controller);\n     clear_interrupt(me, controller);\n     break;\n   case ide_alternate_status_reg:\n-    *(unsigned8*)dest = get_status(me, controller);\n+    *(uint8_t*)dest = get_status(me, controller);\n     break;\n   case ide_error_reg:\n   case ide_sector_count_reg:\n@@ -763,7 +763,7 @@ hw_ide_io_read_buffer(device *me,\n   case ide_dma_prd_table_address_reg1:\n   case ide_dma_prd_table_address_reg2:\n   case ide_dma_prd_table_address_reg3:\n-    *(unsigned8*)dest = controller->reg[reg];\n+    *(uint8_t*)dest = controller->reg[reg];\n     break;\n   default:\n     device_error(me, \"bus-error at address 0x%lx\", (unsigned long)addr);\n@@ -797,10 +797,10 @@ hw_ide_io_write_buffer(device *me,\n     do_fifo_write(me, controller, source, nr_bytes);\n     break;\n   case ide_command_reg:\n-    do_command(me, controller, *(unsigned8*)source);\n+    do_command(me, controller, *(uint8_t*)source);\n     break;\n   case ide_control_reg:\n-    controller->reg[reg] = *(unsigned8*)source;\n+    controller->reg[reg] = *(uint8_t*)source;\n     /* possibly cancel interrupts */\n     if ((controller->reg[reg] & 0x02) == 0x02)\n       clear_interrupt(me, controller);\n@@ -817,7 +817,7 @@ hw_ide_io_write_buffer(device *me,\n   case ide_dma_prd_table_address_reg1:\n   case ide_dma_prd_table_address_reg2:\n   case ide_dma_prd_table_address_reg3:\n-    controller->reg[reg] = *(unsigned8*)source;\n+    controller->reg[reg] = *(uint8_t*)source;\n     break;\n   default:\n     device_error(me, \"bus-error at 0x%lx\", (unsigned long)addr);"
    },
    {
      "sha": "e26b5476a36b1796513f629cf21e90e2ff557f87",
      "filename": "sim/ppc/hw_nvram.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_nvram.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_nvram.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_nvram.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -62,7 +62,7 @@\n    */\n \n typedef struct _hw_nvram_device {\n-  unsigned8 *memory;\n+  uint8_t *memory;\n   unsigned sizeof_memory;\n   time_t host_time;\n   unsigned timezone;\n@@ -87,8 +87,8 @@ hw_nvram_create(const char *name,\n }\n \n typedef struct _hw_nvram_reg_spec {\n-  unsigned32 base;\n-  unsigned32 size;\n+  uint32_t base;\n+  uint32_t size;\n } hw_nvram_reg_spec;\n \n static void\n@@ -200,9 +200,9 @@ hw_nvram_io_read_buffer(device *me,\n   hw_nvram_device *nvram = (hw_nvram_device*)device_data(me);\n   for (i = 0; i < nr_bytes; i++) {\n     unsigned address = (addr + i) % nvram->sizeof_memory;\n-    unsigned8 data = nvram->memory[address];\n+    uint8_t data = nvram->memory[address];\n     hw_nvram_update_clock(nvram, processor);\n-    ((unsigned8*)dest)[i] = data;\n+    ((uint8_t*)dest)[i] = data;\n   }\n   return nr_bytes;\n }\n@@ -220,7 +220,7 @@ hw_nvram_io_write_buffer(device *me,\n   hw_nvram_device *nvram = (hw_nvram_device*)device_data(me);\n   for (i = 0; i < nr_bytes; i++) {\n     unsigned address = (addr + i) % nvram->sizeof_memory;\n-    unsigned8 data = ((unsigned8*)source)[i];\n+    uint8_t data = ((uint8_t*)source)[i];\n     if (address == nvram->addr_control\n \t&& (data & 0x80) == 0\n \t&& (nvram->memory[address] & 0x80) == 0x80)"
    },
    {
      "sha": "42474115a717add336d3543395d42487c2a2f15d",
      "filename": "sim/ppc/hw_opic.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_opic.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_opic.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_opic.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -305,7 +305,7 @@ typedef struct _opic_timer {\n   hw_opic_device *opic; /* ditto */\n   unsigned base_count;\n   int inhibited;\n-  signed64 count; /* *ONLY* if inhibited */\n+  int64_t count; /* *ONLY* if inhibited */\n   event_entry_tag timeout_event;\n   opic_interrupt_source *interrupt_source;\n } opic_timer;\n@@ -347,7 +347,7 @@ struct _hw_opic_device {\n   unsigned timer_frequency;\n \n   /* init register */\n-  unsigned32 init;\n+  uint32_t init;\n \n   /* address maps */\n   opic_idu idu;"
    },
    {
      "sha": "6d78a7c2ff2a8bec7219620f9e8a35963e4e7373",
      "filename": "sim/ppc/hw_register.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_register.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_register.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_register.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -80,7 +80,7 @@ do_register_init(device *me,\n   psim *system = device_system(me);\n   if (prop != NULL) {\n     const char *name = prop->name;\n-    unsigned32 value = device_find_integer_property(me, name);\n+    uint32_t value = device_find_integer_property(me, name);\n     int processor;\n \n     do_register_init(me, device_next_property(prop));"
    },
    {
      "sha": "937e2ad6f812120c444514abf2684e866d43e731",
      "filename": "sim/ppc/hw_sem.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_sem.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_sem.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_sem.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -187,7 +187,7 @@ hw_sem_io_read_buffer(device *me,\n   hw_sem_device *sem = (hw_sem_device*)device_data(me);\n   struct sembuf sb;\n   int status;\n-  unsigned32 u32;\n+  uint32_t u32;\n   union semun help;\n \n   /* do we need to worry about out of range addresses? */"
    },
    {
      "sha": "e150e58333fc21f277b27e5c5af3c306087bb0fc",
      "filename": "sim/ppc/hw_trace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_trace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/hw_trace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/hw_trace.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -69,7 +69,7 @@ hw_trace_ioctl(device *me,\n       const device_property *prop = device_find_property(me, NULL);\n       while (prop != NULL) {\n \tconst char *name = prop->name;\n-\tunsigned32 value = device_find_integer_property(me, name);\n+\tuint32_t value = device_find_integer_property(me, name);\n \ttrace_option(name, value);\n \tprop = device_next_property(prop);\n       }"
    },
    {
      "sha": "9c4cb7a55a98c5c8ae025f5c9bd1bf9b51480c5e",
      "filename": "sim/ppc/idecode_expression.h",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/idecode_expression.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/idecode_expression.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/idecode_expression.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -30,7 +30,7 @@\n /* 32bit target expressions:\n \n    Each calculation is performed three times using each of the\n-   signed64, unsigned64 and long integer types.  The macro ALU_END\n+   int64_t, uint64_t and long integer types.  The macro ALU_END\n    (in _ALU_RESULT_VAL) then selects which of the three alternative\n    results will be used in the final assignment of the target\n    register.  As this selection is determined at compile time by\n@@ -57,17 +57,17 @@\n \n \n /* Macro's to type cast 32bit constants to 64bits */\n-#define SIGNED64(val)   ((signed64)(signed32)(val))\n-#define UNSIGNED64(val) ((unsigned64)(unsigned32)(val))\n+#define SIGNED64(val)   ((int64_t)(int32_t)(val))\n+#define UNSIGNED64(val) ((uint64_t)(uint32_t)(val))\n \n \n /* Start a section of ALU code */\n \n #define ALU_BEGIN(val) \\\n { \\\n   signed_word alu_val; \\\n-  unsigned64 alu_carry_val; \\\n-  signed64 alu_overflow_val; \\\n+  uint64_t alu_carry_val; \\\n+  int64_t alu_overflow_val; \\\n   ALU_SET(val)\n \n \n@@ -78,7 +78,7 @@\n   signed_word const alu_result = _ALU_RESULT_VAL(CA,OE,Rc); \\\n   /* determine the overflow bit if needed */ \\\n   if (OE) { \\\n-    if ((((unsigned64)(alu_overflow_val & BIT64(0))) \\\n+    if ((((uint64_t)(alu_overflow_val & BIT64(0))) \\\n \t >> 32) \\\n         == (alu_overflow_val & BIT64(32))) \\\n       XER &= (~xer_overflow); \\\n@@ -118,23 +118,23 @@\n #define ALU_SET(val) \\\n do { \\\n   alu_val = val; \\\n-  alu_carry_val = ((unsigned64)alu_val) >> 32; \\\n-  alu_overflow_val = ((signed64)alu_val) >> 32; \\\n+  alu_carry_val = ((uint64_t)alu_val) >> 32; \\\n+  alu_overflow_val = ((int64_t)alu_val) >> 32; \\\n } while (0)\n #endif\n #if (WITH_TARGET_WORD_BITSIZE == 32)\n #define ALU_SET(val) \\\n do { \\\n   alu_val = val; \\\n-  alu_carry_val = (unsigned32)(alu_val); \\\n-  alu_overflow_val = (signed32)(alu_val); \\\n+  alu_carry_val = (uint32_t)(alu_val); \\\n+  alu_overflow_val = (int32_t)(alu_val); \\\n } while (0)\n #endif\n \n #if (WITH_TARGET_WORD_BITSIZE == 64)\n #define ALU_ADD(val) \\\n do { \\\n-  unsigned64 alu_lo = (UNSIGNED64(alu_val) \\\n+  uint64_t alu_lo = (UNSIGNED64(alu_val) \\\n \t\t       + UNSIGNED64(val)); \\\n   signed alu_carry = ((alu_lo & BIT(31)) != 0); \\\n   alu_carry_val = (alu_carry_val \\\n@@ -150,8 +150,8 @@ do { \\\n #define ALU_ADD(val) \\\n do { \\\n   alu_val += val; \\\n-  alu_carry_val += (unsigned32)(val); \\\n-  alu_overflow_val += (signed32)(val); \\\n+  alu_carry_val += (uint32_t)(val); \\\n+  alu_overflow_val += (int32_t)(val); \\\n } while (0)\n #endif\n \n@@ -179,8 +179,8 @@ do { \\\n #define ALU_SUB(val) \\\n do { \\\n   alu_val -= val; \\\n-  alu_carry_val -= (unsigned32)(val); \\\n-  alu_overflow_val -= (signed32)(val); \\\n+  alu_carry_val -= (uint32_t)(val); \\\n+  alu_overflow_val -= (int32_t)(val); \\\n } while (0)\n #endif\n #endif\n@@ -191,8 +191,8 @@ do { \\\n #define ALU_OR(val) \\\n do { \\\n   alu_val |= val; \\\n-  alu_carry_val = (unsigned32)(alu_val); \\\n-  alu_overflow_val = (signed32)(alu_val); \\\n+  alu_carry_val = (uint32_t)(alu_val); \\\n+  alu_overflow_val = (int32_t)(alu_val); \\\n } while (0)\n #endif\n \n@@ -203,8 +203,8 @@ do { \\\n #define ALU_XOR(val) \\\n do { \\\n   alu_val ^= val; \\\n-  alu_carry_val = (unsigned32)(alu_val); \\\n-  alu_overflow_val = (signed32)(alu_val); \\\n+  alu_carry_val = (uint32_t)(alu_val); \\\n+  alu_overflow_val = (int32_t)(alu_val); \\\n } while (0)\n #endif\n \n@@ -229,16 +229,16 @@ do { \\\n #define ALU_AND(val) \\\n do { \\\n   alu_val &= val; \\\n-  alu_carry_val = (unsigned32)(alu_val); \\\n-  alu_overflow_val = (signed32)(alu_val); \\\n+  alu_carry_val = (uint32_t)(alu_val); \\\n+  alu_overflow_val = (int32_t)(alu_val); \\\n } while (0)\n #endif\n \n \n #if (WITH_TARGET_WORD_BITSIZE == 64)\n #define ALU_NOT \\\n do { \\\n-  signed64 new_alu_val = ~alu_val; \\\n+  int64_t new_alu_val = ~alu_val; \\\n   ALU_SET(new_alu_val); \\\n } while (0)\n #endif"
    },
    {
      "sha": "2dbce134f8dfbe4d1ba08c2f1abd3e8f91806230",
      "filename": "sim/ppc/pk_disklabel.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/pk_disklabel.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/pk_disklabel.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/pk_disklabel.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -52,32 +52,32 @@\n \n /* PPCbug location structure */\n typedef struct ppcboot_location {\n-  unsigned8 ind;\n-  unsigned8 head;\n-  unsigned8 sector;\n-  unsigned8 cylinder;\n+  uint8_t ind;\n+  uint8_t head;\n+  uint8_t sector;\n+  uint8_t cylinder;\n } ppcboot_location_t;\n \n /* PPCbug partition table layout */\n typedef struct ppcboot_partition {\n   ppcboot_location_t partition_begin;\t/* partition begin */\n   ppcboot_location_t partition_end;\t/* partition end */\n-  unsigned8 sector_begin[4];\t\t/* 32-bit start RBA (zero-based), little endian */\n-  unsigned8 sector_length[4];\t\t/* 32-bit RBA count (one-based), little endian */\n+  uint8_t sector_begin[4];\t\t/* 32-bit start RBA (zero-based), little endian */\n+  uint8_t sector_length[4];\t\t/* 32-bit RBA count (one-based), little endian */\n } ppcboot_partition_t;\n \n #if 0\n /* PPCbug boot layout.  */\n typedef struct ppcboot_hdr {\n-  unsigned8\t\tpc_compatibility[446];\t/* x86 instruction field */\n+  uint8_t\t\tpc_compatibility[446];\t/* x86 instruction field */\n   ppcboot_partition_t\tpartition[4];\t\t/* partition information */\n-  unsigned8\t\tsignature[2];\t\t/* 0x55 and 0xaa */\n-  unsigned8\t\tentry_offset[4];\t/* entry point offset, little endian */\n-  unsigned8\t\tlength[4];\t\t/* load image length, little endian */\n-  unsigned8\t\tflags;\t\t\t/* flag field */\n-  unsigned8\t\tos_id;\t\t\t/* OS_ID */\n+  uint8_t\t\tsignature[2];\t\t/* 0x55 and 0xaa */\n+  uint8_t\t\tentry_offset[4];\t/* entry point offset, little endian */\n+  uint8_t\t\tlength[4];\t\t/* load image length, little endian */\n+  uint8_t\t\tflags;\t\t\t/* flag field */\n+  uint8_t\t\tos_id;\t\t\t/* OS_ID */\n   char\t\t\tpartition_name[32];\t/* partition name */\n-  unsigned8\t\treserved1[470];\t\t/* reserved */\n+  uint8_t\t\treserved1[470];\t\t/* reserved */\n } ppcboot_hdr_t;\n #endif\n \n@@ -92,7 +92,7 @@ typedef struct _disklabel {\n \n \n static unsigned_word\n-sector2uw(unsigned8 s[4])\n+sector2uw(uint8_t s[4])\n {\n   return ((s[3] << 24)\n \t  + (s[2] << 16)\n@@ -169,7 +169,7 @@ static const device_instance_callbacks package_disklabel_callbacks = {\n /* Reconize different types of boot block */\n \n static int\n-block0_is_bpb(const unsigned8 block[])\n+block0_is_bpb(const uint8_t block[])\n {\n   const char ebdic_ibma[] = { 0xc9, 0xc2, 0xd4, 0xc1 };\n   /* ref PowerPC Microprocessor CHRP bindings 1.2b - page 47 */\n@@ -196,7 +196,7 @@ static int\n is_iso9660(device_instance *raw_disk)\n {\n   /* ref PowerPC Microprocessor CHRP bindings 1.2b - page 47 */\n-  unsigned8 block[512];\n+  uint8_t block[512];\n   if (device_instance_seek(raw_disk, 0, 512 * 64) < 0)\n     return 0;\n   if (device_instance_read(raw_disk, block, sizeof(block)) != sizeof(block))\n@@ -220,7 +220,7 @@ is_iso9660(device_instance *raw_disk)\n    Return -1: no active partition */\n \n static int\n-block0_is_fdisk(const unsigned8 block[])\n+block0_is_fdisk(const uint8_t block[])\n {\n   const int partition_type_fields[] = { 0, 0x1c2, 0x1d2, 0x1e2, 0x1f2 };\n   const int partition_active_fields[] = { 0, 0x1be, 0x1ce, 0x1de, 0xee };\n@@ -279,7 +279,7 @@ block0_is_fdisk(const unsigned8 block[])\n /* Verify that block0 corresponds to a MAC disk */\n \n static int\n-block0_is_mac_disk(const unsigned8 block[])\n+block0_is_mac_disk(const uint8_t block[])\n {\n   /* ref PowerPC Microprocessor CHRP bindings 1.2b - page 47 */\n   /* signature - BEx4552 at offset 0 */\n@@ -318,7 +318,7 @@ pk_disklabel_create_instance(device_instance *raw_disk,\n     return raw_disk;\n   }\n   else {\n-    unsigned8 boot_block[512];\n+    uint8_t boot_block[512];\n     /* get the boot block for examination */\n     if (device_instance_seek(raw_disk, 0, 0) < 0)\n       device_error(device_instance_device(raw_disk),"
    },
    {
      "sha": "60840fe843c881461e40af955b3559ba37f7bbe1",
      "filename": "sim/ppc/ppc-instructions",
      "status": "modified",
      "additions": 154,
      "deletions": 154,
      "changes": 308,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/ppc-instructions",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/ppc-instructions",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/ppc-instructions?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -35,49 +35,49 @@\n \n :cache::::RA:RA:\n :cache:::signed_word *:rA:RA:(cpu_registers(processor)->gpr + RA)\n-:cache:::unsigned32:RA_BITMASK:RA:(1 << RA)\n+:cache:::uint32_t:RA_BITMASK:RA:(1 << RA)\n :compute:::int:RA_is_0:RA:(RA == 0)\n :cache::::RT:RT:\n :cache:::signed_word *:rT:RT:(cpu_registers(processor)->gpr + RT)\n-:cache:::unsigned32:RT_BITMASK:RT:(1 << RT)\n+:cache:::uint32_t:RT_BITMASK:RT:(1 << RT)\n :cache::::RS:RS:\n :cache:::signed_word *:rS:RS:(cpu_registers(processor)->gpr + RS)\n-:cache:::unsigned32:RS_BITMASK:RS:(1 << RS)\n+:cache:::uint32_t:RS_BITMASK:RS:(1 << RS)\n :cache::::RB:RB:\n :cache:::signed_word *:rB:RB:(cpu_registers(processor)->gpr + RB)\n-:cache:::unsigned32:RB_BITMASK:RB:(1 << RB)\n+:cache:::uint32_t:RB_BITMASK:RB:(1 << RB)\n :scratch::::FRA:FRA:\n-:cache:::unsigned64 *:frA:FRA:(cpu_registers(processor)->fpr + FRA)\n-:cache:::unsigned32:FRA_BITMASK:FRA:(1 << FRA)\n+:cache:::uint64_t *:frA:FRA:(cpu_registers(processor)->fpr + FRA)\n+:cache:::uint32_t:FRA_BITMASK:FRA:(1 << FRA)\n :scratch::::FRB:FRB:\n-:cache:::unsigned64 *:frB:FRB:(cpu_registers(processor)->fpr + FRB)\n-:cache:::unsigned32:FRB_BITMASK:FRB:(1 << FRB)\n+:cache:::uint64_t *:frB:FRB:(cpu_registers(processor)->fpr + FRB)\n+:cache:::uint32_t:FRB_BITMASK:FRB:(1 << FRB)\n :scratch::::FRC:FRC:\n-:cache:::unsigned64 *:frC:FRC:(cpu_registers(processor)->fpr + FRC)\n-:cache:::unsigned32:FRC_BITMASK:FRC:(1 << FRC)\n+:cache:::uint64_t *:frC:FRC:(cpu_registers(processor)->fpr + FRC)\n+:cache:::uint32_t:FRC_BITMASK:FRC:(1 << FRC)\n :scratch::::FRS:FRS:\n-:cache:::unsigned64 *:frS:FRS:(cpu_registers(processor)->fpr + FRS)\n-:cache:::unsigned32:FRS_BITMASK:FRS:(1 << FRS)\n+:cache:::uint64_t *:frS:FRS:(cpu_registers(processor)->fpr + FRS)\n+:cache:::uint32_t:FRS_BITMASK:FRS:(1 << FRS)\n :scratch::::FRT:FRT:\n-:cache:::unsigned64 *:frT:FRT:(cpu_registers(processor)->fpr + FRT)\n-:cache:::unsigned32:FRT_BITMASK:FRT:(1 << FRT)\n-:cache:::unsigned_word:EXTS_SI:SI:((signed_word)(signed16)instruction)\n+:cache:::uint64_t *:frT:FRT:(cpu_registers(processor)->fpr + FRT)\n+:cache:::uint32_t:FRT_BITMASK:FRT:(1 << FRT)\n+:cache:::unsigned_word:EXTS_SI:SI:((signed_word)(int16_t)instruction)\n :scratch::::BI:BI:\n :cache::::BIT32_BI:BI:BIT32(BI)\n :cache::::BF:BF:\n-:cache:::unsigned32:BF_BITMASK:BF:(1 << BF)\n+:cache:::uint32_t:BF_BITMASK:BF:(1 << BF)\n :scratch::::BA:BA:\n :cache::::BIT32_BA:BA:BIT32(BA)\n-:cache:::unsigned32:BA_BITMASK:BA:(1 << BA)\n+:cache:::uint32_t:BA_BITMASK:BA:(1 << BA)\n :scratch::::BB:BB:\n :cache::::BIT32_BB:BB:BIT32(BB)\n-:cache:::unsigned32:BB_BITMASK:BB:(1 << BB)\n+:cache:::uint32_t:BB_BITMASK:BB:(1 << BB)\n :cache::::BT:BT:\n-:cache:::unsigned32:BT_BITMASK:BT:(1 << BT)\n-:cache:::unsigned_word:EXTS_BD_0b00:BD:(((signed_word)(signed16)instruction) & ~3)\n-:cache:::unsigned_word:EXTS_LI_0b00:LI:((((signed_word)(signed32)(instruction << 6)) >> 6) & ~0x3)\n-:cache:::unsigned_word:EXTS_D:D:((signed_word)(signed16)(instruction))\n-:cache:::unsigned_word:EXTS_DS_0b00:DS:(((signed_word)(signed16)instruction) & ~0x3)\n+:cache:::uint32_t:BT_BITMASK:BT:(1 << BT)\n+:cache:::unsigned_word:EXTS_BD_0b00:BD:(((signed_word)(int16_t)instruction) & ~3)\n+:cache:::unsigned_word:EXTS_LI_0b00:LI:((((signed_word)(int32_t)(instruction << 6)) >> 6) & ~0x3)\n+:cache:::unsigned_word:EXTS_D:D:((signed_word)(int16_t)(instruction))\n+:cache:::unsigned_word:EXTS_DS_0b00:DS:(((signed_word)(int16_t)instruction) & ~0x3)\n #:compute:::int:SPR_is_256:SPR:(SPR == 256)\n \f\n # PowerPC models\n@@ -174,9 +174,9 @@\n \tstruct _model_time {\n \t  ppc_function_unit first_unit;\t\t\t/* first functional unit this insn could use */\n \t  ppc_function_unit second_unit;\t\t/* second functional unit this insn could use */\n-\t  signed16\t    issue;\t\t\t/* # cycles before function unit can process other insns */\n-\t  signed16\t    done;\t\t\t/* # cycles before insn is done */\n-\t  unsigned32\t    flags;\t\t\t/* any flags that are needed */\n+\t  int16_t\t    issue;\t\t\t/* # cycles before function unit can process other insns */\n+\t  int16_t\t    done;\t\t\t/* # cycles before insn is done */\n+\t  uint32_t\t    flags;\t\t\t/* any flags that are needed */\n \t};\n \n \t/* Register mappings in status masks */\n@@ -193,15 +193,15 @@\n \tstruct _model_busy {\n \t  model_busy *next;\t\t\t\t/* next function unit */\n \t  ppc_function_unit unit;\t\t\t/* function unit name */\n-\t  unsigned32 int_busy;\t\t\t\t/* int registers that are busy */\n-\t  unsigned32 fp_busy;\t\t\t\t/* floating point registers that are busy */\n-\t  unsigned32 cr_fpscr_busy;\t\t\t/* CR/FPSCR registers that are busy */\n-\t  signed16 spr_busy;\t\t\t\t/* SPR register that is busy or PPC_NO_SPR */\n-\t  unsigned32 vr_busy;\t\t\t\t/* AltiVec registers that are busy */\n-\t  signed16 vscr_busy;\t\t\t\t/* AltiVec status register busy */\n-\t  signed16 issue;\t\t\t\t/* # of cycles until unit can accept another insn */\n-\t  signed16 done;\t\t\t\t/* # of cycles until insn is done */\n-\t  signed16 nr_writebacks;\t\t\t/* # of registers this unit writes back */\n+\t  uint32_t int_busy;\t\t\t\t/* int registers that are busy */\n+\t  uint32_t fp_busy;\t\t\t\t/* floating point registers that are busy */\n+\t  uint32_t cr_fpscr_busy;\t\t\t/* CR/FPSCR registers that are busy */\n+\t  int16_t spr_busy;\t\t\t\t/* SPR register that is busy or PPC_NO_SPR */\n+\t  uint32_t vr_busy;\t\t\t\t/* AltiVec registers that are busy */\n+\t  int16_t vscr_busy;\t\t\t\t/* AltiVec status register busy */\n+\t  int16_t issue;\t\t\t\t/* # of cycles until unit can accept another insn */\n+\t  int16_t done;\t\t\t\t/* # of cycles until insn is done */\n+\t  int16_t nr_writebacks;\t\t\t/* # of registers this unit writes back */\n \t};\n \t\n \t/* Structure to hold the current state information for the simulated CPU model */\n@@ -225,13 +225,13 @@\n \t  count_type nr_stalls_writeback;\t\t/* # of stalls waiting for a writeback slot */\n \t  count_type nr_units[nr_ppc_function_units];\t/* function unit counts */\n \t  int max_nr_writebacks;\t\t\t/* max # of writeback slots available */\n-\t  unsigned32 int_busy;\t\t\t\t/* int registers that are busy */\n-\t  unsigned32 fp_busy;\t\t\t\t/* floating point registers that are busy */\n-\t  unsigned32 cr_fpscr_busy;\t\t\t/* CR/FPSCR registers that are busy */\n-\t  unsigned8 spr_busy[nr_of_sprs];\t\t/* SPR registers that are busy */\n-\t  unsigned32 vr_busy;\t\t\t\t/* AltiVec registers that are busy */\n-\t  unsigned8 vscr_busy;\t\t\t\t/* AltiVec SC register busy */\n-\t  unsigned8 busy[nr_ppc_function_units];\t/* whether a function is busy or not */\n+\t  uint32_t int_busy;\t\t\t\t/* int registers that are busy */\n+\t  uint32_t fp_busy;\t\t\t\t/* floating point registers that are busy */\n+\t  uint32_t cr_fpscr_busy;\t\t\t/* CR/FPSCR registers that are busy */\n+\t  uint8_t spr_busy[nr_of_sprs];\t\t/* SPR registers that are busy */\n+\t  uint32_t vr_busy;\t\t\t\t/* AltiVec registers that are busy */\n+\t  uint8_t vscr_busy;\t\t\t\t/* AltiVec SC register busy */\n+\t  uint8_t busy[nr_ppc_function_units];\t/* whether a function is busy or not */\n \t};\n \n \tstatic const char *const ppc_function_unit_name[ (int)nr_ppc_function_units ] = {\n@@ -334,7 +334,7 @@ void::model-static::model_trace_release:model_data *model_ptr, model_busy *busy\n \t  TRACE(trace_model, (\"VSCR Register %s is now available.\\n\", spr_name(busy->spr_busy)));\n \n # Trace making registers busy\n-void::model-static::model_trace_make_busy:model_data *model_ptr, unsigned32 int_mask, unsigned32 fp_mask, unsigned32 cr_mask\n+void::model-static::model_trace_make_busy:model_data *model_ptr, uint32_t int_mask, uint32_t fp_mask, uint32_t cr_mask\n \tint i;\n \tif (int_mask) {\n \t  for(i = 0; i < 32; i++) {\n@@ -359,7 +359,7 @@ void::model-static::model_trace_make_busy:model_data *model_ptr, unsigned32 int_\n \t}\n \n # Trace waiting for registers to become available\n-void::model-static::model_trace_busy_p:model_data *model_ptr, unsigned32 int_busy, unsigned32 fp_busy, unsigned32 cr_or_fpscr_busy, int spr_busy\n+void::model-static::model_trace_busy_p:model_data *model_ptr, uint32_t int_busy, uint32_t fp_busy, uint32_t cr_or_fpscr_busy, int spr_busy\n \tint i;\n \tif (int_busy) {\n \t  int_busy &= model_ptr->int_busy;\n@@ -520,7 +520,7 @@ void::model-function::model_serialize:itable_index index, model_data *model_ptr\n # Wait for a CR to become unbusy\n void::model-function::model_wait_for_cr:model_data *model_ptr, unsigned CRBIT\n \tunsigned u;\n-\tunsigned32 cr_mask;\n+\tuint32_t cr_mask;\n \tint cr_var = 0;\n \tfor (u = 0xc0000000; (u != 0) && (CRBIT & u) == 0; u >>= 4 )\n \t  cr_var++;\n@@ -533,8 +533,8 @@ void::model-function::model_wait_for_cr:model_data *model_ptr, unsigned CRBIT\n \t}\n \n # Schedule an instruction that takes integer input registers and produces output registers\n-void::model-function::ppc_insn_int:itable_index index, model_data *model_ptr, const unsigned32 out_mask, const unsigned32 in_mask\n-\tconst unsigned32 int_mask = out_mask | in_mask;\n+void::model-function::ppc_insn_int:itable_index index, model_data *model_ptr, const uint32_t out_mask, const uint32_t in_mask\n+\tconst uint32_t int_mask = out_mask | in_mask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->int_busy & int_mask) != 0) {\n@@ -559,8 +559,8 @@ void::model-function::ppc_insn_int:itable_index index, model_data *model_ptr, co\n \t  model_trace_make_busy(model_ptr, out_mask, 0, 0);\n \n # Schedule an instruction that takes integer input registers and produces output registers & sets a CR register\n-void::model-function::ppc_insn_int_cr:itable_index index, model_data *model_ptr, const unsigned32 out_mask, const unsigned32 in_mask, const unsigned32 cr_mask\n-\tconst unsigned32 int_mask = out_mask | in_mask;\n+void::model-function::ppc_insn_int_cr:itable_index index, model_data *model_ptr, const uint32_t out_mask, const uint32_t in_mask, const uint32_t cr_mask\n+\tconst uint32_t int_mask = out_mask | in_mask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->int_busy & int_mask) || (model_ptr->cr_fpscr_busy & cr_mask)) {\n@@ -591,8 +591,8 @@ void::model-function::ppc_insn_int_cr:itable_index index, model_data *model_ptr,\n \n \n # Schedule an instruction that takes CR input registers and produces output CR registers\n-void::model-function::ppc_insn_cr:itable_index index, model_data *model_ptr, const unsigned32 out_mask, const unsigned32 in_mask\n-\tconst unsigned32 cr_mask = out_mask | in_mask;\n+void::model-function::ppc_insn_cr:itable_index index, model_data *model_ptr, const uint32_t out_mask, const uint32_t in_mask\n+\tconst uint32_t cr_mask = out_mask | in_mask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->cr_fpscr_busy & cr_mask) != 0) {\n@@ -618,8 +618,8 @@ void::model-function::ppc_insn_cr:itable_index index, model_data *model_ptr, con\n \n \n # Schedule an instruction that takes floating point input registers and produces an output fp register\n-void::model-function::ppc_insn_float:itable_index index, model_data *model_ptr, const unsigned32 out_mask, const unsigned32 in_mask\n-\tconst unsigned32 fp_mask = out_mask | in_mask;\n+void::model-function::ppc_insn_float:itable_index index, model_data *model_ptr, const uint32_t out_mask, const uint32_t in_mask\n+\tconst uint32_t fp_mask = out_mask | in_mask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->fp_busy & fp_mask) != 0) {\n@@ -643,8 +643,8 @@ void::model-function::ppc_insn_float:itable_index index, model_data *model_ptr,\n \n \n # Schedule an instruction that takes floating point input registers and produces an output fp register & sets a CR reg\n-void::model-function::ppc_insn_float_cr:itable_index index, model_data *model_ptr, const unsigned32 out_mask, const unsigned32 in_mask, const unsigned32 cr_mask\n-\tconst unsigned32 fp_mask = out_mask | in_mask;\n+void::model-function::ppc_insn_float_cr:itable_index index, model_data *model_ptr, const uint32_t out_mask, const uint32_t in_mask, const uint32_t cr_mask\n+\tconst uint32_t fp_mask = out_mask | in_mask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->fp_busy & fp_mask) || (model_ptr->cr_fpscr_busy & cr_mask)) {\n@@ -670,9 +670,9 @@ void::model-function::ppc_insn_float_cr:itable_index index, model_data *model_pt\n \n \n # Schedule an instruction that takes both int/float input registers and produces output int/float registers\n-void::model-function::ppc_insn_int_float:itable_index index, model_data *model_ptr, const unsigned32 out_int_mask, const unsigned32 out_fp_mask, const unsigned32 in_int_mask, const unsigned32 in_fp_mask\n-\tconst unsigned32 int_mask = out_int_mask | in_int_mask;\n-\tconst unsigned32 fp_mask = out_fp_mask | in_fp_mask;\n+void::model-function::ppc_insn_int_float:itable_index index, model_data *model_ptr, const uint32_t out_int_mask, const uint32_t out_fp_mask, const uint32_t in_int_mask, const uint32_t in_fp_mask\n+\tconst uint32_t int_mask = out_int_mask | in_int_mask;\n+\tconst uint32_t fp_mask = out_fp_mask | in_fp_mask;\n \tmodel_busy *busy_ptr;\n \n \tif ((model_ptr->int_busy & int_mask) || (model_ptr->fp_busy & fp_mask)) {\n@@ -698,7 +698,7 @@ void::model-function::ppc_insn_int_float:itable_index index, model_data *model_p\n \t}\n \n # Schedule an MFSPR instruction that takes 1 special purpose register and produces an integer output register\n-void::model-function::ppc_insn_from_spr:itable_index index, model_data *model_ptr, const unsigned32 int_mask, const unsigned nSPR\n+void::model-function::ppc_insn_from_spr:itable_index index, model_data *model_ptr, const uint32_t int_mask, const unsigned nSPR\n \tmodel_busy *busy_ptr;\n \n \twhile ((model_ptr->int_busy & int_mask) != 0 || model_ptr->spr_busy[nSPR] != 0) {\n@@ -717,7 +717,7 @@ void::model-function::ppc_insn_from_spr:itable_index index, model_data *model_pt\n \t  model_trace_make_busy(model_ptr, int_mask, 0, 0);\n \n # Schedule an MTSPR instruction that takes 1 integer register and produces a special purpose output register\n-void::model-function::ppc_insn_to_spr:itable_index index, model_data *model_ptr, const unsigned32 int_mask, const unsigned nSPR\n+void::model-function::ppc_insn_to_spr:itable_index index, model_data *model_ptr, const uint32_t int_mask, const unsigned nSPR\n \tmodel_busy *busy_ptr;\n \n \twhile ((model_ptr->int_busy & int_mask) != 0 || model_ptr->spr_busy[nSPR] != 0) {\n@@ -735,8 +735,8 @@ void::model-function::ppc_insn_to_spr:itable_index index, model_data *model_ptr,\n \tTRACE(trace_model,(\"Making register %s busy.\\n\", spr_name(nSPR)));\n \n # Schedule a MFCR instruction that moves the CR into an integer register\n-void::model-function::ppc_insn_mfcr:itable_index index, model_data *model_ptr, unsigned32 int_mask\n-\tconst unsigned32 cr_mask = 0xff;\n+void::model-function::ppc_insn_mfcr:itable_index index, model_data *model_ptr, uint32_t int_mask\n+\tconst uint32_t cr_mask = 0xff;\n \tmodel_busy *busy_ptr;\n \n \twhile (((model_ptr->int_busy & int_mask) | (model_ptr->cr_fpscr_busy & cr_mask)) != 0) {\n@@ -755,10 +755,10 @@ void::model-function::ppc_insn_mfcr:itable_index index, model_data *model_ptr, u\n \t  model_trace_make_busy(model_ptr, int_mask, 0, 0);\n \n # Schedule a MTCR instruction that moves an integer register into the CR\n-void::model-function::ppc_insn_mtcr:itable_index index, model_data *model_ptr, unsigned32 int_mask, unsigned FXM\n+void::model-function::ppc_insn_mtcr:itable_index index, model_data *model_ptr, uint32_t int_mask, unsigned FXM\n \tint f;\n \tint nr_crs = 0;\n-\tunsigned32 cr_mask = 0;\n+\tuint32_t cr_mask = 0;\n \tconst model_time *normal_time = &model_ptr->timing[index];\n \tstatic const model_time ppc604_1bit_time = { PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0 };\n \tmodel_busy *busy_ptr;\n@@ -996,8 +996,8 @@ void::model-function::model_branch_predict:model_data *model_ptr, int success\n #\n \n # Convert 32bit single to 64bit double\n-unsigned64::function::DOUBLE:unsigned32 WORD\n-\tunsigned64 FRT;\n+uint64_t::function::DOUBLE:uint32_t WORD\n+\tuint64_t FRT;\n \tif (EXTRACTED32(WORD, 1, 8) > 0\n \t    && EXTRACTED32(WORD, 1, 8) < 255) {\n \t  /* normalized operand */\n@@ -1013,7 +1013,7 @@ unsigned64::function::DOUBLE:unsigned32 WORD\n \t  /* denormalized operand */\n \t  int sign = EXTRACTED32(WORD, 0, 0);\n \t  int exp = -126;\n-\t  unsigned64 frac = INSERTED64(EXTRACTED32(WORD, 9, 31), 1, (52 - 29));\n+\t  uint64_t frac = INSERTED64(EXTRACTED32(WORD, 9, 31), 1, (52 - 29));\n \t  /* normalize the operand */\n \t  while (MASKED64(frac, 0, 0) == 0) {\n \t    frac <<= 1;\n@@ -1038,8 +1038,8 @@ unsigned64::function::DOUBLE:unsigned32 WORD\n \treturn FRT;\n \n # Convert 64bit single to 32bit double\n-unsigned32::function::SINGLE:unsigned64 FRS\n-\tunsigned32 WORD;\n+uint32_t::function::SINGLE:uint64_t FRS\n+\tuint32_t WORD;\n \tif (EXTRACTED64(FRS, 1, 11) > 896\n \t    || EXTRACTED64(FRS, 1, 63) == 0) {\n \t  /* no denormalization required (includes Zero/Infinity/NaN) */\n@@ -1051,7 +1051,7 @@ unsigned32::function::SINGLE:unsigned64 FRS\n \t  /* denormalization required */\n \t  int sign = EXTRACTED64(FRS, 0, 0);\n \t  int exp = EXTRACTED64(FRS, 1, 11) - 1023;\n-\t  unsigned64 frac = (BIT64(0)\n+\t  uint64_t frac = (BIT64(0)\n \t                     | INSERTED64(EXTRACTED64(FRS, 12, 63), 1, 52));\n \t  /* denormalize the operand */\n \t  while (exp < -126) {\n@@ -1069,9 +1069,9 @@ unsigned32::function::SINGLE:unsigned64 FRS\n \n \n # round 64bit double to 64bit but single\n-void::function::Round_Single:cpu *processor, int sign, int *exp, unsigned64 *frac_grx\n+void::function::Round_Single:cpu *processor, int sign, int *exp, uint64_t *frac_grx\n \t/* comparisons ignore u bits */\n-\tunsigned64 out;\n+\tuint64_t out;\n \tint inc = 0;\n \tint lsb = EXTRACTED64(*frac_grx, 23, 23);\n \tint gbit = EXTRACTED64(*frac_grx, 24, 24);\n@@ -1106,7 +1106,7 @@ void::function::Round_Single:cpu *processor, int sign, int *exp, unsigned64 *fra\n \n \n #\n-void::function::Round_Integer:cpu *processor, int sign, unsigned64 *frac, int *frac64, int gbit, int rbit, int xbit, fpscreg round_mode\n+void::function::Round_Integer:cpu *processor, int sign, uint64_t *frac, int *frac64, int gbit, int rbit, int xbit, fpscreg round_mode\n \tint inc = 0;\n \tif (round_mode == fpscr_rn_round_to_nearest) {\n \t  if (*frac64 == 1 && gbit == 1) inc = 1;\n@@ -1130,7 +1130,7 @@ void::function::Round_Integer:cpu *processor, int sign, unsigned64 *frac, int *f\n \tFPSCR_SET_FI(gbit | rbit | xbit);\n \n \n-void::function::Round_Float:cpu *processor, int sign, int *exp, unsigned64 *frac, fpscreg round_mode\n+void::function::Round_Float:cpu *processor, int sign, int *exp, uint64_t *frac, fpscreg round_mode\n \tint carry_out;\n \tint inc = 0;\n \tint lsb = EXTRACTED64(*frac, 52, 52);\n@@ -1163,10 +1163,10 @@ void::function::Round_Float:cpu *processor, int sign, int *exp, unsigned64 *frac\n \n \n # conversion of FP to integer\n-void::function::convert_to_integer:cpu *processor, unsigned_word cia, unsigned64 *frt, unsigned64 frb, fpscreg round_mode, int tgt_precision\n+void::function::convert_to_integer:cpu *processor, unsigned_word cia, uint64_t *frt, uint64_t frb, fpscreg round_mode, int tgt_precision\n \tint i;\n \tint exp = 0;\n-\tunsigned64 frac = 0;\n+\tuint64_t frac = 0;\n \tint frac64 = 0;\n \tint gbit = 0;\n \tint rbit = 0;\n@@ -1206,16 +1206,16 @@ void::function::convert_to_integer:cpu *processor, unsigned_word cia, unsigned64\n \t    frac64 = (frac64 + 1) & 0x1;\n \t  }\n \t  if (tgt_precision == 32 /* can ignore frac64 in compare */\n-\t      && (signed64)frac > (signed64)MASK64(33+1, 63)/*2^31-1 >>1*/)\n+\t      && (int64_t)frac > (int64_t)MASK64(33+1, 63)/*2^31-1 >>1*/)\n \t    GOTO(Large_Operand);\n \t  if (tgt_precision == 64 /* can ignore frac64 in compare */\n-\t      && (signed64)frac > (signed64)MASK64(1+1, 63)/*2^63-1 >>1*/)\n+\t      && (int64_t)frac > (int64_t)MASK64(1+1, 63)/*2^63-1 >>1*/)\n \t    GOTO(Large_Operand);\n \t  if (tgt_precision == 32 /* can ignore frac64 in compare */\n-\t      && (signed64)frac < (signed64)MASK64(0, 32+1)/*-2^31 >>1*/)\n+\t      && (int64_t)frac < (int64_t)MASK64(0, 32+1)/*-2^31 >>1*/)\n \t    GOTO(Large_Operand);\n \t  if (tgt_precision == 64 /* can ignore frac64 in compare */\n-\t      && (signed64)frac < (signed64)MASK64(0, 0+1)/*-2^63 >>1*/)\n+\t      && (int64_t)frac < (int64_t)MASK64(0, 0+1)/*-2^63 >>1*/)\n \t    GOTO(Large_Operand);\n \t  FPSCR_SET_XX(FPSCR & fpscr_fi);\n \t  if (tgt_precision == 32)\n@@ -1284,67 +1284,67 @@ void::function::convert_to_integer:cpu *processor, unsigned_word cia, unsigned64\n \n \n # extract out raw fields of a FP number\n-int::function::sign:unsigned64 FRS\n+int::function::sign:uint64_t FRS\n \treturn (MASKED64(FRS, 0, 0)\n \t        ? -1\n \t        : 1);\n-int::function::biased_exp:unsigned64 frs, int single\n+int::function::biased_exp:uint64_t frs, int single\n \tif (single)\n \t  return EXTRACTED64(frs, 1, 8);\n \telse\n \t  return EXTRACTED64(frs, 1, 11);\n-unsigned64::function::fraction:unsigned64 frs, int single\n+uint64_t::function::fraction:uint64_t frs, int single\n \tif (single)\n \t  return EXTRACTED64(frs, 9, 31);\n \telse\n \t  return EXTRACTED64(frs, 12, 63);\n \n # a number?, each of the below return +1 or -1 (based on sign bit)\n # if true.\n-int::function::is_nor:unsigned64 frs, int single\n+int::function::is_nor:uint64_t frs, int single\n \tint exp = biased_exp(frs, single);\n \treturn (exp >= 1\n \t        && exp <= (single ? 254 : 2046));\n-int::function::is_zero:unsigned64 FRS\n+int::function::is_zero:uint64_t FRS\n \treturn (MASKED64(FRS, 1, 63) == 0\n \t        ? sign(FRS)\n \t        : 0);\n-int::function::is_den:unsigned64 frs, int single\n+int::function::is_den:uint64_t frs, int single\n \tint exp = biased_exp(frs, single);\n-\tunsigned64 frac = fraction(frs, single);\n+\tuint64_t frac = fraction(frs, single);\n \treturn (exp == 0 && frac != 0\n \t        ? sign(frs)\n \t        : 0);\n-int::function::is_inf:unsigned64 frs, int single\n+int::function::is_inf:uint64_t frs, int single\n \tint exp = biased_exp(frs, single);\n-\tunsigned64 frac = fraction(frs, single);\n+\tuint64_t frac = fraction(frs, single);\n \treturn (exp == (single ? 255 : 2047) && frac == 0\n \t        ? sign(frs)\n \t        : 0);\n-int::function::is_NaN:unsigned64 frs, int single\n+int::function::is_NaN:uint64_t frs, int single\n \tint exp = biased_exp(frs, single);\n-\tunsigned64 frac = fraction(frs, single);\n+\tuint64_t frac = fraction(frs, single);\n \treturn (exp == (single ? 255 : 2047) && frac != 0\n \t        ? sign(frs)\n \t        : 0);\n-int::function::is_SNaN:unsigned64 frs, int single\n+int::function::is_SNaN:uint64_t frs, int single\n \treturn (is_NaN(frs, single)\n \t        && !(frs & (single ? MASK64(9, 9) : MASK64(12, 12)))\n \t             ? sign(frs)\n \t             : 0);\n-int::function::is_QNaN:unsigned64 frs, int single\n+int::function::is_QNaN:uint64_t frs, int single\n \treturn (is_NaN(frs, single) && !is_SNaN(frs, single));\n-int::function::is_less_than:unsigned64 *fra, unsigned64 *frb\n+int::function::is_less_than:uint64_t *fra, uint64_t *frb\n \treturn *(double*)fra < *(double*)frb;\n-int::function::is_greater_than:unsigned64 *fra, unsigned64 *frb\n+int::function::is_greater_than:uint64_t *fra, uint64_t *frb\n \treturn *(double*)fra > *(double*)frb;\n-int::function::is_equan_to:unsigned64 *fra, unsigned64 *frb\n+int::function::is_equan_to:uint64_t *fra, uint64_t *frb\n \treturn *(double*)fra == *(double*)frb;\n \n \n # which quiet nan should become the result\n-unsigned64::function::select_qnan:unsigned64 fra, unsigned64 frb, unsigned64 frc, int instruction_is_frsp, int generate_qnan, int single\n-\tunsigned64 frt = 0;\n+uint64_t::function::select_qnan:uint64_t fra, uint64_t frb, uint64_t frc, int instruction_is_frsp, int generate_qnan, int single\n+\tuint64_t frt = 0;\n \tif (is_NaN(fra, single))\n \t  frt = fra;\n \telse if (is_NaN(frb, single))\n@@ -1362,7 +1362,7 @@ unsigned64::function::select_qnan:unsigned64 fra, unsigned64 frb, unsigned64 frc\n \n \n # detect invalid operation\n-int::function::is_invalid_operation:cpu *processor, unsigned_word cia, unsigned64 fra, unsigned64 frb, fpscreg check, int single, int negate\n+int::function::is_invalid_operation:cpu *processor, unsigned_word cia, uint64_t fra, uint64_t frb, fpscreg check, int single, int negate\n \tint fail = 0;\n \tif ((check & fpscr_vxsnan)\n \t    && (is_SNaN(fra, single) || is_SNaN(frb, single))) {\n@@ -1419,7 +1419,7 @@ int::function::is_invalid_operation:cpu *processor, unsigned_word cia, unsigned6\n \n \n # handle case of invalid operation\n-void::function::invalid_arithemetic_operation:cpu *processor, unsigned_word cia, unsigned64 *frt, unsigned64 fra, unsigned64 frb, unsigned64 frc, int instruction_is_frsp, int instruction_is_convert_to_64bit, int instruction_is_convert_to_32bit, int single\n+void::function::invalid_arithemetic_operation:cpu *processor, unsigned_word cia, uint64_t *frt, uint64_t fra, uint64_t frb, uint64_t frc, int instruction_is_frsp, int instruction_is_convert_to_64bit, int instruction_is_convert_to_32bit, int single\n \tif (FPSCR & fpscr_ve) {\n \t  /* invalid operation exception enabled */\n \t  /* FRT unchaged */\n@@ -1448,7 +1448,7 @@ void::function::invalid_arithemetic_operation:cpu *processor, unsigned_word cia,\n \n \n # detect divide by zero\n-int::function::is_invalid_zero_divide:cpu *processor, unsigned_word cia, unsigned64 fra, unsigned64 frb, int single\n+int::function::is_invalid_zero_divide:cpu *processor, unsigned_word cia, uint64_t fra, uint64_t frb, int single\n \tint fail = 0;\n \tif (is_zero (frb)) {\n \t  FPSCR_SET_ZX (1);\n@@ -1460,7 +1460,7 @@ int::function::is_invalid_zero_divide:cpu *processor, unsigned_word cia, unsigne\n \n \n # handle case of invalid operation\n-void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia, unsigned64 *frt, unsigned64 fra, unsigned64 frb, int single\n+void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia, uint64_t *frt, uint64_t fra, uint64_t frb, int single\n \tif (FPSCR & fpscr_ze) {\n \t  /* zero-divide exception enabled */\n \t  /* FRT unchaged */\n@@ -2696,9 +2696,9 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    5,  5,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    5,  5,  0\n *604: PPC_UNIT_MCIU,  PPC_UNIT_MCIU,  4,  4,  0\n-\tsigned64 a = (signed32)(*rA);\n-\tsigned64 b = (signed32)(*rB);\n-\tsigned64 prod = a * b;\n+\tint64_t a = (int32_t)(*rA);\n+\tint64_t b = (int32_t)(*rB);\n+\tint64_t prod = a * b;\n \tsigned_word t = prod;\n \t*rT = *rA * *rB;\n \tif (t != prod && OE)\n@@ -2713,9 +2713,9 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    5,  5,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    5,  5,  0\n *604: PPC_UNIT_MCIU,  PPC_UNIT_MCIU,  4,  4,  0\n-\tsigned64 a = (signed32)(*rA);\n-\tsigned64 b = (signed32)(*rB);\n-\tsigned64 prod = a * b;\n+\tint64_t a = (int32_t)(*rA);\n+\tint64_t b = (int32_t)(*rB);\n+\tint64_t prod = a * b;\n \tsigned_word t = EXTRACTED64(prod, 0, 31);\n \t*rT = t;\n \tCR0_COMPARE(t, 0, Rc);\n@@ -2728,9 +2728,9 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    6,  6,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    6,  6,  0\n *604: PPC_UNIT_MCIU,  PPC_UNIT_MCIU,  4,  4,  0\n-\tunsigned64 a = (unsigned32)(*rA);\n-\tunsigned64 b = (unsigned32)(*rB);\n-\tunsigned64 prod = a * b;\n+\tuint64_t a = (uint32_t)(*rA);\n+\tuint64_t b = (uint32_t)(*rB);\n+\tuint64_t prod = a * b;\n \tsigned_word t = EXTRACTED64(prod, 0, 31);\n \t*rT = t;\n \tCR0_COMPARE(t, 0, Rc);\n@@ -2743,16 +2743,16 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    37, 37, 0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    37, 37, 0\n *604: PPC_UNIT_MCIU,  PPC_UNIT_MCIU,  20, 20, 0\n-\tsigned64 dividend = (signed32)(*rA);\n-\tsigned64 divisor = (signed32)(*rB);\n+\tint64_t dividend = (int32_t)(*rA);\n+\tint64_t divisor = (int32_t)(*rB);\n \tif (divisor == 0 /* nb 0x8000..0 is sign extended */\n \t    || (dividend == 0x80000000 && divisor == -1)) {\n \t  if (OE)\n \t    XER |= (xer_overflow | xer_summary_overflow);\n \t  CR0_COMPARE(0, 0, Rc);\n \t}\n \telse {\n-\t  signed64 quotent = dividend / divisor;\n+\t  int64_t quotent = dividend / divisor;\n \t  *rT = quotent;\n \t  CR0_COMPARE((signed_word)quotent, 0, Rc);\n \t}\n@@ -2765,15 +2765,15 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    37, 37, 0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    37, 37, 0\n *604: PPC_UNIT_MCIU,  PPC_UNIT_MCIU,  20, 20, 0\n-\tunsigned64 dividend = (unsigned32)(*rA);\n-\tunsigned64 divisor = (unsigned32)(*rB);\n+\tuint64_t dividend = (uint32_t)(*rA);\n+\tuint64_t divisor = (uint32_t)(*rB);\n \tif (divisor == 0) {\n \t  if (OE)\n \t    XER |= (xer_overflow | xer_summary_overflow);\n \t  CR0_COMPARE(0, 0, Rc);\n \t}\n \telse {\n-\t  unsigned64 quotent = dividend / divisor;\n+\t  uint64_t quotent = dividend / divisor;\n \t  *rT = quotent;\n \t  CR0_COMPARE((signed_word)quotent, 0, Rc);\n \t}\n@@ -3088,7 +3088,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n-\t*rA = (signed_word)(signed8)*rS;\n+\t*rA = (signed_word)(int8_t)*rS;\n \tCR0_COMPARE(*rA, 0, Rc);\n \tITRACE(trace_alu, (\" Result = %ld (0x%lx)\\n\", (long)*rA, (long)*rA));\n \tPPC_INSN_INT(RA_BITMASK, RS_BITMASK, Rc);\n@@ -3098,7 +3098,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n-\t*rA = (signed_word)(signed16)*rS;\n+\t*rA = (signed_word)(int16_t)*rS;\n \tCR0_COMPARE(*rA, 0, Rc);\n \tITRACE(trace_alu, (\" Result = %ld (0x%lx)\\n\", (long)*rA, (long)*rA));\n \tPPC_INSN_INT(RA_BITMASK, RS_BITMASK, Rc);\n@@ -3108,13 +3108,13 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n-#\t*rA = (signed_word)(signed32)*rS;\n+#\t*rA = (signed_word)(int32_t)*rS;\n #\tCR0_COMPARE(*rA, 0, Rc);\n \n 0.31,6.RS,11.RA,16./,21.58,31.Rc:X:64::Count Leading Zeros Doubleword\n #\tint count = 0;\n-#\tunsigned64 mask = BIT64(0);\n-#\tunsigned64 source = *rS;\n+#\tuint64_t mask = BIT64(0);\n+#\tuint64_t source = *rS;\n #\twhile (!(source & mask) && mask != 0) {\n #\t  mask >>= 1;\n #\t  count++;\n@@ -3128,8 +3128,8 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n \tint count = 0;\n-\tunsigned32 mask = BIT32(0);\n-\tunsigned32 source = *rS;\n+\tuint32_t mask = BIT32(0);\n+\tuint32_t source = *rS;\n \twhile (!(source & mask) && mask != 0) {\n \t  mask >>= 1;\n \t  count++;\n@@ -3177,9 +3177,9 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n \tlong n = SH;\n-\tunsigned32 s = *rS;\n-\tunsigned32 r = ROTL32(s, n);\n-\tunsigned32 m = MASK(MB+32, ME+32);\n+\tuint32_t s = *rS;\n+\tuint32_t r = ROTL32(s, n);\n+\tuint32_t m = MASK(MB+32, ME+32);\n \tsigned_word result = r & m;\n \t*rA = result;\n \tCR0_COMPARE(result, 0, Rc);\n@@ -3209,8 +3209,8 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \n 0.23,6.RS,11.RA,16.RB,21.MB,26.ME,31.Rc:M:::Rotate Left Word then AND with Mask\n \tlong n = MASKED(*rB, 59, 63);\n-\tunsigned32 r = ROTL32(*rS, n);\n-\tunsigned32 m = MASK(MB+32, ME+32);\n+\tuint32_t r = ROTL32(*rS, n);\n+\tuint32_t m = MASK(MB+32, ME+32);\n \tsigned_word result = r & m;\n \t*rA = result;\n \tCR0_COMPARE(result, 0, Rc);\n@@ -3230,8 +3230,8 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n \tlong n = SH;\n-\tunsigned32 r = ROTL32(*rS, n);\n-\tunsigned32 m = MASK(MB+32, ME+32);\n+\tuint32_t r = ROTL32(*rS, n);\n+\tuint32_t m = MASK(MB+32, ME+32);\n \tsigned_word result = (r & m) | (*rA & ~m);\n \t*rA = result;\n \tITRACE(trace_alu, (\": n=%ld *rS=0x%lx r=0x%lx m=0x%lx result=0x%lx\\n\",\n@@ -3249,7 +3249,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n \tint n = MASKED(*rB, 58, 63);\n-\tunsigned32 source = *rS;\n+\tuint32_t source = *rS;\n \tsigned_word shifted;\n \tif (n < 32)\n \t  shifted = (source << n);\n@@ -3270,7 +3270,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n \tint n = MASKED(*rB, 58, 63);\n-\tunsigned32 source = *rS;\n+\tuint32_t source = *rS;\n \tsigned_word shifted;\n \tif (n < 32)\n \t  shifted = (source >> n);\n@@ -3312,18 +3312,18 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *603e:PPC_UNIT_IU,    PPC_UNIT_IU,    1,  1,  0\n *604: PPC_UNIT_SCIU1, PPC_UNIT_SCIU2, 1,  1,  0\n-\tunsigned64 mask;\n+\tuint64_t mask;\n \tint n = MASKED(*rB, 59, 63);\n-\tsigned32 source = (signed32)*rS; /* signed to keep sign bit */\n+\tint32_t source = (int32_t)*rS; /* signed to keep sign bit */\n \tint S = (MASKED(*rS,32,32) != 0);\n-\tsigned64 r = ((unsigned64) source);\n-\tr = ((unsigned64) source) << 32 | (unsigned32) source;\n+\tint64_t r = ((uint64_t) source);\n+\tr = ((uint64_t) source) << 32 | (uint32_t) source;\n \tr = ROTL64(r,64-n);\n \tif (MASKED(*rB,58,58) == 0)\n-\t\tmask = (unsigned64) MASK64(n+32,63);\n+\t\tmask = (uint64_t) MASK64(n+32,63);\n \telse\n-\t\tmask = (unsigned64) 0;\n-\t*rA = (signed_word) ((r & mask) | (((signed64) -1*S) & ~mask)); /* if 64bit will sign extend */\n+\t\tmask = (uint64_t) 0;\n+\t*rA = (signed_word) ((r & mask) | (((int64_t) -1*S) & ~mask)); /* if 64bit will sign extend */\n \tif (S && (MASKED(r & ~mask,32,63)!=0))\n \t  XER |= xer_carry;\n \telse\n@@ -3450,7 +3450,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *603: PPC_UNIT_SRU,   PPC_UNIT_SRU,   1,  1,  0\n *603e:PPC_UNIT_SRU,   PPC_UNIT_SRU,   1,  1,  0\n *604: PPC_UNIT_MCIU,  PPC_UNIT_MCIU,  3,  3,  0\n-\t*rT = (unsigned32)CR;\n+\t*rT = (uint32_t)CR;\n \tPPC_INSN_MFCR(RT_BITMASK);\n \n #\n@@ -3971,7 +3971,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         0, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4018,7 +4018,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         1, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4065,7 +4065,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         0, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4112,7 +4112,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         1, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4159,7 +4159,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         0, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4206,7 +4206,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         1, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4253,7 +4253,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         0, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4300,7 +4300,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \t                         fpscr_vxsnan | fpscr_vximz,\n \t                         1, /*single?*/\n \t                         0) /*negate?*/) {\n-\t  union { double d; unsigned64 u; } tmp;\n+\t  union { double d; uint64_t u; } tmp;\n \t  invalid_arithemetic_operation(processor, cia,\n \t                                &tmp.u, *frA, 0, *frC,\n \t                                0, /*instruction_is_frsp*/\n@@ -4346,7 +4346,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n *604: PPC_UNIT_FPU,   PPC_UNIT_FPU,   1,  3,  0\n \tint sign;\n \tint exp;\n-\tunsigned64 frac_grx;\n+\tuint64_t frac_grx;\n \t/***/\n \t  /* split off cases for what to do */\n \t  if (EXTRACTED64(*frB, 1, 11) < 897\n@@ -4582,7 +4582,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n 0.63,6.FRT,11./,16.FRB,21.846,31.Rc:X:64,f::Floating Convert from Integer Doubleword\n \tint sign = EXTRACTED64(*frB, 0, 0);\n \tint exp = 63;\n-\tunsigned64 frac = *frB;\n+\tuint64_t frac = *frB;\n \t/***/\n \t  if (frac == 0) GOTO(Zero_Operand);\n \t  if (sign == 1) frac = ~frac + 1;\n@@ -4699,13 +4699,13 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \n 0.63,6.BT,11./,16./,21.70,31.Rc:X:f::Move To FPSCR Bit 0\n \tFPSCR_BEGIN;\n-\tunsigned32 bit = BIT32(BT);\n+\tuint32_t bit = BIT32(BT);\n \tFPSCR &= ~bit;\n \tFPSCR_END(Rc);\n \n 0.63,6.BT,11./,16./,21.38,31.Rc:X:f::Move To FPSCR Bit 1\n \tFPSCR_BEGIN;\n-\tunsigned32 bit = BIT32(BT);\n+\tuint32_t bit = BIT32(BT);\n \tif (bit & fpscr_fi)\n \t  bit |= fpscr_xx;\n \tif ((bit & fpscr_vx_bits))\n@@ -4744,7 +4744,7 @@ void::function::invalid_zero_divide_operation:cpu *processor, unsigned_word cia,\n \tif (CURRENT_MODEL == MODEL_ppc601) {\n \t  program_interrupt(processor, cia, optional_instruction_program_interrupt);\n \t} else {\n-\t  unsigned64 zero = 0;\n+\t  uint64_t zero = 0;\n \t  FPSCR_BEGIN;\n \t  if (is_NaN(*frA, 0) || is_less_than (frA, &zero)) *frT = *frB;\n \t  else\t\t\t\t\t\t    *frT = *frC;"
    },
    {
      "sha": "9f1db675e509f63080327c2c31ea659df03320b2",
      "filename": "sim/ppc/psim.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/psim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/psim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/psim.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -873,7 +873,7 @@ psim_read_register(psim *system,\n     break;\n \n   case reg_evr:\n-    *(unsigned64*)cooked_buf = EVR(description.index);\n+    *(uint64_t*)cooked_buf = EVR(description.index);\n     break;\n \n   case reg_acc:\n@@ -1046,8 +1046,8 @@ psim_write_register(psim *system,\n \n   case reg_evr:\n     {\n-      unsigned64 v;\n-      v = *(unsigned64*)cooked_buf;\n+      uint64_t v;\n+      v = *(uint64_t*)cooked_buf;\n       cpu_registers(processor)->e500.gprh[description.index] = v >> 32;\n       cpu_registers(processor)->gpr[description.index] = v;\n       break;"
    },
    {
      "sha": "0ebb2a7a99d040a7c4e48d546ebf68f107834c0b",
      "filename": "sim/ppc/registers.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/registers.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/registers.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/registers.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -155,7 +155,7 @@ register_description(const char reg[])\n   else if (reg[0] == 'e' && reg[1] == 'v' && are_digits(reg + 2)) {\n     description.type = reg_evr;\n     description.index = atoi(reg+2);\n-    description.size = sizeof(unsigned64);\n+    description.size = sizeof(uint64_t);\n   }\n   else if (reg[0] == 'r' && reg[1] == 'h' && are_digits(reg + 2)) {\n     description.type = reg_gprh;\n@@ -165,7 +165,7 @@ register_description(const char reg[])\n   else if (!strcmp(reg, \"acc\")) {\n     description.type = reg_acc;\n     description.index = 0;\n-    description.size = sizeof(unsigned64);\n+    description.size = sizeof(uint64_t);\n   }\n #endif\n   else {"
    },
    {
      "sha": "eb15bca03802b6e4409cb9dbb264a78990dfecf3",
      "filename": "sim/ppc/registers.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/registers.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/registers.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/registers.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -53,7 +53,7 @@ typedef signed_word gpreg;\n  ** Floating Point Registers\n  **/\n \n-typedef unsigned64 fpreg;\n+typedef uint64_t fpreg;\n \n \n \n@@ -62,7 +62,7 @@ typedef unsigned64 fpreg;\n  **\n  **/\n \n-typedef unsigned32 creg;\n+typedef uint32_t creg;\n \n /* The following sub bits are defined for the condition register */\n enum {\n@@ -106,7 +106,7 @@ enum {\n  ** Floating-Point Status and Control Register\n  **/\n \n-typedef unsigned32 fpscreg;\n+typedef uint32_t fpscreg;\n enum {\n   fpscr_fx_bit = 0,\n   fpscr_fx = BIT32(0),\n@@ -170,7 +170,7 @@ enum {\n  ** XER Register\n  **/\n \n-typedef unsigned32 xereg;\n+typedef uint32_t xereg;\n \n enum {\n   xer_summary_overflow = BIT32(0), xer_summary_overflow_bit = 0,\n@@ -192,7 +192,7 @@ enum {\n  ** Segment Registers\n  **/\n \n-typedef unsigned32 sreg;\n+typedef uint32_t sreg;\n enum {\n   nr_of_srs = 16\n };"
    },
    {
      "sha": "3a9c2e71f9a6bb807b110e0b4f6440be7abb15d3",
      "filename": "sim/ppc/sim-main.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/sim-main.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -1,6 +1,6 @@\n #include \"sim-basics.h\"\n \n-typedef unsigned32 sim_cia;\n+typedef uint32_t sim_cia;\n \n #include \"sim-base.h\"\n "
    },
    {
      "sha": "6d20665505ea4b9b8909b3a310771f18c880ef59",
      "filename": "sim/ppc/tree.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/tree.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/tree.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/tree.c?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -855,7 +855,7 @@ tree_parse(device *current,\n \tbreak;\n       case '[':\n \t{\n-\t  unsigned8 words[1024];\n+\t  uint8_t words[1024];\n \t  char *curr = spec.value + 1;\n \t  int nr_words = 0;\n \t  while (1) {\n@@ -1050,7 +1050,7 @@ print_properties(device *me)\n \t  }\n \t}\n \telse {\n-\t  unsigned8 *w = (unsigned8*)property->array;\n+\t  uint8_t *w = (uint8_t*)property->array;\n \t  printf_filtered(\" [\");\n \t  while ((char*)w - (char*)property->array < property->sizeof_array) {\n \t    printf_filtered(\" 0x%2x\", BE2H_1(*w));"
    },
    {
      "sha": "e4a9ec13f2833e19d4c9b3acbb28bd259e4c929c",
      "filename": "sim/ppc/words.h",
      "status": "modified",
      "additions": 17,
      "deletions": 28,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/words.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/95e40d770e95c0d5317c2566a7976bd3421f380a/sim/ppc/words.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ppc/words.h?ref=95e40d770e95c0d5317c2566a7976bd3421f380a",
      "patch": "@@ -27,8 +27,8 @@\n \n /* TYPES:\n \n-     signed*    signed type of the given size\n-     unsigned*  The corresponding insigned type\n+     intNN_t    Signed type of the given bit size\n+     uintNN_t   The corresponding unsigned type\n \n    SIZES\n \n@@ -47,27 +47,16 @@\n \n #include <stdint.h>\n \n-/* bit based */\n-typedef int8_t signed8;\n-typedef int16_t signed16;\n-typedef int32_t signed32;\n-typedef int64_t signed64;\n-\n-typedef uint8_t unsigned8;\n-typedef uint16_t unsigned16;\n-typedef uint32_t unsigned32;\n-typedef uint64_t unsigned64;\n-\n /* byte based */\n-typedef signed8 signed_1;\n-typedef signed16 signed_2;\n-typedef signed32 signed_4;\n-typedef signed64 signed_8;\n+typedef int8_t signed_1;\n+typedef int16_t signed_2;\n+typedef int32_t signed_4;\n+typedef int64_t signed_8;\n \n-typedef unsigned8 unsigned_1;\n-typedef unsigned16 unsigned_2;\n-typedef unsigned32 unsigned_4;\n-typedef unsigned64 unsigned_8;\n+typedef uint8_t unsigned_1;\n+typedef uint16_t unsigned_2;\n+typedef uint32_t unsigned_4;\n+typedef uint64_t unsigned_8;\n \n \n /* for general work, the following are defined */\n@@ -78,19 +67,19 @@ typedef unsigned64 unsigned_8;\n \n /* target architecture based */\n #if (WITH_TARGET_WORD_BITSIZE == 64)\n-typedef unsigned64 unsigned_word;\n-typedef signed64 signed_word;\n+typedef uint64_t unsigned_word;\n+typedef int64_t signed_word;\n #else\n-typedef unsigned32 unsigned_word;\n-typedef signed32 signed_word;\n+typedef uint32_t unsigned_word;\n+typedef int32_t signed_word;\n #endif\n \n \n /* Other instructions */\n-typedef unsigned32 instruction_word;\n+typedef uint32_t instruction_word;\n \n /* IEEE 1275 cell size - only support 32bit mode at present */\n-typedef unsigned32 unsigned_cell;\n-typedef signed32 signed_cell;\n+typedef uint32_t unsigned_cell;\n+typedef int32_t signed_cell;\n \n #endif /* _WORDS_H_ */"
    }
  ]
}