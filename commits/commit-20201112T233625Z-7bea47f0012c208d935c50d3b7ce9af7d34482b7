{
  "sha": "7bea47f0012c208d935c50d3b7ce9af7d34482b7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2JlYTQ3ZjAwMTJjMjA4ZDkzNWM1MGQzYjdjZTlhZjdkMzQ0ODJiNw==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-10-30T20:40:59Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-11-12T23:36:25Z"
    },
    "message": "gdb: rewrite how per language primitive types are managed\n\nConsider the following GDB session:\n\n  $ gdb\n  (gdb) set language c\n  (gdb) ptype void\n  type = void\n  (gdb) set language fortran\n  (gdb) ptype void\n  No symbol table is loaded.  Use the \"file\" command.\n  (gdb)\n\nWith no symbol file loaded GDB and the language set to C GDB knows\nabout the type void, while when the language is set to Fortran GDB\ndoesn't know about the void, why is that?\n\nIn f-lang.c, f_language::language_arch_info, we do have this line:\n\n  lai->primitive_type_vector [f_primitive_type_void]\n    = builtin->builtin_void;\n\nwhere we add the void type to the list of primitive types that GDB\nshould always know about, so what's going wrong?\n\nIt turns out that the primitive types are stored in a C style array,\nindexed by an enum, so Fortran uses `enum f_primitive_types'.  The\narray is allocated and populated in each languages language_arch_info\nmember function.  The array is allocated with an extra entry at the\nend which is left as a NULL value, and this indicates the end of the\narray of types.\n\nUnfortunately for Fortran, a type is not assigned for each element in\nthe enum.  As a result the final populated array has gaps in it, gaps\nwhich are initialised to NULL, and so every time we iterate over the\nlist (for Fortran) we stop early, and never reach the void type.\n\nThis has been the case since 2007 when this functionality was added to\nGDB in commit cad351d11d6c3f6487cd.\n\nObviously I could just fix Fortran by ensuring that either the enum is\ntrimmed, or we create types for the missing types.  However, I think a\nbetter approach would be to move to C++ data structures and removed\nthe fixed enum indexing into the array approach.\n\nAfter this commit the primitive types are pushed into a vector, and\nGDB just iterates over the vector in the obvious way when it needs to\nhunt for a type.  After this commit all the currently defined\nprimitive types can be found when the language is set to Fortran, for\nexample:\n\n  $ gdb\n  (gdb) set language fortran\n  (gdb) ptype void\n  type = void\n  (gdb)\n\nA new test checks this functionality.\n\nI didn't see any other languages with similar issues, but I could have\nmissed something.\n\ngdb/ChangeLog:\n\n\t* ada-exp.y (find_primitive_type): Make parameter const.\n\t* ada-lang.c (enum ada_primitive_types): Delete.\n\t(ada_language::language_arch_info): Update.\n\t* c-lang.c (enum c_primitive_types): Delete.\n\t(c_language_arch_info): Update.\n\t(enum cplus_primitive_types): Delete.\n\t(cplus_language::language_arch_info): Update.\n\t* d-lang.c (enum d_primitive_types): Delete.\n\t(d_language::language_arch_info): Update.\n\t* f-lang.c (enum f_primitive_types): Delete.\n\t(f_language::language_arch_info): Update.\n\t* go-lang.c (enum go_primitive_types): Delete.\n\t(go_language::language_arch_info): Update.\n\t* language.c (auto_or_unknown_language::language_arch_info):\n\tUpdate.\n\t(language_gdbarch_post_init): Use obstack_new, use array indexing.\n\t(language_string_char_type): Add header comment, call function in\n\tlanguage_arch_info.\n\t(language_bool_type): Likewise\n\t(language_arch_info::bool_type): Define.\n\t(language_lookup_primitive_type_1): Delete.\n\t(language_lookup_primitive_type): Rewrite as a templated function\n\tto call function in language_arch_info, then instantiate twice.\n\t(language_arch_info::type_and_symbol::alloc_type_symbol): Define.\n\t(language_arch_info::lookup_primitive_type_and_symbol): Define.\n\t(language_arch_info::lookup_primitive_type): Define twice with\n\tdifferent signatures.\n\t(language_arch_info::lookup_primitive_type_as_symbol): Define.\n\t(language_lookup_primitive_type_as_symbol): Rewrite to call a\n\tmember function in language_arch_info.\n\t* language.h (language_arch_info): Complete rewrite.\n\t(language_lookup_primitive_type): Make templated.\n\t* m2-lang.c (enum m2_primitive_types): Delete.\n\t(m2_language::language_arch_info): Update.\n\t* opencl-lang.c (OCL_P_TYPE): Delete.\n\t(enum opencl_primitive_types): Delete.\n\t(opencl_type_data): Delete.\n\t(builtin_opencl_type): Delete.\n\t(lookup_opencl_vector_type): Update.\n\t(opencl_language::language_arch_info): Update, lots of content\n\tmoved from...\n\t(build_opencl_types): ...here.  This function is now deleted.\n\t(_initialize_opencl_language): Delete.\n\t* p-lang.c (enum pascal_primitive_types): Delete.\n\t(pascal_language::language_arch_info): Update.\n\t* rust-lang.c (enum rust_primitive_types): Delete.\n\t(rust_language::language_arch_info): Update.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/types.exp: Add more tests.",
    "tree": {
      "sha": "2af27e112306612fdb6c55597687ef6640f312e0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2af27e112306612fdb6c55597687ef6640f312e0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7bea47f0012c208d935c50d3b7ce9af7d34482b7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7bea47f0012c208d935c50d3b7ce9af7d34482b7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7bea47f0012c208d935c50d3b7ce9af7d34482b7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7bea47f0012c208d935c50d3b7ce9af7d34482b7/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bf6e5d01d7b149e116a008bd4348983c6f56e9ba",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf6e5d01d7b149e116a008bd4348983c6f56e9ba",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bf6e5d01d7b149e116a008bd4348983c6f56e9ba"
    }
  ],
  "stats": {
    "total": 1446,
    "additions": 630,
    "deletions": 816
  },
  "files": [
    {
      "sha": "4ab418396f641fa6d618494eaf453c6488c28970",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -1,3 +1,53 @@\n+2020-11-12  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* ada-exp.y (find_primitive_type): Make parameter const.\n+\t* ada-lang.c (enum ada_primitive_types): Delete.\n+\t(ada_language::language_arch_info): Update.\n+\t* c-lang.c (enum c_primitive_types): Delete.\n+\t(c_language_arch_info): Update.\n+\t(enum cplus_primitive_types): Delete.\n+\t(cplus_language::language_arch_info): Update.\n+\t* d-lang.c (enum d_primitive_types): Delete.\n+\t(d_language::language_arch_info): Update.\n+\t* f-lang.c (enum f_primitive_types): Delete.\n+\t(f_language::language_arch_info): Update.\n+\t* go-lang.c (enum go_primitive_types): Delete.\n+\t(go_language::language_arch_info): Update.\n+\t* language.c (auto_or_unknown_language::language_arch_info):\n+\tUpdate.\n+\t(language_gdbarch_post_init): Use obstack_new, use array indexing.\n+\t(language_string_char_type): Add header comment, call function in\n+\tlanguage_arch_info.\n+\t(language_bool_type): Likewise\n+\t(language_arch_info::bool_type): Define.\n+\t(language_lookup_primitive_type_1): Delete.\n+\t(language_lookup_primitive_type): Rewrite as a templated function\n+\tto call function in language_arch_info, then instantiate twice.\n+\t(language_arch_info::type_and_symbol::alloc_type_symbol): Define.\n+\t(language_arch_info::lookup_primitive_type_and_symbol): Define.\n+\t(language_arch_info::lookup_primitive_type): Define twice with\n+\tdifferent signatures.\n+\t(language_arch_info::lookup_primitive_type_as_symbol): Define.\n+\t(language_lookup_primitive_type_as_symbol): Rewrite to call a\n+\tmember function in language_arch_info.\n+\t* language.h (language_arch_info): Complete rewrite.\n+\t(language_lookup_primitive_type): Make templated.\n+\t* m2-lang.c (enum m2_primitive_types): Delete.\n+\t(m2_language::language_arch_info): Update.\n+\t* opencl-lang.c (OCL_P_TYPE): Delete.\n+\t(enum opencl_primitive_types): Delete.\n+\t(opencl_type_data): Delete.\n+\t(builtin_opencl_type): Delete.\n+\t(lookup_opencl_vector_type): Update.\n+\t(opencl_language::language_arch_info): Update, lots of content\n+\tmoved from...\n+\t(build_opencl_types): ...here.  This function is now deleted.\n+\t(_initialize_opencl_language): Delete.\n+\t* p-lang.c (enum pascal_primitive_types): Delete.\n+\t(pascal_language::language_arch_info): Update.\n+\t* rust-lang.c (enum rust_primitive_types): Delete.\n+\t(rust_language::language_arch_info): Update.\n+\n 2020-11-12  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.c (dw2_do_instantiate_symtab): Fix call to"
    },
    {
      "sha": "636ec5845b9256ee68ed73888f3f6497503ae43f",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -1026,7 +1026,7 @@ select_possible_type_sym (const std::vector<struct block_symbol> &syms)\n }\n \n static struct type*\n-find_primitive_type (struct parser_state *par_state, char *name)\n+find_primitive_type (struct parser_state *par_state, const char *name)\n {\n   struct type *type;\n   type = language_lookup_primitive_type (par_state->language (),"
    },
    {
      "sha": "714227d24dd5402cb9efec6172587730cf3b61c8",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 38,
      "deletions": 68,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -13594,24 +13594,6 @@ static const struct op_print ada_op_print_tab[] = {\n   {\"'size\", OP_ATR_SIZE, PREC_SUFFIX, 1},\n   {NULL, OP_NULL, PREC_SUFFIX, 0}\n };\n-\f\n-enum ada_primitive_types {\n-  ada_primitive_type_int,\n-  ada_primitive_type_long,\n-  ada_primitive_type_short,\n-  ada_primitive_type_char,\n-  ada_primitive_type_float,\n-  ada_primitive_type_double,\n-  ada_primitive_type_void,\n-  ada_primitive_type_long_long,\n-  ada_primitive_type_long_double,\n-  ada_primitive_type_natural,\n-  ada_primitive_type_positive,\n-  ada_primitive_type_system_address,\n-  ada_primitive_type_storage_offset,\n-  nr_ada_primitive_types\n-};\n-\n \f\n \t\t\t\t/* Language vector */\n \n@@ -13838,63 +13820,51 @@ class ada_language : public language_defn\n   {\n     const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-    lai->primitive_type_vector\n-      = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_ada_primitive_types + 1,\n-\t\t\t\tstruct type *);\n-\n-    lai->primitive_type_vector [ada_primitive_type_int]\n-      = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),\n-\t\t\t   0, \"integer\");\n-    lai->primitive_type_vector [ada_primitive_type_long]\n-      = arch_integer_type (gdbarch, gdbarch_long_bit (gdbarch),\n-\t\t\t   0, \"long_integer\");\n-    lai->primitive_type_vector [ada_primitive_type_short]\n-      = arch_integer_type (gdbarch, gdbarch_short_bit (gdbarch),\n-\t\t\t   0, \"short_integer\");\n-    lai->string_char_type\n-      = lai->primitive_type_vector [ada_primitive_type_char]\n-      = arch_character_type (gdbarch, TARGET_CHAR_BIT, 0, \"character\");\n-    lai->primitive_type_vector [ada_primitive_type_float]\n-      = arch_float_type (gdbarch, gdbarch_float_bit (gdbarch),\n-\t\t\t \"float\", gdbarch_float_format (gdbarch));\n-    lai->primitive_type_vector [ada_primitive_type_double]\n-      = arch_float_type (gdbarch, gdbarch_double_bit (gdbarch),\n-\t\t\t \"long_float\", gdbarch_double_format (gdbarch));\n-    lai->primitive_type_vector [ada_primitive_type_long_long]\n-      = arch_integer_type (gdbarch, gdbarch_long_long_bit (gdbarch),\n-\t\t\t   0, \"long_long_integer\");\n-    lai->primitive_type_vector [ada_primitive_type_long_double]\n-      = arch_float_type (gdbarch, gdbarch_long_double_bit (gdbarch),\n-\t\t\t \"long_long_float\", gdbarch_long_double_format (gdbarch));\n-    lai->primitive_type_vector [ada_primitive_type_natural]\n-      = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),\n-\t\t\t   0, \"natural\");\n-    lai->primitive_type_vector [ada_primitive_type_positive]\n-      = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),\n-\t\t\t   0, \"positive\");\n-    lai->primitive_type_vector [ada_primitive_type_void]\n-      = builtin->builtin_void;\n-\n-    lai->primitive_type_vector [ada_primitive_type_system_address]\n+    /* Helper function to allow shorter lines below.  */\n+    auto add = [&] (struct type *t)\n+    {\n+      lai->add_primitive_type (t);\n+    };\n+\n+    add (arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),\n+\t\t\t    0, \"integer\"));\n+    add (arch_integer_type (gdbarch, gdbarch_long_bit (gdbarch),\n+\t\t\t    0, \"long_integer\"));\n+    add (arch_integer_type (gdbarch, gdbarch_short_bit (gdbarch),\n+\t\t\t    0, \"short_integer\"));\n+    struct type *char_type = arch_character_type (gdbarch, TARGET_CHAR_BIT,\n+\t\t\t\t\t\t  0, \"character\");\n+    lai->set_string_char_type (char_type);\n+    add (char_type);\n+    add (arch_float_type (gdbarch, gdbarch_float_bit (gdbarch),\n+\t\t\t  \"float\", gdbarch_float_format (gdbarch)));\n+    add (arch_float_type (gdbarch, gdbarch_double_bit (gdbarch),\n+\t\t\t  \"long_float\", gdbarch_double_format (gdbarch)));\n+    add (arch_integer_type (gdbarch, gdbarch_long_long_bit (gdbarch),\n+\t\t\t    0, \"long_long_integer\"));\n+    add (arch_float_type (gdbarch, gdbarch_long_double_bit (gdbarch),\n+\t\t\t  \"long_long_float\",\n+\t\t\t  gdbarch_long_double_format (gdbarch)));\n+    add (arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),\n+\t\t\t    0, \"natural\"));\n+    add (arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),\n+\t\t\t    0, \"positive\"));\n+    add (builtin->builtin_void);\n+\n+    struct type *system_addr_ptr\n       = lookup_pointer_type (arch_type (gdbarch, TYPE_CODE_VOID, TARGET_CHAR_BIT,\n \t\t\t\t\t\"void\"));\n-    lai->primitive_type_vector [ada_primitive_type_system_address]\n-      ->set_name (\"system__address\");\n+    system_addr_ptr->set_name (\"system__address\");\n+    add (system_addr_ptr);\n \n     /* Create the equivalent of the System.Storage_Elements.Storage_Offset\n        type.  This is a signed integral type whose size is the same as\n        the size of addresses.  */\n-    {\n-      unsigned int addr_length = TYPE_LENGTH\n-\t(lai->primitive_type_vector [ada_primitive_type_system_address]);\n-\n-      lai->primitive_type_vector [ada_primitive_type_storage_offset]\n-\t= arch_integer_type (gdbarch, addr_length * HOST_CHAR_BIT, 0,\n-\t\t\t     \"storage_offset\");\n-    }\n+    unsigned int addr_length = TYPE_LENGTH (system_addr_ptr);\n+    add (arch_integer_type (gdbarch, addr_length * HOST_CHAR_BIT, 0,\n+\t\t\t    \"storage_offset\"));\n \n-    lai->bool_type_symbol = NULL;\n-    lai->bool_type_default = builtin->builtin_bool;\n+    lai->set_bool_type (builtin->builtin_bool);\n   }\n \n   /* See language.h.  */"
    },
    {
      "sha": "8dbce39893237bba9609c51e3bee34cb93d65a49",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 62,
      "deletions": 132,
      "changes": 194,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -803,62 +803,42 @@ const struct op_print c_op_print_tab[] =\n   {NULL, OP_NULL, PREC_PREFIX, 0}\n };\n \f\n-enum c_primitive_types {\n-  c_primitive_type_int,\n-  c_primitive_type_long,\n-  c_primitive_type_short,\n-  c_primitive_type_char,\n-  c_primitive_type_float,\n-  c_primitive_type_double,\n-  c_primitive_type_void,\n-  c_primitive_type_long_long,\n-  c_primitive_type_signed_char,\n-  c_primitive_type_unsigned_char,\n-  c_primitive_type_unsigned_short,\n-  c_primitive_type_unsigned_int,\n-  c_primitive_type_unsigned_long,\n-  c_primitive_type_unsigned_long_long,\n-  c_primitive_type_long_double,\n-  c_primitive_type_complex,\n-  c_primitive_type_double_complex,\n-  c_primitive_type_decfloat,\n-  c_primitive_type_decdouble,\n-  c_primitive_type_declong,\n-  nr_c_primitive_types\n-};\n \n void\n c_language_arch_info (struct gdbarch *gdbarch,\n \t\t      struct language_arch_info *lai)\n {\n   const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-  lai->string_char_type = builtin->builtin_char;\n-  lai->primitive_type_vector\n-    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_c_primitive_types + 1,\n-\t\t\t      struct type *);\n-  lai->primitive_type_vector [c_primitive_type_int] = builtin->builtin_int;\n-  lai->primitive_type_vector [c_primitive_type_long] = builtin->builtin_long;\n-  lai->primitive_type_vector [c_primitive_type_short] = builtin->builtin_short;\n-  lai->primitive_type_vector [c_primitive_type_char] = builtin->builtin_char;\n-  lai->primitive_type_vector [c_primitive_type_float] = builtin->builtin_float;\n-  lai->primitive_type_vector [c_primitive_type_double] = builtin->builtin_double;\n-  lai->primitive_type_vector [c_primitive_type_void] = builtin->builtin_void;\n-  lai->primitive_type_vector [c_primitive_type_long_long] = builtin->builtin_long_long;\n-  lai->primitive_type_vector [c_primitive_type_signed_char] = builtin->builtin_signed_char;\n-  lai->primitive_type_vector [c_primitive_type_unsigned_char] = builtin->builtin_unsigned_char;\n-  lai->primitive_type_vector [c_primitive_type_unsigned_short] = builtin->builtin_unsigned_short;\n-  lai->primitive_type_vector [c_primitive_type_unsigned_int] = builtin->builtin_unsigned_int;\n-  lai->primitive_type_vector [c_primitive_type_unsigned_long] = builtin->builtin_unsigned_long;\n-  lai->primitive_type_vector [c_primitive_type_unsigned_long_long] = builtin->builtin_unsigned_long_long;\n-  lai->primitive_type_vector [c_primitive_type_long_double] = builtin->builtin_long_double;\n-  lai->primitive_type_vector [c_primitive_type_complex] = builtin->builtin_complex;\n-  lai->primitive_type_vector [c_primitive_type_double_complex] = builtin->builtin_double_complex;\n-  lai->primitive_type_vector [c_primitive_type_decfloat] = builtin->builtin_decfloat;\n-  lai->primitive_type_vector [c_primitive_type_decdouble] = builtin->builtin_decdouble;\n-  lai->primitive_type_vector [c_primitive_type_declong] = builtin->builtin_declong;\n-\n-  lai->bool_type_default = builtin->builtin_int;\n+  /* Helper function to allow shorter lines below.  */\n+  auto add  = [&] (struct type * t)\n+  {\n+    lai->add_primitive_type (t);\n+  };\n+\n+  add (builtin->builtin_int);\n+  add (builtin->builtin_long);\n+  add (builtin->builtin_short);\n+  add (builtin->builtin_char);\n+  add (builtin->builtin_float);\n+  add (builtin->builtin_double);\n+  add (builtin->builtin_void);\n+  add (builtin->builtin_long_long);\n+  add (builtin->builtin_signed_char);\n+  add (builtin->builtin_unsigned_char);\n+  add (builtin->builtin_unsigned_short);\n+  add (builtin->builtin_unsigned_int);\n+  add (builtin->builtin_unsigned_long);\n+  add (builtin->builtin_unsigned_long_long);\n+  add (builtin->builtin_long_double);\n+  add (builtin->builtin_complex);\n+  add (builtin->builtin_double_complex);\n+  add (builtin->builtin_decfloat);\n+  add (builtin->builtin_decdouble);\n+  add (builtin->builtin_declong);\n+\n+  lai->set_string_char_type (builtin->builtin_char);\n+  lai->set_bool_type (builtin->builtin_int);\n }\n \n const struct exp_descriptor exp_descriptor_c = \n@@ -955,34 +935,6 @@ class c_language : public language_defn\n \n static c_language c_language_defn;\n \n-enum cplus_primitive_types {\n-  cplus_primitive_type_int,\n-  cplus_primitive_type_long,\n-  cplus_primitive_type_short,\n-  cplus_primitive_type_char,\n-  cplus_primitive_type_float,\n-  cplus_primitive_type_double,\n-  cplus_primitive_type_void,\n-  cplus_primitive_type_long_long,\n-  cplus_primitive_type_signed_char,\n-  cplus_primitive_type_unsigned_char,\n-  cplus_primitive_type_unsigned_short,\n-  cplus_primitive_type_unsigned_int,\n-  cplus_primitive_type_unsigned_long,\n-  cplus_primitive_type_unsigned_long_long,\n-  cplus_primitive_type_long_double,\n-  cplus_primitive_type_complex,\n-  cplus_primitive_type_double_complex,\n-  cplus_primitive_type_bool,\n-  cplus_primitive_type_decfloat,\n-  cplus_primitive_type_decdouble,\n-  cplus_primitive_type_declong,\n-  cplus_primitive_type_char16_t,\n-  cplus_primitive_type_char32_t,\n-  cplus_primitive_type_wchar_t,\n-  nr_cplus_primitive_types\n-};\n-\n /* A class for the C++ language.  */\n \n class cplus_language : public language_defn\n@@ -1025,61 +977,39 @@ class cplus_language : public language_defn\n   {\n     const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-    lai->string_char_type = builtin->builtin_char;\n-    lai->primitive_type_vector\n-      = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_cplus_primitive_types + 1,\n-\t\t\t\tstruct type *);\n-    lai->primitive_type_vector [cplus_primitive_type_int]\n-      = builtin->builtin_int;\n-    lai->primitive_type_vector [cplus_primitive_type_long]\n-      = builtin->builtin_long;\n-    lai->primitive_type_vector [cplus_primitive_type_short]\n-      = builtin->builtin_short;\n-    lai->primitive_type_vector [cplus_primitive_type_char]\n-      = builtin->builtin_char;\n-    lai->primitive_type_vector [cplus_primitive_type_float]\n-      = builtin->builtin_float;\n-    lai->primitive_type_vector [cplus_primitive_type_double]\n-      = builtin->builtin_double;\n-    lai->primitive_type_vector [cplus_primitive_type_void]\n-      = builtin->builtin_void;\n-    lai->primitive_type_vector [cplus_primitive_type_long_long]\n-      = builtin->builtin_long_long;\n-    lai->primitive_type_vector [cplus_primitive_type_signed_char]\n-      = builtin->builtin_signed_char;\n-    lai->primitive_type_vector [cplus_primitive_type_unsigned_char]\n-      = builtin->builtin_unsigned_char;\n-    lai->primitive_type_vector [cplus_primitive_type_unsigned_short]\n-      = builtin->builtin_unsigned_short;\n-    lai->primitive_type_vector [cplus_primitive_type_unsigned_int]\n-      = builtin->builtin_unsigned_int;\n-    lai->primitive_type_vector [cplus_primitive_type_unsigned_long]\n-      = builtin->builtin_unsigned_long;\n-    lai->primitive_type_vector [cplus_primitive_type_unsigned_long_long]\n-      = builtin->builtin_unsigned_long_long;\n-    lai->primitive_type_vector [cplus_primitive_type_long_double]\n-      = builtin->builtin_long_double;\n-    lai->primitive_type_vector [cplus_primitive_type_complex]\n-      = builtin->builtin_complex;\n-    lai->primitive_type_vector [cplus_primitive_type_double_complex]\n-      = builtin->builtin_double_complex;\n-    lai->primitive_type_vector [cplus_primitive_type_bool]\n-      = builtin->builtin_bool;\n-    lai->primitive_type_vector [cplus_primitive_type_decfloat]\n-      = builtin->builtin_decfloat;\n-    lai->primitive_type_vector [cplus_primitive_type_decdouble]\n-      = builtin->builtin_decdouble;\n-    lai->primitive_type_vector [cplus_primitive_type_declong]\n-      = builtin->builtin_declong;\n-    lai->primitive_type_vector [cplus_primitive_type_char16_t]\n-      = builtin->builtin_char16;\n-    lai->primitive_type_vector [cplus_primitive_type_char32_t]\n-      = builtin->builtin_char32;\n-    lai->primitive_type_vector [cplus_primitive_type_wchar_t]\n-      = builtin->builtin_wchar;\n-\n-    lai->bool_type_symbol = \"bool\";\n-    lai->bool_type_default = builtin->builtin_bool;\n+    /* Helper function to allow shorter lines below.  */\n+    auto add  = [&] (struct type * t)\n+    {\n+      lai->add_primitive_type (t);\n+    };\n+\n+    add (builtin->builtin_int);\n+    add (builtin->builtin_long);\n+    add (builtin->builtin_short);\n+    add (builtin->builtin_char);\n+    add (builtin->builtin_float);\n+    add (builtin->builtin_double);\n+    add (builtin->builtin_void);\n+    add (builtin->builtin_long_long);\n+    add (builtin->builtin_signed_char);\n+    add (builtin->builtin_unsigned_char);\n+    add (builtin->builtin_unsigned_short);\n+    add (builtin->builtin_unsigned_int);\n+    add (builtin->builtin_unsigned_long);\n+    add (builtin->builtin_unsigned_long_long);\n+    add (builtin->builtin_long_double);\n+    add (builtin->builtin_complex);\n+    add (builtin->builtin_double_complex);\n+    add (builtin->builtin_bool);\n+    add (builtin->builtin_decfloat);\n+    add (builtin->builtin_decdouble);\n+    add (builtin->builtin_declong);\n+    add (builtin->builtin_char16);\n+    add (builtin->builtin_char32);\n+    add (builtin->builtin_wchar);\n+\n+    lai->set_string_char_type (builtin->builtin_char);\n+    lai->set_bool_type (builtin->builtin_bool, \"bool\");\n   }\n \n   /* See language.h.  */"
    },
    {
      "sha": "2e7b7b64cb8f37c52e180387fb991e0cc45877bf",
      "filename": "gdb/d-lang.c",
      "status": "modified",
      "additions": 33,
      "deletions": 86,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/d-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/d-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -94,36 +94,6 @@ static const struct op_print d_op_print_tab[] =\n   {NULL, OP_NULL, PREC_PREFIX, 0}\n };\n \n-/* Mapping of all D basic data types into the language vector.  */\n-\n-enum d_primitive_types {\n-  d_primitive_type_void,\n-  d_primitive_type_bool,\n-  d_primitive_type_byte,\n-  d_primitive_type_ubyte,\n-  d_primitive_type_short,\n-  d_primitive_type_ushort,\n-  d_primitive_type_int,\n-  d_primitive_type_uint,\n-  d_primitive_type_long,\n-  d_primitive_type_ulong,\n-  d_primitive_type_cent,    /* Signed 128 bit integer.  */\n-  d_primitive_type_ucent,   /* Unsigned 128 bit integer.  */\n-  d_primitive_type_float,\n-  d_primitive_type_double,\n-  d_primitive_type_real,\n-  d_primitive_type_ifloat,  /* Imaginary float types.  */\n-  d_primitive_type_idouble,\n-  d_primitive_type_ireal,\n-  d_primitive_type_cfloat,  /* Complex number of two float values.  */\n-  d_primitive_type_cdouble,\n-  d_primitive_type_creal,\n-  d_primitive_type_char,    /* Unsigned character types.  */\n-  d_primitive_type_wchar,\n-  d_primitive_type_dchar,\n-  nr_d_primitive_types\n-};\n-\n /* Class representing the D language.  */\n \n class d_language : public language_defn\n@@ -157,62 +127,39 @@ class d_language : public language_defn\n   {\n     const struct builtin_d_type *builtin = builtin_d_type (gdbarch);\n \n-    lai->string_char_type = builtin->builtin_char;\n-    lai->primitive_type_vector\n-      = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_d_primitive_types + 1,\n-\t\t\t\tstruct type *);\n-\n-    lai->primitive_type_vector [d_primitive_type_void]\n-      = builtin->builtin_void;\n-    lai->primitive_type_vector [d_primitive_type_bool]\n-      = builtin->builtin_bool;\n-    lai->primitive_type_vector [d_primitive_type_byte]\n-      = builtin->builtin_byte;\n-    lai->primitive_type_vector [d_primitive_type_ubyte]\n-      = builtin->builtin_ubyte;\n-    lai->primitive_type_vector [d_primitive_type_short]\n-      = builtin->builtin_short;\n-    lai->primitive_type_vector [d_primitive_type_ushort]\n-      = builtin->builtin_ushort;\n-    lai->primitive_type_vector [d_primitive_type_int]\n-      = builtin->builtin_int;\n-    lai->primitive_type_vector [d_primitive_type_uint]\n-      = builtin->builtin_uint;\n-    lai->primitive_type_vector [d_primitive_type_long]\n-      = builtin->builtin_long;\n-    lai->primitive_type_vector [d_primitive_type_ulong]\n-      = builtin->builtin_ulong;\n-    lai->primitive_type_vector [d_primitive_type_cent]\n-      = builtin->builtin_cent;\n-    lai->primitive_type_vector [d_primitive_type_ucent]\n-      = builtin->builtin_ucent;\n-    lai->primitive_type_vector [d_primitive_type_float]\n-      = builtin->builtin_float;\n-    lai->primitive_type_vector [d_primitive_type_double]\n-      = builtin->builtin_double;\n-    lai->primitive_type_vector [d_primitive_type_real]\n-      = builtin->builtin_real;\n-    lai->primitive_type_vector [d_primitive_type_ifloat]\n-      = builtin->builtin_ifloat;\n-    lai->primitive_type_vector [d_primitive_type_idouble]\n-      = builtin->builtin_idouble;\n-    lai->primitive_type_vector [d_primitive_type_ireal]\n-      = builtin->builtin_ireal;\n-    lai->primitive_type_vector [d_primitive_type_cfloat]\n-      = builtin->builtin_cfloat;\n-    lai->primitive_type_vector [d_primitive_type_cdouble]\n-      = builtin->builtin_cdouble;\n-    lai->primitive_type_vector [d_primitive_type_creal]\n-      = builtin->builtin_creal;\n-    lai->primitive_type_vector [d_primitive_type_char]\n-      = builtin->builtin_char;\n-    lai->primitive_type_vector [d_primitive_type_wchar]\n-      = builtin->builtin_wchar;\n-    lai->primitive_type_vector [d_primitive_type_dchar]\n-      = builtin->builtin_dchar;\n-\n-    lai->bool_type_symbol = \"bool\";\n-    lai->bool_type_default = builtin->builtin_bool;\n+    /* Helper function to allow shorter lines below.  */\n+    auto add  = [&] (struct type * t)\n+    {\n+      lai->add_primitive_type (t);\n+    };\n+\n+    add (builtin->builtin_void);\n+    add (builtin->builtin_bool);\n+    add (builtin->builtin_byte);\n+    add (builtin->builtin_ubyte);\n+    add (builtin->builtin_short);\n+    add (builtin->builtin_ushort);\n+    add (builtin->builtin_int);\n+    add (builtin->builtin_uint);\n+    add (builtin->builtin_long);\n+    add (builtin->builtin_ulong);\n+    add (builtin->builtin_cent);\n+    add (builtin->builtin_ucent);\n+    add (builtin->builtin_float);\n+    add (builtin->builtin_double);\n+    add (builtin->builtin_real);\n+    add (builtin->builtin_ifloat);\n+    add (builtin->builtin_idouble);\n+    add (builtin->builtin_ireal);\n+    add (builtin->builtin_cfloat);\n+    add (builtin->builtin_cdouble);\n+    add (builtin->builtin_creal);\n+    add (builtin->builtin_char);\n+    add (builtin->builtin_wchar);\n+    add (builtin->builtin_dchar);\n+\n+    lai->set_string_char_type (builtin->builtin_char);\n+    lai->set_bool_type (builtin->builtin_bool, \"bool\");\n   }\n \n   /* See language.h.  */"
    },
    {
      "sha": "75cc05e2a71fc44cd6d91008c02e2f0bc6b5f3dd",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 20,
      "deletions": 46,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -97,22 +97,6 @@ const struct op_print f_language::op_print_tab[] =\n   {NULL, OP_NULL, PREC_REPEAT, 0}\n };\n \f\n-enum f_primitive_types {\n-  f_primitive_type_character,\n-  f_primitive_type_logical,\n-  f_primitive_type_logical_s1,\n-  f_primitive_type_logical_s2,\n-  f_primitive_type_logical_s8,\n-  f_primitive_type_integer,\n-  f_primitive_type_integer_s2,\n-  f_primitive_type_real,\n-  f_primitive_type_real_s8,\n-  f_primitive_type_real_s16,\n-  f_primitive_type_complex_s8,\n-  f_primitive_type_complex_s16,\n-  f_primitive_type_void,\n-  nr_f_primitive_types\n-};\n \n /* Called from fortran_value_subarray to take a slice of an array or a\n    string.  ARRAY is the array or string to be accessed.  EXP, POS, and\n@@ -720,36 +704,26 @@ f_language::language_arch_info (struct gdbarch *gdbarch,\n {\n   const struct builtin_f_type *builtin = builtin_f_type (gdbarch);\n \n-  lai->string_char_type = builtin->builtin_character;\n-  lai->primitive_type_vector\n-    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_f_primitive_types + 1,\n-\t\t\t      struct type *);\n-\n-  lai->primitive_type_vector [f_primitive_type_character]\n-    = builtin->builtin_character;\n-  lai->primitive_type_vector [f_primitive_type_logical]\n-    = builtin->builtin_logical;\n-  lai->primitive_type_vector [f_primitive_type_logical_s1]\n-    = builtin->builtin_logical_s1;\n-  lai->primitive_type_vector [f_primitive_type_logical_s2]\n-    = builtin->builtin_logical_s2;\n-  lai->primitive_type_vector [f_primitive_type_logical_s8]\n-    = builtin->builtin_logical_s8;\n-  lai->primitive_type_vector [f_primitive_type_real]\n-    = builtin->builtin_real;\n-  lai->primitive_type_vector [f_primitive_type_real_s8]\n-    = builtin->builtin_real_s8;\n-  lai->primitive_type_vector [f_primitive_type_real_s16]\n-    = builtin->builtin_real_s16;\n-  lai->primitive_type_vector [f_primitive_type_complex_s8]\n-    = builtin->builtin_complex_s8;\n-  lai->primitive_type_vector [f_primitive_type_complex_s16]\n-    = builtin->builtin_complex_s16;\n-  lai->primitive_type_vector [f_primitive_type_void]\n-    = builtin->builtin_void;\n-\n-  lai->bool_type_symbol = \"logical\";\n-  lai->bool_type_default = builtin->builtin_logical_s2;\n+  /* Helper function to allow shorter lines below.  */\n+  auto add  = [&] (struct type * t)\n+  {\n+    lai->add_primitive_type (t);\n+  };\n+\n+  add (builtin->builtin_character);\n+  add (builtin->builtin_logical);\n+  add (builtin->builtin_logical_s1);\n+  add (builtin->builtin_logical_s2);\n+  add (builtin->builtin_logical_s8);\n+  add (builtin->builtin_real);\n+  add (builtin->builtin_real_s8);\n+  add (builtin->builtin_real_s16);\n+  add (builtin->builtin_complex_s8);\n+  add (builtin->builtin_complex_s16);\n+  add (builtin->builtin_void);\n+\n+  lai->set_string_char_type (builtin->builtin_character);\n+  lai->set_bool_type (builtin->builtin_logical_s2, \"logical\");\n }\n \n /* See language.h.  */"
    },
    {
      "sha": "4547b52219bfca5bfd7cf236dc4abe5a347204ae",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 28,
      "deletions": 67,
      "changes": 95,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -482,28 +482,6 @@ static const struct op_print go_op_print_tab[] =\n   {NULL, OP_NULL, PREC_SUFFIX, 0}\n };\n \n-enum go_primitive_types {\n-  go_primitive_type_void,\n-  go_primitive_type_char,\n-  go_primitive_type_bool,\n-  go_primitive_type_int,\n-  go_primitive_type_uint,\n-  go_primitive_type_uintptr,\n-  go_primitive_type_int8,\n-  go_primitive_type_int16,\n-  go_primitive_type_int32,\n-  go_primitive_type_int64,\n-  go_primitive_type_uint8,\n-  go_primitive_type_uint16,\n-  go_primitive_type_uint32,\n-  go_primitive_type_uint64,\n-  go_primitive_type_float32,\n-  go_primitive_type_float64,\n-  go_primitive_type_complex64,\n-  go_primitive_type_complex128,\n-  nr_go_primitive_types\n-};\n-\n /* Class representing the Go language.  */\n \n class go_language : public language_defn\n@@ -529,51 +507,34 @@ class go_language : public language_defn\n   {\n     const struct builtin_go_type *builtin = builtin_go_type (gdbarch);\n \n-    lai->string_char_type = builtin->builtin_char;\n-\n-    lai->primitive_type_vector\n-      = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_go_primitive_types + 1,\n-\t\t\t\tstruct type *);\n-\n-    lai->primitive_type_vector [go_primitive_type_void]\n-      = builtin->builtin_void;\n-    lai->primitive_type_vector [go_primitive_type_char]\n-      = builtin->builtin_char;\n-    lai->primitive_type_vector [go_primitive_type_bool]\n-      = builtin->builtin_bool;\n-    lai->primitive_type_vector [go_primitive_type_int]\n-      = builtin->builtin_int;\n-    lai->primitive_type_vector [go_primitive_type_uint]\n-      = builtin->builtin_uint;\n-    lai->primitive_type_vector [go_primitive_type_uintptr]\n-      = builtin->builtin_uintptr;\n-    lai->primitive_type_vector [go_primitive_type_int8]\n-      = builtin->builtin_int8;\n-    lai->primitive_type_vector [go_primitive_type_int16]\n-      = builtin->builtin_int16;\n-    lai->primitive_type_vector [go_primitive_type_int32]\n-      = builtin->builtin_int32;\n-    lai->primitive_type_vector [go_primitive_type_int64]\n-      = builtin->builtin_int64;\n-    lai->primitive_type_vector [go_primitive_type_uint8]\n-      = builtin->builtin_uint8;\n-    lai->primitive_type_vector [go_primitive_type_uint16]\n-      = builtin->builtin_uint16;\n-    lai->primitive_type_vector [go_primitive_type_uint32]\n-      = builtin->builtin_uint32;\n-    lai->primitive_type_vector [go_primitive_type_uint64]\n-      = builtin->builtin_uint64;\n-    lai->primitive_type_vector [go_primitive_type_float32]\n-      = builtin->builtin_float32;\n-    lai->primitive_type_vector [go_primitive_type_float64]\n-      = builtin->builtin_float64;\n-    lai->primitive_type_vector [go_primitive_type_complex64]\n-      = builtin->builtin_complex64;\n-    lai->primitive_type_vector [go_primitive_type_complex128]\n-      = builtin->builtin_complex128;\n-\n-    lai->bool_type_symbol = \"bool\";\n-    lai->bool_type_default = builtin->builtin_bool;\n+    /* Helper function to allow shorter lines below.  */\n+    auto add  = [&] (struct type * t) -> struct type *\n+    {\n+      lai->add_primitive_type (t);\n+      return t;\n+    };\n+\n+    add (builtin->builtin_void);\n+    add (builtin->builtin_char);\n+    add (builtin->builtin_bool);\n+    add (builtin->builtin_int);\n+    add (builtin->builtin_uint);\n+    add (builtin->builtin_uintptr);\n+    add (builtin->builtin_int8);\n+    add (builtin->builtin_int16);\n+    add (builtin->builtin_int32);\n+    add (builtin->builtin_int64);\n+    add (builtin->builtin_uint8);\n+    add (builtin->builtin_uint16);\n+    add (builtin->builtin_uint32);\n+    add (builtin->builtin_uint64);\n+    add (builtin->builtin_float32);\n+    add (builtin->builtin_float64);\n+    add (builtin->builtin_complex64);\n+    add (builtin->builtin_complex128);\n+\n+    lai->set_string_char_type (builtin->builtin_char);\n+    lai->set_bool_type (builtin->builtin_bool, \"bool\");\n   }\n \n   /* See language.h.  */"
    },
    {
      "sha": "579cf9198c80c1ca7e14b7e36c21cdbb6c013481",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 105,
      "deletions": 100,
      "changes": 205,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -797,10 +797,8 @@ class auto_or_unknown_language : public language_defn\n   void language_arch_info (struct gdbarch *gdbarch,\n \t\t\t   struct language_arch_info *lai) const override\n   {\n-    lai->string_char_type = builtin_type (gdbarch)->builtin_char;\n-    lai->bool_type_default = builtin_type (gdbarch)->builtin_int;\n-    lai->primitive_type_vector = GDBARCH_OBSTACK_CALLOC (gdbarch, 1,\n-\t\t\t\t\t\t       struct type *);\n+    lai->set_string_char_type (builtin_type (gdbarch)->builtin_char);\n+    lai->set_bool_type (builtin_type (gdbarch)->builtin_int);\n   }\n \n   /* See language.h.  */\n@@ -985,102 +983,71 @@ struct language_gdbarch\n static void *\n language_gdbarch_post_init (struct gdbarch *gdbarch)\n {\n-  struct language_gdbarch *l;\n-\n-  l = GDBARCH_OBSTACK_ZALLOC (gdbarch, struct language_gdbarch);\n+  struct language_gdbarch *l\n+    = obstack_new<struct language_gdbarch> (gdbarch_obstack (gdbarch));\n   for (const auto &lang : language_defn::languages)\n     {\n       gdb_assert (lang != nullptr);\n-      lang->language_arch_info (gdbarch,\n-\t\t\t\tl->arch_info + lang->la_language);\n+      lang->language_arch_info (gdbarch, &l->arch_info[lang->la_language]);\n     }\n \n   return l;\n }\n \n+/* See language.h.  */\n+\n struct type *\n language_string_char_type (const struct language_defn *la,\n \t\t\t   struct gdbarch *gdbarch)\n {\n   struct language_gdbarch *ld\n     = (struct language_gdbarch *) gdbarch_data (gdbarch, language_gdbarch_data);\n-\n-  return ld->arch_info[la->la_language].string_char_type;\n+  return ld->arch_info[la->la_language].string_char_type ();\n }\n \n+/* See language.h.  */\n+\n struct type *\n language_bool_type (const struct language_defn *la,\n \t\t    struct gdbarch *gdbarch)\n {\n   struct language_gdbarch *ld\n     = (struct language_gdbarch *) gdbarch_data (gdbarch, language_gdbarch_data);\n+  return ld->arch_info[la->la_language].bool_type ();\n+}\n+\n+/* See language.h.  */\n \n-  if (ld->arch_info[la->la_language].bool_type_symbol)\n+struct type *\n+language_arch_info::bool_type () const\n+{\n+  if (m_bool_type_name != nullptr)\n     {\n       struct symbol *sym;\n \n-      sym = lookup_symbol (ld->arch_info[la->la_language].bool_type_symbol,\n-\t\t\t   NULL, VAR_DOMAIN, NULL).symbol;\n-      if (sym)\n+      sym = lookup_symbol (m_bool_type_name, NULL, VAR_DOMAIN, NULL).symbol;\n+      if (sym != nullptr)\n \t{\n \t  struct type *type = SYMBOL_TYPE (sym);\n-\n-\t  if (type && type->code () == TYPE_CODE_BOOL)\n+\t  if (type != nullptr && type->code () == TYPE_CODE_BOOL)\n \t    return type;\n \t}\n     }\n \n-  return ld->arch_info[la->la_language].bool_type_default;\n-}\n-\n-/* Helper function for primitive type lookup.  */\n-\n-static struct type **\n-language_lookup_primitive_type_1 (const struct language_arch_info *lai,\n-\t\t\t\t  const char *name)\n-{\n-  struct type **p;\n-\n-  for (p = lai->primitive_type_vector; (*p) != NULL; p++)\n-    {\n-      if (strcmp ((*p)->name (), name) == 0)\n-\treturn p;\n-    }\n-  return NULL;\n+  return m_bool_type_default;\n }\n \n /* See language.h.  */\n \n-struct type *\n-language_lookup_primitive_type (const struct language_defn *la,\n-\t\t\t\tstruct gdbarch *gdbarch,\n-\t\t\t\tconst char *name)\n-{\n-  struct language_gdbarch *ld =\n-    (struct language_gdbarch *) gdbarch_data (gdbarch, language_gdbarch_data);\n-  struct type **typep;\n-\n-  typep = language_lookup_primitive_type_1 (&ld->arch_info[la->la_language],\n-\t\t\t\t\t    name);\n-  if (typep == NULL)\n-    return NULL;\n-  return *typep;\n-}\n-\n-/* Helper function for type lookup as a symbol.\n-   Create the symbol corresponding to type TYPE in language LANG.  */\n-\n-static struct symbol *\n-language_alloc_type_symbol (enum language lang, struct type *type)\n+struct symbol *\n+language_arch_info::type_and_symbol::alloc_type_symbol\n+\t(enum language lang, struct type *type)\n {\n   struct symbol *symbol;\n   struct gdbarch *gdbarch;\n-\n   gdb_assert (!TYPE_OBJFILE_OWNED (type));\n-\n   gdbarch = TYPE_OWNER (type).gdbarch;\n   symbol = new (gdbarch_obstack (gdbarch)) struct symbol ();\n-\n   symbol->m_name = type->name ();\n   symbol->set_language (lang, nullptr);\n   symbol->owner.arch = gdbarch;\n@@ -1089,41 +1056,88 @@ language_alloc_type_symbol (enum language lang, struct type *type)\n   SYMBOL_TYPE (symbol) = type;\n   SYMBOL_DOMAIN (symbol) = VAR_DOMAIN;\n   SYMBOL_ACLASS_INDEX (symbol) = LOC_TYPEDEF;\n-\n   return symbol;\n }\n \n-/* Initialize the primitive type symbols of language LD.\n-   The primitive type vector must have already been initialized.  */\n+/* See language.h.  */\n \n-static void\n-language_init_primitive_type_symbols (struct language_arch_info *lai,\n-\t\t\t\t      const struct language_defn *la,\n-\t\t\t\t      struct gdbarch *gdbarch)\n+language_arch_info::type_and_symbol *\n+language_arch_info::lookup_primitive_type_and_symbol (const char *name)\n {\n-  int n;\n+  for (struct type_and_symbol &tas : primitive_types_and_symbols)\n+    {\n+      if (strcmp (tas.type ()->name (), name) == 0)\n+\treturn &tas;\n+    }\n \n-  gdb_assert (lai->primitive_type_vector != NULL);\n+  return nullptr;\n+}\n+\n+/* See language.h.  */\n \n-  for (n = 0; lai->primitive_type_vector[n] != NULL; ++n)\n-    continue;\n+struct type *\n+language_arch_info::lookup_primitive_type (const char *name)\n+{\n+  type_and_symbol *tas = lookup_primitive_type_and_symbol (name);\n+  if (tas != nullptr)\n+    return tas->type ();\n+  return nullptr;\n+}\n \n-  lai->primitive_type_symbols\n-    = GDBARCH_OBSTACK_CALLOC (gdbarch, n + 1, struct symbol *);\n+/* See language.h.  */\n \n-  for (n = 0; lai->primitive_type_vector[n] != NULL; ++n)\n+struct type *\n+language_arch_info::lookup_primitive_type\n+\t(std::function<bool (struct type *)> filter)\n+{\n+  for (struct type_and_symbol &tas : primitive_types_and_symbols)\n     {\n-      lai->primitive_type_symbols[n]\n-\t= language_alloc_type_symbol (la->la_language,\n-\t\t\t\t      lai->primitive_type_vector[n]);\n+      if (filter (tas.type ()))\n+\treturn tas.type ();\n     }\n \n-  /* Note: The result of symbol lookup is normally a symbol *and* the block\n-     it was found in.  Builtin types don't live in blocks.  We *could* give\n-     them one, but there is no current need so to keep things simple symbol\n-     lookup is extended to allow for BLOCK_FOUND to be NULL.  */\n+  return nullptr;\n+}\n+\n+/* See language.h.  */\n+\n+struct symbol *\n+language_arch_info::lookup_primitive_type_as_symbol (const char *name,\n+\t\t\t\t\t\t     enum language lang)\n+{\n+  type_and_symbol *tas = lookup_primitive_type_and_symbol (name);\n+  if (tas != nullptr)\n+    return tas->symbol (lang);\n+  return nullptr;\n+}\n+\n+/* See language.h.  */\n+\n+template<typename T>\n+struct type *\n+language_lookup_primitive_type (const struct language_defn *la,\n+\t\t\t\tstruct gdbarch *gdbarch,\n+\t\t\t\tT arg)\n+{\n+  struct language_gdbarch *ld =\n+    (struct language_gdbarch *) gdbarch_data (gdbarch, language_gdbarch_data);\n+  return ld->arch_info[la->la_language].lookup_primitive_type (arg);\n }\n \n+/* Template instantiation.  */\n+\n+template struct type *\n+language_lookup_primitive_type (const struct language_defn *la,\n+\t\t\t\tstruct gdbarch *gdbarch,\n+\t\t\t\tconst char *arg);\n+\n+/* Template instantiation.  */\n+\n+template struct type *\n+language_lookup_primitive_type (const struct language_defn *la,\n+\t\t\t\tstruct gdbarch *gdbarch,\n+\t\t\t\tstd::function<bool (struct type *)> arg);\n+\n /* See language.h.  */\n \n struct symbol *\n@@ -1134,33 +1148,24 @@ language_lookup_primitive_type_as_symbol (const struct language_defn *la,\n   struct language_gdbarch *ld\n     = (struct language_gdbarch *) gdbarch_data (gdbarch, language_gdbarch_data);\n   struct language_arch_info *lai = &ld->arch_info[la->la_language];\n-  struct type **typep;\n-  struct symbol *sym;\n \n   if (symbol_lookup_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"language_lookup_primitive_type_as_symbol\"\n-\t\t\t  \" (%s, %s, %s)\",\n-\t\t\t  la->name (), host_address_to_string (gdbarch), name);\n-    }\n-\n-  typep = language_lookup_primitive_type_1 (lai, name);\n-  if (typep == NULL)\n-    {\n-      if (symbol_lookup_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \" = NULL\\n\");\n-      return NULL;\n-    }\n-\n-  /* The set of symbols is lazily initialized.  */\n-  if (lai->primitive_type_symbols == NULL)\n-    language_init_primitive_type_symbols (lai, la, gdbarch);\n+    fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\"language_lookup_primitive_type_as_symbol\"\n+\t\t\t\" (%s, %s, %s)\",\n+\t\t\tla->name (), host_address_to_string (gdbarch), name);\n \n-  sym = lai->primitive_type_symbols[typep - lai->primitive_type_vector];\n+  struct symbol *sym\n+    = lai->lookup_primitive_type_as_symbol (name, la->la_language);\n \n   if (symbol_lookup_debug)\n     fprintf_unfiltered (gdb_stdlog, \" = %s\\n\", host_address_to_string (sym));\n+\n+  /* Note: The result of symbol lookup is normally a symbol *and* the block\n+     it was found in.  Builtin types don't live in blocks.  We *could* give\n+     them one, but there is no current need so to keep things simple symbol\n+     lookup is extended to allow for BLOCK_FOUND to be NULL.  */\n+\n   return sym;\n }\n "
    },
    {
      "sha": "1b60264665184be9bd5d51ad393871baf3d8482e",
      "filename": "gdb/language.h",
      "status": "modified",
      "additions": 129,
      "deletions": 14,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/language.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/language.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.h?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -89,23 +89,129 @@ enum macro_expansion\n \n struct language_arch_info\n {\n-  /* Its primitive types.  This is a vector ended by a NULL pointer.\n-     These types can be specified by name in parsing types in\n-     expressions, regardless of whether the program being debugged\n-     actually defines such a type.  */\n-  struct type **primitive_type_vector;\n+  /* A default constructor.  */\n+  language_arch_info () = default;\n \n-  /* Symbol wrappers around primitive_type_vector, so that the symbol lookup\n-     machinery can return them.  */\n-  struct symbol **primitive_type_symbols;\n+  DISABLE_COPY_AND_ASSIGN (language_arch_info);\n+\n+  /* Set the default boolean type to be TYPE.  If NAME is not nullptr then\n+     before using TYPE a symbol called NAME will be looked up, and the type\n+     of this symbol will be used instead.  Should only be called once when\n+     performing setup for a particular language in combination with a\n+     particular gdbarch.  */\n+  void set_bool_type (struct type *type, const char *name = nullptr)\n+  {\n+    gdb_assert (m_bool_type_default == nullptr);\n+    gdb_assert (m_bool_type_name == nullptr);\n+    gdb_assert (type != nullptr);\n+    m_bool_type_default = type;\n+    m_bool_type_name = name;\n+  }\n+\n+  /* Set the type to be used for characters within a string.  Should only\n+     be called once when performing setup for a particular language in\n+     combination with a particular gdbarch.  */\n+  void set_string_char_type (struct type *type)\n+  {\n+    gdb_assert (m_string_char_type == nullptr);\n+    gdb_assert (type != nullptr);\n+    m_string_char_type = type;\n+  }\n+\n+  /* Return the type for characters within a string.  */\n+  struct type *string_char_type () const\n+  { return m_string_char_type; }\n+\n+  /* Return the type to be used for booleans.  */\n+  struct type *bool_type () const;\n+\n+  /* Add TYPE to the list of primitive types for this particular language,\n+     with this OS/ABI combination.  */\n+  void add_primitive_type (struct type *type)\n+  {\n+    gdb_assert (type != nullptr);\n+    primitive_types_and_symbols.push_back (type_and_symbol (type));\n+  }\n+\n+  /* Lookup a primitive type called NAME.  Will return nullptr if no\n+     matching type is found.  */\n+  struct type *lookup_primitive_type (const char *name);\n+\n+  /* Lookup a primitive type for which FILTER returns true.  Will return\n+     nullptr if no matching type is found.  */\n+  struct type *lookup_primitive_type\n+\t(std::function<bool (struct type *)> filter);\n+\n+  /* Lookup a primitive type called NAME and return the type as a symbol.\n+     LANG is the language for which type is being looked up.  */\n+  struct symbol *lookup_primitive_type_as_symbol (const char *name,\n+\t\t\t\t\t\t  enum language lang);\n+private:\n+\n+  /* A structure storing a type and a corresponding symbol.  The type is\n+     defined at construction time, while the symbol is lazily created only\n+     when asked for, but is then cached for future use.  */\n+  struct type_and_symbol\n+  {\n+    /* Constructor.  */\n+    explicit type_and_symbol (struct type *type)\n+      : m_type (type)\n+    { /* Nothing.  */ }\n+\n+    /* Default move constructor.  */\n+    type_and_symbol (type_and_symbol&&) = default;\n+\n+    DISABLE_COPY_AND_ASSIGN (type_and_symbol);\n+\n+    /* Return the type from this object.  */\n+    struct type *type () const\n+    { return m_type; }\n+\n+    /* Create and return a symbol wrapping M_TYPE from this object.  */\n+    struct symbol *symbol (enum language lang)\n+    {\n+      if (m_symbol == nullptr)\n+\tm_symbol = alloc_type_symbol (lang, m_type);\n+      return m_symbol;\n+    }\n+\n+  private:\n+    /* The type primitive type.  */\n+    struct type *m_type = nullptr;\n+\n+    /* A symbol wrapping M_TYPE, only created when first asked for.  */\n+    struct symbol *m_symbol = nullptr;\n+\n+    /* Helper function for type lookup as a symbol.  Create the symbol\n+       corresponding to type TYPE in language LANG.  */\n+    static struct symbol *alloc_type_symbol (enum language lang,\n+\t\t\t\t\t     struct type *type);\n+  };\n+\n+  /* Lookup a type_and_symbol entry from the primitive_types_and_symbols\n+     vector for a type matching NAME.  Return a pointer to the\n+     type_and_symbol object from the vector.  This will return nullptr if\n+     there is no type matching NAME found.  */\n+  type_and_symbol *lookup_primitive_type_and_symbol (const char *name);\n+\n+  /* Vector of the primitive types added through add_primitive_type.  These\n+     types can be specified by name in parsing types in expressions,\n+     regardless of whether the program being debugged actually defines such\n+     a type.\n+\n+     Within the vector each type is paired with a lazily created symbol,\n+     which can be fetched by the symbol lookup machinery, should they be\n+     needed.  */\n+  std::vector<type_and_symbol> primitive_types_and_symbols;\n \n   /* Type of elements of strings.  */\n-  struct type *string_char_type;\n+  struct type *m_string_char_type = nullptr;\n \n   /* Symbol name of type to use as boolean type, if defined.  */\n-  const char *bool_type_symbol;\n+  const char *m_bool_type_name = nullptr;\n+\n   /* Otherwise, this is the default boolean builtin type.  */\n-  struct type *bool_type_default;\n+  struct type *m_bool_type_default = nullptr;\n };\n \n /* In a language (particularly C++) a function argument of an aggregate\n@@ -601,18 +707,27 @@ extern enum language_mode\n   }\n language_mode;\n \n+/* Return the type that should be used for booleans for language L in\n+   GDBARCH.  */\n+\n struct type *language_bool_type (const struct language_defn *l,\n \t\t\t\t struct gdbarch *gdbarch);\n \n+/* Return the type that should be used for characters within a string for\n+   language L in GDBARCH.  */\n+\n struct type *language_string_char_type (const struct language_defn *l,\n \t\t\t\t\tstruct gdbarch *gdbarch);\n \n-/* Look up type NAME in language L, and return its definition for architecture\n-   GDBARCH.  Returns NULL if not found.  */\n+/* Look up a type from the set of OS/ABI specific types defined in GDBARCH\n+   for language L.  ARG is used for selecting the matching type, and is\n+   passed through to the corresponding lookup_primitive_type member\n+   function inside the language_arch_info class.  */\n \n+template<typename T>\n struct type *language_lookup_primitive_type (const struct language_defn *l,\n \t\t\t\t\t     struct gdbarch *gdbarch,\n-\t\t\t\t\t     const char *name);\n+\t\t\t\t\t     T arg);\n \n /* Wrapper around language_lookup_primitive_type to return the\n    corresponding symbol.  */"
    },
    {
      "sha": "1155469e0a51729ecba25e03825752bd98f1ba67",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 28,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -161,16 +161,6 @@ const struct op_print m2_language::op_print_tab[] =\n   {NULL, OP_NULL, PREC_BUILTIN_FUNCTION, 0}\n };\n \f\n-/* The built-in types of Modula-2.  */\n-\n-enum m2_primitive_types {\n-  m2_primitive_type_char,\n-  m2_primitive_type_int,\n-  m2_primitive_type_card,\n-  m2_primitive_type_real,\n-  m2_primitive_type_bool,\n-  nr_m2_primitive_types\n-};\n \n const struct exp_descriptor m2_language::exp_descriptor_modula2 =\n {\n@@ -194,24 +184,20 @@ m2_language::language_arch_info (struct gdbarch *gdbarch,\n {\n   const struct builtin_m2_type *builtin = builtin_m2_type (gdbarch);\n \n-  lai->string_char_type = builtin->builtin_char;\n-  lai->primitive_type_vector\n-    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_m2_primitive_types + 1,\n-\t\t\t      struct type *);\n-\n-  lai->primitive_type_vector [m2_primitive_type_char]\n-    = builtin->builtin_char;\n-  lai->primitive_type_vector [m2_primitive_type_int]\n-    = builtin->builtin_int;\n-  lai->primitive_type_vector [m2_primitive_type_card]\n-    = builtin->builtin_card;\n-  lai->primitive_type_vector [m2_primitive_type_real]\n-    = builtin->builtin_real;\n-  lai->primitive_type_vector [m2_primitive_type_bool]\n-    = builtin->builtin_bool;\n-\n-  lai->bool_type_symbol = \"BOOLEAN\";\n-  lai->bool_type_default = builtin->builtin_bool;\n+  /* Helper function to allow shorter lines below.  */\n+  auto add  = [&] (struct type * t)\n+  {\n+    lai->add_primitive_type (t);\n+  };\n+\n+  add (builtin->builtin_char);\n+  add (builtin->builtin_int);\n+  add (builtin->builtin_card);\n+  add (builtin->builtin_real);\n+  add (builtin->builtin_bool);\n+\n+  lai->set_string_char_type (builtin->builtin_char);\n+  lai->set_bool_type (builtin->builtin_bool, \"BOOLEAN\");\n }\n \n /* See languge.h.  */"
    },
    {
      "sha": "11032b1864e6dcb325b0a7997218bfbd722996e4",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 80,
      "deletions": 164,
      "changes": 244,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -28,49 +28,6 @@\n #include \"c-lang.h\"\n #include \"gdbarch.h\"\n \n-/* This macro generates enum values from a given type.  */\n-\n-#define OCL_P_TYPE(TYPE)\\\n-  opencl_primitive_type_##TYPE,\\\n-  opencl_primitive_type_##TYPE##2,\\\n-  opencl_primitive_type_##TYPE##3,\\\n-  opencl_primitive_type_##TYPE##4,\\\n-  opencl_primitive_type_##TYPE##8,\\\n-  opencl_primitive_type_##TYPE##16\n-\n-enum opencl_primitive_types {\n-  OCL_P_TYPE (char),\n-  OCL_P_TYPE (uchar),\n-  OCL_P_TYPE (short),\n-  OCL_P_TYPE (ushort),\n-  OCL_P_TYPE (int),\n-  OCL_P_TYPE (uint),\n-  OCL_P_TYPE (long),\n-  OCL_P_TYPE (ulong),\n-  OCL_P_TYPE (half),\n-  OCL_P_TYPE (float),\n-  OCL_P_TYPE (double),\n-  opencl_primitive_type_bool,\n-  opencl_primitive_type_unsigned_char,\n-  opencl_primitive_type_unsigned_short,\n-  opencl_primitive_type_unsigned_int,\n-  opencl_primitive_type_unsigned_long,\n-  opencl_primitive_type_size_t,\n-  opencl_primitive_type_ptrdiff_t,\n-  opencl_primitive_type_intptr_t,\n-  opencl_primitive_type_uintptr_t,\n-  opencl_primitive_type_void,\n-  nr_opencl_primitive_types\n-};\n-\n-static struct gdbarch_data *opencl_type_data;\n-\n-static struct type **\n-builtin_opencl_type (struct gdbarch *gdbarch)\n-{\n-  return (struct type **) gdbarch_data (gdbarch, opencl_type_data);\n-}\n-\n /* Returns the corresponding OpenCL vector type from the given type code,\n    the length of the element type, the unsigned flag and the amount of\n    elements (N).  */\n@@ -80,10 +37,7 @@ lookup_opencl_vector_type (struct gdbarch *gdbarch, enum type_code code,\n \t\t\t   unsigned int el_length, unsigned int flag_unsigned,\n \t\t\t   int n)\n {\n-  int i;\n   unsigned int length;\n-  struct type *type = NULL;\n-  struct type **types = builtin_opencl_type (gdbarch);\n \n   /* Check if n describes a valid OpenCL vector size (2, 3, 4, 8, 16).  */\n   if (n != 2 && n != 3 && n != 4 && n != 8 && n != 16)\n@@ -92,24 +46,20 @@ lookup_opencl_vector_type (struct gdbarch *gdbarch, enum type_code code,\n   /* Triple vectors have the size of a quad vector.  */\n   length = (n == 3) ?  el_length * 4 : el_length * n;\n \n-  for (i = 0; i < nr_opencl_primitive_types; i++)\n-    {\n-      LONGEST lowb, highb;\n-\n-      if (types[i]->code () == TYPE_CODE_ARRAY && types[i]->is_vector ()\n-\t  && get_array_bounds (types[i], &lowb, &highb)\n-\t  && TYPE_TARGET_TYPE (types[i])->code () == code\n-\t  && TYPE_TARGET_TYPE (types[i])->is_unsigned () == flag_unsigned\n-\t  && TYPE_LENGTH (TYPE_TARGET_TYPE (types[i])) == el_length\n-\t  && TYPE_LENGTH (types[i]) == length\n-\t  && highb - lowb + 1 == n)\n-\t{\n-\t  type = types[i];\n-\t  break;\n-\t}\n-    }\n-\n-  return type;\n+  std::function<bool (struct type *)> filter = [&] (struct type *type)\n+  {\n+    LONGEST lowb, highb;\n+\n+    return (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n+\t    && get_array_bounds (type, &lowb, &highb)\n+\t    && TYPE_TARGET_TYPE (type)->code () == code\n+\t    && TYPE_TARGET_TYPE (type)->is_unsigned () == flag_unsigned\n+\t    && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == el_length\n+\t    && TYPE_LENGTH (type) == length\n+\t    && highb - lowb + 1 == n);\n+  };\n+  const struct language_defn *lang = language_def (language_opencl);\n+  return language_lookup_primitive_type (lang, gdbarch, filter);\n }\n \n /* Returns nonzero if the array ARR contains duplicates within\n@@ -1026,17 +976,77 @@ class opencl_language : public language_defn\n   void language_arch_info (struct gdbarch *gdbarch,\n \t\t\t   struct language_arch_info *lai) const override\n   {\n-    struct type **types = builtin_opencl_type (gdbarch);\n+    /* Helper function to allow shorter lines below.  */\n+    auto add  = [&] (struct type * t) -> struct type *\n+    {\n+      lai->add_primitive_type (t);\n+      return t;\n+    };\n \n-    /* Copy primitive types vector from gdbarch.  */\n-    lai->primitive_type_vector = types;\n+/* Helper macro to create strings.  */\n+#define OCL_STRING(S) #S\n+\n+/* This macro allocates and assigns the type struct pointers\n+   for the vector types.  */\n+#define BUILD_OCL_VTYPES(TYPE, ELEMENT_TYPE)\t\t\t\\\n+    do\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstruct type *tmp;\t\t\t\t\t\\\n+\ttmp = add (init_vector_type (ELEMENT_TYPE, 2));\t\t\\\n+\ttmp->set_name (OCL_STRING(TYPE ## 2));\t\t\t\\\n+\ttmp = add (init_vector_type (ELEMENT_TYPE, 3));\t\t\\\n+\ttmp->set_name (OCL_STRING(TYPE ## 3));\t\t\t\\\n+\tTYPE_LENGTH (tmp) = 4 * TYPE_LENGTH (ELEMENT_TYPE);\t\\\n+\ttmp = add (init_vector_type (ELEMENT_TYPE, 4));\t\t\\\n+\ttmp->set_name (OCL_STRING(TYPE ## 4));\t\t\t\\\n+\ttmp = add (init_vector_type (ELEMENT_TYPE, 8));\t\t\\\n+\ttmp->set_name (OCL_STRING(TYPE ## 8));\t\t\t\\\n+\ttmp = init_vector_type (ELEMENT_TYPE, 16);\t\t\\\n+\ttmp->set_name (OCL_STRING(TYPE ## 16));\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    while (false)\n+\n+    struct type *el_type, *char_type, *int_type;\n+\n+    char_type = el_type = add (arch_integer_type (gdbarch, 8, 0, \"char\"));\n+    BUILD_OCL_VTYPES (char, el_type);\n+    el_type = add (arch_integer_type (gdbarch, 8, 1, \"uchar\"));\n+    BUILD_OCL_VTYPES (uchar, el_type);\n+    el_type = add (arch_integer_type (gdbarch, 16, 0, \"short\"));\n+    BUILD_OCL_VTYPES (short, el_type);\n+    el_type = add (arch_integer_type (gdbarch, 16, 1, \"ushort\"));\n+    BUILD_OCL_VTYPES (ushort, el_type);\n+    int_type = el_type = add (arch_integer_type (gdbarch, 32, 0, \"int\"));\n+    BUILD_OCL_VTYPES (int, el_type);\n+    el_type = add (arch_integer_type (gdbarch, 32, 1, \"uint\"));\n+    BUILD_OCL_VTYPES (uint, el_type);\n+    el_type = add (arch_integer_type (gdbarch, 64, 0, \"long\"));\n+    BUILD_OCL_VTYPES (long, el_type);\n+    el_type = add (arch_integer_type (gdbarch, 64, 1, \"ulong\"));\n+    BUILD_OCL_VTYPES (ulong, el_type);\n+    el_type = add (arch_float_type (gdbarch, 16, \"half\", floatformats_ieee_half));\n+    BUILD_OCL_VTYPES (half, el_type);\n+    el_type = add (arch_float_type (gdbarch, 32, \"float\", floatformats_ieee_single));\n+    BUILD_OCL_VTYPES (float, el_type);\n+    el_type = add (arch_float_type (gdbarch, 64, \"double\", floatformats_ieee_double));\n+    BUILD_OCL_VTYPES (double, el_type);\n+\n+    add (arch_boolean_type (gdbarch, 8, 1, \"bool\"));\n+    add (arch_integer_type (gdbarch, 8, 1, \"unsigned char\"));\n+    add (arch_integer_type (gdbarch, 16, 1, \"unsigned short\"));\n+    add (arch_integer_type (gdbarch, 32, 1, \"unsigned int\"));\n+    add (arch_integer_type (gdbarch, 64, 1, \"unsigned long\"));\n+    add (arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 1, \"size_t\"));\n+    add (arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 0, \"ptrdiff_t\"));\n+    add (arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 0, \"intptr_t\"));\n+    add (arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 1, \"uintptr_t\"));\n+    add (arch_type (gdbarch, TYPE_CODE_VOID, TARGET_CHAR_BIT, \"void\"));\n \n     /* Type of elements of strings.  */\n-    lai->string_char_type = types [opencl_primitive_type_char];\n+    lai->set_string_char_type (char_type);\n \n     /* Specifies the return type of logical and relational operations.  */\n-    lai->bool_type_symbol = \"int\";\n-    lai->bool_type_default = types [opencl_primitive_type_int];\n+    lai->set_bool_type (int_type, \"int\");\n   }\n \n   /* See language.h.  */\n@@ -1078,97 +1088,3 @@ class opencl_language : public language_defn\n /* Single instance of the OpenCL language class.  */\n \n static opencl_language opencl_language_defn;\n-\n-static void *\n-build_opencl_types (struct gdbarch *gdbarch)\n-{\n-  struct type **types\n-    = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_opencl_primitive_types + 1,\n-\t\t\t      struct type *);\n-\n-/* Helper macro to create strings.  */\n-#define OCL_STRING(S) #S\n-/* This macro allocates and assigns the type struct pointers\n-   for the vector types.  */\n-#define BUILD_OCL_VTYPES(TYPE)\\\n-  types[opencl_primitive_type_##TYPE##2] \\\n-    = init_vector_type (types[opencl_primitive_type_##TYPE], 2); \\\n-  types[opencl_primitive_type_##TYPE##2]->set_name (OCL_STRING(TYPE ## 2)); \\\n-  types[opencl_primitive_type_##TYPE##3] \\\n-    = init_vector_type (types[opencl_primitive_type_##TYPE], 3); \\\n-  types[opencl_primitive_type_##TYPE##3]->set_name (OCL_STRING(TYPE ## 3)); \\\n-  TYPE_LENGTH (types[opencl_primitive_type_##TYPE##3]) \\\n-    = 4 * TYPE_LENGTH (types[opencl_primitive_type_##TYPE]); \\\n-  types[opencl_primitive_type_##TYPE##4] \\\n-    = init_vector_type (types[opencl_primitive_type_##TYPE], 4); \\\n-  types[opencl_primitive_type_##TYPE##4]->set_name (OCL_STRING(TYPE ## 4)); \\\n-  types[opencl_primitive_type_##TYPE##8] \\\n-    = init_vector_type (types[opencl_primitive_type_##TYPE], 8); \\\n-  types[opencl_primitive_type_##TYPE##8]->set_name (OCL_STRING(TYPE ## 8)); \\\n-  types[opencl_primitive_type_##TYPE##16] \\\n-    = init_vector_type (types[opencl_primitive_type_##TYPE], 16); \\\n-  types[opencl_primitive_type_##TYPE##16]->set_name (OCL_STRING(TYPE ## 16))\n-\n-  types[opencl_primitive_type_char]\n-    = arch_integer_type (gdbarch, 8, 0, \"char\");\n-  BUILD_OCL_VTYPES (char);\n-  types[opencl_primitive_type_uchar]\n-    = arch_integer_type (gdbarch, 8, 1, \"uchar\");\n-  BUILD_OCL_VTYPES (uchar);\n-  types[opencl_primitive_type_short]\n-    = arch_integer_type (gdbarch, 16, 0, \"short\");\n-  BUILD_OCL_VTYPES (short);\n-  types[opencl_primitive_type_ushort]\n-    = arch_integer_type (gdbarch, 16, 1, \"ushort\");\n-  BUILD_OCL_VTYPES (ushort);\n-  types[opencl_primitive_type_int]\n-    = arch_integer_type (gdbarch, 32, 0, \"int\");\n-  BUILD_OCL_VTYPES (int);\n-  types[opencl_primitive_type_uint]\n-    = arch_integer_type (gdbarch, 32, 1, \"uint\");\n-  BUILD_OCL_VTYPES (uint);\n-  types[opencl_primitive_type_long]\n-    = arch_integer_type (gdbarch, 64, 0, \"long\");\n-  BUILD_OCL_VTYPES (long);\n-  types[opencl_primitive_type_ulong]\n-    = arch_integer_type (gdbarch, 64, 1, \"ulong\");\n-  BUILD_OCL_VTYPES (ulong);\n-  types[opencl_primitive_type_half]\n-    = arch_float_type (gdbarch, 16, \"half\", floatformats_ieee_half);\n-  BUILD_OCL_VTYPES (half);\n-  types[opencl_primitive_type_float]\n-    = arch_float_type (gdbarch, 32, \"float\", floatformats_ieee_single);\n-  BUILD_OCL_VTYPES (float);\n-  types[opencl_primitive_type_double]\n-    = arch_float_type (gdbarch, 64, \"double\", floatformats_ieee_double);\n-  BUILD_OCL_VTYPES (double);\n-  types[opencl_primitive_type_bool]\n-    = arch_boolean_type (gdbarch, 8, 1, \"bool\");\n-  types[opencl_primitive_type_unsigned_char]\n-    = arch_integer_type (gdbarch, 8, 1, \"unsigned char\");\n-  types[opencl_primitive_type_unsigned_short]\n-    = arch_integer_type (gdbarch, 16, 1, \"unsigned short\");\n-  types[opencl_primitive_type_unsigned_int]\n-    = arch_integer_type (gdbarch, 32, 1, \"unsigned int\");\n-  types[opencl_primitive_type_unsigned_long]\n-    = arch_integer_type (gdbarch, 64, 1, \"unsigned long\");\n-  types[opencl_primitive_type_size_t]\n-    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 1, \"size_t\");\n-  types[opencl_primitive_type_ptrdiff_t]\n-    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 0, \"ptrdiff_t\");\n-  types[opencl_primitive_type_intptr_t]\n-    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 0, \"intptr_t\");\n-  types[opencl_primitive_type_uintptr_t]\n-    = arch_integer_type (gdbarch, gdbarch_ptr_bit (gdbarch), 1, \"uintptr_t\");\n-  types[opencl_primitive_type_void]\n-    = arch_type (gdbarch, TYPE_CODE_VOID, TARGET_CHAR_BIT, \"void\");\n-\n-  return types;\n-}\n-\n-void _initialize_opencl_language ();\n-void\n-_initialize_opencl_language ()\n-{\n-  opencl_type_data = gdbarch_data_register_post_init (build_opencl_types);\n-}"
    },
    {
      "sha": "1610c0accae4231ff4948be212debabf06c6b848",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 26,
      "deletions": 61,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -227,26 +227,6 @@ const struct op_print pascal_op_print_tab[] =\n   {NULL, OP_NULL, PREC_PREFIX, 0}\n };\n \f\n-enum pascal_primitive_types {\n-  pascal_primitive_type_int,\n-  pascal_primitive_type_long,\n-  pascal_primitive_type_short,\n-  pascal_primitive_type_char,\n-  pascal_primitive_type_float,\n-  pascal_primitive_type_double,\n-  pascal_primitive_type_void,\n-  pascal_primitive_type_long_long,\n-  pascal_primitive_type_signed_char,\n-  pascal_primitive_type_unsigned_char,\n-  pascal_primitive_type_unsigned_short,\n-  pascal_primitive_type_unsigned_int,\n-  pascal_primitive_type_unsigned_long,\n-  pascal_primitive_type_unsigned_long_long,\n-  pascal_primitive_type_long_double,\n-  pascal_primitive_type_complex,\n-  pascal_primitive_type_double_complex,\n-  nr_pascal_primitive_types\n-};\n \n /* Class representing the Pascal language.  */\n \n@@ -282,47 +262,32 @@ class pascal_language : public language_defn\n   {\n     const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-    lai->string_char_type = builtin->builtin_char;\n-    lai->primitive_type_vector\n-      = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_pascal_primitive_types + 1,\n-\t\t\t      struct type *);\n-    lai->primitive_type_vector [pascal_primitive_type_int]\n-      = builtin->builtin_int;\n-    lai->primitive_type_vector [pascal_primitive_type_long]\n-      = builtin->builtin_long;\n-    lai->primitive_type_vector [pascal_primitive_type_short]\n-      = builtin->builtin_short;\n-    lai->primitive_type_vector [pascal_primitive_type_char]\n-      = builtin->builtin_char;\n-    lai->primitive_type_vector [pascal_primitive_type_float]\n-      = builtin->builtin_float;\n-    lai->primitive_type_vector [pascal_primitive_type_double]\n-      = builtin->builtin_double;\n-    lai->primitive_type_vector [pascal_primitive_type_void]\n-      = builtin->builtin_void;\n-    lai->primitive_type_vector [pascal_primitive_type_long_long]\n-      = builtin->builtin_long_long;\n-    lai->primitive_type_vector [pascal_primitive_type_signed_char]\n-      = builtin->builtin_signed_char;\n-    lai->primitive_type_vector [pascal_primitive_type_unsigned_char]\n-      = builtin->builtin_unsigned_char;\n-    lai->primitive_type_vector [pascal_primitive_type_unsigned_short]\n-      = builtin->builtin_unsigned_short;\n-    lai->primitive_type_vector [pascal_primitive_type_unsigned_int]\n-      = builtin->builtin_unsigned_int;\n-    lai->primitive_type_vector [pascal_primitive_type_unsigned_long]\n-      = builtin->builtin_unsigned_long;\n-    lai->primitive_type_vector [pascal_primitive_type_unsigned_long_long]\n-      = builtin->builtin_unsigned_long_long;\n-    lai->primitive_type_vector [pascal_primitive_type_long_double]\n-      = builtin->builtin_long_double;\n-    lai->primitive_type_vector [pascal_primitive_type_complex]\n-      = builtin->builtin_complex;\n-    lai->primitive_type_vector [pascal_primitive_type_double_complex]\n-      = builtin->builtin_double_complex;\n-\n-    lai->bool_type_symbol = \"boolean\";\n-    lai->bool_type_default = builtin->builtin_bool;\n+    /* Helper function to allow shorter lines below.  */\n+    auto add  = [&] (struct type * t)\n+    {\n+      lai->add_primitive_type (t);\n+    };\n+\n+    add (builtin->builtin_int);\n+    add (builtin->builtin_long);\n+    add (builtin->builtin_short);\n+    add (builtin->builtin_char);\n+    add (builtin->builtin_float);\n+    add (builtin->builtin_double);\n+    add (builtin->builtin_void);\n+    add (builtin->builtin_long_long);\n+    add (builtin->builtin_signed_char);\n+    add (builtin->builtin_unsigned_char);\n+    add (builtin->builtin_unsigned_short);\n+    add (builtin->builtin_unsigned_int);\n+    add (builtin->builtin_unsigned_long);\n+    add (builtin->builtin_unsigned_long_long);\n+    add (builtin->builtin_long_double);\n+    add (builtin->builtin_complex);\n+    add (builtin->builtin_double_complex);\n+\n+    lai->set_string_char_type (builtin->builtin_char);\n+    lai->set_bool_type (builtin->builtin_bool, \"boolean\");\n   }\n \n   /* See language.h.  */"
    },
    {
      "sha": "407be569308d2b50a39604b4184f462cd7065c91",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 29,
      "deletions": 49,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -961,27 +961,6 @@ rust_slice_type (const char *name, struct type *elt_type,\n   return type;\n }\n \n-enum rust_primitive_types\n-{\n-  rust_primitive_bool,\n-  rust_primitive_char,\n-  rust_primitive_i8,\n-  rust_primitive_u8,\n-  rust_primitive_i16,\n-  rust_primitive_u16,\n-  rust_primitive_i32,\n-  rust_primitive_u32,\n-  rust_primitive_i64,\n-  rust_primitive_u64,\n-  rust_primitive_isize,\n-  rust_primitive_usize,\n-  rust_primitive_f32,\n-  rust_primitive_f64,\n-  rust_primitive_unit,\n-  rust_primitive_str,\n-  nr_rust_primitive_types\n-};\n-\n \f\n \n /* A helper for rust_evaluate_subexp that handles OP_FUNCALL.  */\n@@ -1927,39 +1906,40 @@ class rust_language : public language_defn\n   {\n     const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-    struct type **types\n-      = GDBARCH_OBSTACK_CALLOC (gdbarch, nr_rust_primitive_types + 1,\n-\t\t\t\tstruct type *);\n-\n-    types[rust_primitive_bool] = arch_boolean_type (gdbarch, 8, 1, \"bool\");\n-    types[rust_primitive_char] = arch_character_type (gdbarch, 32, 1, \"char\");\n-    types[rust_primitive_i8] = arch_integer_type (gdbarch, 8, 0, \"i8\");\n-    types[rust_primitive_u8] = arch_integer_type (gdbarch, 8, 1, \"u8\");\n-    types[rust_primitive_i16] = arch_integer_type (gdbarch, 16, 0, \"i16\");\n-    types[rust_primitive_u16] = arch_integer_type (gdbarch, 16, 1, \"u16\");\n-    types[rust_primitive_i32] = arch_integer_type (gdbarch, 32, 0, \"i32\");\n-    types[rust_primitive_u32] = arch_integer_type (gdbarch, 32, 1, \"u32\");\n-    types[rust_primitive_i64] = arch_integer_type (gdbarch, 64, 0, \"i64\");\n-    types[rust_primitive_u64] = arch_integer_type (gdbarch, 64, 1, \"u64\");\n+    /* Helper function to allow shorter lines below.  */\n+    auto add  = [&] (struct type * t) -> struct type *\n+    {\n+      lai->add_primitive_type (t);\n+      return t;\n+    };\n+\n+    struct type *bool_type\n+      = add (arch_boolean_type (gdbarch, 8, 1, \"bool\"));\n+    add (arch_character_type (gdbarch, 32, 1, \"char\"));\n+    add (arch_integer_type (gdbarch, 8, 0, \"i8\"));\n+    struct type *u8_type\n+      = add (arch_integer_type (gdbarch, 8, 1, \"u8\"));\n+    add (arch_integer_type (gdbarch, 16, 0, \"i16\"));\n+    add (arch_integer_type (gdbarch, 16, 1, \"u16\"));\n+    add (arch_integer_type (gdbarch, 32, 0, \"i32\"));\n+    add (arch_integer_type (gdbarch, 32, 1, \"u32\"));\n+    add (arch_integer_type (gdbarch, 64, 0, \"i64\"));\n+    add (arch_integer_type (gdbarch, 64, 1, \"u64\"));\n \n     unsigned int length = 8 * TYPE_LENGTH (builtin->builtin_data_ptr);\n-    types[rust_primitive_isize] = arch_integer_type (gdbarch, length, 0, \"isize\");\n-    types[rust_primitive_usize] = arch_integer_type (gdbarch, length, 1, \"usize\");\n-\n-    types[rust_primitive_f32] = arch_float_type (gdbarch, 32, \"f32\",\n-\t\t\t\t\t\t floatformats_ieee_single);\n-    types[rust_primitive_f64] = arch_float_type (gdbarch, 64, \"f64\",\n-\t\t\t\t\t\t floatformats_ieee_double);\n+    add (arch_integer_type (gdbarch, length, 0, \"isize\"));\n+    struct type *usize_type\n+      = add (arch_integer_type (gdbarch, length, 1, \"usize\"));\n \n-    types[rust_primitive_unit] = arch_integer_type (gdbarch, 0, 1, \"()\");\n+    add (arch_float_type (gdbarch, 32, \"f32\", floatformats_ieee_single));\n+    add (arch_float_type (gdbarch, 64, \"f64\", floatformats_ieee_double));\n+    add (arch_integer_type (gdbarch, 0, 1, \"()\"));\n \n-    struct type *tem = make_cv_type (1, 0, types[rust_primitive_u8], NULL);\n-    types[rust_primitive_str] = rust_slice_type (\"&str\", tem,\n-\t\t\t\t\t\t types[rust_primitive_usize]);\n+    struct type *tem = make_cv_type (1, 0, u8_type, NULL);\n+    add (rust_slice_type (\"&str\", tem, usize_type));\n \n-    lai->primitive_type_vector = types;\n-    lai->bool_type_default = types[rust_primitive_bool];\n-    lai->string_char_type = types[rust_primitive_u8];\n+    lai->set_bool_type (bool_type);\n+    lai->set_string_char_type (u8_type);\n   }\n \n   /* See language.h.  */"
    },
    {
      "sha": "8cff6467603d3a7813c84b29d0790b98928d709c",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -1,3 +1,7 @@\n+2020-11-12  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/types.exp: Add more tests.\n+\n 2020-11-12  Tom Tromey  <tom@tromey.com>\n \n \tPR rust/26799:"
    },
    {
      "sha": "39dc13b6a3e3fac7373896b758f88695bd7671f4",
      "filename": "gdb/testsuite/gdb.fortran/types.exp",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/testsuite/gdb.fortran/types.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7bea47f0012c208d935c50d3b7ce9af7d34482b7/gdb/testsuite/gdb.fortran/types.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/types.exp?ref=7bea47f0012c208d935c50d3b7ce9af7d34482b7",
      "patch": "@@ -71,6 +71,16 @@ proc test_float_literal_types_accepted {} {\n     gdb_test \"pt 10e20\" \"type = real\\\\*\\[0-9\\]+\"\n }\n \n+# Test the the primitive Fortran types, those that GDB should always\n+# know, even if the program does not define them, are in fact, known.\n+proc test_primitive_types_known {} {\n+    foreach type {void character logical*1 integer*2 integer*8 \\\n+\t\t      logical*2 logical*8 integer logical*4 real \\\n+\t\t      real*8 real*16} {\n+\tgdb_test \"ptype $type\" [string_to_regexp \"type = $type\"]\n+    }\n+}\n+\n # Start with a fresh gdb.\n \n gdb_exit\n@@ -80,6 +90,7 @@ gdb_reinitialize_dir $srcdir/$subdir\n gdb_test \"set print sevenbit-strings\" \"\"\n \n if [set_lang_fortran] then {\n+    test_primitive_types_known\n     test_integer_literal_types_accepted\n     test_integer_literal_types_rejected\n     test_logical_literal_types_accepted"
    }
  ]
}