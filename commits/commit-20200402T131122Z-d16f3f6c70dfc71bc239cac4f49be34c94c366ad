{
  "sha": "d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDE2ZjNmNmM3MGRmYzcxYmMyMzljYWM0ZjQ5YmUzNGM5NGMzNjZhZA==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-04-02T13:11:22Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2020-04-02T13:11:22Z"
    },
    "message": "gdbserver/linux-low: turn some static functions into private methods\n\ngdbserver/ChangeLog:\n2020-04-02  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\tTurn some static functions in linux-low.cc into private methods of\n\tlinux_process_target.\n\n\t* linux-low.cc (handle_extended_wait): Turn into ...\n\t(linux_process_target::handle_extended_wait): ...this.  Call\n\t'mourn' on 'this' object instead of 'the_target'.\n\t(maybe_move_out_of_jump_pad): Turn into...\n\t(linux_process_target::maybe_move_out_of_jump_pad): ...this.\n\t(linux_low_filter_event): Turn into...\n\t(linux_process_target::filter_event): ...this.\n\t(linux_wait_for_event_filtered): Turn into...\n\t(linux_process_target::wait_for_event_filtered): ...this.\n\t(linux_wait_for_event): Turn into...\n\t(linux_process_target::wait_for_event): ...this.\n\t(linux_wait_1): Turn into...\n\t(linux_process_target::wait_1): ...this.\n\t(wait_for_sigstop): Turn into...\n\t(linux_process_target::wait_for_sigstop): ...this.\n\t(move_out_of_jump_pad_callback): Turn into...\n\t(linux_process_target::move_out_of_jump_pad): ...this.\n\t(stop_all_lwps): Turn into...\n\t(linux_process_target::stop_all_lwps): ...this.\n\t(start_step_over): Turn into...\n\t(linux_process_target::start_step_over): ...this.\n\t(complete_ongoing_step_over): Turn into...\n\t(linux_process_target::complete_ongoing_step_over): ...this.\n\t(proceed_all_lwps): Turn into...\n\t(linux_process_target::proceed_all_lwps): ...this.\n\t(unstop_all_lwps): Turn into...\n\t(linux_process_target::unstop_all_lwps): ...this.\n\n\t* linux-low.h (class linux_process_target)\n\t<handle_extended_wait>\n\t<maybe_move_out_of_jump_pad>\n\tfilter_event>\n\t<wait_for_event_filtered>\n\t<wait_for_event>\n\t<wait_1>\n\t<wait_for_sigstop>\n\t<move_out_of_jump_pad>\n\t<stop_all_lwps>\n\t<start_step_over>\n\t<complete_ongoing_step_over>\n\t<proceed_all_lwps>\n\t<unstop_all_lwps>: Declare.\n\n\tUpdate the callers below.\n\n\t* linux-low.cc (linux_process_target::attach): Update.\n\t(linux_process_target::stabilize_threads): Ditto.\n\t(linux_process_target::wait): Ditto.",
    "tree": {
      "sha": "9eec92f83ee4bd62b12d03fb59ad0c220120c277",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9eec92f83ee4bd62b12d03fb59ad0c220120c277"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a5863204fb1b9c03627edc3bb447c5958ef96458",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5863204fb1b9c03627edc3bb447c5958ef96458",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a5863204fb1b9c03627edc3bb447c5958ef96458"
    }
  ],
  "stats": {
    "total": 328,
    "additions": 195,
    "deletions": 133
  },
  "files": [
    {
      "sha": "6b789265f8bb10e693b7d0bc3d687022eb4b8429",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 54,
      "deletions": 0,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
      "patch": "@@ -1,3 +1,57 @@\n+2020-04-02  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\tTurn some static functions in linux-low.cc into private methods of\n+\tlinux_process_target.\n+\n+\t* linux-low.cc (handle_extended_wait): Turn into ...\n+\t(linux_process_target::handle_extended_wait): ...this.  Call\n+\t'mourn' on 'this' object instead of 'the_target'.\n+\t(maybe_move_out_of_jump_pad): Turn into...\n+\t(linux_process_target::maybe_move_out_of_jump_pad): ...this.\n+\t(linux_low_filter_event): Turn into...\n+\t(linux_process_target::filter_event): ...this.\n+\t(linux_wait_for_event_filtered): Turn into...\n+\t(linux_process_target::wait_for_event_filtered): ...this.\n+\t(linux_wait_for_event): Turn into...\n+\t(linux_process_target::wait_for_event): ...this.\n+\t(linux_wait_1): Turn into...\n+\t(linux_process_target::wait_1): ...this.\n+\t(wait_for_sigstop): Turn into...\n+\t(linux_process_target::wait_for_sigstop): ...this.\n+\t(move_out_of_jump_pad_callback): Turn into...\n+\t(linux_process_target::move_out_of_jump_pad): ...this.\n+\t(stop_all_lwps): Turn into...\n+\t(linux_process_target::stop_all_lwps): ...this.\n+\t(start_step_over): Turn into...\n+\t(linux_process_target::start_step_over): ...this.\n+\t(complete_ongoing_step_over): Turn into...\n+\t(linux_process_target::complete_ongoing_step_over): ...this.\n+\t(proceed_all_lwps): Turn into...\n+\t(linux_process_target::proceed_all_lwps): ...this.\n+\t(unstop_all_lwps): Turn into...\n+\t(linux_process_target::unstop_all_lwps): ...this.\n+\n+\t* linux-low.h (class linux_process_target)\n+\t<handle_extended_wait>\n+\t<maybe_move_out_of_jump_pad>\n+\tfilter_event>\n+\t<wait_for_event_filtered>\n+\t<wait_for_event>\n+\t<wait_1>\n+\t<wait_for_sigstop>\n+\t<move_out_of_jump_pad>\n+\t<stop_all_lwps>\n+\t<start_step_over>\n+\t<complete_ongoing_step_over>\n+\t<proceed_all_lwps>\n+\t<unstop_all_lwps>: Declare.\n+\n+\tUpdate the callers below.\n+\n+\t* linux-low.cc (linux_process_target::attach): Update.\n+\t(linux_process_target::stabilize_threads): Ditto.\n+\t(linux_process_target::wait): Ditto.\n+\n 2020-04-02  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* linux-low.h (struct linux_target_ops): Update the comment for"
    },
    {
      "sha": "e748bfc9c6da503e8ad1182e799c017c7411a25c",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 58,
      "deletions": 133,
      "changes": 191,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
      "patch": "@@ -269,20 +269,13 @@ static int stabilizing_threads;\n \n static void linux_resume_one_lwp (struct lwp_info *lwp,\n \t\t\t\t  int step, int signal, siginfo_t *info);\n-static void stop_all_lwps (int suspend, struct lwp_info *except);\n-static void unstop_all_lwps (int unsuspend, struct lwp_info *except);\n static void unsuspend_all_lwps (struct lwp_info *except);\n-static int linux_wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,\n-\t\t\t\t\t  int *wstat, int options);\n-static int linux_wait_for_event (ptid_t ptid, int *wstat, int options);\n static struct lwp_info *add_lwp (ptid_t ptid);\n static void mark_lwp_dead (struct lwp_info *lwp, int wstat);\n static int lwp_is_marked_dead (struct lwp_info *lwp);\n-static void proceed_all_lwps (void);\n static int finish_step_over (struct lwp_info *lwp);\n static int kill_lwp (unsigned long lwpid, int signo);\n static void enqueue_pending_signal (struct lwp_info *lwp, int signal, siginfo_t *info);\n-static void complete_ongoing_step_over (void);\n static int linux_low_ptrace_options (int attached);\n static int check_ptrace_stopped_lwp_gone (struct lwp_info *lp);\n static void proceed_one_lwp (thread_info *thread, lwp_info *except);\n@@ -355,7 +348,6 @@ static int linux_event_pipe[2] = { -1, -1 };\n #define target_is_async_p() (linux_event_pipe[0] != -1)\n \n static void send_sigstop (struct lwp_info *lwp);\n-static void wait_for_sigstop (void);\n \n /* Return non-zero if HEADER is a 64-bit ELF file.  */\n \n@@ -471,14 +463,9 @@ linux_arch_setup_thread (struct thread_info *thread)\n   current_thread = saved_thread;\n }\n \n-/* Handle a GNU/Linux extended wait response.  If we see a clone,\n-   fork, or vfork event, we need to add the new LWP to our list\n-   (and return 0 so as not to report the trap to higher layers).\n-   If we see an exec event, we will modify ORIG_EVENT_LWP to point\n-   to a new LWP representing the new program.  */\n-\n-static int\n-handle_extended_wait (struct lwp_info **orig_event_lwp, int wstat)\n+int\n+linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n+\t\t\t\t\t    int wstat)\n {\n   client_state &cs = get_client_state ();\n   struct lwp_info *event_lwp = *orig_event_lwp;\n@@ -711,7 +698,7 @@ handle_extended_wait (struct lwp_info **orig_event_lwp, int wstat)\n       syscalls_to_catch = std::move (proc->syscalls_to_catch);\n \n       /* Delete the execing process and all its threads.  */\n-      the_target->mourn (proc);\n+      mourn (proc);\n       current_thread = NULL;\n \n       /* Create a new process/lwp/thread.  */\n@@ -1234,8 +1221,7 @@ linux_process_target::attach (unsigned long pid)\n       int wstat, lwpid;\n       ptid_t pid_ptid = ptid_t (pid);\n \n-      lwpid = linux_wait_for_event_filtered (pid_ptid, pid_ptid,\n-\t\t\t\t\t     &wstat, __WALL);\n+      lwpid = wait_for_event_filtered (pid_ptid, pid_ptid, &wstat, __WALL);\n       gdb_assert (lwpid > 0);\n \n       lwp = find_lwp_pid (ptid_t (lwpid));\n@@ -1345,7 +1331,7 @@ kill_wait_lwp (struct lwp_info *lwp)\n \n \t - The loop is most likely unnecessary.\n \n-\t - We don't use linux_wait_for_event as that could delete lwps\n+\t - We don't use wait_for_event as that could delete lwps\n \t   while we're iterating over them.  We're not interested in\n \t   any pending status at this point, only in making sure all\n \t   wait status on the kernel side are collected until the\n@@ -2045,13 +2031,8 @@ linux_fast_tracepoint_collecting (struct lwp_info *lwp,\n   return fast_tracepoint_collecting (thread_area, lwp->stop_pc, status);\n }\n \n-/* The reason we resume in the caller, is because we want to be able\n-   to pass lwp->status_pending as WSTAT, and we need to clear\n-   status_pending_p before resuming, otherwise, linux_resume_one_lwp\n-   refuses to resume.  */\n-\n-static int\n-maybe_move_out_of_jump_pad (struct lwp_info *lwp, int *wstat)\n+bool\n+linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n {\n   struct thread_info *saved_thread;\n \n@@ -2099,7 +2080,7 @@ maybe_move_out_of_jump_pad (struct lwp_info *lwp, int *wstat)\n \t\t\t      lwpid_of (current_thread));\n \t      current_thread = saved_thread;\n \n-\t      return 1;\n+\t      return true;\n \t    }\n \t}\n       else\n@@ -2171,7 +2152,7 @@ maybe_move_out_of_jump_pad (struct lwp_info *lwp, int *wstat)\n \t\t  lwpid_of (current_thread));\n \n   current_thread = saved_thread;\n-  return 0;\n+  return false;\n }\n \n /* Enqueue one signal in the \"signals to report later when out of the\n@@ -2346,12 +2327,8 @@ linux_low_ptrace_options (int attached)\n   return options;\n }\n \n-/* Do low-level handling of the event, and check if we should go on\n-   and pass it to caller code.  Return the affected lwp if we are, or\n-   NULL otherwise.  */\n-\n-static struct lwp_info *\n-linux_low_filter_event (int lwpid, int wstat)\n+lwp_info *\n+linux_process_target::filter_event (int lwpid, int wstat)\n {\n   client_state &cs = get_client_state ();\n   struct lwp_info *child;\n@@ -2604,18 +2581,10 @@ resume_stopped_resumed_lwps (thread_info *thread)\n     }\n }\n \n-/* Wait for an event from child(ren) WAIT_PTID, and return any that\n-   match FILTER_PTID (leaving others pending).  The PTIDs can be:\n-   minus_one_ptid, to specify any child; a pid PTID, specifying all\n-   lwps of a thread group; or a PTID representing a single lwp.  Store\n-   the stop status through the status pointer WSTAT.  OPTIONS is\n-   passed to the waitpid call.  Return 0 if no event was found and\n-   OPTIONS contains WNOHANG.  Return -1 if no unwaited-for children\n-   was found.  Return the PID of the stopped child otherwise.  */\n-\n-static int\n-linux_wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,\n-\t\t\t       int *wstatp, int options)\n+int\n+linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n+\t\t\t\t\t       ptid_t filter_ptid,\n+\t\t\t\t\t       int *wstatp, int options)\n {\n   struct thread_info *event_thread;\n   struct lwp_info *event_child, *requested_child;\n@@ -2734,7 +2703,7 @@ linux_wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,\n \t  /* Filter all events.  IOW, leave all events pending.  We'll\n \t     randomly select an event LWP out of all that have events\n \t     below.  */\n-\t  linux_low_filter_event (ret, *wstatp);\n+\t  filter_event (ret, *wstatp);\n \t  /* Retry until nothing comes out of waitpid.  A single\n \t     SIGCHLD can indicate more than one child stopped.  */\n \t  continue;\n@@ -2811,18 +2780,10 @@ linux_wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,\n   return lwpid_of (event_thread);\n }\n \n-/* Wait for an event from child(ren) PTID.  PTIDs can be:\n-   minus_one_ptid, to specify any child; a pid PTID, specifying all\n-   lwps of a thread group; or a PTID representing a single lwp.  Store\n-   the stop status through the status pointer WSTAT.  OPTIONS is\n-   passed to the waitpid call.  Return 0 if no event was found and\n-   OPTIONS contains WNOHANG.  Return -1 if no unwaited-for children\n-   was found.  Return the PID of the stopped child otherwise.  */\n-\n-static int\n-linux_wait_for_event (ptid_t ptid, int *wstatp, int options)\n+int\n+linux_process_target::wait_for_event (ptid_t ptid, int *wstatp, int options)\n {\n-  return linux_wait_for_event_filtered (ptid, ptid, wstatp, options);\n+  return wait_for_event_filtered (ptid, ptid, wstatp, options);\n }\n \n /* Select one LWP out of those that have events pending.  */\n@@ -2897,12 +2858,8 @@ unsuspend_all_lwps (struct lwp_info *except)\n     });\n }\n \n-static void move_out_of_jump_pad_callback (thread_info *thread);\n static bool stuck_in_jump_pad_callback (thread_info *thread);\n static bool lwp_running (thread_info *thread);\n-static ptid_t linux_wait_1 (ptid_t ptid,\n-\t\t\t    struct target_waitstatus *ourstatus,\n-\t\t\t    int target_options);\n \n /* Stabilize threads (move out of jump pads).\n \n@@ -2952,7 +2909,10 @@ linux_process_target::stabilize_threads ()\n   stabilizing_threads = 1;\n \n   /* Kick 'em all.  */\n-  for_each_thread (move_out_of_jump_pad_callback);\n+  for_each_thread ([this] (thread_info *thread)\n+    {\n+      move_out_of_jump_pad (thread);\n+    });\n \n   /* Loop until all are stopped out of the jump pads.  */\n   while (find_thread (lwp_running) != NULL)\n@@ -2964,7 +2924,7 @@ linux_process_target::stabilize_threads ()\n       /* Note that we go through the full wait even loop.  While\n \t moving threads out of jump pad, we need to be able to step\n \t over internal breakpoints and such.  */\n-      linux_wait_1 (minus_one_ptid, &ourstatus, 0);\n+      wait_1 (minus_one_ptid, &ourstatus, 0);\n \n       if (ourstatus.kind == TARGET_WAITKIND_STOPPED)\n \t{\n@@ -3074,11 +3034,9 @@ gdb_catch_this_syscall_p (struct lwp_info *event_child)\n   return 0;\n }\n \n-/* Wait for process, returns status.  */\n-\n-static ptid_t\n-linux_wait_1 (ptid_t ptid,\n-\t      struct target_waitstatus *ourstatus, int target_options)\n+ptid_t\n+linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n+\t\t\t      int target_options)\n {\n   client_state &cs = get_client_state ();\n   int w;\n@@ -3096,7 +3054,7 @@ linux_wait_1 (ptid_t ptid,\n   if (debug_threads)\n     {\n       debug_enter ();\n-      debug_printf (\"linux_wait_1: [%s]\\n\", target_pid_to_str (ptid));\n+      debug_printf (\"wait_1: [%s]\\n\", target_pid_to_str (ptid));\n     }\n \n   /* Translate generic target options into linux options.  */\n@@ -3128,13 +3086,13 @@ linux_wait_1 (ptid_t ptid,\n     any_resumed = 0;\n \n   if (step_over_bkpt == null_ptid)\n-    pid = linux_wait_for_event (ptid, &w, options);\n+    pid = wait_for_event (ptid, &w, options);\n   else\n     {\n       if (debug_threads)\n \tdebug_printf (\"step_over_bkpt set [%s], doing a blocking wait\\n\",\n \t\t      target_pid_to_str (step_over_bkpt));\n-      pid = linux_wait_for_event (step_over_bkpt, &w, options & ~WNOHANG);\n+      pid = wait_for_event (step_over_bkpt, &w, options & ~WNOHANG);\n     }\n \n   if (pid == 0 || (pid == -1 && !any_resumed))\n@@ -3143,7 +3101,7 @@ linux_wait_1 (ptid_t ptid,\n \n       if (debug_threads)\n \t{\n-\t  debug_printf (\"linux_wait_1 ret = null_ptid, \"\n+\t  debug_printf (\"wait_1 ret = null_ptid, \"\n \t\t\t\"TARGET_WAITKIND_IGNORE\\n\");\n \t  debug_exit ();\n \t}\n@@ -3155,7 +3113,7 @@ linux_wait_1 (ptid_t ptid,\n     {\n       if (debug_threads)\n \t{\n-\t  debug_printf (\"linux_wait_1 ret = null_ptid, \"\n+\t  debug_printf (\"wait_1 ret = null_ptid, \"\n \t\t\t\"TARGET_WAITKIND_NO_RESUMED\\n\");\n \t  debug_exit ();\n \t}\n@@ -3166,7 +3124,7 @@ linux_wait_1 (ptid_t ptid,\n \n   event_child = get_thread_lwp (current_thread);\n \n-  /* linux_wait_for_event only returns an exit status for the last\n+  /* wait_for_event only returns an exit status for the last\n      child of a process.  Report it.  */\n   if (WIFEXITED (w) || WIFSIGNALED (w))\n     {\n@@ -3177,7 +3135,7 @@ linux_wait_1 (ptid_t ptid,\n \n \t  if (debug_threads)\n \t    {\n-\t      debug_printf (\"linux_wait_1 ret = %s, exited with \"\n+\t      debug_printf (\"wait_1 ret = %s, exited with \"\n \t\t\t    \"retcode %d\\n\",\n \t\t\t    target_pid_to_str (ptid_of (current_thread)),\n \t\t\t    WEXITSTATUS (w));\n@@ -3191,7 +3149,7 @@ linux_wait_1 (ptid_t ptid,\n \n \t  if (debug_threads)\n \t    {\n-\t      debug_printf (\"linux_wait_1 ret = %s, terminated with \"\n+\t      debug_printf (\"wait_1 ret = %s, terminated with \"\n \t\t\t    \"signal %d\\n\",\n \t\t\t    target_pid_to_str (ptid_of (current_thread)),\n \t\t\t    WTERMSIG (w));\n@@ -3225,9 +3183,8 @@ linux_wait_1 (ptid_t ptid,\n       int breakpoint_kind = 0;\n       CORE_ADDR stop_pc = event_child->stop_pc;\n \n-      breakpoint_kind =\n-\tthe_target->breakpoint_kind_from_current_state (&stop_pc);\n-      the_target->sw_breakpoint_from_kind (breakpoint_kind, &increment_pc);\n+      breakpoint_kind = breakpoint_kind_from_current_state (&stop_pc);\n+      sw_breakpoint_from_kind (breakpoint_kind, &increment_pc);\n \n       if (debug_threads)\n \t{\n@@ -3400,7 +3357,7 @@ linux_wait_1 (ptid_t ptid,\n \n \t\t  if (debug_threads)\n \t\t    {\n-\t\t      debug_printf (\"linux_wait_1 ret = %s, stopped \"\n+\t\t      debug_printf (\"wait_1 ret = %s, stopped \"\n \t\t\t\t    \"while stabilizing threads\\n\",\n \t\t\t\t    target_pid_to_str (ptid_of (current_thread)));\n \t\t      debug_exit ();\n@@ -3799,7 +3756,7 @@ linux_wait_1 (ptid_t ptid,\n \n   if (debug_threads)\n     {\n-      debug_printf (\"linux_wait_1 ret = %s, %d, %d\\n\",\n+      debug_printf (\"wait_1 ret = %s, %d, %d\\n\",\n \t\t    target_pid_to_str (ptid_of (current_thread)),\n \t\t    ourstatus->kind, ourstatus->value.sig);\n       debug_exit ();\n@@ -3852,7 +3809,7 @@ linux_process_target::wait (ptid_t ptid,\n \n   do\n     {\n-      event_ptid = linux_wait_1 (ptid, ourstatus, target_options);\n+      event_ptid = wait_1 (ptid, ourstatus, target_options);\n     }\n   while ((target_options & TARGET_WNOHANG) == 0\n \t && event_ptid == null_ptid\n@@ -3985,10 +3942,8 @@ lwp_is_marked_dead (struct lwp_info *lwp)\n \t      || WIFSIGNALED (lwp->status_pending)));\n }\n \n-/* Wait for all children to stop for the SIGSTOPs we just queued.  */\n-\n-static void\n-wait_for_sigstop (void)\n+void\n+linux_process_target::wait_for_sigstop ()\n {\n   struct thread_info *saved_thread;\n   ptid_t saved_tid;\n@@ -4007,8 +3962,7 @@ wait_for_sigstop (void)\n   /* Passing NULL_PTID as filter indicates we want all events to be\n      left pending.  Eventually this returns when there are no\n      unwaited-for children left.  */\n-  ret = linux_wait_for_event_filtered (minus_one_ptid, null_ptid,\n-\t\t\t\t       &wstat, __WALL);\n+  ret = wait_for_event_filtered (minus_one_ptid, null_ptid, &wstat, __WALL);\n   gdb_assert (ret == -1);\n \n   if (saved_thread == NULL || mythread_alive (saved_tid))\n@@ -4053,8 +4007,8 @@ stuck_in_jump_pad_callback (thread_info *thread)\n \t      != fast_tpoint_collect_result::not_collecting));\n }\n \n-static void\n-move_out_of_jump_pad_callback (thread_info *thread)\n+void\n+linux_process_target::move_out_of_jump_pad (thread_info *thread)\n {\n   struct thread_info *saved_thread;\n   struct lwp_info *lwp = get_thread_lwp (thread);\n@@ -4114,12 +4068,8 @@ lwp_running (thread_info *thread)\n   return !lwp->stopped;\n }\n \n-/* Stop all lwps that aren't stopped yet, except EXCEPT, if not NULL.\n-   If SUSPEND, then also increase the suspend count of every LWP,\n-   except EXCEPT.  */\n-\n-static void\n-stop_all_lwps (int suspend, struct lwp_info *except)\n+void\n+linux_process_target::stop_all_lwps (int suspend, lwp_info *except)\n {\n   /* Should not be called recursively.  */\n   gdb_assert (stopping_threads == NOT_STOPPING_THREADS);\n@@ -4758,18 +4708,8 @@ need_step_over_p (thread_info *thread)\n   return false;\n }\n \n-/* Start a step-over operation on LWP.  When LWP stopped at a\n-   breakpoint, to make progress, we need to remove the breakpoint out\n-   of the way.  If we let other threads run while we do that, they may\n-   pass by the breakpoint location and miss hitting it.  To avoid\n-   that, a step-over momentarily stops all threads while LWP is\n-   single-stepped by either hardware or software while the breakpoint\n-   is temporarily uninserted from the inferior.  When the single-step\n-   finishes, we reinsert the breakpoint, and let all threads that are\n-   supposed to be running, run again.  */\n-\n-static int\n-start_step_over (struct lwp_info *lwp)\n+void\n+linux_process_target::start_step_over (lwp_info *lwp)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n   struct thread_info *saved_thread;\n@@ -4813,7 +4753,6 @@ start_step_over (struct lwp_info *lwp)\n \n   /* Require next event from this LWP.  */\n   step_over_bkpt = thread->id;\n-  return 1;\n }\n \n /* Finish a step-over.  Reinsert the breakpoint we had uninserted in\n@@ -4858,14 +4797,8 @@ finish_step_over (struct lwp_info *lwp)\n     return 0;\n }\n \n-/* If there's a step over in progress, wait until all threads stop\n-   (that is, until the stepping thread finishes its step), and\n-   unsuspend all lwps.  The stepping thread ends with its status\n-   pending, which is processed later when we get back to processing\n-   events.  */\n-\n-static void\n-complete_ongoing_step_over (void)\n+void\n+linux_process_target::complete_ongoing_step_over ()\n {\n   if (step_over_bkpt != null_ptid)\n     {\n@@ -4879,8 +4812,8 @@ complete_ongoing_step_over (void)\n       /* Passing NULL_PTID as filter indicates we want all events to\n \t be left pending.  Eventually this returns when there are no\n \t unwaited-for children left.  */\n-      ret = linux_wait_for_event_filtered (minus_one_ptid, null_ptid,\n-\t\t\t\t\t   &wstat, __WALL);\n+      ret = wait_for_event_filtered (minus_one_ptid, null_ptid, &wstat,\n+\t\t\t\t     __WALL);\n       gdb_assert (ret == -1);\n \n       lwp = find_lwp_pid (step_over_bkpt);\n@@ -5197,12 +5130,8 @@ unsuspend_and_proceed_one_lwp (thread_info *thread, lwp_info *except)\n   proceed_one_lwp (thread, except);\n }\n \n-/* When we finish a step-over, set threads running again.  If there's\n-   another thread that may need a step-over, now's the time to start\n-   it.  Eventually, we'll move all threads past their breakpoints.  */\n-\n-static void\n-proceed_all_lwps (void)\n+void\n+linux_process_target::proceed_all_lwps ()\n {\n   struct thread_info *need_step_over;\n \n@@ -5236,12 +5165,8 @@ proceed_all_lwps (void)\n     });\n }\n \n-/* Stopped LWPs that the client wanted to be running, that don't have\n-   pending statuses, are set to run again, except for EXCEPT, if not\n-   NULL.  This undoes a stop_all_lwps call.  */\n-\n-static void\n-unstop_all_lwps (int unsuspend, struct lwp_info *except)\n+void\n+linux_process_target::unstop_all_lwps (int unsuspend, lwp_info *except)\n {\n   if (debug_threads)\n     {"
    },
    {
      "sha": "bc7abce2ac6802d983f4d6f306245a4d909af994",
      "filename": "gdbserver/linux-low.h",
      "status": "modified",
      "additions": 83,
      "deletions": 0,
      "changes": 83,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/gdbserver/linux-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d16f3f6c70dfc71bc239cac4f49be34c94c366ad/gdbserver/linux-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.h?ref=d16f3f6c70dfc71bc239cac4f49be34c94c366ad",
      "patch": "@@ -480,6 +480,89 @@ class linux_process_target : public process_stratum_target\n   bool supports_catch_syscall () override;\n \n   int get_ipa_tdesc_idx () override;\n+\n+private:\n+\n+  /* Handle a GNU/Linux extended wait response.  If we see a clone,\n+     fork, or vfork event, we need to add the new LWP to our list\n+     (and return 0 so as not to report the trap to higher layers).\n+     If we see an exec event, we will modify ORIG_EVENT_LWP to point\n+     to a new LWP representing the new program.  */\n+  int handle_extended_wait (lwp_info **orig_event_lwp, int wstat);\n+\n+  /* Do low-level handling of the event, and check if we should go on\n+     and pass it to caller code.  Return the affected lwp if we are, or\n+     NULL otherwise.  */\n+  lwp_info *filter_event (int lwpid, int wstat);\n+\n+  /* Wait for an event from child(ren) WAIT_PTID, and return any that\n+     match FILTER_PTID (leaving others pending).  The PTIDs can be:\n+     minus_one_ptid, to specify any child; a pid PTID, specifying all\n+     lwps of a thread group; or a PTID representing a single lwp.  Store\n+     the stop status through the status pointer WSTAT.  OPTIONS is\n+     passed to the waitpid call.  Return 0 if no event was found and\n+     OPTIONS contains WNOHANG.  Return -1 if no unwaited-for children\n+     was found.  Return the PID of the stopped child otherwise.  */\n+  int wait_for_event_filtered (ptid_t wait_ptid, ptid_t filter_ptid,\n+\t\t\t       int *wstatp, int options);\n+\n+  /* Wait for an event from child(ren) PTID.  PTIDs can be:\n+     minus_one_ptid, to specify any child; a pid PTID, specifying all\n+     lwps of a thread group; or a PTID representing a single lwp.  Store\n+     the stop status through the status pointer WSTAT.  OPTIONS is\n+     passed to the waitpid call.  Return 0 if no event was found and\n+     OPTIONS contains WNOHANG.  Return -1 if no unwaited-for children\n+     was found.  Return the PID of the stopped child otherwise.  */\n+  int wait_for_event (ptid_t ptid, int *wstatp, int options);\n+\n+  /* Wait for all children to stop for the SIGSTOPs we just queued.  */\n+  void wait_for_sigstop ();\n+\n+  /* Wait for process, returns status.  */\n+  ptid_t wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n+\t\t int target_options);\n+\n+  /* Stop all lwps that aren't stopped yet, except EXCEPT, if not NULL.\n+     If SUSPEND, then also increase the suspend count of every LWP,\n+     except EXCEPT.  */\n+  void stop_all_lwps (int suspend, lwp_info *except);\n+\n+  /* Stopped LWPs that the client wanted to be running, that don't have\n+     pending statuses, are set to run again, except for EXCEPT, if not\n+     NULL.  This undoes a stop_all_lwps call.  */\n+  void unstop_all_lwps (int unsuspend, lwp_info *except);\n+\n+  /* Start a step-over operation on LWP.  When LWP stopped at a\n+     breakpoint, to make progress, we need to remove the breakpoint out\n+     of the way.  If we let other threads run while we do that, they may\n+     pass by the breakpoint location and miss hitting it.  To avoid\n+     that, a step-over momentarily stops all threads while LWP is\n+     single-stepped by either hardware or software while the breakpoint\n+     is temporarily uninserted from the inferior.  When the single-step\n+     finishes, we reinsert the breakpoint, and let all threads that are\n+     supposed to be running, run again.  */\n+  void start_step_over (lwp_info *lwp);\n+\n+  /* If there's a step over in progress, wait until all threads stop\n+     (that is, until the stepping thread finishes its step), and\n+     unsuspend all lwps.  The stepping thread ends with its status\n+     pending, which is processed later when we get back to processing\n+     events.  */\n+  void complete_ongoing_step_over ();\n+\n+  /* When we finish a step-over, set threads running again.  If there's\n+     another thread that may need a step-over, now's the time to start\n+     it.  Eventually, we'll move all threads past their breakpoints.  */\n+  void proceed_all_lwps ();\n+\n+  /* The reason we resume in the caller, is because we want to be able\n+     to pass lwp->status_pending as WSTAT, and we need to clear\n+     status_pending_p before resuming, otherwise, resume_one_lwp\n+     refuses to resume.  */\n+  bool maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat);\n+\n+  /* Move THREAD out of the jump pad.  */\n+  void move_out_of_jump_pad (thread_info *thread);\n };\n \n #define get_thread_lwp(thr) ((struct lwp_info *) (thread_target_data (thr)))"
    }
  ]
}