{
  "sha": "28a0d291cd726f5945f54412143377fde3842bcb",
  "node_id": "C_kwDOANOeidoAKDI4YTBkMjkxY2Q3MjZmNTk0NWY1NDQxMjE0MzM3N2ZkZTM4NDJiY2I",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-12-03T21:35:38Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-12-08T03:16:43Z"
    },
    "message": "gdb: make struct linespect contain vectors, not pointers to vectors\n\nstruct linespec contains pointers to vectors, instead of containing\nvectors directly.  This is probably historical, when linespec_parser\n(which contains a struct linespec field) was not C++-ified yet.  But it\nseems easy to change the pointers to vectors to just vectors today.\nThis simplifies the code, we don't need to manually allocate and delete\nthe vectors and there's no pointer that can be NULL.\n\nAs far as I understand, there was not meaningful distinction between a\nNULL pointer to vector and an empty vector.  So all NULL checks are\nchanged for !empty checks.\n\nChange-Id: Ie759707da14d9d984169b93233343a86e2de9ee6",
    "tree": {
      "sha": "cadf7285ab0754cb953d204524575d8813009bb7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cadf7285ab0754cb953d204524575d8813009bb7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/28a0d291cd726f5945f54412143377fde3842bcb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28a0d291cd726f5945f54412143377fde3842bcb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/28a0d291cd726f5945f54412143377fde3842bcb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28a0d291cd726f5945f54412143377fde3842bcb/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "abca192fed507de150e04d2173f4c3531d0c6d92",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abca192fed507de150e04d2173f4c3531d0c6d92",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/abca192fed507de150e04d2173f4c3531d0c6d92"
    }
  ],
  "stats": {
    "total": 222,
    "additions": 105,
    "deletions": 117
  },
  "files": [
    {
      "sha": "0d3820b978530b919ec122c368819cadf2a8e883",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 105,
      "deletions": 117,
      "changes": 222,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/28a0d291cd726f5945f54412143377fde3842bcb/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/28a0d291cd726f5945f54412143377fde3842bcb/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=28a0d291cd726f5945f54412143377fde3842bcb",
      "patch": "@@ -95,26 +95,27 @@ struct address_entry\n struct linespec\n {\n   /* An explicit location describing the SaLs.  */\n-  struct explicit_location explicit_loc;\n+  struct explicit_location explicit_loc {};\n \n-  /* The list of symtabs to search to which to limit the search.  May not\n-     be NULL.  If explicit.SOURCE_FILENAME is NULL (no user-specified\n-     filename), FILE_SYMTABS should contain one single NULL member.  This\n-     will cause the code to use the default symtab.  */\n-  std::vector<symtab *> *file_symtabs;\n+  /* The list of symtabs to search to which to limit the search.\n+\n+     If explicit.SOURCE_FILENAME is NULL (no user-specified filename),\n+     FILE_SYMTABS should contain one single NULL member.  This will cause the\n+     code to use the default symtab.  */\n+  std::vector<symtab *> file_symtabs;\n \n   /* A list of matching function symbols and minimal symbols.  Both lists\n-     may be NULL (or empty) if no matching symbols were found.  */\n-  std::vector<block_symbol> *function_symbols;\n-  std::vector<bound_minimal_symbol> *minimal_symbols;\n+     may be empty if no matching symbols were found.  */\n+  std::vector<block_symbol> function_symbols;\n+  std::vector<bound_minimal_symbol> minimal_symbols;\n \n   /* A structure of matching label symbols and the corresponding\n-     function symbol in which the label was found.  Both may be NULL\n-     or both must be non-NULL.  */\n+     function symbol in which the label was found.  Both may be empty\n+     or both must be non-empty.  */\n   struct\n   {\n-    std::vector<block_symbol> *label_symbols;\n-    std::vector<block_symbol> *function_symbols;\n+    std::vector<block_symbol> label_symbols;\n+    std::vector<block_symbol> function_symbols;\n   } labels;\n };\n \n@@ -185,7 +186,7 @@ struct collect_info\n   struct linespec_state *state;\n \n   /* A list of symtabs to which to restrict matches.  */\n-  std::vector<symtab *> *file_symtabs;\n+  const std::vector<symtab *> *file_symtabs;\n \n   /* The result being accumulated.  */\n   struct\n@@ -315,7 +316,7 @@ struct linespec_parser\n #define PARSER_STATE(PPTR) (&(PPTR)->state)\n \n   /* The result of the parse.  */\n-  struct linespec result {};\n+  linespec result;\n #define PARSER_RESULT(PPTR) (&(PPTR)->result)\n \n   /* What the parser believes the current word point should complete\n@@ -365,13 +366,14 @@ static std::vector<symtab_and_line> decode_objc (struct linespec_state *self,\n static std::vector<symtab *> symtabs_from_filename\n   (const char *, struct program_space *pspace);\n \n-static std::vector<block_symbol> *find_label_symbols\n-  (struct linespec_state *self, std::vector<block_symbol> *function_symbols,\n-   std::vector<block_symbol> *label_funcs_ret, const char *name,\n-   bool completion_mode = false);\n+static std::vector<block_symbol> find_label_symbols\n+  (struct linespec_state *self,\n+   const std::vector<block_symbol> &function_symbols,\n+   std::vector<block_symbol> *label_funcs_ret,\n+   const char *name, bool completion_mode = false);\n \n static void find_linespec_symbols (struct linespec_state *self,\n-\t\t\t\t   std::vector<symtab *> *file_symtabs,\n+\t\t\t\t   const std::vector<symtab *> &file_symtabs,\n \t\t\t\t   const char *name,\n \t\t\t\t   symbol_name_match_type name_match_type,\n \t\t\t\t   std::vector<block_symbol> *symbols,\n@@ -1787,9 +1789,6 @@ linespec_parse_basic (linespec_parser *parser)\n {\n   gdb::unique_xmalloc_ptr<char> name;\n   linespec_token token;\n-  std::vector<block_symbol> symbols;\n-  std::vector<block_symbol> *labels;\n-  std::vector<bound_minimal_symbol> minimal_symbols;\n \n   /* Get the next token.  */\n   token = linespec_lexer_lex_one (parser);\n@@ -1886,6 +1885,9 @@ linespec_parse_basic (linespec_parser *parser)\n     }\n   else\n     {\n+      std::vector<block_symbol> symbols;\n+      std::vector<bound_minimal_symbol> minimal_symbols;\n+\n       /* Try looking it up as a function/method.  */\n       find_linespec_symbols (PARSER_STATE (parser),\n \t\t\t     PARSER_RESULT (parser)->file_symtabs, name.get (),\n@@ -1894,24 +1896,23 @@ linespec_parse_basic (linespec_parser *parser)\n \n       if (!symbols.empty () || !minimal_symbols.empty ())\n \t{\n-\t  PARSER_RESULT (parser)->function_symbols\n-\t    = new std::vector<block_symbol> (std::move (symbols));\n-\t  PARSER_RESULT (parser)->minimal_symbols\n-\t    = new std::vector<bound_minimal_symbol>\n-\t\t(std::move (minimal_symbols));\n+\t  PARSER_RESULT (parser)->function_symbols = std::move (symbols);\n+\t  PARSER_RESULT (parser)->minimal_symbols = std::move (minimal_symbols);\n \t  PARSER_EXPLICIT (parser)->function_name = name.release ();\n \t}\n       else\n \t{\n \t  /* NAME was not a function or a method.  So it must be a label\n \t     name or user specified variable like \"break foo.c:$zippo\".  */\n-\t  labels = find_label_symbols (PARSER_STATE (parser), NULL,\n-\t\t\t\t       &symbols, name.get ());\n-\t  if (labels != NULL)\n+\t  std::vector<block_symbol> labels\n+\t    = find_label_symbols (PARSER_STATE (parser), {}, &symbols,\n+\t\t\t\t  name.get ());\n+\n+\t  if (!labels.empty ())\n \t    {\n-\t      PARSER_RESULT (parser)->labels.label_symbols = labels;\n+\t      PARSER_RESULT (parser)->labels.label_symbols = std::move (labels);\n \t      PARSER_RESULT (parser)->labels.function_symbols\n-\t\t= new std::vector<block_symbol> (std::move (symbols));\n+\t\t  = std::move (symbols);\n \t      PARSER_EXPLICIT (parser)->label_name = name.release ();\n \t    }\n \t  else if (token.type == LSTOKEN_STRING\n@@ -2006,18 +2007,21 @@ linespec_parse_basic (linespec_parser *parser)\n \t    }\n \t  else\n \t    {\n+\t      std::vector<block_symbol> symbols;\n+\n \t      /* Grab a copy of the label's name and look it up.  */\n \t      name = copy_token_string (token);\n-\t      labels\n+\t      std::vector<block_symbol> labels\n \t\t= find_label_symbols (PARSER_STATE (parser),\n \t\t\t\t      PARSER_RESULT (parser)->function_symbols,\n \t\t\t\t      &symbols, name.get ());\n \n-\t      if (labels != NULL)\n+\t      if (!labels.empty ())\n \t\t{\n-\t\t  PARSER_RESULT (parser)->labels.label_symbols = labels;\n+\t\t  PARSER_RESULT (parser)->labels.label_symbols\n+\t\t    = std::move (labels);\n \t\t  PARSER_RESULT (parser)->labels.function_symbols\n-\t\t    = new std::vector<block_symbol> (std::move (symbols));\n+\t\t    = std::move (symbols);\n \t\t  PARSER_EXPLICIT (parser)->label_name = name.release ();\n \t\t}\n \t      else\n@@ -2085,8 +2089,8 @@ canonicalize_linespec (struct linespec_state *state, const linespec *ls)\n       if (explicit_loc->function_name == NULL)\n \t{\n \t  /* No function was specified, so add the symbol name.  */\n-\t  gdb_assert (ls->labels.function_symbols->size () == 1);\n-\t  block_symbol s = ls->labels.function_symbols->front ();\n+\t  gdb_assert (ls->labels.function_symbols.size () == 1);\n+\t  block_symbol s = ls->labels.function_symbols.front ();\n \t  explicit_loc->function_name = xstrdup (s.symbol->natural_name ());\n \t}\n     }\n@@ -2116,15 +2120,15 @@ create_sals_line_offset (struct linespec_state *self,\n      set_default_source_symtab_and_line uses\n      select_source_symtab that calls us with such an argument.  */\n \n-  if (ls->file_symtabs->size () == 1\n-      && ls->file_symtabs->front () == nullptr)\n+  if (ls->file_symtabs.size () == 1\n+      && ls->file_symtabs.front () == nullptr)\n     {\n       set_current_program_space (self->program_space);\n \n       /* Make sure we have at least a default source line.  */\n       set_default_source_symtab_and_line ();\n       initialize_defaults (&self->default_symtab, &self->default_line);\n-      *ls->file_symtabs\n+      ls->file_symtabs\n \t= collect_symtabs_from_filename (self->default_symtab->filename,\n \t\t\t\t\t self->search_pspace);\n       use_default = 1;\n@@ -2257,12 +2261,12 @@ convert_linespec_to_sals (struct linespec_state *state, linespec *ls)\n {\n   std::vector<symtab_and_line> sals;\n \n-  if (ls->labels.label_symbols != NULL)\n+  if (!ls->labels.label_symbols.empty ())\n     {\n       /* We have just a bunch of functions/methods or labels.  */\n       struct symtab_and_line sal;\n \n-      for (const auto &sym : *ls->labels.label_symbols)\n+      for (const auto &sym : ls->labels.label_symbols)\n \t{\n \t  struct program_space *pspace\n \t    = SYMTAB_PSPACE (symbol_symtab (sym.symbol));\n@@ -2273,18 +2277,18 @@ convert_linespec_to_sals (struct linespec_state *state, linespec *ls)\n \t\t\t     sym.symbol->natural_name (), 0);\n \t}\n     }\n-  else if (ls->function_symbols != NULL || ls->minimal_symbols != NULL)\n+  else if (!ls->function_symbols.empty () || !ls->minimal_symbols.empty ())\n     {\n       /* We have just a bunch of functions and/or methods.  */\n-      if (ls->function_symbols != NULL)\n+      if (!ls->function_symbols.empty ())\n \t{\n \t  /* Sort symbols so that symbols with the same program space are next\n \t     to each other.  */\n-\t  std::sort (ls->function_symbols->begin (),\n-\t\t     ls->function_symbols->end (),\n+\t  std::sort (ls->function_symbols.begin (),\n+\t\t     ls->function_symbols.end (),\n \t\t     compare_symbols);\n \n-\t  for (const auto &sym : *ls->function_symbols)\n+\t  for (const auto &sym : ls->function_symbols)\n \t    {\n \t      program_space *pspace\n \t\t= SYMTAB_PSPACE (symbol_symtab (sym.symbol));\n@@ -2297,13 +2301,13 @@ convert_linespec_to_sals (struct linespec_state *state, linespec *ls)\n \t      bool found_ifunc = false;\n \n \t      if (state->funfirstline\n-\t\t   && ls->minimal_symbols != NULL\n+\t\t   && !ls->minimal_symbols.empty ()\n \t\t   && SYMBOL_CLASS (sym.symbol) == LOC_BLOCK)\n \t\t{\n \t\t  const CORE_ADDR addr\n \t\t    = BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym.symbol));\n \n-\t\t  for (const auto &elem : *ls->minimal_symbols)\n+\t\t  for (const auto &elem : ls->minimal_symbols)\n \t\t    {\n \t\t      if (MSYMBOL_TYPE (elem.minsym) == mst_text_gnu_ifunc\n \t\t\t  || MSYMBOL_TYPE (elem.minsym) == mst_data_gnu_ifunc)\n@@ -2340,14 +2344,14 @@ convert_linespec_to_sals (struct linespec_state *state, linespec *ls)\n \t    }\n \t}\n \n-      if (ls->minimal_symbols != NULL)\n+      if (!ls->minimal_symbols.empty ())\n \t{\n \t  /* Sort minimal symbols by program space, too  */\n-\t  std::sort (ls->minimal_symbols->begin (),\n-\t\t     ls->minimal_symbols->end (),\n+\t  std::sort (ls->minimal_symbols.begin (),\n+\t\t     ls->minimal_symbols.end (),\n \t\t     compare_msymbols);\n \n-\t  for (const auto &elem : *ls->minimal_symbols)\n+\t  for (const auto &elem : ls->minimal_symbols)\n \t    {\n \t      program_space *pspace = elem.objfile->pspace;\n \t      set_current_program_space (pspace);\n@@ -2398,8 +2402,6 @@ convert_explicit_location_to_linespec (struct linespec_state *self,\n \t\t\t\t       const char *label_name,\n \t\t\t\t       struct line_offset line_offset)\n {\n-  std::vector<block_symbol> symbols;\n-  std::vector<block_symbol> *labels;\n   std::vector<bound_minimal_symbol> minimal_symbols;\n \n   result->explicit_loc.func_name_match_type = fname_match_type;\n@@ -2408,7 +2410,7 @@ convert_explicit_location_to_linespec (struct linespec_state *self,\n     {\n       try\n \t{\n-\t  *result->file_symtabs\n+\t  result->file_symtabs\n \t    = symtabs_from_filename (source_filename, self->search_pspace);\n \t}\n       catch (const gdb_exception_error &except)\n@@ -2420,11 +2422,13 @@ convert_explicit_location_to_linespec (struct linespec_state *self,\n   else\n     {\n       /* A NULL entry means to use the default symtab.  */\n-      result->file_symtabs->push_back (nullptr);\n+      result->file_symtabs.push_back (nullptr);\n     }\n \n   if (function_name != NULL)\n     {\n+      std::vector<block_symbol> symbols;\n+\n       find_linespec_symbols (self, result->file_symtabs,\n \t\t\t     function_name, fname_match_type,\n \t\t\t     &symbols, &minimal_symbols);\n@@ -2434,25 +2438,24 @@ convert_explicit_location_to_linespec (struct linespec_state *self,\n \t\t\t\tresult->explicit_loc.source_filename);\n \n       result->explicit_loc.function_name = xstrdup (function_name);\n-      result->function_symbols\n-\t= new std::vector<block_symbol> (std::move (symbols));\n-      result->minimal_symbols\n-\t= new std::vector<bound_minimal_symbol> (std::move (minimal_symbols));\n+      result->function_symbols = std::move (symbols);\n+      result->minimal_symbols = std::move (minimal_symbols);\n     }\n \n   if (label_name != NULL)\n     {\n-      labels = find_label_symbols (self, result->function_symbols,\n-\t\t\t\t   &symbols, label_name);\n+      std::vector<block_symbol> symbols;\n+      std::vector<block_symbol> labels\n+\t= find_label_symbols (self, result->function_symbols,\n+\t\t\t      &symbols, label_name);\n \n-      if (labels == NULL)\n+      if (labels.empty ())\n \tundefined_label_error (result->explicit_loc.function_name,\n \t\t\t       label_name);\n \n       result->explicit_loc.label_name = xstrdup (label_name);\n       result->labels.label_symbols = labels;\n-      result->labels.function_symbols\n-\t= new std::vector<block_symbol> (std::move (symbols));\n+      result->labels.function_symbols = std::move (symbols);\n     }\n \n   if (line_offset.sign != LINE_OFFSET_UNKNOWN)\n@@ -2591,7 +2594,7 @@ parse_linespec (linespec_parser *parser, const char *arg,\n     {\n       /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */\n       if (parser->completion_tracker == NULL)\n-\tPARSER_RESULT (parser)->file_symtabs->push_back (nullptr);\n+\tPARSER_RESULT (parser)->file_symtabs.push_back (nullptr);\n \n       /* User specified a convenience variable or history value.  */\n       gdb::unique_xmalloc_ptr<char> var = copy_token_string (token);\n@@ -2632,7 +2635,7 @@ parse_linespec (linespec_parser *parser, const char *arg,\n       /* Check if the input is a filename.  */\n       try\n \t{\n-\t  *PARSER_RESULT (parser)->file_symtabs\n+\t  PARSER_RESULT (parser)->file_symtabs\n \t    = symtabs_from_filename (user_filename.get (),\n \t\t\t\t     PARSER_STATE (parser)->search_pspace);\n \t}\n@@ -2655,7 +2658,7 @@ parse_linespec (linespec_parser *parser, const char *arg,\n       else\n \t{\n \t  /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */\n-\t  PARSER_RESULT (parser)->file_symtabs->push_back (nullptr);\n+\t  PARSER_RESULT (parser)->file_symtabs.push_back (nullptr);\n \t}\n     }\n   /* If the next token is not EOI, KEYWORD, or COMMA, issue an error.  */\n@@ -2671,17 +2674,17 @@ parse_linespec (linespec_parser *parser, const char *arg,\n   else\n     {\n       /* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */\n-      PARSER_RESULT (parser)->file_symtabs->push_back (nullptr);\n+      PARSER_RESULT (parser)->file_symtabs.push_back (nullptr);\n     }\n \n   /* Parse the rest of the linespec.  */\n   linespec_parse_basic (parser);\n \n   if (parser->completion_tracker == NULL\n-      && PARSER_RESULT (parser)->function_symbols == NULL\n-      && PARSER_RESULT (parser)->labels.label_symbols == NULL\n+      && PARSER_RESULT (parser)->function_symbols.empty ()\n+      && PARSER_RESULT (parser)->labels.label_symbols.empty ()\n       && PARSER_EXPLICIT (parser)->line_offset.sign == LINE_OFFSET_UNKNOWN\n-      && PARSER_RESULT (parser)->minimal_symbols == NULL)\n+      && PARSER_RESULT (parser)->minimal_symbols.empty ())\n     {\n       /* The linespec didn't parse.  Re-throw the file exception if\n \t there was one.  */\n@@ -2753,7 +2756,6 @@ linespec_parser::linespec_parser (int flags,\n \t\t\t\t  struct linespec_result *canonical)\n {\n   lexer.current.type = LSTOKEN_CONSUMED;\n-  PARSER_RESULT (this)->file_symtabs = new std::vector<symtab *> ();\n   PARSER_EXPLICIT (this)->func_name_match_type\n     = symbol_name_match_type::WILD;\n   PARSER_EXPLICIT (this)->line_offset.sign = LINE_OFFSET_UNKNOWN;\n@@ -2779,12 +2781,6 @@ linespec_parser::~linespec_parser ()\n   xfree (PARSER_EXPLICIT (this)->label_name);\n   xfree (PARSER_EXPLICIT (this)->function_name);\n \n-  delete PARSER_RESULT (this)->file_symtabs;\n-  delete PARSER_RESULT (this)->function_symbols;\n-  delete PARSER_RESULT (this)->minimal_symbols;\n-  delete PARSER_RESULT (this)->labels.label_symbols;\n-  delete PARSER_RESULT (this)->labels.function_symbols;\n-\n   linespec_state_destructor (PARSER_STATE (this));\n }\n \n@@ -2913,20 +2909,16 @@ complete_label (completion_tracker &tracker,\n \t\tconst char *label_name)\n {\n   std::vector<block_symbol> label_function_symbols;\n-  std::vector<block_symbol> *labels\n+  std::vector<block_symbol> labels\n     = find_label_symbols (PARSER_STATE (parser),\n \t\t\t  PARSER_RESULT (parser)->function_symbols,\n \t\t\t  &label_function_symbols,\n \t\t\t  label_name, true);\n \n-  if (labels != nullptr)\n+  for (const auto &label : labels)\n     {\n-      for (const auto &label : *labels)\n-\t{\n-\t  char *match = xstrdup (label.symbol->search_name ());\n-\t  tracker.add_completion (gdb::unique_xmalloc_ptr<char> (match));\n-\t}\n-      delete labels;\n+      char *match = xstrdup (label.symbol->search_name ());\n+      tracker.add_completion (gdb::unique_xmalloc_ptr<char> (match));\n     }\n }\n \n@@ -3031,10 +3023,8 @@ linespec_complete (completion_tracker &tracker, const char *text,\n \t\t\t     func_name, match_type,\n \t\t\t     &function_symbols, &minimal_symbols);\n \n-      PARSER_RESULT (&parser)->function_symbols\n-\t= new std::vector<block_symbol> (std::move (function_symbols));\n-      PARSER_RESULT (&parser)->minimal_symbols\n-\t= new std::vector<bound_minimal_symbol> (std::move (minimal_symbols));\n+      PARSER_RESULT (&parser)->function_symbols = std::move (function_symbols);\n+      PARSER_RESULT (&parser)->minimal_symbols = std::move (minimal_symbols);\n \n       complete_label (tracker, &parser, parser.completion_word);\n     }\n@@ -3436,10 +3426,8 @@ decode_objc (struct linespec_state *self, linespec *ls, const char *arg)\n       saved_arg[new_argptr - arg] = '\\0';\n \n       ls->explicit_loc.function_name = xstrdup (saved_arg);\n-      ls->function_symbols\n-\t= new std::vector<block_symbol> (std::move (symbols));\n-      ls->minimal_symbols\n-\t= new std::vector<bound_minimal_symbol> (std::move (minimal_symbols));\n+      ls->function_symbols = std::move (symbols);\n+      ls->minimal_symbols = std::move (minimal_symbols);\n       values = convert_linespec_to_sals (self, ls);\n \n       if (self->canonical)\n@@ -3533,14 +3521,14 @@ decode_compound_collector::operator () (block_symbol *bsym)\n \n static std::vector<block_symbol>\n lookup_prefix_sym (struct linespec_state *state,\n-\t\t   std::vector<symtab *> *file_symtabs,\n+\t\t   const std::vector<symtab *> &file_symtabs,\n \t\t   const char *class_name)\n {\n   decode_compound_collector collector;\n \n   lookup_name_info lookup_name (class_name, symbol_name_match_type::FULL);\n \n-  for (const auto &elt : *file_symtabs)\n+  for (const auto &elt : file_symtabs)\n     {\n       if (elt == nullptr)\n \t{\n@@ -3658,7 +3646,8 @@ find_superclass_methods (std::vector<struct type *> &&superclasses,\n    in SYMBOLS (for debug symbols) and MINSYMS (for minimal symbols).  */\n \n static void\n-find_method (struct linespec_state *self, std::vector<symtab *> *file_symtabs,\n+find_method (struct linespec_state *self,\n+\t     const std::vector<symtab *> &file_symtabs,\n \t     const char *class_name, const char *method_name,\n \t     std::vector<block_symbol> *sym_classes,\n \t     std::vector<block_symbol> *symbols,\n@@ -3675,7 +3664,7 @@ find_method (struct linespec_state *self, std::vector<symtab *> *file_symtabs,\n \t     compare_symbols);\n \n   info.state = self;\n-  info.file_symtabs = file_symtabs;\n+  info.file_symtabs = &file_symtabs;\n   info.result.symbols = symbols;\n   info.result.minimal_symbols = minsyms;\n \n@@ -3875,7 +3864,7 @@ symbol_searcher::find_all_symbols (const std::string &name,\n \n static void\n find_function_symbols (struct linespec_state *state,\n-\t\t       std::vector<symtab *> *file_symtabs, const char *name,\n+\t\t       const std::vector<symtab *> &file_symtabs, const char *name,\n \t\t       symbol_name_match_type name_match_type,\n \t\t       std::vector<block_symbol> *symbols,\n \t\t       std::vector<bound_minimal_symbol> *minsyms)\n@@ -3886,7 +3875,7 @@ find_function_symbols (struct linespec_state *state,\n   info.state = state;\n   info.result.symbols = symbols;\n   info.result.minimal_symbols = minsyms;\n-  info.file_symtabs = file_symtabs;\n+  info.file_symtabs = &file_symtabs;\n \n   /* Try NAME as an Objective-C selector.  */\n   find_imps (name, &symbol_names);\n@@ -3903,7 +3892,7 @@ find_function_symbols (struct linespec_state *state,\n \n static void\n find_linespec_symbols (struct linespec_state *state,\n-\t\t       std::vector<symtab *> *file_symtabs,\n+\t\t       const std::vector<symtab *> &file_symtabs,\n \t\t       const char *lookup_name,\n \t\t       symbol_name_match_type name_match_type,\n \t\t       std::vector <block_symbol> *symbols,\n@@ -4031,18 +4020,17 @@ find_label_symbols_in_block (const struct block *block,\n     }\n }\n \n-/* Return all labels that match name NAME in FUNCTION_SYMBOLS or NULL\n-   if no matches were found.\n+/* Return all labels that match name NAME in FUNCTION_SYMBOLS.\n \n    Return the actual function symbol in which the label was found in\n    LABEL_FUNC_RET.  If COMPLETION_MODE is true, then NAME is\n    interpreted as a label name prefix.  Otherwise, only labels named\n    exactly NAME match.  */\n \n \n-static std::vector<block_symbol> *\n+static std::vector<block_symbol>\n find_label_symbols (struct linespec_state *self,\n-\t\t    std::vector<block_symbol> *function_symbols,\n+\t\t    const std::vector<block_symbol> &function_symbols,\n \t\t    std::vector<block_symbol> *label_funcs_ret,\n \t\t    const char *name,\n \t\t    bool completion_mode)\n@@ -4051,7 +4039,7 @@ find_label_symbols (struct linespec_state *self,\n   struct symbol *fn_sym;\n   std::vector<block_symbol> result;\n \n-  if (function_symbols == NULL)\n+  if (function_symbols.empty ())\n     {\n       set_current_program_space (self->program_space);\n       block = get_current_search_block ();\n@@ -4060,16 +4048,18 @@ find_label_symbols (struct linespec_state *self,\n \t   block && !BLOCK_FUNCTION (block);\n \t   block = BLOCK_SUPERBLOCK (block))\n \t;\n+\n       if (!block)\n-\treturn NULL;\n+\treturn {};\n+\n       fn_sym = BLOCK_FUNCTION (block);\n \n       find_label_symbols_in_block (block, name, fn_sym, completion_mode,\n \t\t\t\t   &result, label_funcs_ret);\n     }\n   else\n     {\n-      for (const auto &elt : *function_symbols)\n+      for (const auto &elt : function_symbols)\n \t{\n \t  fn_sym = elt.symbol;\n \t  set_current_program_space (SYMTAB_PSPACE (symbol_symtab (fn_sym)));\n@@ -4080,9 +4070,7 @@ find_label_symbols (struct linespec_state *self,\n \t}\n     }\n \n-  if (!result.empty ())\n-    return new std::vector<block_symbol> (std::move (result));\n-  return nullptr;\n+  return result;\n }\n \n \f\n@@ -4098,7 +4086,7 @@ decode_digits_list_mode (struct linespec_state *self,\n \n   std::vector<symtab_and_line> values;\n \n-  for (const auto &elt : *ls->file_symtabs)\n+  for (const auto &elt : ls->file_symtabs)\n     {\n       /* The logic above should ensure this.  */\n       gdb_assert (elt != NULL);\n@@ -4130,7 +4118,7 @@ decode_digits_ordinary (struct linespec_state *self,\n \t\t\tstruct linetable_entry **best_entry)\n {\n   std::vector<symtab_and_line> sals;\n-  for (const auto &elt : *ls->file_symtabs)\n+  for (const auto &elt : ls->file_symtabs)\n     {\n       std::vector<CORE_ADDR> pcs;\n "
    }
  ]
}