{
  "sha": "6751ebaea074088b6e30ad885669cd65b8608d20",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Njc1MWViYWVhMDc0MDg4YjZlMzBhZDg4NTY2OWNkNjViODYwOGQyMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:43:55Z"
    },
    "message": "Remove \"keep\" parameter from cutu_reader constructor\n\ncutu_reader has a \"keep\" parameter, which is used to decide what to do\nwith a new CU when the reader is destroyed.  Most code does not try to\npreserve the CU, so this patch removes this parameter and instead adds\na new method that users can call to preserve the CU on the chain.\n\ngdb/ChangeLog\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (class cutu_reader) <cutu_reader,\n\tinit_tu_and_read_dwo_dies>: Remove \"keep\" parameter.\n\t<keep>: Declare method.\n\t<m_keep>: Remove member.\n\t<~cutu_reader>: Remove.\n\t(cutu_reader::init_tu_and_read_dwo_dies): Update.\n\t(cutu_reader::cutu_reader): Update.\n\t(cutu_reader::keep): Rename from ~cutu_reader.\n\t(process_psymtab_comp_unit, build_type_psymtabs_1)\n\t(process_skeletonless_type_unit, load_partial_comp_unit)\n\t(load_full_comp_unit, dwarf2_read_addr_index)\n\t(read_signatured_type): Update.\n\nChange-Id: I859b1c64313569d76d46317c14e9b077ebc3a27b",
    "tree": {
      "sha": "d852c16fdee275792168538b19298afa86b7a7cb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d852c16fdee275792168538b19298afa86b7a7cb"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6751ebaea074088b6e30ad885669cd65b8608d20",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6751ebaea074088b6e30ad885669cd65b8608d20",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6751ebaea074088b6e30ad885669cd65b8608d20",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6751ebaea074088b6e30ad885669cd65b8608d20/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "135f543748f651938774666649bb0365018d62da",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/135f543748f651938774666649bb0365018d62da",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/135f543748f651938774666649bb0365018d62da"
    }
  ],
  "stats": {
    "total": 70,
    "additions": 43,
    "deletions": 27
  },
  "files": [
    {
      "sha": "3aecd1284fade5fc370df58b7b45531184ce1dbf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6751ebaea074088b6e30ad885669cd65b8608d20/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6751ebaea074088b6e30ad885669cd65b8608d20/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6751ebaea074088b6e30ad885669cd65b8608d20",
      "patch": "@@ -1,3 +1,18 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (class cutu_reader) <cutu_reader,\n+\tinit_tu_and_read_dwo_dies>: Remove \"keep\" parameter.\n+\t<keep>: Declare method.\n+\t<m_keep>: Remove member.\n+\t<~cutu_reader>: Remove.\n+\t(cutu_reader::init_tu_and_read_dwo_dies): Update.\n+\t(cutu_reader::cutu_reader): Update.\n+\t(cutu_reader::keep): Rename from ~cutu_reader.\n+\t(process_psymtab_comp_unit, build_type_psymtabs_1)\n+\t(process_skeletonless_type_unit, load_partial_comp_unit)\n+\t(load_full_comp_unit, dwarf2_read_addr_index)\n+\t(read_signatured_type): Update.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (process_psymtab_comp_unit_reader): Remove"
    },
    {
      "sha": "d1622dc74fa34bcd9cd29a4941a66be56ce9b349",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 28,
      "deletions": 27,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6751ebaea074088b6e30ad885669cd65b8608d20/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6751ebaea074088b6e30ad885669cd65b8608d20/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=6751ebaea074088b6e30ad885669cd65b8608d20",
      "patch": "@@ -881,27 +881,28 @@ class cutu_reader : public die_reader_specs\n \n   cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \t       struct abbrev_table *abbrev_table,\n-\t       int use_existing_cu, int keep,\n+\t       int use_existing_cu,\n \t       bool skip_partial);\n \n   explicit cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \t\t\tstruct dwarf2_cu *parent_cu = nullptr,\n \t\t\tstruct dwo_file *dwo_file = nullptr);\n \n-  ~cutu_reader ();\n-\n   DISABLE_COPY_AND_ASSIGN (cutu_reader);\n \n   const gdb_byte *info_ptr = nullptr;\n   struct die_info *comp_unit_die = nullptr;\n   bool dummy_p = false;\n \n+  /* Release the new CU, putting it on the chain.  This cannot be done\n+     for dummy CUs.  */\n+  void keep ();\n+\n private:\n   void init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n-\t\t\t\t  int use_existing_cu, int keep);\n+\t\t\t\t  int use_existing_cu);\n \n   struct dwarf2_per_cu_data *m_this_cu;\n-  int m_keep = 0;\n   std::unique_ptr<dwarf2_cu> m_new_cu;\n \n   /* The ordinary abbreviation table.  */\n@@ -6723,7 +6724,7 @@ lookup_dwo_unit (struct dwarf2_per_cu_data *this_cu,\n \n void\n cutu_reader::init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n-\t\t\t\t\tint use_existing_cu, int keep)\n+\t\t\t\t\tint use_existing_cu)\n {\n   struct signatured_type *sig_type;\n   struct die_reader_specs reader;\n@@ -6771,19 +6772,14 @@ cutu_reader::init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n    This is an optimization for when we already have the abbrev table.\n \n    If USE_EXISTING_CU is non-zero, and THIS_CU->cu is non-NULL, then use it.\n-   Otherwise, a new CU is allocated with xmalloc.\n-\n-   If KEEP is non-zero, then if we allocated a dwarf2_cu we add it to\n-   read_in_chain.  Otherwise the dwarf2_cu data is freed at the\n-   end.  */\n+   Otherwise, a new CU is allocated with xmalloc.  */\n \n cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \t\t\t  struct abbrev_table *abbrev_table,\n-\t\t\t  int use_existing_cu, int keep,\n+\t\t\t  int use_existing_cu,\n \t\t\t  bool skip_partial)\n   : die_reader_specs {},\n-    m_this_cu (this_cu),\n-    m_keep (keep)\n+    m_this_cu (this_cu)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n@@ -6803,17 +6799,14 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \t\t\tthis_cu->is_debug_types ? \"type\" : \"comp\",\n \t\t\tsect_offset_str (this_cu->sect_off));\n \n-  if (use_existing_cu)\n-    gdb_assert (keep);\n-\n   /* If we're reading a TU directly from a DWO file, including a virtual DWO\n      file (instead of going through the stub), short-circuit all of this.  */\n   if (this_cu->reading_dwo_directly)\n     {\n       /* Narrow down the scope of possibilities to have to understand.  */\n       gdb_assert (this_cu->is_debug_types);\n       gdb_assert (abbrev_table == NULL);\n-      init_tu_and_read_dwo_dies (this_cu, use_existing_cu, keep);\n+      init_tu_and_read_dwo_dies (this_cu, use_existing_cu);\n       return;\n     }\n \n@@ -6969,10 +6962,12 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n     }\n }\n \n-cutu_reader::~cutu_reader ()\n+void\n+cutu_reader::keep ()\n {\n   /* Done, clean up.  */\n-  if (m_new_cu != NULL && m_keep && !dummy_p)\n+  gdb_assert (!dummy_p);\n+  if (m_new_cu != NULL)\n     {\n       struct dwarf2_per_objfile *dwarf2_per_objfile\n \t= m_this_cu->dwarf2_per_objfile;\n@@ -7376,7 +7371,7 @@ process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,\n   if (this_cu->cu != NULL)\n     free_one_cached_comp_unit (this_cu);\n \n-  cutu_reader reader (this_cu, NULL, 0, 0, false);\n+  cutu_reader reader (this_cu, NULL, 0, false);\n \n   if (reader.dummy_p)\n     {\n@@ -7545,7 +7540,7 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t}\n \n       cutu_reader reader (&tu.sig_type->per_cu, abbrev_table.get (),\n-\t\t\t  0, 0, false);\n+\t\t\t  0, false);\n       if (!reader.dummy_p)\n \tbuild_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\t    reader.comp_unit_die);\n@@ -7653,7 +7648,7 @@ process_skeletonless_type_unit (void **slot, void *info)\n   *slot = entry;\n \n   /* This does the job that build_type_psymtabs_1 would have done.  */\n-  cutu_reader reader (&entry->per_cu, NULL, 0, 0, false);\n+  cutu_reader reader (&entry->per_cu, NULL, 0, false);\n   if (!reader.dummy_p)\n     build_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\treader.comp_unit_die);\n@@ -7782,7 +7777,7 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n static void\n load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)\n {\n-  cutu_reader reader (this_cu, NULL, 1, 1, false);\n+  cutu_reader reader (this_cu, NULL, 1, false);\n \n   if (!reader.dummy_p)\n     {\n@@ -7794,6 +7789,8 @@ load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)\n \t If not, there's no more debug_info for this comp unit.  */\n       if (reader.comp_unit_die->has_children)\n \tload_partial_dies (&reader, reader.info_ptr, 0);\n+\n+      reader.keep ();\n     }\n }\n \n@@ -8892,7 +8889,7 @@ load_full_comp_unit (struct dwarf2_per_cu_data *this_cu,\n {\n   gdb_assert (! this_cu->is_debug_types);\n \n-  cutu_reader reader (this_cu, NULL, 1, 1, skip_partial);\n+  cutu_reader reader (this_cu, NULL, 1, skip_partial);\n   if (reader.dummy_p)\n     return;\n \n@@ -8923,6 +8920,8 @@ load_full_comp_unit (struct dwarf2_per_cu_data *this_cu,\n      Similarly, if we do not read the producer, we can not apply\n      producer-specific interpretation.  */\n   prepare_one_comp_unit (cu, cu->dies, pretend_language);\n+\n+  reader.keep ();\n }\n \n /* Add a DIE to the delayed physname list.  */\n@@ -18916,7 +18915,7 @@ dwarf2_read_addr_index (struct dwarf2_per_cu_data *per_cu,\n     }\n   else\n     {\n-      cutu_reader reader (per_cu, NULL, 0, 0, false);\n+      cutu_reader reader (per_cu, NULL, 0, false);\n       addr_base = reader.cu->addr_base;\n       addr_size = reader.cu->header.addr_size;\n     }\n@@ -22748,7 +22747,7 @@ read_signatured_type (struct signatured_type *sig_type)\n   gdb_assert (per_cu->is_debug_types);\n   gdb_assert (per_cu->cu == NULL);\n \n-  cutu_reader reader (per_cu, NULL, 0, 1, false);\n+  cutu_reader reader (per_cu, NULL, 0, false);\n \n   if (!reader.dummy_p)\n     {\n@@ -22779,6 +22778,8 @@ read_signatured_type (struct signatured_type *sig_type)\n \t correctly.  Similarly, if we do not read the producer, we can\n \t not apply producer-specific interpretation.  */\n       prepare_one_comp_unit (cu, cu->dies, language_minimal);\n+\n+      reader.keep ();\n     }\n \n   sig_type->per_cu.tu_read = 1;"
    }
  ]
}