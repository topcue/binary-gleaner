{
  "sha": "c058728c31684d08da396f1bf50fabaa196dc9d9",
  "node_id": "C_kwDOANOeidoAKGMwNTg3MjhjMzE2ODRkMDhkYTM5NmYxYmY1MGZhYmFhMTk2ZGM5ZDk",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-01-17T02:27:58Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-01-18T18:44:32Z"
    },
    "message": "gdbserver: introduce threads_debug_printf, THREADS_SCOPED_DEBUG_ENTER_EXIT\n\nAdd the threads_debug_printf and THREADS_SCOPED_DEBUG_ENTER_EXIT, which\nuse the logging infrastructure from gdbsupport/common-debug.h.  Replace\nall debug_print uses that are predicated by debug_threads with\nthreads_dethreads_debug_printf.  Replace uses of the debug_enter and\ndebug_exit macros with THREADS_SCOPED_DEBUG_ENTER_EXIT, which serves\nessentially the same purpose, but allows showing what comes between the\nenter and the exit in an indented form.\n\nNote that \"threads\" debug is currently used for a bit of everything in\nGDBserver, not only threads related stuff.  It should ideally be cleaned\nup and separated logically as is done in GDB, but that's out of the\nscope of this patch.\n\nChange-Id: I2d4546464462cb4c16f7f1168c5cec5a89f2289a",
    "tree": {
      "sha": "8e0d08d18cf135f7071fa9ee37dd549ee86656a8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8e0d08d18cf135f7071fa9ee37dd549ee86656a8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c058728c31684d08da396f1bf50fabaa196dc9d9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c058728c31684d08da396f1bf50fabaa196dc9d9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c058728c31684d08da396f1bf50fabaa196dc9d9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c058728c31684d08da396f1bf50fabaa196dc9d9/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c68665c7260985ac8497ccafcea961f4a261c675",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c68665c7260985ac8497ccafcea961f4a261c675",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c68665c7260985ac8497ccafcea961f4a261c675"
    }
  ],
  "stats": {
    "total": 1281,
    "additions": 483,
    "deletions": 798
  },
  "files": [
    {
      "sha": "365bd2195b229a5f8af23d9d77b48217390f3bd5",
      "filename": "gdbserver/ax.cc",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/ax.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/ax.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ax.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -39,7 +39,7 @@ ax_vdebug (const char *fmt, ...)\n #ifdef IN_PROCESS_AGENT\n   fprintf (stderr, PROG \"/ax: %s\\n\", buf);\n #else\n-  debug_printf (PROG \"/ax: %s\\n\", buf);\n+  threads_debug_printf (PROG \"/ax: %s\", buf);\n #endif\n   va_end (ap);\n }"
    },
    {
      "sha": "8b3e95e65cd16b5d914fa620a014e30508a32555",
      "filename": "gdbserver/debug.cc",
      "status": "modified",
      "additions": 0,
      "deletions": 24,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/debug.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/debug.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/debug.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -110,30 +110,6 @@ debug_flush (void)\n   fflush (debug_file);\n }\n \n-/* Notify the user that the code is entering FUNCTION_NAME.\n-   FUNCTION_NAME is the name of the calling function, or NULL if unknown.\n-\n-   This is intended to be called via the debug_enter macro.  */\n-\n-void\n-do_debug_enter (const char *function_name)\n-{\n-  if (function_name != NULL)\n-    debug_printf (\">>>> entering %s\\n\", function_name);\n-}\n-\n-/* Notify the user that the code is exiting FUNCTION_NAME.\n-   FUNCTION_NAME is the name of the calling function, or NULL if unknown.\n-\n-   This is intended to be called via the debug_exit macro.  */\n-\n-void\n-do_debug_exit (const char *function_name)\n-{\n-  if (function_name != NULL)\n-    debug_printf (\"<<<< exiting %s\\n\", function_name);\n-}\n-\n /* See debug.h.  */\n \n ssize_t"
    },
    {
      "sha": "4220246de793d4f8ed38a72a5580ef54d8526dac",
      "filename": "gdbserver/debug.h",
      "status": "modified",
      "additions": 11,
      "deletions": 20,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/debug.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/debug.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/debug.h?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -35,31 +35,22 @@ extern int using_threads;\n \n extern bool debug_threads;\n \n+/* Print a \"threads\" debug statement.  */\n+\n+#define threads_debug_printf(fmt, ...) \\\n+  debug_prefixed_printf_cond (debug_threads, \\\n+\t\t\t      \"threads\", fmt, ##__VA_ARGS__)\n+\n+/* Print \"threads\" enter/exit debug statements.  */\n+\n+#define THREADS_SCOPED_DEBUG_ENTER_EXIT \\\n+  scoped_debug_enter_exit (debug_threads, \"threads\")\n+\n extern int debug_timestamp;\n \n void debug_flush (void);\n-void do_debug_enter (const char *function_name);\n-void do_debug_exit (const char *function_name);\n \n /* Async signal safe debug output function that calls write directly.  */\n ssize_t debug_write (const void *buf, size_t nbyte);\n \n-/* These macros are for use in major functions that produce a lot of\n-   debugging output.  They help identify in the mass of debugging output\n-   when these functions enter and exit.  debug_enter is intended to be\n-   called at the start of a function, before any other debugging output.\n-   debug_exit is intended to be called at the end of the same function,\n-   after all debugging output.  */\n-#ifdef FUNCTION_NAME\n-#define debug_enter() \\\n-  do { do_debug_enter (FUNCTION_NAME); } while (0)\n-#define debug_exit() \\\n-  do { do_debug_exit (FUNCTION_NAME); } while (0)\n-#else\n-#define debug_enter() \\\n-  do { } while (0)\n-#define debug_exit() \\\n-  do { } while (0)\n-#endif\n-\n #endif /* GDBSERVER_DEBUG_H */"
    },
    {
      "sha": "96dd4d009ab8ce49e281e795fa51b5834d40de0f",
      "filename": "gdbserver/fork-child.cc",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/fork-child.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/fork-child.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/fork-child.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -45,11 +45,7 @@ void\n prefork_hook (const char *args)\n {\n   client_state &cs = get_client_state ();\n-  if (debug_threads)\n-    {\n-      debug_printf (\"args: %s\\n\", args);\n-      debug_flush ();\n-    }\n+  threads_debug_printf (\"args: %s\", args);\n \n #ifdef SIGTTOU\n   signal (SIGTTOU, SIG_DFL);"
    },
    {
      "sha": "aef69b34525936d476aa7761afa555644d17d8a3",
      "filename": "gdbserver/linux-aarch64-low.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-aarch64-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-aarch64-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-aarch64-low.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -2467,9 +2467,8 @@ emit_ops_insns (const uint32_t *start, int len)\n {\n   CORE_ADDR buildaddr = current_insn_ptr;\n \n-  if (debug_threads)\n-    debug_printf (\"Adding %d instrucions at %s\\n\",\n-\t\t  len, paddress (buildaddr));\n+  threads_debug_printf (\"Adding %d instrucions at %s\",\n+\t\t\tlen, paddress (buildaddr));\n \n   append_insns (&buildaddr, len, start);\n   current_insn_ptr = buildaddr;"
    },
    {
      "sha": "9e571a4d771f7cac2a8aa041d54852756206d09f",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 366,
      "deletions": 599,
      "changes": 965,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -376,8 +376,7 @@ linux_process_target::delete_lwp (lwp_info *lwp)\n {\n   struct thread_info *thr = get_lwp_thread (lwp);\n \n-  if (debug_threads)\n-    debug_printf (\"deleting %ld\\n\", lwpid_of (thr));\n+  threads_debug_printf (\"deleting %ld\", lwpid_of (thr));\n \n   remove_thread (thr);\n \n@@ -489,13 +488,10 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \n \t  ptid = ptid_t (new_pid, new_pid);\n \n-\t  if (debug_threads)\n-\t    {\n-\t      debug_printf (\"HEW: Got fork event from LWP %ld, \"\n-\t\t\t    \"new child is %d\\n\",\n-\t\t\t    ptid_of (event_thr).lwp (),\n-\t\t\t    ptid.pid ());\n-\t    }\n+\t  threads_debug_printf (\"Got fork event from LWP %ld, \"\n+\t\t\t\t\"new child is %d\",\n+\t\t\t\tptid_of (event_thr).lwp (),\n+\t\t\t\tptid.pid ());\n \n \t  /* Add the new process to the tables and clone the breakpoint\n \t     lists of the parent.  We need to do this even if the new process\n@@ -520,8 +516,7 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \t  if (stopping_threads == STOPPING_AND_SUSPENDING_THREADS\n \t      || event_lwp->bp_reinsert != 0)\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"HEW: leaving child suspended\\n\");\n+\t      threads_debug_printf (\"leaving child suspended\");\n \t      child_lwp->suspended = 1;\n \t    }\n \n@@ -586,10 +581,9 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \t  return 0;\n \t}\n \n-      if (debug_threads)\n-\tdebug_printf (\"HEW: Got clone event \"\n-\t\t      \"from LWP %ld, new child is LWP %ld\\n\",\n-\t\t      lwpid_of (event_thr), new_pid);\n+      threads_debug_printf\n+\t(\"Got clone event from LWP %ld, new child is LWP %ld\",\n+\t lwpid_of (event_thr), new_pid);\n \n       ptid = ptid_t (pid_of (event_thr), new_pid);\n       new_lwp = add_lwp (ptid);\n@@ -652,11 +646,8 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n       ptid_t event_ptid;\n       pid_t event_pid;\n \n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"HEW: Got exec event from LWP %ld\\n\",\n-\t\t\tlwpid_of (event_thr));\n-\t}\n+      threads_debug_printf (\"Got exec event from LWP %ld\",\n+\t\t\t    lwpid_of (event_thr));\n \n       /* Get the event ptid.  */\n       event_ptid = ptid_of (event_thr);\n@@ -720,8 +711,7 @@ linux_process_target::get_pc (lwp_info *lwp)\n   regcache = get_thread_regcache (current_thread, 1);\n   pc = low_get_pc (regcache);\n \n-  if (debug_threads)\n-    debug_printf (\"pc is 0x%lx\\n\", (long) pc);\n+  threads_debug_printf (\"pc is 0x%lx\", (long) pc);\n \n   return pc;\n }\n@@ -737,8 +727,7 @@ linux_process_target::get_syscall_trapinfo (lwp_info *lwp, int *sysno)\n   regcache = get_thread_regcache (current_thread, 1);\n   low_get_syscall_trapinfo (regcache, sysno);\n \n-  if (debug_threads)\n-    debug_printf (\"get_syscall_trapinfo sysno %d\\n\", *sysno);\n+  threads_debug_printf (\"get_syscall_trapinfo sysno %d\", *sysno);\n }\n \n void\n@@ -827,13 +816,9 @@ linux_process_target::save_stop_reason (lwp_info *lwp)\n \n   if (lwp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT)\n     {\n-      if (debug_threads)\n-\t{\n-\t  struct thread_info *thr = get_lwp_thread (lwp);\n-\n-\t  debug_printf (\"CSBB: %s stopped by software breakpoint\\n\",\n-\t\t\ttarget_pid_to_str (ptid_of (thr)).c_str ());\n-\t}\n+      threads_debug_printf\n+\t(\"%s stopped by software breakpoint\",\n+\t target_pid_to_str (ptid_of (get_lwp_thread (lwp))).c_str ());\n \n       /* Back up the PC if necessary.  */\n       if (pc != sw_breakpoint_pc)\n@@ -847,35 +832,17 @@ linux_process_target::save_stop_reason (lwp_info *lwp)\n       pc = sw_breakpoint_pc;\n     }\n   else if (lwp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT)\n-    {\n-      if (debug_threads)\n-\t{\n-\t  struct thread_info *thr = get_lwp_thread (lwp);\n-\n-\t  debug_printf (\"CSBB: %s stopped by hardware breakpoint\\n\",\n-\t\t\ttarget_pid_to_str (ptid_of (thr)).c_str ());\n-\t}\n-    }\n+    threads_debug_printf\n+      (\"%s stopped by hardware breakpoint\",\n+       target_pid_to_str (ptid_of (get_lwp_thread (lwp))).c_str ());\n   else if (lwp->stop_reason == TARGET_STOPPED_BY_WATCHPOINT)\n-    {\n-      if (debug_threads)\n-\t{\n-\t  struct thread_info *thr = get_lwp_thread (lwp);\n-\n-\t  debug_printf (\"CSBB: %s stopped by hardware watchpoint\\n\",\n-\t\t\ttarget_pid_to_str (ptid_of (thr)).c_str ());\n-\t}\n-    }\n+    threads_debug_printf\n+      (\"%s stopped by hardware watchpoint\",\n+       target_pid_to_str (ptid_of (get_lwp_thread (lwp))).c_str ());\n   else if (lwp->stop_reason == TARGET_STOPPED_BY_SINGLE_STEP)\n-    {\n-      if (debug_threads)\n-\t{\n-\t  struct thread_info *thr = get_lwp_thread (lwp);\n-\n-\t  debug_printf (\"CSBB: %s stopped by trace\\n\",\n-\t\t\ttarget_pid_to_str (ptid_of (thr)).c_str ());\n-\t}\n-    }\n+    threads_debug_printf\n+      (\"%s stopped by trace\",\n+       target_pid_to_str (ptid_of (get_lwp_thread (lwp))).c_str ());\n \n   lwp->stop_pc = pc;\n   return true;\n@@ -1003,8 +970,7 @@ linux_process_target::attach_lwp (ptid_t ptid)\n \n   if (linux_proc_pid_is_stopped (lwpid))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Attached to a stopped process\\n\");\n+      threads_debug_printf (\"Attached to a stopped process\");\n \n       /* The process is definitely stopped.  It is in a job control\n \t stop, unless the kernel predates the TASK_STOPPED /\n@@ -1080,8 +1046,7 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n       int lwpid = ptid.lwp ();\n       int err;\n \n-      if (debug_threads)\n-\tdebug_printf (\"Found new lwp %d\\n\", lwpid);\n+      threads_debug_printf (\"Found new lwp %d\", lwpid);\n \n       err = the_linux_target->attach_lwp (ptid);\n \n@@ -1091,14 +1056,9 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t case, confirm the status in /proc/PID/status.  */\n       if (err == ESRCH\n \t  || (err == EPERM && linux_proc_pid_is_gone (lwpid)))\n-\t{\n-\t  if (debug_threads)\n-\t    {\n-\t      debug_printf (\"Cannot attach to lwp %d: \"\n-\t\t\t    \"thread is gone (%d: %s)\\n\",\n-\t\t\t    lwpid, err, safe_strerror (err));\n-\t    }\n-\t}\n+\tthreads_debug_printf\n+\t  (\"Cannot attach to lwp %d: thread is gone (%d: %s)\",\n+\t   lwpid, err, safe_strerror (err));\n       else if (err != 0)\n \t{\n \t  std::string reason\n@@ -1237,9 +1197,9 @@ linux_kill_one_lwp (struct lwp_info *lwp)\n     {\n       int save_errno = errno;\n \n-      debug_printf (\"LKL:  kill_lwp (SIGKILL) %s, 0, 0 (%s)\\n\",\n-\t\t    target_pid_to_str (ptid_of (thr)).c_str (),\n-\t\t    save_errno ? safe_strerror (save_errno) : \"OK\");\n+      threads_debug_printf (\"kill_lwp (SIGKILL) %s, 0, 0 (%s)\",\n+\t\t\t    target_pid_to_str (ptid_of (thr)).c_str (),\n+\t\t\t    save_errno ? safe_strerror (save_errno) : \"OK\");\n     }\n \n   errno = 0;\n@@ -1248,9 +1208,9 @@ linux_kill_one_lwp (struct lwp_info *lwp)\n     {\n       int save_errno = errno;\n \n-      debug_printf (\"LKL:  PTRACE_KILL %s, 0, 0 (%s)\\n\",\n-\t\t    target_pid_to_str (ptid_of (thr)).c_str (),\n-\t\t    save_errno ? safe_strerror (save_errno) : \"OK\");\n+      threads_debug_printf (\"PTRACE_KILL %s, 0, 0 (%s)\",\n+\t\t\t    target_pid_to_str (ptid_of (thr)).c_str (),\n+\t\t\t    save_errno ? safe_strerror (save_errno) : \"OK\");\n     }\n }\n \n@@ -1265,8 +1225,7 @@ kill_wait_lwp (struct lwp_info *lwp)\n   int wstat;\n   int res;\n \n-  if (debug_threads)\n-    debug_printf (\"kwl: killing lwp %d, for pid: %d\\n\", lwpid, pid);\n+  threads_debug_printf (\"killing lwp %d, for pid: %d\", lwpid, pid);\n \n   do\n     {\n@@ -1312,9 +1271,8 @@ kill_one_lwp_callback (thread_info *thread, int pid)\n \n   if (lwpid_of (thread) == pid)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"lkop: is last of process %s\\n\",\n-\t\t      target_pid_to_str (thread->id).c_str ());\n+      threads_debug_printf (\"is last of process %s\",\n+\t\t\t    target_pid_to_str (thread->id).c_str ());\n       return;\n     }\n \n@@ -1340,11 +1298,7 @@ linux_process_target::kill (process_info *process)\n   lwp_info *lwp = find_lwp_pid (ptid_t (pid));\n \n   if (lwp == NULL)\n-    {\n-      if (debug_threads)\n-\tdebug_printf (\"lk_1: cannot find lwp for pid: %d\\n\",\n-\t\t      pid);\n-    }\n+    threads_debug_printf (\"cannot find lwp for pid: %d\", pid);\n   else\n     kill_wait_lwp (lwp);\n \n@@ -1386,30 +1340,27 @@ get_detach_signal (struct thread_info *thread)\n \n   if (!WIFSTOPPED (status))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"GPS: lwp %s hasn't stopped: no pending signal\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str ());\n+      threads_debug_printf (\"lwp %s hasn't stopped: no pending signal\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str ());\n       return 0;\n     }\n \n   /* Extended wait statuses aren't real SIGTRAPs.  */\n   if (WSTOPSIG (status) == SIGTRAP && linux_is_extended_waitstatus (status))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"GPS: lwp %s had stopped with extended \"\n-\t\t      \"status: no pending signal\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str ());\n+      threads_debug_printf (\"lwp %s had stopped with extended \"\n+\t\t\t    \"status: no pending signal\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str ());\n       return 0;\n     }\n \n   signo = gdb_signal_from_host (WSTOPSIG (status));\n \n   if (cs.program_signals_p && !cs.program_signals[signo])\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"GPS: lwp %s had signal %s, but it is in nopass state\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str (),\n-\t\t      gdb_signal_to_string (signo));\n+      threads_debug_printf (\"lwp %s had signal %s, but it is in nopass state\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str (),\n+\t\t\t    gdb_signal_to_string (signo));\n       return 0;\n     }\n   else if (!cs.program_signals_p\n@@ -1418,20 +1369,18 @@ get_detach_signal (struct thread_info *thread)\n \t      SIGTRAP/SIGINT, which is GDB's default.  */\n \t   && (signo == GDB_SIGNAL_TRAP || signo == GDB_SIGNAL_INT))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"GPS: lwp %s had signal %s, \"\n-\t\t      \"but we don't know if we should pass it. \"\n-\t\t      \"Default to not.\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str (),\n-\t\t      gdb_signal_to_string (signo));\n+      threads_debug_printf (\"lwp %s had signal %s, \"\n+\t\t\t    \"but we don't know if we should pass it. \"\n+\t\t\t    \"Default to not.\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str (),\n+\t\t\t    gdb_signal_to_string (signo));\n       return 0;\n     }\n   else\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"GPS: lwp %s has pending signal %s: delivering it.\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str (),\n-\t\t      gdb_signal_to_string (signo));\n+      threads_debug_printf (\"lwp %s has pending signal %s: delivering it\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str (),\n+\t\t\t    gdb_signal_to_string (signo));\n \n       return WSTOPSIG (status);\n     }\n@@ -1447,9 +1396,8 @@ linux_process_target::detach_one_lwp (lwp_info *lwp)\n   /* If there is a pending SIGSTOP, get rid of it.  */\n   if (lwp->stop_expected)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Sending SIGCONT to %s\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str ());\n+      threads_debug_printf (\"Sending SIGCONT to %s\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str ());\n \n       kill_lwp (lwpid_of (thread), SIGCONT);\n       lwp->stop_expected = 0;\n@@ -1509,12 +1457,10 @@ linux_process_target::detach_one_lwp (lwp_info *lwp)\n \t\t safe_strerror (save_errno));\n \t}\n     }\n-  else if (debug_threads)\n-    {\n-      debug_printf (\"PTRACE_DETACH (%s, %s, 0) (OK)\\n\",\n-\t\t    target_pid_to_str (ptid_of (thread)).c_str (),\n-\t\t    strsignal (sig));\n-    }\n+  else\n+    threads_debug_printf (\"PTRACE_DETACH (%s, %s, 0) (OK)\",\n+\t\t\t  target_pid_to_str (ptid_of (thread)).c_str (),\n+\t\t\t  strsignal (sig));\n \n   delete_lwp (lwp);\n }\n@@ -1645,35 +1591,31 @@ linux_process_target::thread_still_has_status_pending (thread_info *thread)\n \n       if (pc != lp->stop_pc)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"PC of %ld changed\\n\",\n-\t\t\t  lwpid_of (thread));\n+\t  threads_debug_printf (\"PC of %ld changed\",\n+\t\t\t\tlwpid_of (thread));\n \t  discard = 1;\n \t}\n \n #if !USE_SIGTRAP_SIGINFO\n       else if (lp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT\n \t       && !low_breakpoint_at (pc))\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"previous SW breakpoint of %ld gone\\n\",\n-\t\t\t  lwpid_of (thread));\n+\t  threads_debug_printf (\"previous SW breakpoint of %ld gone\",\n+\t\t\t\tlwpid_of (thread));\n \t  discard = 1;\n \t}\n       else if (lp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT\n \t       && !hardware_breakpoint_inserted_here (pc))\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"previous HW breakpoint of %ld gone\\n\",\n-\t\t\t  lwpid_of (thread));\n+\t  threads_debug_printf (\"previous HW breakpoint of %ld gone\",\n+\t\t\t\tlwpid_of (thread));\n \t  discard = 1;\n \t}\n #endif\n \n       if (discard)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"discarding pending breakpoint status\\n\");\n+\t  threads_debug_printf (\"discarding pending breakpoint status\");\n \t  lp->status_pending_p = 0;\n \t  return 0;\n \t}\n@@ -1784,11 +1726,10 @@ linux_process_target::check_zombie_leaders ()\n \n     leader_lp = find_lwp_pid (ptid_t (leader_pid));\n \n-    if (debug_threads)\n-      debug_printf (\"leader_pid=%d, leader_lp!=NULL=%d, \"\n-\t\t    \"num_lwps=%d, zombie=%d\\n\",\n-\t\t    leader_pid, leader_lp!= NULL, num_lwps (leader_pid),\n-\t\t    linux_proc_pid_is_zombie (leader_pid));\n+    threads_debug_printf (\"leader_pid=%d, leader_lp!=NULL=%d, \"\n+\t\t\t  \"num_lwps=%d, zombie=%d\",\n+\t\t\t  leader_pid, leader_lp!= NULL, num_lwps (leader_pid),\n+\t\t\t  linux_proc_pid_is_zombie (leader_pid));\n \n     if (leader_lp != NULL && !leader_lp->stopped\n \t/* Check if there are other threads in the group, as we may\n@@ -1824,10 +1765,9 @@ linux_process_target::check_zombie_leaders ()\n \t   previous leader did exit voluntarily before some other\n \t   thread execs).  */\n \n-\tif (debug_threads)\n-\t  debug_printf (\"CZL: Thread group leader %d zombie \"\n-\t\t\t\"(it exited, or another thread execd).\\n\",\n-\t\t\tleader_pid);\n+\tthreads_debug_printf (\"Thread group leader %d zombie \"\n+\t\t\t      \"(it exited, or another thread execd).\",\n+\t\t\t      leader_pid);\n \n \tdelete_lwp (leader_lp);\n       }\n@@ -1855,13 +1795,10 @@ lwp_suspended_inc (struct lwp_info *lwp)\n {\n   lwp->suspended++;\n \n-  if (debug_threads && lwp->suspended > 4)\n-    {\n-      struct thread_info *thread = get_lwp_thread (lwp);\n-\n-      debug_printf (\"LWP %ld has a suspiciously high suspend count,\"\n-\t\t    \" suspended=%d\\n\", lwpid_of (thread), lwp->suspended);\n-    }\n+  if (lwp->suspended > 4)\n+    threads_debug_printf\n+      (\"LWP %ld has a suspiciously high suspend count, suspended=%d\",\n+       lwpid_of (get_lwp_thread (lwp)), lwp->suspended);\n }\n \n /* Decrement LWP's suspend count.  */\n@@ -1923,8 +1860,7 @@ handle_tracepoints (struct lwp_info *lwp)\n \n   if (tpoint_related_event)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"got a tracepoint event\\n\");\n+      threads_debug_printf (\"got a tracepoint event\");\n       return 1;\n     }\n \n@@ -1967,10 +1903,9 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n     {\n       struct fast_tpoint_collect_status status;\n \n-      if (debug_threads)\n-\tdebug_printf (\"Checking whether LWP %ld needs to move out of the \"\n-\t\t      \"jump pad.\\n\",\n-\t\t      lwpid_of (current_thread));\n+      threads_debug_printf\n+\t(\"Checking whether LWP %ld needs to move out of the jump pad.\",\n+\t lwpid_of (current_thread));\n \n       fast_tpoint_collect_result r\n \t= linux_fast_tracepoint_collecting (lwp, &status);\n@@ -1995,10 +1930,9 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n \t\t    = set_breakpoint_at (status.adjusted_insn_addr, NULL);\n \t\t}\n \n-\t      if (debug_threads)\n-\t\tdebug_printf (\"Checking whether LWP %ld needs to move out of \"\n-\t\t\t      \"the jump pad...it does\\n\",\n-\t\t\t      lwpid_of (current_thread));\n+\t      threads_debug_printf\n+\t\t(\"Checking whether LWP %ld needs to move out of the jump pad...\"\n+\t\t \" it does\", lwpid_of (current_thread));\n \n \t      return true;\n \t    }\n@@ -2050,9 +1984,9 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n \n \t  if (lwp->exit_jump_pad_bkpt != NULL)\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"Cancelling fast exit-jump-pad: removing bkpt. \"\n-\t\t\t      \"stopping all threads momentarily.\\n\");\n+\t      threads_debug_printf\n+\t\t(\"Cancelling fast exit-jump-pad: removing bkpt.\"\n+\t\t \"stopping all threads momentarily.\");\n \n \t      stop_all_lwps (1, lwp);\n \n@@ -2066,10 +2000,9 @@ linux_process_target::maybe_move_out_of_jump_pad (lwp_info *lwp, int *wstat)\n \t}\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"Checking whether LWP %ld needs to move out of the \"\n-\t\t  \"jump pad...no\\n\",\n-\t\t  lwpid_of (current_thread));\n+  threads_debug_printf\n+    (\"Checking whether LWP %ld needs to move out of the jump pad... no\",\n+     lwpid_of (current_thread));\n \n   return false;\n }\n@@ -2082,17 +2015,15 @@ enqueue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n {\n   struct thread_info *thread = get_lwp_thread (lwp);\n \n-  if (debug_threads)\n-    debug_printf (\"Deferring signal %d for LWP %ld.\\n\",\n-\t\t  WSTOPSIG (*wstat), lwpid_of (thread));\n+  threads_debug_printf (\"Deferring signal %d for LWP %ld.\",\n+\t\t\tWSTOPSIG (*wstat), lwpid_of (thread));\n \n   if (debug_threads)\n     {\n       for (const auto &sig : lwp->pending_signals_to_report)\n-\tdebug_printf (\"   Already queued %d\\n\",\n-\t\t      sig.signal);\n+\tthreads_debug_printf (\"   Already queued %d\", sig.signal);\n \n-      debug_printf (\"   (no more currently queued signals)\\n\");\n+      threads_debug_printf (\"   (no more currently queued signals)\");\n     }\n \n   /* Don't enqueue non-RT signals if they are already in the deferred\n@@ -2104,11 +2035,9 @@ enqueue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n \t{\n \t  if (sig.signal == WSTOPSIG (*wstat))\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"Not requeuing already queued non-RT signal %d\"\n-\t\t\t      \" for LWP %ld\\n\",\n-\t\t\t      sig.signal,\n-\t\t\t      lwpid_of (thread));\n+\t      threads_debug_printf\n+\t\t(\"Not requeuing already queued non-RT signal %d for LWP %ld\",\n+\t\t sig.signal, lwpid_of (thread));\n \t      return;\n \t    }\n \t}\n@@ -2139,17 +2068,15 @@ dequeue_one_deferred_signal (struct lwp_info *lwp, int *wstat)\n \n       lwp->pending_signals_to_report.pop_front ();\n \n-      if (debug_threads)\n-\tdebug_printf (\"Reporting deferred signal %d for LWP %ld.\\n\",\n-\t\t      WSTOPSIG (*wstat), lwpid_of (thread));\n+      threads_debug_printf (\"Reporting deferred signal %d for LWP %ld.\",\n+\t\t\t    WSTOPSIG (*wstat), lwpid_of (thread));\n \n       if (debug_threads)\n \t{\n \t  for (const auto &sig : lwp->pending_signals_to_report)\n-\t    debug_printf (\"   Still queued %d\\n\",\n-\t\t\t  sig.signal);\n+\t    threads_debug_printf (\"   Still queued %d\", sig.signal);\n \n-\t  debug_printf (\"   (no more queued signals)\\n\");\n+\t  threads_debug_printf (\"   (no more queued signals)\");\n \t}\n \n       return 1;\n@@ -2240,11 +2167,8 @@ linux_process_target::filter_event (int lwpid, int wstat)\n       ptid_t child_ptid;\n \n       /* A multi-thread exec after we had seen the leader exiting.  */\n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"LLW: Re-adding thread group leader LWP %d\"\n-\t\t\t\"after exec.\\n\", lwpid);\n-\t}\n+      threads_debug_printf (\"Re-adding thread group leader LWP %d after exec.\",\n+\t\t\t    lwpid);\n \n       child_ptid = ptid_t (lwpid, lwpid);\n       child = add_lwp (child_ptid);\n@@ -2273,8 +2197,7 @@ linux_process_target::filter_event (int lwpid, int wstat)\n   /* Check if the thread has exited.  */\n   if ((WIFEXITED (wstat) || WIFSIGNALED (wstat)))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"LLFE: %d exited.\\n\", lwpid);\n+      threads_debug_printf (\"%d exited\", lwpid);\n \n       if (finish_step_over (child))\n \t{\n@@ -2380,33 +2303,29 @@ linux_process_target::filter_event (int lwpid, int wstat)\n   if (WIFSTOPPED (wstat) && WSTOPSIG (wstat) == SIGSTOP\n       && child->stop_expected)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Expected stop.\\n\");\n+      threads_debug_printf (\"Expected stop.\");\n+\n       child->stop_expected = 0;\n \n       if (thread->last_resume_kind == resume_stop)\n \t{\n \t  /* We want to report the stop to the core.  Treat the\n \t     SIGSTOP as a normal event.  */\n-\t  if (debug_threads)\n-\t    debug_printf (\"LLW: resume_stop SIGSTOP caught for %s.\\n\",\n-\t\t\t  target_pid_to_str (ptid_of (thread)).c_str ());\n+\t  threads_debug_printf (\"resume_stop SIGSTOP caught for %s.\",\n+\t\t\t\ttarget_pid_to_str (ptid_of (thread)).c_str ());\n \t}\n       else if (stopping_threads != NOT_STOPPING_THREADS)\n \t{\n \t  /* Stopping threads.  We don't want this SIGSTOP to end up\n \t     pending.  */\n-\t  if (debug_threads)\n-\t    debug_printf (\"LLW: SIGSTOP caught for %s \"\n-\t\t\t  \"while stopping threads.\\n\",\n-\t\t\t  target_pid_to_str (ptid_of (thread)).c_str ());\n+\t  threads_debug_printf (\"SIGSTOP caught for %s while stopping threads.\",\n+\t\t\t\ttarget_pid_to_str (ptid_of (thread)).c_str ());\n \t  return;\n \t}\n       else\n \t{\n \t  /* This is a delayed SIGSTOP.  Filter out the event.  */\n-\t  if (debug_threads)\n-\t    debug_printf (\"LLW: %s %s, 0, 0 (discard delayed SIGSTOP)\\n\",\n+\t  threads_debug_printf (\"%s %s, 0, 0 (discard delayed SIGSTOP)\",\n \t\t\t  child->stepping ? \"step\" : \"continue\",\n \t\t\t  target_pid_to_str (ptid_of (thread)).c_str ());\n \n@@ -2449,11 +2368,9 @@ linux_process_target::resume_stopped_resumed_lwps (thread_info *thread)\n       if (thread->last_resume_kind == resume_step)\n \tstep = maybe_hw_step (thread);\n \n-      if (debug_threads)\n-\tdebug_printf (\"RSRL: resuming stopped-resumed LWP %s at %s: step=%d\\n\",\n-\t\t      target_pid_to_str (ptid_of (thread)).c_str (),\n-\t\t      paddress (lp->stop_pc),\n-\t\t      step);\n+      threads_debug_printf (\"resuming stopped-resumed LWP %s at %s: step=%d\",\n+\t\t\t    target_pid_to_str (ptid_of (thread)).c_str (),\n+\t\t\t    paddress (lp->stop_pc), step);\n \n       resume_one_lwp (lp, step, GDB_SIGNAL_0, NULL);\n     }\n@@ -2485,9 +2402,10 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n \t});\n \n       if (event_thread != NULL)\n-\tevent_child = get_thread_lwp (event_thread);\n-      if (debug_threads && event_thread)\n-\tdebug_printf (\"Got a pending child %ld\\n\", lwpid_of (event_thread));\n+\t{\n+\t  event_child = get_thread_lwp (event_thread);\n+\t  threads_debug_printf (\"Got a pending child %ld\", lwpid_of (event_thread));\n+\t}\n     }\n   else if (filter_ptid != null_ptid)\n     {\n@@ -2522,9 +2440,10 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n \n   if (event_child != NULL)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Got an event from pending child %ld (%04x)\\n\",\n-\t\t      lwpid_of (event_thread), event_child->status_pending);\n+      threads_debug_printf (\"Got an event from pending child %ld (%04x)\",\n+\t\t\t    lwpid_of (event_thread),\n+\t\t\t    event_child->status_pending);\n+\n       *wstatp = event_child->status_pending;\n       event_child->status_pending_p = 0;\n       event_child->status_pending = 0;\n@@ -2566,17 +2485,13 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n       errno = 0;\n       ret = my_waitpid (-1, wstatp, options | WNOHANG);\n \n-      if (debug_threads)\n-\tdebug_printf (\"LWFE: waitpid(-1, ...) returned %d, %s\\n\",\n-\t\t      ret, errno ? safe_strerror (errno) : \"ERRNO-OK\");\n+      threads_debug_printf (\"waitpid(-1, ...) returned %d, %s\",\n+\t\t\t    ret, errno ? safe_strerror (errno) : \"ERRNO-OK\");\n \n       if (ret > 0)\n \t{\n-\t  if (debug_threads)\n-\t    {\n-\t      debug_printf (\"LLW: waitpid %ld received %s\\n\",\n-\t\t\t    (long) ret, status_to_str (*wstatp).c_str ());\n-\t    }\n+\t  threads_debug_printf (\"waitpid %ld received %s\",\n+\t\t\t\t(long) ret, status_to_str (*wstatp).c_str ());\n \n \t  /* Filter all events.  IOW, leave all events pending.  We'll\n \t     randomly select an event LWP out of all that have events\n@@ -2629,25 +2544,23 @@ linux_process_target::wait_for_event_filtered (ptid_t wait_ptid,\n \t over 0 (below), as it is more detailed.  */\n       if (find_thread (not_stopped) == NULL)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"LLW: exit (no unwaited-for LWP)\\n\");\n+\t  threads_debug_printf (\"exit (no unwaited-for LWP)\");\n+\n \t  gdb_sigmask (SIG_SETMASK, &prev_mask, NULL);\n \t  return -1;\n \t}\n \n       /* No interesting event to report to the caller.  */\n       if ((options & WNOHANG))\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"WNOHANG set, no event found\\n\");\n+\t  threads_debug_printf (\"WNOHANG set, no event found\");\n \n \t  gdb_sigmask (SIG_SETMASK, &prev_mask, NULL);\n \t  return 0;\n \t}\n \n       /* Block until we get an event reported with SIGCHLD.  */\n-      if (debug_threads)\n-\tdebug_printf (\"sigsuspend'ing\\n\");\n+      threads_debug_printf (\"sigsuspend'ing\");\n \n       sigsuspend (&prev_mask);\n       gdb_sigmask (SIG_SETMASK, &prev_mask, NULL);\n@@ -2694,11 +2607,9 @@ select_event_lwp (struct lwp_info **orig_lp)\n \t});\n \n       if (event_thread != NULL)\n-\t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"SEL: Select single-step %s\\n\",\n-\t\t\t  target_pid_to_str (ptid_of (event_thread)).c_str ());\n-\t}\n+\tthreads_debug_printf\n+\t  (\"Select single-step %s\",\n+\t   target_pid_to_str (ptid_of (event_thread)).c_str ());\n     }\n   if (event_thread == NULL)\n     {\n@@ -2781,9 +2692,8 @@ linux_process_target::stabilize_threads ()\n \n   if (thread_stuck != NULL)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"can't stabilize, LWP %ld is stuck in jump pad\\n\",\n-\t\t      lwpid_of (thread_stuck));\n+      threads_debug_printf (\"can't stabilize, LWP %ld is stuck in jump pad\",\n+\t\t\t    lwpid_of (thread_stuck));\n       return;\n     }\n \n@@ -2837,8 +2747,9 @@ linux_process_target::stabilize_threads ()\n \t\t       });\n \n       if (thread_stuck != NULL)\n-\tdebug_printf (\"couldn't stabilize, LWP %ld got stuck in jump pad\\n\",\n-\t\t      lwpid_of (thread_stuck));\n+\tthreads_debug_printf\n+\t  (\"couldn't stabilize, LWP %ld got stuck in jump pad\",\n+\t   lwpid_of (thread_stuck));\n     }\n }\n \n@@ -2914,6 +2825,8 @@ ptid_t\n linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t\t\t      target_wait_flags target_options)\n {\n+  THREADS_SCOPED_DEBUG_ENTER_EXIT;\n+\n   client_state &cs = get_client_state ();\n   int w;\n   struct lwp_info *event_child;\n@@ -2927,11 +2840,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n   int in_step_range;\n   int any_resumed;\n \n-  if (debug_threads)\n-    {\n-      debug_enter ();\n-      debug_printf (\"wait_1: [%s]\\n\", target_pid_to_str (ptid).c_str ());\n-    }\n+  threads_debug_printf (\"[%s]\", target_pid_to_str (ptid).c_str ());\n \n   /* Translate generic target options into linux options.  */\n   options = __WALL;\n@@ -2965,34 +2874,23 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n     pid = wait_for_event (ptid, &w, options);\n   else\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"step_over_bkpt set [%s], doing a blocking wait\\n\",\n-\t\t      target_pid_to_str (step_over_bkpt).c_str ());\n+      threads_debug_printf (\"step_over_bkpt set [%s], doing a blocking wait\",\n+\t\t\t    target_pid_to_str (step_over_bkpt).c_str ());\n       pid = wait_for_event (step_over_bkpt, &w, options & ~WNOHANG);\n     }\n \n   if (pid == 0 || (pid == -1 && !any_resumed))\n     {\n       gdb_assert (target_options & TARGET_WNOHANG);\n \n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"wait_1 ret = null_ptid, \"\n-\t\t\t\"TARGET_WAITKIND_IGNORE\\n\");\n-\t  debug_exit ();\n-\t}\n+      threads_debug_printf (\"ret = null_ptid, TARGET_WAITKIND_IGNORE\");\n \n       ourstatus->set_ignore ();\n       return null_ptid;\n     }\n   else if (pid == -1)\n     {\n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"wait_1 ret = null_ptid, \"\n-\t\t\t\"TARGET_WAITKIND_NO_RESUMED\\n\");\n-\t  debug_exit ();\n-\t}\n+      threads_debug_printf (\"ret = null_ptid, TARGET_WAITKIND_NO_RESUMED\");\n \n       ourstatus->set_no_resumed ();\n       return null_ptid;\n@@ -3008,27 +2906,19 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t{\n \t  ourstatus->set_exited (WEXITSTATUS (w));\n \n-\t  if (debug_threads)\n-\t    {\n-\t      debug_printf (\"wait_1 ret = %s, exited with \"\n-\t\t\t    \"retcode %d\\n\",\n-\t\t\t    target_pid_to_str (ptid_of (current_thread)).c_str (),\n-\t\t\t    WEXITSTATUS (w));\n-\t      debug_exit ();\n-\t    }\n+\t  threads_debug_printf\n+\t    (\"ret = %s, exited with retcode %d\",\n+\t     target_pid_to_str (ptid_of (current_thread)).c_str (),\n+\t     WEXITSTATUS (w));\n \t}\n       else\n \t{\n \t  ourstatus->set_signalled (gdb_signal_from_host (WTERMSIG (w)));\n \n-\t  if (debug_threads)\n-\t    {\n-\t      debug_printf (\"wait_1 ret = %s, terminated with \"\n-\t\t\t    \"signal %d\\n\",\n-\t\t\t    target_pid_to_str (ptid_of (current_thread)).c_str (),\n-\t\t\t    WTERMSIG (w));\n-\t      debug_exit ();\n-\t    }\n+\t  threads_debug_printf\n+\t    (\"ret = %s, terminated with signal %d\",\n+\t     target_pid_to_str (ptid_of (current_thread)).c_str (),\n+\t     WTERMSIG (w));\n \t}\n \n       if (ourstatus->kind () == TARGET_WAITKIND_EXITED)\n@@ -3060,11 +2950,9 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n       breakpoint_kind = breakpoint_kind_from_current_state (&stop_pc);\n       sw_breakpoint_from_kind (breakpoint_kind, &increment_pc);\n \n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"step-over for %s executed software breakpoint\\n\",\n-\t\t\ttarget_pid_to_str (ptid_of (current_thread)).c_str ());\n-\t}\n+      threads_debug_printf\n+\t(\"step-over for %s executed software breakpoint\",\n+\t target_pid_to_str (ptid_of (current_thread)).c_str ());\n \n       if (increment_pc != 0)\n \t{\n@@ -3117,10 +3005,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n       trace_event = handle_tracepoints (event_child);\n \n       if (bp_explains_trap)\n-\t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Hit a gdbserver breakpoint.\\n\");\n-\t}\n+\tthreads_debug_printf (\"Hit a gdbserver breakpoint.\");\n     }\n   else\n     {\n@@ -3141,37 +3026,33 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n       && supports_fast_tracepoints ()\n       && agent_loaded_p ())\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Got signal %d for LWP %ld.  Check if we need \"\n-\t\t      \"to defer or adjust it.\\n\",\n-\t\t      WSTOPSIG (w), lwpid_of (current_thread));\n+      threads_debug_printf (\"Got signal %d for LWP %ld.  Check if we need \"\n+\t\t\t    \"to defer or adjust it.\",\n+\t\t\t    WSTOPSIG (w), lwpid_of (current_thread));\n \n       /* Allow debugging the jump pad itself.  */\n       if (current_thread->last_resume_kind != resume_step\n \t  && maybe_move_out_of_jump_pad (event_child, &w))\n \t{\n \t  enqueue_one_deferred_signal (event_child, &w);\n \n-\t  if (debug_threads)\n-\t    debug_printf (\"Signal %d for LWP %ld deferred (in jump pad)\\n\",\n-\t\t\t  WSTOPSIG (w), lwpid_of (current_thread));\n+\t  threads_debug_printf (\"Signal %d for LWP %ld deferred (in jump pad)\",\n+\t\t\t\tWSTOPSIG (w), lwpid_of (current_thread));\n \n \t  resume_one_lwp (event_child, 0, 0, NULL);\n \n-\t  if (debug_threads)\n-\t    debug_exit ();\n \t  return ignore_event (ourstatus);\n \t}\n     }\n \n   if (event_child->collecting_fast_tracepoint\n       != fast_tpoint_collect_result::not_collecting)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"LWP %ld was trying to move out of the jump pad (%d). \"\n-\t\t      \"Check if we're already there.\\n\",\n-\t\t      lwpid_of (current_thread),\n-\t\t      (int) event_child->collecting_fast_tracepoint);\n+      threads_debug_printf\n+\t(\"LWP %ld was trying to move out of the jump pad (%d). \"\n+\t \"Check if we're already there.\",\n+\t lwpid_of (current_thread),\n+\t (int) event_child->collecting_fast_tracepoint);\n \n       trace_event = 1;\n \n@@ -3184,9 +3065,9 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t  /* No longer need this breakpoint.  */\n \t  if (event_child->exit_jump_pad_bkpt != NULL)\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"No longer need exit-jump-pad bkpt; removing it.\"\n-\t\t\t      \"stopping all threads momentarily.\\n\");\n+\t      threads_debug_printf\n+\t\t(\"No longer need exit-jump-pad bkpt; removing it.\"\n+\t\t \"stopping all threads momentarily.\");\n \n \t      /* Other running threads could hit this breakpoint.\n \t\t We don't handle moribund locations like GDB does,\n@@ -3209,33 +3090,23 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n       if (event_child->collecting_fast_tracepoint\n \t  == fast_tpoint_collect_result::not_collecting)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"fast tracepoint finished \"\n-\t\t\t  \"collecting successfully.\\n\");\n+\t  threads_debug_printf\n+\t    (\"fast tracepoint finished collecting successfully.\");\n \n \t  /* We may have a deferred signal to report.  */\n \t  if (dequeue_one_deferred_signal (event_child, &w))\n-\t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"dequeued one signal.\\n\");\n-\t    }\n+\t    threads_debug_printf (\"dequeued one signal.\");\n \t  else\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"no deferred signals.\\n\");\n+\t      threads_debug_printf (\"no deferred signals.\");\n \n \t      if (stabilizing_threads)\n \t\t{\n \t\t  ourstatus->set_stopped (GDB_SIGNAL_0);\n \n-\t\t  if (debug_threads)\n-\t\t    {\n-\t\t      debug_printf (\"wait_1 ret = %s, stopped \"\n-\t\t\t\t    \"while stabilizing threads\\n\",\n-\t\t\t\t    target_pid_to_str\n-\t\t\t\t      (ptid_of (current_thread)).c_str ());\n-\t\t      debug_exit ();\n-\t\t    }\n+\t\t  threads_debug_printf\n+\t\t    (\"ret = %s, stopped while stabilizing threads\",\n+\t\t     target_pid_to_str (ptid_of (current_thread)).c_str ());\n \n \t\t  return ptid_of (current_thread);\n \t\t}\n@@ -3250,16 +3121,11 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n       && WSTOPSIG (w) == SYSCALL_SIGTRAP\n       && !gdb_catch_this_syscall (event_child))\n     {\n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"Ignored syscall for LWP %ld.\\n\",\n-\t\t\tlwpid_of (current_thread));\n-\t}\n+      threads_debug_printf (\"Ignored syscall for LWP %ld.\",\n+\t\t\t    lwpid_of (current_thread));\n \n       resume_one_lwp (event_child, event_child->stepping, 0, NULL);\n \n-      if (debug_threads)\n-\tdebug_exit ();\n       return ignore_event (ourstatus);\n     }\n \n@@ -3287,9 +3153,8 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n     {\n       siginfo_t info, *info_p;\n \n-      if (debug_threads)\n-\tdebug_printf (\"Ignored signal %d for LWP %ld.\\n\",\n-\t\t      WSTOPSIG (w), lwpid_of (current_thread));\n+      threads_debug_printf (\"Ignored signal %d for LWP %ld.\",\n+\t\t\t    WSTOPSIG (w), lwpid_of (current_thread));\n \n       if (ptrace (PTRACE_GETSIGINFO, lwpid_of (current_thread),\n \t\t  (PTRACE_TYPE_ARG3) 0, &info) == 0)\n@@ -3316,9 +3181,6 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t\t\t  WSTOPSIG (w), info_p);\n \t}\n \n-      if (debug_threads)\n-\tdebug_exit ();\n-\n       return ignore_event (ourstatus);\n     }\n \n@@ -3361,20 +3223,20 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n      shouldn't know about.  */\n   if (!report_to_gdb)\n     {\n-      if (debug_threads)\n-\t{\n-\t  if (bp_explains_trap)\n-\t    debug_printf (\"Hit a gdbserver breakpoint.\\n\");\n-\t  if (step_over_finished)\n-\t    debug_printf (\"Step-over finished.\\n\");\n-\t  if (trace_event)\n-\t    debug_printf (\"Tracepoint event.\\n\");\n-\t  if (lwp_in_step_range (event_child))\n-\t    debug_printf (\"Range stepping pc 0x%s [0x%s, 0x%s).\\n\",\n-\t\t\t  paddress (event_child->stop_pc),\n-\t\t\t  paddress (event_child->step_range_start),\n-\t\t\t  paddress (event_child->step_range_end));\n-\t}\n+      if (bp_explains_trap)\n+\tthreads_debug_printf (\"Hit a gdbserver breakpoint.\");\n+\n+      if (step_over_finished)\n+\tthreads_debug_printf (\"Step-over finished.\");\n+\n+      if (trace_event)\n+\tthreads_debug_printf (\"Tracepoint event.\");\n+\n+      if (lwp_in_step_range (event_child))\n+\tthreads_debug_printf (\"Range stepping pc 0x%s [0x%s, 0x%s).\",\n+\t\t\t      paddress (event_child->stop_pc),\n+\t\t\t      paddress (event_child->step_range_start),\n+\t\t\t      paddress (event_child->step_range_end));\n \n       /* We're not reporting this breakpoint to GDB, so apply the\n \t decr_pc_after_break adjustment to the inferior's regcache\n@@ -3410,36 +3272,36 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t    }\n \t}\n \n-      if (debug_threads)\n-\tdebug_printf (\"proceeding all threads.\\n\");\n-      proceed_all_lwps ();\n+      threads_debug_printf (\"proceeding all threads.\");\n \n-      if (debug_threads)\n-\tdebug_exit ();\n+      proceed_all_lwps ();\n \n       return ignore_event (ourstatus);\n     }\n \n-  if (debug_threads)\n-    {\n-      if (event_child->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n-\tdebug_printf (\"LWP %ld: extended event with waitstatus %s\\n\",\n-\t\t      lwpid_of (get_lwp_thread (event_child)),\n-\t\t      event_child->waitstatus.to_string ().c_str ());\n-      if (current_thread->last_resume_kind == resume_step)\n-\t{\n-\t  if (event_child->step_range_start == event_child->step_range_end)\n-\t    debug_printf (\"GDB wanted to single-step, reporting event.\\n\");\n-\t  else if (!lwp_in_step_range (event_child))\n-\t    debug_printf (\"Out of step range, reporting event.\\n\");\n-\t}\n-      if (event_child->stop_reason == TARGET_STOPPED_BY_WATCHPOINT)\n-\tdebug_printf (\"Stopped by watchpoint.\\n\");\n-      else if (gdb_breakpoint_here (event_child->stop_pc))\n-\tdebug_printf (\"Stopped by GDB breakpoint.\\n\");\n-      if (debug_threads)\n-\tdebug_printf (\"Hit a non-gdbserver trap event.\\n\");\n-    }\n+    if (debug_threads)\n+      {\n+\tif (event_child->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n+\t  threads_debug_printf (\"LWP %ld: extended event with waitstatus %s\",\n+\t\t\t\tlwpid_of (get_lwp_thread (event_child)),\n+\t\t\t\tevent_child->waitstatus.to_string ().c_str ());\n+\n+\tif (current_thread->last_resume_kind == resume_step)\n+\t  {\n+\t    if (event_child->step_range_start == event_child->step_range_end)\n+\t      threads_debug_printf\n+\t\t(\"GDB wanted to single-step, reporting event.\");\n+\t    else if (!lwp_in_step_range (event_child))\n+\t      threads_debug_printf (\"Out of step range, reporting event.\");\n+\t  }\n+\n+\tif (event_child->stop_reason == TARGET_STOPPED_BY_WATCHPOINT)\n+\t  threads_debug_printf (\"Stopped by watchpoint.\");\n+\telse if (gdb_breakpoint_here (event_child->stop_pc))\n+\t  threads_debug_printf (\"Stopped by GDB breakpoint.\");\n+      }\n+\n+    threads_debug_printf (\"Hit a non-gdbserver trap event.\");\n \n   /* Alright, we're going to report a stop.  */\n \n@@ -3630,13 +3492,9 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \n   gdb_assert (step_over_bkpt == null_ptid);\n \n-  if (debug_threads)\n-    {\n-      debug_printf (\"wait_1 ret = %s, %d, %d\\n\",\n-\t\t    target_pid_to_str (ptid_of (current_thread)).c_str (),\n-\t\t    ourstatus->kind (), ourstatus->sig ());\n-      debug_exit ();\n-    }\n+  threads_debug_printf (\"ret = %s, %d, %d\",\n+\t\t\ttarget_pid_to_str (ptid_of (current_thread)).c_str (),\n+\t\t\tourstatus->kind (), ourstatus->sig ());\n \n   if (ourstatus->kind () == TARGET_WAITKIND_EXITED)\n     return filter_exit_event (event_child, ourstatus);\n@@ -3736,14 +3594,12 @@ send_sigstop (struct lwp_info *lwp)\n      send another.  */\n   if (lwp->stop_expected)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Have pending sigstop for lwp %d\\n\", pid);\n+      threads_debug_printf (\"Have pending sigstop for lwp %d\", pid);\n \n       return;\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"Sending sigstop to lwp %d\\n\", pid);\n+  threads_debug_printf (\"Sending sigstop to lwp %d\", pid);\n \n   lwp->stop_expected = 1;\n   kill_lwp (pid, SIGSTOP);\n@@ -3828,8 +3684,7 @@ linux_process_target::wait_for_sigstop ()\n \n   scoped_restore_current_thread restore_thread;\n \n-  if (debug_threads)\n-    debug_printf (\"wait_for_sigstop: pulling events\\n\");\n+  threads_debug_printf (\"pulling events\");\n \n   /* Passing NULL_PTID as filter indicates we want all events to be\n      left pending.  Eventually this returns when there are no\n@@ -3841,8 +3696,7 @@ linux_process_target::wait_for_sigstop ()\n     return;\n   else\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Previously current thread died.\\n\");\n+      threads_debug_printf (\"Previously current thread died.\");\n \n       /* We can't change the current inferior behind GDB's back,\n \t otherwise, a subsequent command may apply to the wrong\n@@ -3901,19 +3755,16 @@ linux_process_target::move_out_of_jump_pad (thread_info *thread)\n       && thread->last_resume_kind != resume_step\n       && maybe_move_out_of_jump_pad (lwp, wstat))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"LWP %ld needs stabilizing (in jump pad)\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"LWP %ld needs stabilizing (in jump pad)\",\n+\t\t\t    lwpid_of (thread));\n \n       if (wstat)\n \t{\n \t  lwp->status_pending_p = 0;\n \t  enqueue_one_deferred_signal (lwp, wstat);\n \n-\t  if (debug_threads)\n-\t    debug_printf (\"Signal %d for LWP %ld deferred \"\n-\t\t\t  \"(in jump pad)\\n\",\n-\t\t\t  WSTOPSIG (*wstat), lwpid_of (thread));\n+\t  threads_debug_printf (\"Signal %d for LWP %ld deferred (in jump pad\",\n+\t\t\t\tWSTOPSIG (*wstat), lwpid_of (thread));\n \t}\n \n       resume_one_lwp (lwp, 0, 0, NULL);\n@@ -3939,16 +3790,13 @@ linux_process_target::stop_all_lwps (int suspend, lwp_info *except)\n   /* Should not be called recursively.  */\n   gdb_assert (stopping_threads == NOT_STOPPING_THREADS);\n \n-  if (debug_threads)\n-    {\n-      debug_enter ();\n-      debug_printf (\"stop_all_lwps (%s, except=%s)\\n\",\n-\t\t    suspend ? \"stop-and-suspend\" : \"stop\",\n-\t\t    (except != NULL\n-\t\t     ? target_pid_to_str\n-\t\t\t (ptid_of (get_lwp_thread (except))).c_str ()\n-\t\t     : \"none\"));\n-    }\n+  THREADS_SCOPED_DEBUG_ENTER_EXIT;\n+\n+  threads_debug_printf\n+    (\"%s, except=%s\", suspend ? \"stop-and-suspend\" : \"stop\",\n+     (except != NULL\n+      ? target_pid_to_str (ptid_of (get_lwp_thread (except))).c_str ()\n+      : \"none\"));\n \n   stopping_threads = (suspend\n \t\t      ? STOPPING_AND_SUSPENDING_THREADS\n@@ -3968,12 +3816,7 @@ linux_process_target::stop_all_lwps (int suspend, lwp_info *except)\n   wait_for_sigstop ();\n   stopping_threads = NOT_STOPPING_THREADS;\n \n-  if (debug_threads)\n-    {\n-      debug_printf (\"stop_all_lwps done, setting stopping_threads \"\n-\t\t    \"back to !stopping\\n\");\n-      debug_exit ();\n-    }\n+  threads_debug_printf (\"setting stopping_threads back to !stopping\");\n }\n \n /* Enqueue one signal in the chain of signals which need to be\n@@ -4019,10 +3862,7 @@ linux_process_target::single_step (lwp_info* lwp)\n       step = 0;\n     }\n   else\n-    {\n-      if (debug_threads)\n-\tdebug_printf (\"stepping is not implemented on this target\");\n-    }\n+    threads_debug_printf (\"stepping is not implemented on this target\");\n \n   return step;\n }\n@@ -4092,11 +3932,10 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n \n   if (lwp->status_pending_p)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Not resuming lwp %ld (%s, stop %s);\"\n-\t\t      \" has pending status\\n\",\n-\t\t      lwpid_of (thread), step ? \"step\" : \"continue\",\n-\t\t      lwp->stop_expected ? \"expected\" : \"not expected\");\n+      threads_debug_printf\n+\t(\"Not resuming lwp %ld (%s, stop %s); has pending status\",\n+\t lwpid_of (thread), step ? \"step\" : \"continue\",\n+\t lwp->stop_expected ? \"expected\" : \"not expected\");\n       return;\n     }\n \n@@ -4115,9 +3954,8 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n      worthwhile just to solve this one, however.  */\n   if (lwp->bp_reinsert != 0)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"  pending reinsert at 0x%s\\n\",\n-\t\t      paddress (lwp->bp_reinsert));\n+      threads_debug_printf (\"  pending reinsert at 0x%s\",\n+\t\t\t    paddress (lwp->bp_reinsert));\n \n       if (supports_hardware_single_step ())\n \t{\n@@ -4135,18 +3973,15 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n     }\n \n   if (fast_tp_collecting == fast_tpoint_collect_result::before_insn)\n-    {\n-      if (debug_threads)\n-\tdebug_printf (\"lwp %ld wants to get out of fast tracepoint jump pad\"\n-\t\t      \" (exit-jump-pad-bkpt)\\n\",\n-\t\t      lwpid_of (thread));\n-    }\n+    threads_debug_printf\n+      (\"lwp %ld wants to get out of fast tracepoint jump pad \"\n+       \"(exit-jump-pad-bkpt)\", lwpid_of (thread));\n+\n   else if (fast_tp_collecting == fast_tpoint_collect_result::at_insn)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"lwp %ld wants to get out of fast tracepoint jump pad\"\n-\t\t      \" single-stepping\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf\n+\t(\"lwp %ld wants to get out of fast tracepoint jump pad single-stepping\",\n+\t lwpid_of (thread));\n \n       if (supports_hardware_single_step ())\n \tstep = 1;\n@@ -4168,9 +4003,9 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n      enhancement.  */\n   if (thread->while_stepping != NULL)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"lwp %ld has a while-stepping action -> forcing step.\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf\n+\t(\"lwp %ld has a while-stepping action -> forcing step.\",\n+\t lwpid_of (thread));\n \n       step = single_step (lwp);\n     }\n@@ -4181,11 +4016,8 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n \n       lwp->stop_pc = low_get_pc (regcache);\n \n-      if (debug_threads)\n-\t{\n-\t  debug_printf (\"  %s from pc 0x%lx\\n\", step ? \"step\" : \"continue\",\n-\t\t\t(long) lwp->stop_pc);\n-\t}\n+      threads_debug_printf (\"  %s from pc 0x%lx\", step ? \"step\" : \"continue\",\n+\t\t\t    (long) lwp->stop_pc);\n     }\n \n   /* If we have pending signals, consume one if it can be delivered to\n@@ -4202,10 +4034,9 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n       lwp->pending_signals.pop_front ();\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"Resuming lwp %ld (%s, signal %d, stop %s)\\n\",\n-\t\t  lwpid_of (thread), step ? \"step\" : \"continue\", signal,\n-\t\t  lwp->stop_expected ? \"expected\" : \"not expected\");\n+  threads_debug_printf (\"Resuming lwp %ld (%s, signal %d, stop %s)\",\n+\t\t\tlwpid_of (thread), step ? \"step\" : \"continue\", signal,\n+\t\t\tlwp->stop_expected ? \"expected\" : \"not expected\");\n \n   low_prepare_to_resume (lwp);\n \n@@ -4319,13 +4150,11 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t  if (resume[ndx].kind == resume_stop\n \t      && thread->last_resume_kind == resume_stop)\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"already %s LWP %ld at GDB's request\\n\",\n-\t\t\t      (thread->last_status.kind ()\n-\t\t\t       == TARGET_WAITKIND_STOPPED)\n-\t\t\t      ? \"stopped\"\n-\t\t\t      : \"stopping\",\n-\t\t\t      lwpid_of (thread));\n+\t      threads_debug_printf\n+\t\t(\"already %s LWP %ld at GDB's request\",\n+\t\t (thread->last_status.kind () == TARGET_WAITKIND_STOPPED\n+\t\t  ? \"stopped\" : \"stopping\"),\n+\t\t  lwpid_of (thread));\n \n \t      continue;\n \t    }\n@@ -4335,13 +4164,11 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t  if (resume[ndx].kind != resume_stop\n \t      && thread->last_resume_kind != resume_stop)\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"already %s LWP %ld at GDB's request\\n\",\n-\t\t\t      (thread->last_resume_kind\n-\t\t\t       == resume_step)\n-\t\t\t      ? \"stepping\"\n-\t\t\t      : \"continuing\",\n-\t\t\t      lwpid_of (thread));\n+\t      threads_debug_printf\n+\t\t(\"already %s LWP %ld at GDB's request\",\n+\t\t (thread->last_resume_kind == resume_step\n+\t\t  ? \"stepping\" : \"continuing\"),\n+\t\t lwpid_of (thread));\n \t      continue;\n \t    }\n \n@@ -4355,9 +4182,9 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t\t  && (rel->waitstatus.kind () == TARGET_WAITKIND_FORKED\n \t\t      || rel->waitstatus.kind () == TARGET_WAITKIND_VFORKED))\n \t\t{\n-\t\t  if (debug_threads)\n-\t\t    debug_printf (\"not resuming LWP %ld: has queued stop reply\\n\",\n-\t\t\t\t  lwpid_of (thread));\n+\t\t  threads_debug_printf\n+\t\t    (\"not resuming LWP %ld: has queued stop reply\",\n+\t\t     lwpid_of (thread));\n \t\t  continue;\n \t\t}\n \t    }\n@@ -4368,9 +4195,9 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t     (wildcard) resume request.  */\n \t  if (in_queued_stop_replies (thread->id))\n \t    {\n-\t      if (debug_threads)\n-\t\tdebug_printf (\"not resuming LWP %ld: has queued stop reply\\n\",\n-\t\t\t      lwpid_of (thread));\n+\t      threads_debug_printf\n+\t\t(\"not resuming LWP %ld: has queued stop reply\",\n+\t\t lwpid_of (thread));\n \t      continue;\n \t    }\n \n@@ -4389,11 +4216,11 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t    {\n \t      lwp->status_pending_p = 1;\n \n-\t      if (debug_threads)\n-\t\tdebug_printf (\"Dequeueing deferred signal %d for LWP %ld, \"\n-\t\t\t      \"leaving status pending.\\n\",\n-\t\t\t      WSTOPSIG (lwp->status_pending),\n-\t\t\t      lwpid_of (thread));\n+\t      threads_debug_printf\n+\t\t(\"Dequeueing deferred signal %d for LWP %ld, \"\n+\t\t \"leaving status pending.\",\n+\t\t WSTOPSIG (lwp->status_pending),\n+\t\t lwpid_of (thread));\n \t    }\n \n \t  return;\n@@ -4434,37 +4261,33 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n \n   if (!lwp->stopped)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Need step over [LWP %ld]? Ignoring, not stopped\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"Need step over [LWP %ld]? Ignoring, not stopped\",\n+\t\t\t    lwpid_of (thread));\n       return false;\n     }\n \n   if (thread->last_resume_kind == resume_stop)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Need step over [LWP %ld]? Ignoring, should remain\"\n-\t\t      \" stopped\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf\n+\t(\"Need step over [LWP %ld]? Ignoring, should remain stopped\",\n+\t lwpid_of (thread));\n       return false;\n     }\n \n   gdb_assert (lwp->suspended >= 0);\n \n   if (lwp->suspended)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Need step over [LWP %ld]? Ignoring, suspended\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"Need step over [LWP %ld]? Ignoring, suspended\",\n+\t\t\t    lwpid_of (thread));\n       return false;\n     }\n \n   if (lwp->status_pending_p)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Need step over [LWP %ld]? Ignoring, has pending\"\n-\t\t      \" status.\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf\n+\t(\"Need step over [LWP %ld]? Ignoring, has pending status.\",\n+\t lwpid_of (thread));\n       return false;\n     }\n \n@@ -4479,11 +4302,10 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n      command, or poked thread's registers herself.  */\n   if (pc != lwp->stop_pc)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Need step over [LWP %ld]? Cancelling, PC was changed. \"\n-\t\t      \"Old stop_pc was 0x%s, PC is now 0x%s\\n\",\n-\t\t      lwpid_of (thread),\n-\t\t      paddress (lwp->stop_pc), paddress (pc));\n+      threads_debug_printf\n+\t(\"Need step over [LWP %ld]? Cancelling, PC was changed. \"\n+\t \"Old stop_pc was 0x%s, PC is now 0x%s\", lwpid_of (thread),\n+\t paddress (lwp->stop_pc), paddress (pc));\n       return false;\n     }\n \n@@ -4493,10 +4315,9 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n       && !lwp->pending_signals.empty ()\n       && lwp_signal_can_be_delivered (lwp))\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Need step over [LWP %ld]? Ignoring, has pending\"\n-\t\t      \" signals.\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf\n+\t(\"Need step over [LWP %ld]? Ignoring, has pending signals.\",\n+\t lwpid_of (thread));\n \n       return false;\n     }\n@@ -4514,30 +4335,27 @@ linux_process_target::thread_needs_step_over (thread_info *thread)\n \t  && gdb_condition_true_at_breakpoint (pc)\n \t  && gdb_no_commands_at_breakpoint (pc))\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Need step over [LWP %ld]? yes, but found\"\n-\t\t\t  \" GDB breakpoint at 0x%s; skipping step over\\n\",\n-\t\t\t  lwpid_of (thread), paddress (pc));\n+\t  threads_debug_printf (\"Need step over [LWP %ld]? yes, but found\"\n+\t\t\t\t\" GDB breakpoint at 0x%s; skipping step over\",\n+\t\t\t\tlwpid_of (thread), paddress (pc));\n \n \t  return false;\n \t}\n       else\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Need step over [LWP %ld]? yes, \"\n-\t\t\t  \"found breakpoint at 0x%s\\n\",\n-\t\t\t  lwpid_of (thread), paddress (pc));\n+\t  threads_debug_printf (\"Need step over [LWP %ld]? yes, \"\n+\t\t\t\t\"found breakpoint at 0x%s\",\n+\t\t\t\tlwpid_of (thread), paddress (pc));\n \n \t  /* We've found an lwp that needs stepping over --- return 1 so\n \t     that find_thread stops looking.  */\n \t  return true;\n \t}\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"Need step over [LWP %ld]? No, no breakpoint found\"\n-\t\t  \" at 0x%s\\n\",\n-\t\t  lwpid_of (thread), paddress (pc));\n+  threads_debug_printf\n+    (\"Need step over [LWP %ld]? No, no breakpoint found at 0x%s\",\n+     lwpid_of (thread), paddress (pc));\n \n   return false;\n }\n@@ -4548,9 +4366,8 @@ linux_process_target::start_step_over (lwp_info *lwp)\n   struct thread_info *thread = get_lwp_thread (lwp);\n   CORE_ADDR pc;\n \n-  if (debug_threads)\n-    debug_printf (\"Starting step-over on LWP %ld.  Stopping all threads\\n\",\n-\t\t  lwpid_of (thread));\n+  threads_debug_printf (\"Starting step-over on LWP %ld.  Stopping all threads\",\n+\t\t\tlwpid_of (thread));\n \n   stop_all_lwps (1, lwp);\n \n@@ -4561,8 +4378,7 @@ linux_process_target::start_step_over (lwp_info *lwp)\n \t\t      lwp->suspended);\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"Done stopping all threads for step-over.\\n\");\n+  threads_debug_printf (\"Done stopping all threads for step-over.\");\n \n   /* Note, we should always reach here with an already adjusted PC,\n      either by GDB (if we're resuming due to GDB's request), or by our\n@@ -4595,8 +4411,7 @@ linux_process_target::finish_step_over (lwp_info *lwp)\n     {\n       scoped_restore_current_thread restore_thread;\n \n-      if (debug_threads)\n-\tdebug_printf (\"Finished step over.\\n\");\n+      threads_debug_printf (\"Finished step over.\");\n \n       switch_to_thread (get_lwp_thread (lwp));\n \n@@ -4634,8 +4449,7 @@ linux_process_target::complete_ongoing_step_over ()\n       int wstat;\n       int ret;\n \n-      if (debug_threads)\n-\tdebug_printf (\"detach: step over in progress, finish it first\\n\");\n+      threads_debug_printf (\"detach: step over in progress, finish it first\");\n \n       /* Passing NULL_PTID as filter indicates we want all events to\n \t be left pending.  Eventually this returns when there are no\n@@ -4659,19 +4473,15 @@ linux_process_target::complete_ongoing_step_over ()\n \t      thread_info *thread = get_lwp_thread (lwp);\n \t      if (thread->last_resume_kind != resume_step)\n \t\t{\n-\t\t  if (debug_threads)\n-\t\t    debug_printf (\"detach: discard step-over SIGTRAP\\n\");\n+\t\t  threads_debug_printf (\"detach: discard step-over SIGTRAP\");\n \n \t\t  lwp->status_pending_p = 0;\n \t\t  lwp->status_pending = 0;\n \t\t  resume_one_lwp (lwp, lwp->stepping, 0, NULL);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  if (debug_threads)\n-\t\t    debug_printf (\"detach: resume_step, \"\n-\t\t\t\t  \"not discarding step-over SIGTRAP\\n\");\n-\t\t}\n+\t\tthreads_debug_printf\n+\t\t  (\"detach: resume_step, not discarding step-over SIGTRAP\");\n \t    }\n \t}\n       step_over_bkpt = null_ptid;\n@@ -4691,23 +4501,20 @@ linux_process_target::resume_one_thread (thread_info *thread,\n \n   if (lwp->resume->kind == resume_stop)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"resume_stop request for LWP %ld\\n\", lwpid_of (thread));\n+      threads_debug_printf (\"resume_stop request for LWP %ld\",\n+\t\t\t    lwpid_of (thread));\n \n       if (!lwp->stopped)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"stopping LWP %ld\\n\", lwpid_of (thread));\n+\t  threads_debug_printf (\"stopping LWP %ld\", lwpid_of (thread));\n \n \t  /* Stop the thread, and wait for the event asynchronously,\n \t     through the event loop.  */\n \t  send_sigstop (lwp);\n \t}\n       else\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"already stopped LWP %ld\\n\",\n-\t\t\t  lwpid_of (thread));\n+\t  threads_debug_printf (\"already stopped LWP %ld\", lwpid_of (thread));\n \n \t  /* The LWP may have been stopped in an internal event that\n \t     was not meant to be notified back to GDB (e.g., gdbserver\n@@ -4769,16 +4576,12 @@ linux_process_target::resume_one_thread (thread_info *thread,\n \n   if (!leave_pending)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"resuming LWP %ld\\n\", lwpid_of (thread));\n+      threads_debug_printf (\"resuming LWP %ld\", lwpid_of (thread));\n \n       proceed_one_lwp (thread, NULL);\n     }\n   else\n-    {\n-      if (debug_threads)\n-\tdebug_printf (\"leaving LWP %ld stopped\\n\", lwpid_of (thread));\n-    }\n+    threads_debug_printf (\"leaving LWP %ld stopped\", lwpid_of (thread));\n \n   thread->last_status.set_ignore ();\n   lwp->resume = NULL;\n@@ -4789,11 +4592,7 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n {\n   struct thread_info *need_step_over = NULL;\n \n-  if (debug_threads)\n-    {\n-      debug_enter ();\n-      debug_printf (\"linux_resume:\\n\");\n-    }\n+ THREADS_SCOPED_DEBUG_ENTER_EXIT;\n \n   for_each_thread ([&] (thread_info *thread)\n     {\n@@ -4827,16 +4626,13 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n \n   bool leave_all_stopped = (need_step_over != NULL || any_pending);\n \n-  if (debug_threads)\n-    {\n-      if (need_step_over != NULL)\n-\tdebug_printf (\"Not resuming all, need step over\\n\");\n-      else if (any_pending)\n-\tdebug_printf (\"Not resuming, all-stop and found \"\n-\t\t      \"an LWP with pending status\\n\");\n-      else\n-\tdebug_printf (\"Resuming, no pending status or step over needed\\n\");\n-    }\n+  if (need_step_over != NULL)\n+    threads_debug_printf (\"Not resuming all, need step over\");\n+  else if (any_pending)\n+    threads_debug_printf (\"Not resuming, all-stop and found \"\n+\t\t\t  \"an LWP with pending status\");\n+  else\n+    threads_debug_printf (\"Resuming, no pending status or step over needed\");\n \n   /* Even if we're leaving threads stopped, queue all signals we'd\n      otherwise deliver.  */\n@@ -4848,12 +4644,6 @@ linux_process_target::resume (thread_resume *resume_info, size_t n)\n   if (need_step_over)\n     start_step_over (get_thread_lwp (need_step_over));\n \n-  if (debug_threads)\n-    {\n-      debug_printf (\"linux_resume done\\n\");\n-      debug_exit ();\n-    }\n-\n   /* We may have events that were pending that can/should be sent to\n      the client now.  Trigger a linux_wait call.  */\n   if (target_is_async_p ())\n@@ -4869,39 +4659,34 @@ linux_process_target::proceed_one_lwp (thread_info *thread, lwp_info *except)\n   if (lwp == except)\n     return;\n \n-  if (debug_threads)\n-    debug_printf (\"proceed_one_lwp: lwp %ld\\n\", lwpid_of (thread));\n+  threads_debug_printf (\"lwp %ld\", lwpid_of (thread));\n \n   if (!lwp->stopped)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"   LWP %ld already running\\n\", lwpid_of (thread));\n+      threads_debug_printf (\"   LWP %ld already running\", lwpid_of (thread));\n       return;\n     }\n \n   if (thread->last_resume_kind == resume_stop\n       && thread->last_status.kind () != TARGET_WAITKIND_IGNORE)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"   client wants LWP to remain %ld stopped\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"   client wants LWP to remain %ld stopped\",\n+\t\t\t    lwpid_of (thread));\n       return;\n     }\n \n   if (lwp->status_pending_p)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"   LWP %ld has pending status, leaving stopped\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"   LWP %ld has pending status, leaving stopped\",\n+\t\t\t    lwpid_of (thread));\n       return;\n     }\n \n   gdb_assert (lwp->suspended >= 0);\n \n   if (lwp->suspended)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"   LWP %ld is suspended\\n\", lwpid_of (thread));\n+      threads_debug_printf (\"   LWP %ld is suspended\", lwpid_of (thread));\n       return;\n     }\n \n@@ -4920,19 +4705,17 @@ linux_process_target::proceed_one_lwp (thread_info *thread, lwp_info *except)\n \t another one here.  Note that if the LWP already has a SIGSTOP\n \t pending, this is a no-op.  */\n \n-      if (debug_threads)\n-\tdebug_printf (\"Client wants LWP %ld to stop. \"\n-\t\t      \"Making sure it has a SIGSTOP pending\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf\n+\t(\"Client wants LWP %ld to stop.  Making sure it has a SIGSTOP pending\",\n+\t lwpid_of (thread));\n \n       send_sigstop (lwp);\n     }\n \n   if (thread->last_resume_kind == resume_step)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"   stepping LWP %ld, client wants it stepping\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"   stepping LWP %ld, client wants it stepping\",\n+\t\t\t    lwpid_of (thread));\n \n       /* If resume_step is requested by GDB, install single-step\n \t breakpoints when the thread is about to be actually resumed if\n@@ -4945,9 +4728,8 @@ linux_process_target::proceed_one_lwp (thread_info *thread, lwp_info *except)\n     }\n   else if (lwp->bp_reinsert != 0)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"   stepping LWP %ld, reinsert set\\n\",\n-\t\t      lwpid_of (thread));\n+      threads_debug_printf (\"   stepping LWP %ld, reinsert set\",\n+\t\t\t    lwpid_of (thread));\n \n       step = maybe_hw_step (thread);\n     }\n@@ -4990,18 +4772,15 @@ linux_process_target::proceed_all_lwps ()\n \n       if (need_step_over != NULL)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"proceed_all_lwps: found \"\n-\t\t\t  \"thread %ld needing a step-over\\n\",\n-\t\t\t  lwpid_of (need_step_over));\n+\t  threads_debug_printf (\"found thread %ld needing a step-over\",\n+\t\t\t\tlwpid_of (need_step_over));\n \n \t  start_step_over (get_thread_lwp (need_step_over));\n \t  return;\n \t}\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"Proceeding, no step-over needed\\n\");\n+  threads_debug_printf (\"Proceeding, no step-over needed\");\n \n   for_each_thread ([this] (thread_info *thread)\n     {\n@@ -5012,15 +4791,13 @@ linux_process_target::proceed_all_lwps ()\n void\n linux_process_target::unstop_all_lwps (int unsuspend, lwp_info *except)\n {\n-  if (debug_threads)\n-    {\n-      debug_enter ();\n-      if (except)\n-\tdebug_printf (\"unstopping all lwps, except=(LWP %ld)\\n\",\n-\t\t      lwpid_of (get_lwp_thread (except)));\n-      else\n-\tdebug_printf (\"unstopping all lwps\\n\");\n-    }\n+  THREADS_SCOPED_DEBUG_ENTER_EXIT;\n+\n+  if (except)\n+    threads_debug_printf (\"except=(LWP %ld)\",\n+\t\t  lwpid_of (get_lwp_thread (except)));\n+  else\n+    threads_debug_printf (\"except=nullptr\");\n \n   if (unsuspend)\n     for_each_thread ([&] (thread_info *thread)\n@@ -5032,12 +4809,6 @@ linux_process_target::unstop_all_lwps (int unsuspend, lwp_info *except)\n       {\n \tproceed_one_lwp (thread, except);\n       });\n-\n-  if (debug_threads)\n-    {\n-      debug_printf (\"unstop_all_lwps done\\n\");\n-      debug_exit ();\n-    }\n }\n \n \n@@ -5622,8 +5393,8 @@ linux_process_target::write_memory (CORE_ADDR memaddr,\n \t}\n       *p = '\\0';\n \n-      debug_printf (\"Writing %s to 0x%08lx in process %d\\n\",\n-\t\t    str, (long) memaddr, pid);\n+      threads_debug_printf (\"Writing %s to 0x%08lx in process %d\",\n+\t\t\t    str, (long) memaddr, pid);\n     }\n \n   /* Fill start and end extra bytes of buffer with existing memory data.  */\n@@ -5967,10 +5738,9 @@ linux_process_target::qxfer_siginfo (const char *annex,\n \n   pid = lwpid_of (current_thread);\n \n-  if (debug_threads)\n-    debug_printf (\"%s siginfo for lwp %d.\\n\",\n-\t\t  readbuf != NULL ? \"Reading\" : \"Writing\",\n-\t\t  pid);\n+  threads_debug_printf (\"%s siginfo for lwp %d.\",\n+\t\t\treadbuf != NULL ? \"Reading\" : \"Writing\",\n+\t\t\tpid);\n \n   if (offset >= sizeof (siginfo))\n     return -1;\n@@ -6040,9 +5810,8 @@ linux_process_target::async (bool enable)\n {\n   bool previous = target_is_async_p ();\n \n-  if (debug_threads)\n-    debug_printf (\"linux_async (%d), previous=%d\\n\",\n-\t\t  enable, previous);\n+  threads_debug_printf (\"async (%d), previous=%d\",\n+\t\t\tenable, previous);\n \n   if (previous != enable)\n     {\n@@ -7129,8 +6898,7 @@ linux_get_pc_32bit (struct regcache *regcache)\n   uint32_t pc;\n \n   collect_register_by_name (regcache, \"pc\", &pc);\n-  if (debug_threads)\n-    debug_printf (\"stop pc is 0x%\" PRIx32 \"\\n\", pc);\n+  threads_debug_printf (\"stop pc is 0x%\" PRIx32, pc);\n   return pc;\n }\n \n@@ -7154,8 +6922,7 @@ linux_get_pc_64bit (struct regcache *regcache)\n   uint64_t pc;\n \n   collect_register_by_name (regcache, \"pc\", &pc);\n-  if (debug_threads)\n-    debug_printf (\"stop pc is 0x%\" PRIx64 \"\\n\", pc);\n+  threads_debug_printf (\"stop pc is 0x%\" PRIx64, pc);\n   return pc;\n }\n "
    },
    {
      "sha": "5adc28070574734bf3972be9b93b522ab3192523",
      "filename": "gdbserver/linux-s390-low.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-s390-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-s390-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-s390-low.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -1503,9 +1503,8 @@ add_insns (const unsigned char *start, int len)\n {\n   CORE_ADDR buildaddr = current_insn_ptr;\n \n-  if (debug_threads)\n-    debug_printf (\"Adding %d bytes of insn at %s\\n\",\n-\t\t  len, paddress (buildaddr));\n+  threads_debug_printf (\"Adding %d bytes of insn at %s\",\n+\t\t\tlen, paddress (buildaddr));\n \n   append_insns (&buildaddr, len, start);\n   current_insn_ptr = buildaddr;"
    },
    {
      "sha": "d2b55f6f0d2b9f027f192601087c90cda6afa461",
      "filename": "gdbserver/linux-x86-low.cc",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-x86-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/linux-x86-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-x86-low.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -1628,9 +1628,8 @@ add_insns (unsigned char *start, int len)\n {\n   CORE_ADDR buildaddr = current_insn_ptr;\n \n-  if (debug_threads)\n-    debug_printf (\"Adding %d bytes of insn at %s\\n\",\n-\t\t  len, paddress (buildaddr));\n+  threads_debug_printf (\"Adding %d bytes of insn at %s\",\n+\t\t\tlen, paddress (buildaddr));\n \n   append_insns (&buildaddr, len, start);\n   current_insn_ptr = buildaddr;"
    },
    {
      "sha": "5f5cdb18797e241be884aaa9850e8e4a55f5bbe1",
      "filename": "gdbserver/mem-break.cc",
      "status": "modified",
      "additions": 55,
      "deletions": 73,
      "changes": 128,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/mem-break.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/mem-break.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/mem-break.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -371,10 +371,9 @@ insert_memory_breakpoint (struct raw_breakpoint *bp)\n   err = read_inferior_memory (bp->pc, buf, bp_size (bp));\n   if (err != 0)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Failed to read shadow memory of\"\n-\t\t      \" breakpoint at 0x%s (%s).\\n\",\n-\t\t      paddress (bp->pc), safe_strerror (err));\n+      threads_debug_printf (\"Failed to read shadow memory of\"\n+\t\t\t    \" breakpoint at 0x%s (%s).\",\n+\t\t\t    paddress (bp->pc), safe_strerror (err));\n     }\n   else\n     {\n@@ -383,11 +382,8 @@ insert_memory_breakpoint (struct raw_breakpoint *bp)\n       err = the_target->write_memory (bp->pc, bp_opcode (bp),\n \t\t\t\t      bp_size (bp));\n       if (err != 0)\n-\t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Failed to insert breakpoint at 0x%s (%s).\\n\",\n-\t\t\t  paddress (bp->pc), safe_strerror (err));\n-\t}\n+\tthreads_debug_printf (\"Failed to insert breakpoint at 0x%s (%s).\",\n+\t\t\t      paddress (bp->pc), safe_strerror (err));\n     }\n   return err != 0 ? -1 : 0;\n }\n@@ -411,12 +407,10 @@ remove_memory_breakpoint (struct raw_breakpoint *bp)\n   memcpy (buf, bp->old_data, bp_size (bp));\n   err = target_write_memory (bp->pc, buf, bp_size (bp));\n   if (err != 0)\n-    {\n-      if (debug_threads)\n-\tdebug_printf (\"Failed to uninsert raw breakpoint \"\n-\t\t      \"at 0x%s (%s) while deleting it.\\n\",\n-\t\t      paddress (bp->pc), safe_strerror (err));\n-    }\n+      threads_debug_printf (\"Failed to uninsert raw breakpoint \"\n+\t\t\t    \"at 0x%s (%s) while deleting it.\",\n+\t\t\t    paddress (bp->pc), safe_strerror (err));\n+\n   return err != 0 ? -1 : 0;\n }\n \n@@ -438,9 +432,9 @@ set_raw_breakpoint_at (enum raw_bkpt_type type, CORE_ADDR where, int kind,\n \t{\n \t  /* A different kind than previously seen.  The previous\n \t     breakpoint must be gone then.  */\n-\t  if (debug_threads)\n-\t    debug_printf (\"Inconsistent breakpoint kind?  Was %d, now %d.\\n\",\n-\t\t\t  bp->kind, kind);\n+\t  threads_debug_printf\n+\t    (\"Inconsistent breakpoint kind?  Was %d, now %d.\",\n+\t     bp->kind, kind);\n \t  bp->inserted = -1;\n \t  bp = NULL;\n \t}\n@@ -463,9 +457,8 @@ set_raw_breakpoint_at (enum raw_bkpt_type type, CORE_ADDR where, int kind,\n       *err = the_target->insert_point (bp->raw_type, bp->pc, bp->kind, bp);\n       if (*err != 0)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Failed to insert breakpoint at 0x%s (%d).\\n\",\n-\t\t\t  paddress (where), *err);\n+\t  threads_debug_printf (\"Failed to insert breakpoint at 0x%s (%d).\",\n+\t\t\t\tpaddress (where), *err);\n \n \t  return NULL;\n \t}\n@@ -594,10 +587,10 @@ delete_fast_tracepoint_jump (struct fast_tracepoint_jump *todel)\n \t\t  /* Something went wrong, relink the jump.  */\n \t\t  *bp_link = prev_bp_link;\n \n-\t\t  if (debug_threads)\n-\t\t    debug_printf (\"Failed to uninsert fast tracepoint jump \"\n-\t\t\t\t  \"at 0x%s (%s) while deleting it.\\n\",\n-\t\t\t\t  paddress (bp->pc), safe_strerror (ret));\n+\t\t  threads_debug_printf\n+\t\t    (\"Failed to uninsert fast tracepoint jump \"\n+\t\t     \"at 0x%s (%s) while deleting it.\",\n+\t\t     paddress (bp->pc), safe_strerror (ret));\n \t\t  return ret;\n \t\t}\n \n@@ -657,10 +650,9 @@ set_fast_tracepoint_jump (CORE_ADDR where,\n   err = read_inferior_memory (where, buf, length);\n   if (err != 0)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Failed to read shadow memory of\"\n-\t\t      \" fast tracepoint at 0x%s (%s).\\n\",\n-\t\t      paddress (where), safe_strerror (err));\n+      threads_debug_printf (\"Failed to read shadow memory of\"\n+\t\t\t    \" fast tracepoint at 0x%s (%s).\",\n+\t\t\t    paddress (where), safe_strerror (err));\n       free (jp);\n       return NULL;\n     }\n@@ -682,9 +674,9 @@ set_fast_tracepoint_jump (CORE_ADDR where,\n   err = target_write_memory (where, buf, length);\n   if (err != 0)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Failed to insert fast tracepoint jump at 0x%s (%s).\\n\",\n-\t\t      paddress (where), safe_strerror (err));\n+      threads_debug_printf\n+\t(\"Failed to insert fast tracepoint jump at 0x%s (%s).\",\n+\t paddress (where), safe_strerror (err));\n \n       /* Unlink it.  */\n       proc->fast_tracepoint_jumps = jp->next;\n@@ -707,10 +699,9 @@ uninsert_fast_tracepoint_jumps_at (CORE_ADDR pc)\n     {\n       /* This can happen when we remove all breakpoints while handling\n \t a step-over.  */\n-      if (debug_threads)\n-\tdebug_printf (\"Could not find fast tracepoint jump at 0x%s \"\n-\t\t      \"in list (uninserting).\\n\",\n-\t\t      paddress (pc));\n+      threads_debug_printf (\"Could not find fast tracepoint jump at 0x%s \"\n+\t\t\t    \"in list (uninserting).\",\n+\t\t\t    paddress (pc));\n       return;\n     }\n \n@@ -736,10 +727,9 @@ uninsert_fast_tracepoint_jumps_at (CORE_ADDR pc)\n \t{\n \t  jp->inserted = 1;\n \n-\t  if (debug_threads)\n-\t    debug_printf (\"Failed to uninsert fast tracepoint jump at\"\n-\t\t\t  \" 0x%s (%s).\\n\",\n-\t\t\t  paddress (pc), safe_strerror (err));\n+\t  threads_debug_printf (\"Failed to uninsert fast tracepoint jump at\"\n+\t\t\t\t\" 0x%s (%s).\",\n+\t\t\t\tpaddress (pc), safe_strerror (err));\n \t}\n     }\n }\n@@ -756,10 +746,9 @@ reinsert_fast_tracepoint_jumps_at (CORE_ADDR where)\n     {\n       /* This can happen when we remove breakpoints when a tracepoint\n \t hit causes a tracing stop, while handling a step-over.  */\n-      if (debug_threads)\n-\tdebug_printf (\"Could not find fast tracepoint jump at 0x%s \"\n-\t\t      \"in list (reinserting).\\n\",\n-\t\t      paddress (where));\n+      threads_debug_printf (\"Could not find fast tracepoint jump at 0x%s \"\n+\t\t\t    \"in list (reinserting).\",\n+\t\t\t    paddress (where));\n       return;\n     }\n \n@@ -783,10 +772,9 @@ reinsert_fast_tracepoint_jumps_at (CORE_ADDR where)\n     {\n       jp->inserted = 0;\n \n-      if (debug_threads)\n-\tdebug_printf (\"Failed to reinsert fast tracepoint jump at\"\n-\t\t      \" 0x%s (%s).\\n\",\n-\t\t      paddress (where), safe_strerror (err));\n+      threads_debug_printf (\"Failed to reinsert fast tracepoint jump at\"\n+\t\t\t    \" 0x%s (%s).\",\n+\t\t\t    paddress (where), safe_strerror (err));\n     }\n }\n \n@@ -897,10 +885,9 @@ delete_raw_breakpoint (struct process_info *proc, struct raw_breakpoint *todel)\n \t\t  /* Something went wrong, relink the breakpoint.  */\n \t\t  *bp_link = prev_bp_link;\n \n-\t\t  if (debug_threads)\n-\t\t    debug_printf (\"Failed to uninsert raw breakpoint \"\n-\t\t\t\t  \"at 0x%s while deleting it.\\n\",\n-\t\t\t\t  paddress (bp->pc));\n+\t\t  threads_debug_printf (\"Failed to uninsert raw breakpoint \"\n+\t\t\t\t\t\"at 0x%s while deleting it.\",\n+\t\t\t\t\tpaddress (bp->pc));\n \t\t  return ret;\n \t\t}\n \t    }\n@@ -1404,10 +1391,9 @@ gdb_no_commands_at_breakpoint_z_type (char z_type, CORE_ADDR addr)\n   if (bp == NULL)\n     return 1;\n \n-  if (debug_threads)\n-    debug_printf (\"at 0x%s, type Z%c, bp command_list is 0x%s\\n\",\n-\t\t  paddress (addr), z_type,\n-\t\t  phex_nz ((uintptr_t) bp->command_list, 0));\n+  threads_debug_printf (\"at 0x%s, type Z%c, bp command_list is 0x%s\",\n+\t\t\tpaddress (addr), z_type,\n+\t\t\tphex_nz ((uintptr_t) bp->command_list, 0));\n   return (bp->command_list == NULL);\n }\n \n@@ -1521,9 +1507,8 @@ uninsert_raw_breakpoint (struct raw_breakpoint *bp)\n {\n   if (bp->inserted < 0)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"Breakpoint at %s is marked insert-disabled.\\n\",\n-\t\t      paddress (bp->pc));\n+      threads_debug_printf (\"Breakpoint at %s is marked insert-disabled.\",\n+\t\t\t    paddress (bp->pc));\n     }\n   else if (bp->inserted > 0)\n     {\n@@ -1536,9 +1521,8 @@ uninsert_raw_breakpoint (struct raw_breakpoint *bp)\n \t{\n \t  bp->inserted = 1;\n \n-\t  if (debug_threads)\n-\t    debug_printf (\"Failed to uninsert raw breakpoint at 0x%s.\\n\",\n-\t\t\t  paddress (bp->pc));\n+\t  threads_debug_printf (\"Failed to uninsert raw breakpoint at 0x%s.\",\n+\t\t\t\tpaddress (bp->pc));\n \t}\n     }\n }\n@@ -1565,10 +1549,9 @@ uninsert_breakpoints_at (CORE_ADDR pc)\n     {\n       /* This can happen when we remove all breakpoints while handling\n \t a step-over.  */\n-      if (debug_threads)\n-\tdebug_printf (\"Could not find breakpoint at 0x%s \"\n-\t\t      \"in list (uninserting).\\n\",\n-\t\t      paddress (pc));\n+      threads_debug_printf (\"Could not find breakpoint at 0x%s \"\n+\t\t\t    \"in list (uninserting).\",\n+\t\t\t    paddress (pc));\n     }\n }\n \n@@ -1622,9 +1605,9 @@ reinsert_raw_breakpoint (struct raw_breakpoint *bp)\n   err = the_target->insert_point (bp->raw_type, bp->pc, bp->kind, bp);\n   if (err == 0)\n     bp->inserted = 1;\n-  else if (debug_threads)\n-    debug_printf (\"Failed to reinsert breakpoint at 0x%s (%d).\\n\",\n-\t\t  paddress (bp->pc), err);\n+  else\n+    threads_debug_printf (\"Failed to reinsert breakpoint at 0x%s (%d).\",\n+\t\t\t  paddress (bp->pc), err);\n }\n \n void\n@@ -1648,10 +1631,9 @@ reinsert_breakpoints_at (CORE_ADDR pc)\n     {\n       /* This can happen when we remove all breakpoints while handling\n \t a step-over.  */\n-      if (debug_threads)\n-\tdebug_printf (\"Could not find raw breakpoint at 0x%s \"\n-\t\t      \"in list (reinserting).\\n\",\n-\t\t      paddress (pc));\n+      threads_debug_printf (\"Could not find raw breakpoint at 0x%s \"\n+\t\t\t    \"in list (reinserting).\",\n+\t\t\t    paddress (pc));\n     }\n }\n "
    },
    {
      "sha": "8cd8f52710538e96c0da20e4064c136015cf549a",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -144,8 +144,7 @@ handle_accept_event (int err, gdb_client_data client_data)\n   struct sockaddr_storage sockaddr;\n   socklen_t len = sizeof (sockaddr);\n \n-  if (debug_threads)\n-    debug_printf (\"handling possible accept event\\n\");\n+  threads_debug_printf (\"handling possible accept event\");\n \n   remote_desc = accept (listen_desc, (struct sockaddr *) &sockaddr, &len);\n   if (remote_desc == -1)\n@@ -1084,9 +1083,8 @@ void\n prepare_resume_reply (char *buf, ptid_t ptid, const target_waitstatus &status)\n {\n   client_state &cs = get_client_state ();\n-  if (debug_threads)\n-    debug_printf (\"Writing resume reply for %s:%d\\n\",\n-\t\t  target_pid_to_str (ptid).c_str (), status.kind ());\n+  threads_debug_printf (\"Writing resume reply for %s:%d\",\n+\t\t\ttarget_pid_to_str (ptid).c_str (), status.kind ());\n \n   switch (status.kind ())\n     {"
    },
    {
      "sha": "02b09e50da7f64811e92e544d40fbbb209f3b894",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 13,
      "deletions": 19,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -1228,8 +1228,7 @@ handle_detach (char *own_buf)\n \t pass signals down without informing GDB.  */\n       if (!non_stop)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Forcing non-stop mode\\n\");\n+\t  threads_debug_printf (\"Forcing non-stop mode\");\n \n \t  non_stop = true;\n \t  the_target->start_non_stop (true);\n@@ -3336,10 +3335,10 @@ queue_stop_reply_callback (thread_info *thread)\n     {\n       if (target_thread_stopped (thread))\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"Reporting thread %s as already stopped with %s\\n\",\n-\t\t\t  target_pid_to_str (thread->id).c_str (),\n-\t\t\t  thread->last_status.to_string ().c_str ());\n+\t  threads_debug_printf\n+\t    (\"Reporting thread %s as already stopped with %s\",\n+\t     target_pid_to_str (thread->id).c_str (),\n+\t     thread->last_status.to_string ().c_str ());\n \n \t  gdb_assert (thread->last_status.kind () != TARGET_WAITKIND_IGNORE);\n \n@@ -4183,16 +4182,14 @@ process_point_options (struct gdb_breakpoint *bp, const char **packet)\n       if (*dataptr == 'X')\n \t{\n \t  /* Conditional expression.  */\n-\t  if (debug_threads)\n-\t    debug_printf (\"Found breakpoint condition.\\n\");\n+\t  threads_debug_printf (\"Found breakpoint condition.\");\n \t  if (!add_breakpoint_condition (bp, &dataptr))\n \t    dataptr = strchrnul (dataptr, ';');\n \t}\n       else if (startswith (dataptr, \"cmds:\"))\n \t{\n \t  dataptr += strlen (\"cmds:\");\n-\t  if (debug_threads)\n-\t    debug_printf (\"Found breakpoint commands %s.\\n\", dataptr);\n+\t  threads_debug_printf (\"Found breakpoint commands %s.\", dataptr);\n \t  persist = (*dataptr == '1');\n \t  dataptr += 2;\n \t  if (add_breakpoint_commands (bp, &dataptr, persist))\n@@ -4576,8 +4573,7 @@ process_serial_event (void)\n void\n handle_serial_event (int err, gdb_client_data client_data)\n {\n-  if (debug_threads)\n-    debug_printf (\"handling possible serial event\\n\");\n+  threads_debug_printf (\"handling possible serial event\");\n \n   /* Really handle it.  */\n   if (process_serial_event () < 0)\n@@ -4610,8 +4606,7 @@ void\n handle_target_event (int err, gdb_client_data client_data)\n {\n   client_state &cs = get_client_state ();\n-  if (debug_threads)\n-    debug_printf (\"handling possible target event\\n\");\n+  threads_debug_printf (\"handling possible target event\");\n \n   cs.last_ptid = mywait (minus_one_ptid, &cs.last_status,\n \t\t      TARGET_WNOHANG, 1);\n@@ -4663,11 +4658,10 @@ handle_target_event (int err, gdb_client_data client_data)\n \t\t inferior, as if it wasn't being traced.  */\n \t      enum gdb_signal signal;\n \n-\t      if (debug_threads)\n-\t\tdebug_printf (\"GDB not connected; forwarding event %d for\"\n-\t\t\t      \" [%s]\\n\",\n-\t\t\t      (int) cs.last_status.kind (),\n-\t\t\t      target_pid_to_str (cs.last_ptid).c_str ());\n+\t      threads_debug_printf (\"GDB not connected; forwarding event %d for\"\n+\t\t\t\t    \" [%s]\",\n+\t\t\t\t    (int) cs.last_status.kind (),\n+\t\t\t\t    target_pid_to_str (cs.last_ptid).c_str ());\n \n \t      if (cs.last_status.kind () == TARGET_WAITKIND_STOPPED)\n \t\tsignal = cs.last_status.sig ();"
    },
    {
      "sha": "6e0e2228a5f982e943e5cf7356d0550f64c53a98",
      "filename": "gdbserver/thread-db.cc",
      "status": "modified",
      "additions": 17,
      "deletions": 27,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/thread-db.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/thread-db.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/thread-db.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -184,9 +184,8 @@ find_one_thread (ptid_t ptid)\n     error (\"Cannot get thread info for LWP %d: %s\",\n \t   lwpid, thread_db_err_str (err));\n \n-  if (debug_threads)\n-    debug_printf (\"Found thread %ld (LWP %d)\\n\",\n-\t\t  (unsigned long) ti.ti_tid, ti.ti_lid);\n+  threads_debug_printf (\"Found thread %ld (LWP %d)\",\n+\t\t\t(unsigned long) ti.ti_tid, ti.ti_lid);\n \n   if (lwpid != ti.ti_lid)\n     {\n@@ -218,9 +217,8 @@ attach_thread (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p)\n   struct lwp_info *lwp;\n   int err;\n \n-  if (debug_threads)\n-    debug_printf (\"Attaching to thread %ld (LWP %d)\\n\",\n-\t\t  (unsigned long) ti_p->ti_tid, ti_p->ti_lid);\n+  threads_debug_printf (\"Attaching to thread %ld (LWP %d)\",\n+\t\t\t(unsigned long) ti_p->ti_tid, ti_p->ti_lid);\n   err = the_linux_target->attach_lwp (ptid);\n   if (err != 0)\n     {\n@@ -283,10 +281,9 @@ find_new_threads_callback (const td_thrhandle_t *th_p, void *data)\n \t thread that previously exited and was joined.  (glibc marks\n \t terminated and joined threads with kernel thread ID -1.  See\n \t glibc PR17707.  */\n-      if (debug_threads)\n-\tdebug_printf (\"thread_db: skipping exited and \"\n-\t\t      \"joined thread (0x%lx)\\n\",\n-\t\t      (unsigned long) ti.ti_tid);\n+      threads_debug_printf (\"thread_db: skipping exited and \"\n+\t\t\t    \"joined thread (0x%lx)\",\n+\t\t\t    (unsigned long) ti.ti_tid);\n       return 0;\n     }\n \n@@ -333,9 +330,8 @@ thread_db_find_new_threads (void)\n \t\t\t\t\t TD_THR_ANY_STATE,\n \t\t\t\t\t TD_THR_LOWEST_PRIORITY,\n \t\t\t\t\t TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);\n-      if (debug_threads)\n-\tdebug_printf (\"Found %d threads in iteration %d.\\n\",\n-\t\t      new_thread_count, iteration);\n+      threads_debug_printf (\"Found %d threads in iteration %d.\",\n+\t\t\t    new_thread_count, iteration);\n \n       if (new_thread_count != 0)\n \t{\n@@ -492,8 +488,7 @@ thread_db_load_search (void)\n   err = tdb->td_ta_new_p (&tdb->proc_handle, &tdb->thread_agent);\n   if (err != TD_OK)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"td_ta_new(): %s\\n\", thread_db_err_str (err));\n+      threads_debug_printf (\"td_ta_new(): %s\", thread_db_err_str (err));\n       free (tdb);\n       proc->priv->thread_db = NULL;\n       return 0;\n@@ -535,8 +530,7 @@ try_thread_db_load_1 (void *handle)\n     {\t\t\t\t\t\t\t\t\\\n       if ((a) == NULL)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  if (debug_threads)\t\t\t\t\t\\\n-\t    debug_printf (\"dlsym: %s\\n\", dlerror ());\t\t\\\n+\t  threads_debug_printf (\"dlsym: %s\", dlerror ());\t\\\n \t  if (required)\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\\\n \t      free (tdb);\t\t\t\t\t\\\n@@ -556,8 +550,7 @@ try_thread_db_load_1 (void *handle)\n   err = tdb->td_ta_new_p (&tdb->proc_handle, &tdb->thread_agent);\n   if (err != TD_OK)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"td_ta_new(): %s\\n\", thread_db_err_str (err));\n+      threads_debug_printf (\"td_ta_new(): %s\", thread_db_err_str (err));\n       free (tdb);\n       proc->priv->thread_db = NULL;\n       return 0;\n@@ -601,14 +594,12 @@ try_thread_db_load (const char *library)\n {\n   void *handle;\n \n-  if (debug_threads)\n-    debug_printf (\"Trying host libthread_db library: %s.\\n\",\n-\t\t  library);\n+  threads_debug_printf (\"Trying host libthread_db library: %s.\",\n+\t\t\tlibrary);\n   handle = dlopen (library, RTLD_NOW);\n   if (handle == NULL)\n     {\n-      if (debug_threads)\n-\tdebug_printf (\"dlopen failed: %s.\\n\", dlerror ());\n+      threads_debug_printf (\"dlopen failed: %s.\", dlerror ());\n       return 0;\n     }\n \n@@ -623,7 +614,7 @@ try_thread_db_load (const char *library)\n \t  const char *const libpath = dladdr_to_soname (td_init);\n \n \t  if (libpath != NULL)\n-\t    debug_printf (\"Host %s resolved to: %s.\\n\", library, libpath);\n+\t    threads_debug_printf (\"Host %s resolved to: %s.\", library, libpath);\n \t}\n     }\n #endif\n@@ -722,8 +713,7 @@ thread_db_load_search (void)\n \t}\n     }\n \n-  if (debug_threads)\n-    debug_printf (\"thread_db_load_search returning %d\\n\", rc);\n+  threads_debug_printf (\"thread_db_load_search returning %d\", rc);\n   return rc;\n }\n "
    },
    {
      "sha": "5459dc34cbb5527376cf9ee68822db7a39a2ed60",
      "filename": "gdbserver/tracepoint.cc",
      "status": "modified",
      "additions": 10,
      "deletions": 16,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/tracepoint.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c058728c31684d08da396f1bf50fabaa196dc9d9/gdbserver/tracepoint.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/tracepoint.cc?ref=c058728c31684d08da396f1bf50fabaa196dc9d9",
      "patch": "@@ -87,11 +87,7 @@ trace_vdebug (const char *fmt, ...)\n \n #define trace_debug(fmt, args...)\t\\\n   do {\t\t\t\t\t\t\\\n-    if (debug_threads)\t\t\t\t\\\n-      {\t\t\t\t\t\t\\\n-\tdebug_printf ((fmt), ##args);\t\t\\\n-\tdebug_printf (\"\\n\");\t\t\t\\\n-      }\t\t\t\t\t\t\\\n+      threads_debug_printf ((fmt), ##args);\t\\\n   } while (0)\n \n #endif\n@@ -324,8 +320,7 @@ tracepoint_look_up_symbols (void)\n \n       if (look_up_one_symbol (symbol_list[i].name, addrp, 1) == 0)\n \t{\n-\t  if (debug_threads)\n-\t    debug_printf (\"symbol `%s' not found\\n\", symbol_list[i].name);\n+\t  threads_debug_printf (\"symbol `%s' not found\", symbol_list[i].name);\n \t  return;\n \t}\n     }\n@@ -4519,15 +4514,14 @@ handle_tracepoint_bkpts (struct thread_info *tinfo, CORE_ADDR stop_pc)\n \t\t   ipa_expr_eval_result,\n \t\t   paddress (ipa_error_tracepoint));\n \n-      if (debug_threads)\n-\t{\n-\t  if (ipa_trace_buffer_is_full)\n-\t    trace_debug (\"lib stopped due to full buffer.\");\n-\t  if (ipa_stopping_tracepoint)\n-\t    trace_debug (\"lib stopped due to tpoint\");\n-\t  if (ipa_error_tracepoint)\n-\t    trace_debug (\"lib stopped due to error\");\n-\t}\n+      if (ipa_trace_buffer_is_full)\n+\ttrace_debug (\"lib stopped due to full buffer.\");\n+\n+      if (ipa_stopping_tracepoint)\n+\ttrace_debug (\"lib stopped due to tpoint\");\n+\n+      if (ipa_error_tracepoint)\n+\ttrace_debug (\"lib stopped due to error\");\n \n       if (ipa_stopping_tracepoint != 0)\n \t{"
    }
  ]
}