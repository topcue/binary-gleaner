{
  "sha": "e228ef975e92d3bc860fc6b87039447392ba53aa",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTIyOGVmOTc1ZTkyZDNiYzg2MGZjNmI4NzAzOTQ0NzM5MmJhNTNhYQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-04-30T16:22:23Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-04-30T16:22:24Z"
    },
    "message": "Share DLL code between gdb and gdbserver\n\nThis moves the new DLL-loading code into nat/windows-nat.c, and\nchanges both gdb and gdbserver to use the shared code.  One\nclient-provided callback, handle_load_dll, is changed to allow the\ncode to be shared.  This callback was actually never called from\nnat/windows-nat.c; maybe I had planned to share more here and then\ndidn't finish... I'm not sure.\n\ngdb/ChangeLog\n2021-04-30  Tom Tromey  <tromey@adacore.com>\n\n\t* windows-nat.c (windows_nat::handle_load_dll): Update.\n\t(windows_nat_target::get_windows_debug_event): Call\n\tdll_loaded_event.\n\t(windows_add_all_dlls, windows_add_dll): Move to\n\tnat/windows-nat.c.\n\t* nat/windows-nat.h (handle_load_dll): Change parameters.\n\t(dll_loaded_event, windows_add_all_dlls): Declare.\n\t* nat/windows-nat.c (windows_add_dll, windows_add_all_dlls): Move\n\tfrom windows-nat.c.\n\t(dll_loaded_event): New function.\n\ngdbserver/ChangeLog\n2021-04-30  Tom Tromey  <tromey@adacore.com>\n\n\t* win32-low.cc (do_initial_child_stuff): Update.\n\t(windows_nat::handle_load_dll): Rename from win32_add_one_solib.\n\tChange parameter type.\n\t(win32_add_dll, win32_add_all_dlls)\n\t(windows_nat::handle_load_dll): Remove.\n\t(get_child_debug_event): Call dll_loaded_event.",
    "tree": {
      "sha": "a42a01934906c6be7a513b6abf370cb34f21620c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a42a01934906c6be7a513b6abf370cb34f21620c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e228ef975e92d3bc860fc6b87039447392ba53aa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e228ef975e92d3bc860fc6b87039447392ba53aa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e228ef975e92d3bc860fc6b87039447392ba53aa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e228ef975e92d3bc860fc6b87039447392ba53aa/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "de0718729053b7c558166f3cc1a7d170c48a25de",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de0718729053b7c558166f3cc1a7d170c48a25de",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/de0718729053b7c558166f3cc1a7d170c48a25de"
    }
  ],
  "stats": {
    "total": 540,
    "additions": 209,
    "deletions": 331
  },
  "files": [
    {
      "sha": "4bb6ef832d9ce540b011b97de0b77268d27fa21d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=e228ef975e92d3bc860fc6b87039447392ba53aa",
      "patch": "@@ -1,3 +1,16 @@\n+2021-04-30  Tom Tromey  <tromey@adacore.com>\n+\n+\t* windows-nat.c (windows_nat::handle_load_dll): Update.\n+\t(windows_nat_target::get_windows_debug_event): Call\n+\tdll_loaded_event.\n+\t(windows_add_all_dlls, windows_add_dll): Move to\n+\tnat/windows-nat.c.\n+\t* nat/windows-nat.h (handle_load_dll): Change parameters.\n+\t(dll_loaded_event, windows_add_all_dlls): Declare.\n+\t* nat/windows-nat.c (windows_add_dll, windows_add_all_dlls): Move\n+\tfrom windows-nat.c.\n+\t(dll_loaded_event): New function.\n+\n 2021-04-30  Tom Tromey  <tromey@adacore.com>\n \n \t* nat/windows-nat.h (GenerateConsoleCtrlEvent): New define."
    },
    {
      "sha": "377810c9f0ed9ac9cfd93209426b24a2c31f3ea7",
      "filename": "gdb/nat/windows-nat.c",
      "status": "modified",
      "additions": 162,
      "deletions": 0,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/nat/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/nat/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/windows-nat.c?ref=e228ef975e92d3bc860fc6b87039447392ba53aa",
      "patch": "@@ -333,6 +333,168 @@ handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n #undef DEBUG_EXCEPTION_SIMPLE\n }\n \n+/* Iterate over all DLLs currently mapped by our inferior, looking for\n+   a DLL which is loaded at LOAD_ADDR.  If found, add the DLL to our\n+   list of solibs; otherwise do nothing.  LOAD_ADDR NULL means add all\n+   DLLs to the list of solibs; this is used when the inferior finishes\n+   its initialization, and all the DLLs it statically depends on are\n+   presumed loaded.  */\n+\n+static void\n+windows_add_dll (LPVOID load_addr)\n+{\n+  HMODULE dummy_hmodule;\n+  DWORD cb_needed;\n+  HMODULE *hmodules;\n+  int i;\n+\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    {\n+      if (EnumProcessModulesEx (current_process_handle, &dummy_hmodule,\n+\t\t\t\tsizeof (HMODULE), &cb_needed,\n+\t\t\t\tLIST_MODULES_32BIT) == 0)\n+\treturn;\n+    }\n+  else\n+#endif\n+    {\n+      if (EnumProcessModules (current_process_handle, &dummy_hmodule,\n+\t\t\t      sizeof (HMODULE), &cb_needed) == 0)\n+\treturn;\n+    }\n+\n+  if (cb_needed < 1)\n+    return;\n+\n+  hmodules = (HMODULE *) alloca (cb_needed);\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    {\n+      if (EnumProcessModulesEx (current_process_handle, hmodules,\n+\t\t\t\tcb_needed, &cb_needed,\n+\t\t\t\tLIST_MODULES_32BIT) == 0)\n+\treturn;\n+    }\n+  else\n+#endif\n+    {\n+      if (EnumProcessModules (current_process_handle, hmodules,\n+\t\t\t      cb_needed, &cb_needed) == 0)\n+\treturn;\n+    }\n+\n+  char system_dir[MAX_PATH];\n+  char syswow_dir[MAX_PATH];\n+  size_t system_dir_len = 0;\n+  bool convert_syswow_dir = false;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+#endif\n+    {\n+      /* This fails on 32bit Windows because it has no SysWOW64 directory,\n+\t and in this case a path conversion isn't necessary.  */\n+      UINT len = GetSystemWow64DirectoryA (syswow_dir, sizeof (syswow_dir));\n+      if (len > 0)\n+\t{\n+\t  /* Check that we have passed a large enough buffer.  */\n+\t  gdb_assert (len < sizeof (syswow_dir));\n+\n+\t  len = GetSystemDirectoryA (system_dir, sizeof (system_dir));\n+\t  /* Error check.  */\n+\t  gdb_assert (len != 0);\n+\t  /* Check that we have passed a large enough buffer.  */\n+\t  gdb_assert (len < sizeof (system_dir));\n+\n+\t  strcat (system_dir, \"\\\\\");\n+\t  strcat (syswow_dir, \"\\\\\");\n+\t  system_dir_len = strlen (system_dir);\n+\n+\t  convert_syswow_dir = true;\n+\t}\n+\n+    }\n+  for (i = 1; i < (int) (cb_needed / sizeof (HMODULE)); i++)\n+    {\n+      MODULEINFO mi;\n+#ifdef __USEWIDE\n+      wchar_t dll_name[MAX_PATH];\n+      char dll_name_mb[MAX_PATH];\n+#else\n+      char dll_name[MAX_PATH];\n+#endif\n+      const char *name;\n+      if (GetModuleInformation (current_process_handle, hmodules[i],\n+\t\t\t\t&mi, sizeof (mi)) == 0)\n+\tcontinue;\n+\n+      if (GetModuleFileNameEx (current_process_handle, hmodules[i],\n+\t\t\t       dll_name, sizeof (dll_name)) == 0)\n+\tcontinue;\n+#ifdef __USEWIDE\n+      wcstombs (dll_name_mb, dll_name, MAX_PATH);\n+      name = dll_name_mb;\n+#else\n+      name = dll_name;\n+#endif\n+      /* Convert the DLL path of 32bit processes returned by\n+\t GetModuleFileNameEx from the 64bit system directory to the\n+\t 32bit syswow64 directory if necessary.  */\n+      std::string syswow_dll_path;\n+      if (convert_syswow_dir\n+\t  && strncasecmp (name, system_dir, system_dir_len) == 0\n+\t  && strchr (name + system_dir_len, '\\\\') == nullptr)\n+\t{\n+\t  syswow_dll_path = syswow_dir;\n+\t  syswow_dll_path += name + system_dir_len;\n+\t  name = syswow_dll_path.c_str();\n+\t}\n+\n+      /* Record the DLL if either LOAD_ADDR is NULL or the address\n+\t at which the DLL was loaded is equal to LOAD_ADDR.  */\n+      if (!(load_addr != nullptr && mi.lpBaseOfDll != load_addr))\n+\t{\n+\t  handle_load_dll (name, mi.lpBaseOfDll);\n+\t  if (load_addr != nullptr)\n+\t    return;\n+\t}\n+    }\n+}\n+\n+/* See nat/windows-nat.h.  */\n+\n+void\n+dll_loaded_event ()\n+{\n+  gdb_assert (current_event.dwDebugEventCode == LOAD_DLL_DEBUG_EVENT);\n+\n+  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;\n+  const char *dll_name;\n+\n+  /* Try getting the DLL name via the lpImageName field of the event.\n+     Note that Microsoft documents this fields as strictly optional,\n+     in the sense that it might be NULL.  And the first DLL event in\n+     particular is explicitly documented as \"likely not pass[ed]\"\n+     (source: MSDN LOAD_DLL_DEBUG_INFO structure).  */\n+  dll_name = get_image_name (current_process_handle,\n+\t\t\t     event->lpImageName, event->fUnicode);\n+  /* If the DLL name could not be gleaned via lpImageName, try harder\n+     by enumerating all the DLLs loaded into the inferior, looking for\n+     one that is loaded at base address = lpBaseOfDll. */\n+  if (dll_name != nullptr)\n+    handle_load_dll (dll_name, event->lpBaseOfDll);\n+  else if (event->lpBaseOfDll != nullptr)\n+    windows_add_dll (event->lpBaseOfDll);\n+}\n+\n+/* See nat/windows-nat.h.  */\n+\n+void\n+windows_add_all_dlls ()\n+{\n+  windows_add_dll (nullptr);\n+}\n+\n /* See nat/windows-nat.h.  */\n \n bool"
    },
    {
      "sha": "821866bc63feab8be050b7ee5f07b23ae7d7c8a9",
      "filename": "gdb/nat/windows-nat.h",
      "status": "modified",
      "additions": 13,
      "deletions": 1,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/nat/windows-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/nat/windows-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/windows-nat.h?ref=e228ef975e92d3bc860fc6b87039447392ba53aa",
      "patch": "@@ -135,9 +135,12 @@ extern int handle_output_debug_string (struct target_waitstatus *ourstatus);\n    This function assumes that the current event did not occur during\n    inferior initialization.\n \n+   DLL_NAME is the name of the library.  BASE is the base load\n+   address.\n+\n    This function must be supplied by the embedding application.  */\n \n-extern void handle_load_dll ();\n+extern void handle_load_dll (const char *dll_name, LPVOID base);\n \n /* Handle a DLL unload event.\n \n@@ -234,6 +237,15 @@ typedef enum\n extern handle_exception_result handle_exception\n   (struct target_waitstatus *ourstatus, bool debug_exceptions);\n \n+/* Call to indicate that a DLL was loaded.  */\n+\n+extern void dll_loaded_event ();\n+\n+/* Iterate over all DLLs currently mapped by our inferior, and\n+   add them to our list of solibs.  */\n+\n+extern void windows_add_all_dlls ();\n+\n /* Return true if there is a pending stop matching\n    desired_stop_thread_id.  If DEBUG_EVENTS is true, logging will be\n    enabled.  */"
    },
    {
      "sha": "22f8b7a2028aa97023fe95080fa18f3a85bbef35",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 168,
      "changes": 172,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e228ef975e92d3bc860fc6b87039447392ba53aa/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=e228ef975e92d3bc860fc6b87039447392ba53aa",
      "patch": "@@ -787,38 +787,13 @@ windows_make_so (const char *name, LPVOID load_addr)\n   return so;\n }\n \n-static bool windows_add_dll (LPVOID);\n-\n /* See nat/windows-nat.h.  */\n \n void\n-windows_nat::handle_load_dll ()\n+windows_nat::handle_load_dll (const char *dll_name, LPVOID base)\n {\n-  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;\n-  const char *dll_name;\n-\n-  /* Try getting the DLL name via the lpImageName field of the event.\n-     Note that Microsoft documents this fields as strictly optional,\n-     in the sense that it might be NULL.  And the first DLL event in\n-     particular is explicitly documented as \"likely not pass[ed]\"\n-     (source: MSDN LOAD_DLL_DEBUG_INFO structure).  */\n-  dll_name = get_image_name (current_process_handle,\n-\t\t\t     event->lpImageName, event->fUnicode);\n-  /* If the DLL name could not be gleaned via lpImageName, try harder\n-     by enumerating all the DLLs loaded into the inferior, looking for\n-     one that is loaded at base address = lpBaseOfDll. */\n-  if (dll_name != nullptr)\n-    {\n-\n-      solib_end->next = windows_make_so (dll_name, event->lpBaseOfDll);\n-      solib_end = solib_end->next;\n-    }\n-  else if (event->lpBaseOfDll != nullptr\n-\t   && windows_add_dll (event->lpBaseOfDll))\n-    dll_name = solib_end->so_name;\n-\n-  if (dll_name == nullptr)\n-    return;\n+  solib_end->next = windows_make_so (dll_name, base);\n+  solib_end = solib_end->next;\n \n   lm_info_windows *li = (lm_info_windows *) solib_end->lm_info;\n \n@@ -1641,7 +1616,7 @@ windows_nat_target::get_windows_debug_event (int pid,\n       CloseHandle (current_event.u.LoadDll.hFile);\n       if (saw_create != 1 || ! windows_initialization_done)\n \tbreak;\n-      catch_errors (handle_load_dll);\n+      catch_errors (dll_loaded_event);\n       ourstatus->kind = TARGET_WAITKIND_LOADED;\n       ourstatus->value.integer = 0;\n       thread_id = current_event.dwThreadId;\n@@ -1823,145 +1798,6 @@ windows_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     }\n }\n \n-/* Iterate over all DLLs currently mapped by our inferior, and\n-   add them to our list of solibs.  */\n-\n-static void\n-windows_add_all_dlls (void)\n-{\n-  windows_add_dll (NULL);\n-}\n-\n-/* Iterate over all DLLs currently mapped by our inferior, looking for\n-   a DLL which is loaded at LOAD_ADDR.  If found, add the DLL to our\n-   list of solibs and return 'true'; otherwise do nothing and return\n-   'false'.  LOAD_ADDR NULL means add all DLLs to the list of solibs;\n-   this is used when the inferior finishes its initialization, and all\n-   the DLLs it statically depends on are presumed loaded.  */\n-\n-static bool\n-windows_add_dll (LPVOID load_addr)\n-{\n-  HMODULE dummy_hmodule;\n-  DWORD cb_needed;\n-  HMODULE *hmodules;\n-  int i;\n-\n-#ifdef __x86_64__\n-  if (wow64_process)\n-    {\n-      if (EnumProcessModulesEx (current_process_handle, &dummy_hmodule,\n-\t\t\t\tsizeof (HMODULE), &cb_needed,\n-\t\t\t\tLIST_MODULES_32BIT) == 0)\n-\treturn false;\n-    }\n-  else\n-#endif\n-    {\n-      if (EnumProcessModules (current_process_handle, &dummy_hmodule,\n-\t\t\t      sizeof (HMODULE), &cb_needed) == 0)\n-\treturn false;\n-    }\n-\n-  if (cb_needed < 1)\n-    return false;\n-\n-  hmodules = (HMODULE *) alloca (cb_needed);\n-#ifdef __x86_64__\n-  if (wow64_process)\n-    {\n-      if (EnumProcessModulesEx (current_process_handle, hmodules,\n-\t\t\t\tcb_needed, &cb_needed,\n-\t\t\t\tLIST_MODULES_32BIT) == 0)\n-\treturn false;\n-    }\n-  else\n-#endif\n-    {\n-      if (EnumProcessModules (current_process_handle, hmodules,\n-\t\t\t      cb_needed, &cb_needed) == 0)\n-\treturn false;\n-    }\n-\n-  char system_dir[__PMAX];\n-  char syswow_dir[__PMAX];\n-  size_t system_dir_len = 0;\n-  bool convert_syswow_dir = false;\n-#ifdef __x86_64__\n-  if (wow64_process)\n-#endif\n-    {\n-      /* This fails on 32bit Windows because it has no SysWOW64 directory,\n-\t and in this case a path conversion isn't necessary.  */\n-      UINT len = GetSystemWow64DirectoryA (syswow_dir, sizeof (syswow_dir));\n-      if (len > 0)\n-\t{\n-\t  /* Check that we have passed a large enough buffer.  */\n-\t  gdb_assert (len < sizeof (syswow_dir));\n-\n-\t  len = GetSystemDirectoryA (system_dir, sizeof (system_dir));\n-\t  /* Error check.  */\n-\t  gdb_assert (len != 0);\n-\t  /* Check that we have passed a large enough buffer.  */\n-\t  gdb_assert (len < sizeof (system_dir));\n-\n-\t  strcat (system_dir, \"\\\\\");\n-\t  strcat (syswow_dir, \"\\\\\");\n-\t  system_dir_len = strlen (system_dir);\n-\n-\t  convert_syswow_dir = true;\n-\t}\n-\n-    }\n-  for (i = 1; i < (int) (cb_needed / sizeof (HMODULE)); i++)\n-    {\n-      MODULEINFO mi;\n-#ifdef __USEWIDE\n-      wchar_t dll_name[__PMAX];\n-      char dll_name_mb[__PMAX];\n-#else\n-      char dll_name[__PMAX];\n-#endif\n-      const char *name;\n-      if (GetModuleInformation (current_process_handle, hmodules[i],\n-\t\t\t\t&mi, sizeof (mi)) == 0)\n-\tcontinue;\n-\n-      if (GetModuleFileNameEx (current_process_handle, hmodules[i],\n-\t\t\t       dll_name, sizeof (dll_name)) == 0)\n-\tcontinue;\n-#ifdef __USEWIDE\n-      wcstombs (dll_name_mb, dll_name, __PMAX);\n-      name = dll_name_mb;\n-#else\n-      name = dll_name;\n-#endif\n-      /* Convert the DLL path of 32bit processes returned by\n-\t GetModuleFileNameEx from the 64bit system directory to the\n-\t 32bit syswow64 directory if necessary.  */\n-      std::string syswow_dll_path;\n-      if (convert_syswow_dir\n-\t  && strncasecmp (name, system_dir, system_dir_len) == 0\n-\t  && strchr (name + system_dir_len, '\\\\') == nullptr)\n-\t{\n-\t  syswow_dll_path = syswow_dir;\n-\t  syswow_dll_path += name + system_dir_len;\n-\t  name = syswow_dll_path.c_str();\n-\t}\n-\n-      /* Record the DLL if either LOAD_ADDR is NULL or the address\n-\t at which the DLL was loaded is equal to LOAD_ADDR.  */\n-      if (!(load_addr != nullptr && mi.lpBaseOfDll != load_addr))\n-\t{\n-\t  solib_end->next = windows_make_so (name, mi.lpBaseOfDll);\n-\t  solib_end = solib_end->next;\n-\t  if (load_addr != nullptr)\n-\t    return true;\n-\t}\n-    }\n-  return load_addr == nullptr ? true : false;\n-}\n-\n void\n windows_nat_target::do_initial_windows_stuff (DWORD pid, bool attaching)\n {"
    },
    {
      "sha": "057ed158be918e4b2af761af1724d08bd70c196f",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e228ef975e92d3bc860fc6b87039447392ba53aa/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e228ef975e92d3bc860fc6b87039447392ba53aa/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=e228ef975e92d3bc860fc6b87039447392ba53aa",
      "patch": "@@ -1,3 +1,12 @@\n+2021-04-30  Tom Tromey  <tromey@adacore.com>\n+\n+\t* win32-low.cc (do_initial_child_stuff): Update.\n+\t(windows_nat::handle_load_dll): Rename from win32_add_one_solib.\n+\tChange parameter type.\n+\t(win32_add_dll, win32_add_all_dlls)\n+\t(windows_nat::handle_load_dll): Remove.\n+\t(get_child_debug_event): Call dll_loaded_event.\n+\n 2021-04-30  Tom Tromey  <tromey@adacore.com>\n \n \t* win32-low.cc (GETPROCADDRESS): Remove."
    },
    {
      "sha": "5c7946bd33a8462d7f61bd62d838d51398806bea",
      "filename": "gdbserver/win32-low.cc",
      "status": "modified",
      "additions": 8,
      "deletions": 162,
      "changes": 170,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e228ef975e92d3bc860fc6b87039447392ba53aa/gdbserver/win32-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e228ef975e92d3bc860fc6b87039447392ba53aa/gdbserver/win32-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-low.cc?ref=e228ef975e92d3bc860fc6b87039447392ba53aa",
      "patch": "@@ -90,8 +90,6 @@ const struct target_desc *wow64_win32_tdesc;\n \n #define NUM_REGS (the_low_target.num_regs ())\n \n-static void win32_add_all_dlls (void);\n-\n /* Get the thread ID from the current selected inferior (the current\n    thread).  */\n static ptid_t\n@@ -419,7 +417,7 @@ do_initial_child_stuff (HANDLE proch, DWORD pid, int attached)\n      Rather than try to work around this sort of issue, it is much\n      simpler to just ignore DLL load/unload events during the startup\n      phase, and then process them all in one batch now.  */\n-  win32_add_all_dlls ();\n+  windows_add_all_dlls ();\n \n   child_initialization_done = 1;\n }\n@@ -937,9 +935,13 @@ win32_process_target::resume (thread_resume *resume_info, size_t n)\n   child_continue (continue_status, tid);\n }\n \n-static void\n-win32_add_one_solib (const char *name, CORE_ADDR load_addr)\n+/* See nat/windows-nat.h.  */\n+\n+void\n+windows_nat::handle_load_dll (const char *name, LPVOID base)\n {\n+  CORE_ADDR load_addr = (CORE_ADDR) (uintptr_t) base;\n+\n   char buf[MAX_PATH + 1];\n   char buf2[MAX_PATH + 1];\n \n@@ -987,162 +989,6 @@ win32_add_one_solib (const char *name, CORE_ADDR load_addr)\n   loaded_dll (buf2, load_addr);\n }\n \n-/* Iterate over all DLLs currently mapped by our inferior, looking for\n-   a DLL loaded at LOAD_ADDR; if found, return its file name,\n-   otherwise return NULL.  If LOAD_ADDR is NULL, add all mapped DLLs\n-   to our list of solibs.  */\n-\n-static char *\n-win32_add_dll (LPVOID load_addr)\n-{\n-  size_t i;\n-  HMODULE dh_buf[1];\n-  HMODULE *DllHandle = dh_buf;\n-  DWORD cbNeeded;\n-  BOOL ok;\n-\n-  cbNeeded = 0;\n-#ifdef __x86_64__\n-  if (wow64_process)\n-    ok = EnumProcessModulesEx (current_process_handle,\n-\t\t\t       DllHandle,\n-\t\t\t       sizeof (HMODULE),\n-\t\t\t       &cbNeeded,\n-\t\t\t       LIST_MODULES_32BIT);\n-  else\n-#endif\n-    ok = EnumProcessModules (current_process_handle,\n-\t\t\t     DllHandle,\n-\t\t\t     sizeof (HMODULE),\n-\t\t\t     &cbNeeded);\n-\n-  if (!ok || !cbNeeded)\n-    return NULL;\n-\n-  DllHandle = (HMODULE *) alloca (cbNeeded);\n-  if (!DllHandle)\n-    return NULL;\n-\n-#ifdef __x86_64__\n-  if (wow64_process)\n-    ok = EnumProcessModulesEx (current_process_handle,\n-\t\t\t       DllHandle,\n-\t\t\t       cbNeeded,\n-\t\t\t       &cbNeeded,\n-\t\t\t       LIST_MODULES_32BIT);\n-  else\n-#endif\n-    ok = EnumProcessModules (current_process_handle,\n-\t\t\t     DllHandle,\n-\t\t\t     cbNeeded,\n-\t\t\t     &cbNeeded);\n-  if (!ok)\n-    return NULL;\n-\n-  char system_dir[MAX_PATH];\n-  char syswow_dir[MAX_PATH];\n-  size_t system_dir_len = 0;\n-  bool convert_syswow_dir = false;\n-#ifdef __x86_64__\n-  if (wow64_process)\n-#endif\n-    {\n-      /* This fails on 32bit Windows because it has no SysWOW64 directory,\n-\t and in this case a path conversion isn't necessary.  */\n-      UINT len = GetSystemWow64DirectoryA (syswow_dir, sizeof (syswow_dir));\n-      if (len > 0)\n-\t{\n-\t  /* Check that we have passed a large enough buffer.  */\n-\t  gdb_assert (len < sizeof (syswow_dir));\n-\n-\t  len = GetSystemDirectoryA (system_dir, sizeof (system_dir));\n-\t  /* Error check.  */\n-\t  gdb_assert (len != 0);\n-\t  /* Check that we have passed a large enough buffer.  */\n-\t  gdb_assert (len < sizeof (system_dir));\n-\n-\t  strcat (system_dir, \"\\\\\");\n-\t  strcat (syswow_dir, \"\\\\\");\n-\t  system_dir_len = strlen (system_dir);\n-\n-\t  convert_syswow_dir = true;\n-\t}\n-\n-    }\n-\n-  for (i = 1; i < ((size_t) cbNeeded / sizeof (HMODULE)); i++)\n-    {\n-      MODULEINFO mi;\n-      static char dll_name[MAX_PATH];\n-\n-      if (!GetModuleInformation (current_process_handle,\n-\t\t\t\t DllHandle[i],\n-\t\t\t\t &mi,\n-\t\t\t\t sizeof (mi)))\n-\tcontinue;\n-      if (GetModuleFileNameExA (current_process_handle,\n-\t\t\t\tDllHandle[i],\n-\t\t\t\tdll_name,\n-\t\t\t\tMAX_PATH) == 0)\n-\tcontinue;\n-\n-      if (load_addr != nullptr && mi.lpBaseOfDll != load_addr)\n-\tcontinue;\n-\n-      const char *name = dll_name;\n-      /* Convert the DLL path of 32bit processes returned by\n-\t GetModuleFileNameEx from the 64bit system directory to the\n-\t 32bit syswow64 directory if necessary.  */\n-      std::string syswow_dll_path;\n-      if (convert_syswow_dir\n-\t  && strncasecmp (dll_name, system_dir, system_dir_len) == 0\n-\t  && strchr (dll_name + system_dir_len, '\\\\') == nullptr)\n-\t{\n-\t  syswow_dll_path = syswow_dir;\n-\t  syswow_dll_path += dll_name + system_dir_len;\n-\t  name = syswow_dll_path.c_str();\n-\t}\n-\n-      if (load_addr != nullptr)\n-\t{\n-\t  if (name != dll_name)\n-\t    strcpy (dll_name, name);\n-\t  return dll_name;\n-\t}\n-      else\n-\twin32_add_one_solib (name, (CORE_ADDR) (uintptr_t) mi.lpBaseOfDll);\n-    }\n-  return NULL;\n-}\n-\n-/* Iterate over all DLLs currently mapped by our inferior, and\n-   add them to our list of solibs.  */\n-\n-static void\n-win32_add_all_dlls (void)\n-{\n-  win32_add_dll (NULL);\n-}\n-\n-/* See nat/windows-nat.h.  */\n-\n-void\n-windows_nat::handle_load_dll ()\n-{\n-  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;\n-  const char *dll_name;\n-\n-  dll_name = get_image_name (current_process_handle,\n-\t\t\t     event->lpImageName, event->fUnicode);\n-  if (dll_name == nullptr\n-      && event->lpBaseOfDll != nullptr)\n-    dll_name = win32_add_dll (event->lpBaseOfDll);\n-  if (dll_name == nullptr)\n-    return;\n-\n-  win32_add_one_solib (dll_name, (CORE_ADDR) (uintptr_t) event->lpBaseOfDll);\n-}\n-\n /* See nat/windows-nat.h.  */\n \n void\n@@ -1367,7 +1213,7 @@ get_child_debug_event (DWORD *continue_status,\n       CloseHandle (current_event.u.LoadDll.hFile);\n       if (! child_initialization_done)\n \tbreak;\n-      handle_load_dll ();\n+      dll_loaded_event ();\n \n       ourstatus->kind = TARGET_WAITKIND_LOADED;\n       ourstatus->value.sig = GDB_SIGNAL_TRAP;"
    }
  ]
}