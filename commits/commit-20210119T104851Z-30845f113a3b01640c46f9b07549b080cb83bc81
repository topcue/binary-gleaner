{
  "sha": "30845f113a3b01640c46f9b07549b080cb83bc81",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzA4NDVmMTEzYTNiMDE2NDBjNDZmOWIwNzU0OWIwODBjYjgzYmM4MQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-01-19T08:56:11Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-01-19T10:48:51Z"
    },
    "message": "PowerPC use_local_plt\n\nPut the logic to select local vs. usual .plt section in one place.\n\n\t* elf64-ppc.c (elf_hash_entry): New inline function.  Use\n\tthroughout to replace casts.\n\t(branch_reloc_hash_match): Remove const from params.\n\t(use_local_plt): New function.\n\t(allocate_dynrelocs, ppc_build_one_stub, ppc_size_one_stub),\n\t(build_global_entry_stubs_and_plt, ppc64_elf_relocate_section):\n\tUse use_local_plt.\n\t* elf32-ppc.c (use_local_plt): New function.\n\t(allocate_dynrelocs, ppc_elf_relocate_section),\n\t(write_global_sym_plt): Use use_local_plt.",
    "tree": {
      "sha": "5d2750c6be95c1f4250e93e44ef87c86e81d571c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5d2750c6be95c1f4250e93e44ef87c86e81d571c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/30845f113a3b01640c46f9b07549b080cb83bc81",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30845f113a3b01640c46f9b07549b080cb83bc81",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/30845f113a3b01640c46f9b07549b080cb83bc81",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30845f113a3b01640c46f9b07549b080cb83bc81/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a75a6a416477915b7d236537c9170ced3064df11",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a75a6a416477915b7d236537c9170ced3064df11",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a75a6a416477915b7d236537c9170ced3064df11"
    }
  ],
  "stats": {
    "total": 138,
    "additions": 78,
    "deletions": 60
  },
  "files": [
    {
      "sha": "c97976dd8b2b9416c701915b5f4bb0b0d871cd22",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30845f113a3b01640c46f9b07549b080cb83bc81/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30845f113a3b01640c46f9b07549b080cb83bc81/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=30845f113a3b01640c46f9b07549b080cb83bc81",
      "patch": "@@ -1,3 +1,16 @@\n+2021-01-19  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf64-ppc.c (elf_hash_entry): New inline function.  Use\n+\tthroughout to replace casts.\n+\t(branch_reloc_hash_match): Remove const from params.\n+\t(use_local_plt): New function.\n+\t(allocate_dynrelocs, ppc_build_one_stub, ppc_size_one_stub),\n+\t(build_global_entry_stubs_and_plt, ppc64_elf_relocate_section):\n+\tUse use_local_plt.\n+\t* elf32-ppc.c (use_local_plt): New function.\n+\t(allocate_dynrelocs, ppc_elf_relocate_section),\n+\t(write_global_sym_plt): Use use_local_plt.\n+\n 2021-01-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR ld/27193"
    },
    {
      "sha": "a8da3049986ba69934e1d624550f9e70999d3544",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30845f113a3b01640c46f9b07549b080cb83bc81/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30845f113a3b01640c46f9b07549b080cb83bc81/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=30845f113a3b01640c46f9b07549b080cb83bc81",
      "patch": "@@ -5094,6 +5094,18 @@ ensure_undef_dynamic (struct bfd_link_info *info,\n   return TRUE;\n }\n \n+/* Choose whether to use htab->iplt or htab->pltlocal rather than the\n+   usual htab->elf.splt section for a PLT entry.  */\n+\n+static inline\n+bfd_boolean use_local_plt (struct bfd_link_info *info,\n+\t\t\t   struct elf_link_hash_entry *h)\n+{\n+  return (h == NULL\n+\t  || h->dynindx == -1\n+\t  || !elf_hash_table (info)->dynamic_sections_created);\n+}\n+\n /* Allocate space in associated reloc sections for dynamic relocs.  */\n \n static bfd_boolean\n@@ -5103,7 +5115,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   struct ppc_elf_link_hash_entry *eh;\n   struct ppc_elf_link_hash_table *htab;\n   struct elf_dyn_relocs *p;\n-  bfd_boolean dyn;\n \n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n@@ -5271,8 +5282,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n      b) is an ifunc, or\n      c) has plt16 relocs and has been processed by adjust_dynamic_symbol, or\n      d) has plt16 relocs and we are linking statically.  */\n-  dyn = htab->elf.dynamic_sections_created && h->dynindx != -1;\n-  if (dyn\n+  if ((htab->elf.dynamic_sections_created && h->dynindx != -1)\n       || h->type == STT_GNU_IFUNC\n       || (h->needs_plt && h->dynamic_adjusted)\n       || (h->needs_plt\n@@ -5290,6 +5300,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \tif (ent->plt.refcount > 0)\n \t  {\n \t    asection *s = htab->elf.splt;\n+\t    bfd_boolean dyn = !use_local_plt (info, h);\n \n \t    if (!dyn)\n \t      {\n@@ -8373,9 +8384,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \n \t\t  unresolved_reloc = FALSE;\n \t\t  plt = htab->elf.splt;\n-\t\t  if (!htab->elf.dynamic_sections_created\n-\t\t      || h == NULL\n-\t\t      || h->dynindx == -1)\n+\t\t  if (use_local_plt (info, h))\n \t\t    {\n \t\t      if (ifunc != NULL)\n \t\t\tplt = htab->elf.iplt;\n@@ -9351,6 +9360,8 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n   for (ent = h->plt.plist; ent != NULL; ent = ent->next)\n     if (ent->plt.offset != (bfd_vma) -1)\n       {\n+\tbfd_boolean dyn = !use_local_plt (info, h);\n+\n \tif (!doneone)\n \t  {\n \t    Elf_Internal_Rela rela;\n@@ -9359,9 +9370,7 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n \t    asection *plt = htab->elf.splt;\n \t    asection *relplt = htab->elf.srelplt;\n \n-\t    if (htab->plt_type == PLT_NEW\n-\t\t|| !htab->elf.dynamic_sections_created\n-\t\t|| h->dynindx == -1)\n+\t    if (htab->plt_type == PLT_NEW || !dyn)\n \t      reloc_index = ent->plt.offset / 4;\n \t    else\n \t      {\n@@ -9374,9 +9383,7 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n \n \t    /* This symbol has an entry in the procedure linkage table.\n \t       Set it up.  */\n-\t    if (htab->plt_type == PLT_VXWORKS\n-\t\t&& htab->elf.dynamic_sections_created\n-\t\t&& h->dynindx != -1)\n+\t    if (htab->plt_type == PLT_VXWORKS && dyn)\n \t      {\n \t\tbfd_vma got_offset;\n \t\tconst bfd_vma *plt_entry;\n@@ -9499,8 +9506,7 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n \t    else\n \t      {\n \t\trela.r_addend = 0;\n-\t\tif (!htab->elf.dynamic_sections_created\n-\t\t    || h->dynindx == -1)\n+\t\tif (!dyn)\n \t\t  {\n \t\t    if (h->type == STT_GNU_IFUNC)\n \t\t      {\n@@ -9529,9 +9535,7 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n \t\t\t\t     + plt->output_offset\n \t\t\t\t     + ent->plt.offset);\n \n-\t\t    if (htab->plt_type == PLT_OLD\n-\t\t\t|| !htab->elf.dynamic_sections_created\n-\t\t\t|| h->dynindx == -1)\n+\t\t    if (htab->plt_type == PLT_OLD || !dyn)\n \t\t      {\n \t\t\t/* We don't need to fill in the .plt.  The ppc dynamic\n \t\t\t   linker will fill it in.  */\n@@ -9550,8 +9554,7 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n \t    if (relplt != NULL)\n \t      {\n \t\t/* Fill in the entry in the .rela.plt section.  */\n-\t\tif (!htab->elf.dynamic_sections_created\n-\t\t    || h->dynindx == -1)\n+\t\tif (!dyn)\n \t\t  {\n \t\t    if (h->type == STT_GNU_IFUNC)\n \t\t      rela.r_info = ELF32_R_INFO (0, R_PPC_IRELATIVE);\n@@ -9574,15 +9577,12 @@ write_global_sym_plt (struct elf_link_hash_entry *h, void *inf)\n \t    doneone = TRUE;\n \t  }\n \n-\tif (htab->plt_type == PLT_NEW\n-\t    || !htab->elf.dynamic_sections_created\n-\t    || h->dynindx == -1)\n+\tif (htab->plt_type == PLT_NEW || !dyn)\n \t  {\n \t    unsigned char *p;\n \t    asection *plt = htab->elf.splt;\n \n-\t    if (!htab->elf.dynamic_sections_created\n-\t\t|| h->dynindx == -1)\n+\t    if (!dyn)\n \t      {\n \t\tif (h->type == STT_GNU_IFUNC)\n \t\t  plt = htab->elf.iplt;"
    },
    {
      "sha": "ed595074b94404de6ba9decba13b722be0451fd0",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 41,
      "deletions": 36,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30845f113a3b01640c46f9b07549b080cb83bc81/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30845f113a3b01640c46f9b07549b080cb83bc81/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=30845f113a3b01640c46f9b07549b080cb83bc81",
      "patch": "@@ -3149,6 +3149,12 @@ ppc_elf_hash_entry (struct elf_link_hash_entry *ent)\n   return (struct ppc_link_hash_entry *) ent;\n }\n \n+static inline struct elf_link_hash_entry *\n+elf_hash_entry (struct ppc_link_hash_entry *ent)\n+{\n+  return (struct elf_link_hash_entry *) ent;\n+}\n+\n /* ppc64 ELF linker hash table.  */\n \n struct ppc_link_hash_table\n@@ -5656,10 +5662,10 @@ static bfd_boolean\n is_tls_get_addr (struct elf_link_hash_entry *h,\n \t\t struct ppc_link_hash_table *htab)\n {\n-  return (h == (struct elf_link_hash_entry *) htab->tls_get_addr_fd\n-\t  || h == (struct elf_link_hash_entry *) htab->tga_desc_fd\n-\t  || h == (struct elf_link_hash_entry *) htab->tls_get_addr\n-\t  || h == (struct elf_link_hash_entry *) htab->tga_desc);\n+  return (h == elf_hash_entry (htab->tls_get_addr_fd)\n+\t  || h == elf_hash_entry (htab->tga_desc_fd)\n+\t  || h == elf_hash_entry (htab->tls_get_addr)\n+\t  || h == elf_hash_entry (htab->tga_desc));\n }\n \n static bfd_boolean func_desc_adjust (struct elf_link_hash_entry *, void *);\n@@ -7856,7 +7862,7 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)\n \t\t  if (tga_fd != NULL)\n \t\t    {\n \t\t      htab->tls_get_addr_fd = ppc_elf_hash_entry (opt_fd);\n-\t\t      tga = (struct elf_link_hash_entry *) htab->tls_get_addr;\n+\t\t      tga = elf_hash_entry (htab->tls_get_addr);\n \t\t      if (opt != NULL && tga != NULL)\n \t\t\t{\n \t\t\t  tga->root.type = bfd_link_hash_indirect;\n@@ -7917,12 +7923,12 @@ ppc64_elf_tls_setup (struct bfd_link_info *info)\n    any of HASH1, HASH2, HASH3, or HASH4.  */\n \n static bfd_boolean\n-branch_reloc_hash_match (const bfd *ibfd,\n-\t\t\t const Elf_Internal_Rela *rel,\n-\t\t\t const struct ppc_link_hash_entry *hash1,\n-\t\t\t const struct ppc_link_hash_entry *hash2,\n-\t\t\t const struct ppc_link_hash_entry *hash3,\n-\t\t\t const struct ppc_link_hash_entry *hash4)\n+branch_reloc_hash_match (bfd *ibfd,\n+\t\t\t Elf_Internal_Rela *rel,\n+\t\t\t struct ppc_link_hash_entry *hash1,\n+\t\t\t struct ppc_link_hash_entry *hash2,\n+\t\t\t struct ppc_link_hash_entry *hash3,\n+\t\t\t struct ppc_link_hash_entry *hash4)\n {\n   Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);\n   enum elf_ppc64_reloc_type r_type = ELF64_R_TYPE (rel->r_info);\n@@ -7935,10 +7941,10 @@ branch_reloc_hash_match (const bfd *ibfd,\n \n       h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n       h = elf_follow_link (h);\n-      if (h == (struct elf_link_hash_entry *) hash1\n-\t  || h == (struct elf_link_hash_entry *) hash2\n-\t  || h == (struct elf_link_hash_entry *) hash3\n-\t  || h == (struct elf_link_hash_entry *) hash4)\n+      if (h == elf_hash_entry (hash1)\n+\t  || h == elf_hash_entry (hash2)\n+\t  || h == elf_hash_entry (hash3)\n+\t  || h == elf_hash_entry (hash4))\n \treturn TRUE;\n     }\n   return FALSE;\n@@ -9629,6 +9635,18 @@ ensure_undef_dynamic (struct bfd_link_info *info,\n   return TRUE;\n }\n \n+/* Choose whether to use htab->iplt or htab->pltlocal rather than the\n+   usual htab->elf.splt section for a PLT entry.  */\n+\n+static inline\n+bfd_boolean use_local_plt (struct bfd_link_info *info,\n+\t\t\t   struct elf_link_hash_entry *h)\n+{\n+  return (h == NULL\n+\t  || h->dynindx == -1\n+\t  || !elf_hash_table (info)->dynamic_sections_created);\n+}\n+\n /* Allocate space in .plt, .got and associated reloc sections for\n    dynamic relocs.  */\n \n@@ -9818,8 +9836,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n       for (pent = h->plt.plist; pent != NULL; pent = pent->next)\n \tif (pent->plt.refcount > 0)\n \t  {\n-\t    if (!htab->elf.dynamic_sections_created\n-\t\t|| h->dynindx == -1)\n+\t    if (use_local_plt (info, h))\n \t      {\n \t\tif (h->type == STT_GNU_IFUNC)\n \t\t  {\n@@ -11703,9 +11720,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    abort ();\n \n \t  plt = htab->elf.splt;\n-\t  if (!htab->elf.dynamic_sections_created\n-\t      || stub_entry->h == NULL\n-\t      || stub_entry->h->elf.dynindx == -1)\n+\t  if (use_local_plt (info, elf_hash_entry (stub_entry->h)))\n \t    {\n \t      if (stub_entry->symtype == STT_GNU_IFUNC)\n \t\tplt = htab->elf.iplt;\n@@ -11837,9 +11852,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \tabort ();\n \n       plt = htab->elf.splt;\n-      if (!htab->elf.dynamic_sections_created\n-\t  || stub_entry->h == NULL\n-\t  || stub_entry->h->elf.dynindx == -1)\n+      if (use_local_plt (info, elf_hash_entry (stub_entry->h)))\n \t{\n \t  if (stub_entry->symtype == STT_GNU_IFUNC)\n \t    plt = htab->elf.iplt;\n@@ -12208,9 +12221,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \tabort ();\n \n       plt = htab->elf.splt;\n-      if (!htab->elf.dynamic_sections_created\n-\t  || stub_entry->h == NULL\n-\t  || stub_entry->h->elf.dynindx == -1)\n+      if (use_local_plt (info, elf_hash_entry (stub_entry->h)))\n \t{\n \t  if (stub_entry->symtype == STT_GNU_IFUNC)\n \t    plt = htab->elf.iplt;\n@@ -12292,9 +12303,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       if (targ >= (bfd_vma) -2)\n \tabort ();\n       plt = htab->elf.splt;\n-      if (!htab->elf.dynamic_sections_created\n-\t  || stub_entry->h == NULL\n-\t  || stub_entry->h->elf.dynindx == -1)\n+      if (use_local_plt (info, elf_hash_entry (stub_entry->h)))\n \t{\n \t  if (stub_entry->symtype == STT_GNU_IFUNC)\n \t    plt = htab->elf.iplt;\n@@ -14061,8 +14070,7 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)\n \tasection *plt, *relplt;\n \tbfd_byte *loc;\n \n-\tif (!htab->elf.dynamic_sections_created\n-\t    || h->dynindx == -1)\n+\tif (use_local_plt (info, h))\n \t  {\n \t    if (!(h->def_regular\n \t\t  && (h->root.type == bfd_link_hash_defined\n@@ -14151,8 +14159,7 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)\n \n \tp = s->contents + h->root.u.def.value;\n \tplt = htab->elf.splt;\n-\tif (!htab->elf.dynamic_sections_created\n-\t    || h->dynindx == -1)\n+\tif (use_local_plt (info, h))\n \t  {\n \t    if (h->type == STT_GNU_IFUNC)\n \t      plt = htab->elf.iplt;\n@@ -16490,9 +16497,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t      bfd_vma got;\n \n \t\t      plt = htab->elf.splt;\n-\t\t      if (!htab->elf.dynamic_sections_created\n-\t\t\t  || h == NULL\n-\t\t\t  || h->elf.dynindx == -1)\n+\t\t      if (use_local_plt (info, elf_hash_entry (h)))\n \t\t\t{\n \t\t\t  if (h != NULL\n \t\t\t      ? h->elf.type == STT_GNU_IFUNC"
    }
  ]
}