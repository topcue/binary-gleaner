{
  "sha": "cb44333d99548bbbf7be06387a31877ee9322ab4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2I0NDMzM2Q5OTU0OGJiYmY3YmUwNjM4N2EzMTg3N2VlOTMyMmFiNA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-07-22T20:31:43Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-08-06T14:04:33Z"
    },
    "message": "Add file offsets to the source cache\n\nCurrently, gdb stores the number of lines and an array of file offsets\nfor the start of each line in struct symtab.  This patch moves this\ninformation to the source cache.  This has two benefits.\n\nFirst, it allows gdb to read a source file less frequently.\nCurrently, a source file may be read multiple times: once when\ncomputing the file offsets, once when highlighting, and then pieces\nmay be read again while printing source lines.  With this change, the\nfile is read once for its source text and file offsets; and then\nperhaps read again if it is evicted from the cache.\n\nSecond, if multiple symtabs cover the same source file, then this will\nshare the file offsets between them.  I'm not sure whether this\nhappens in practice.\n\ngdb/ChangeLog\n2019-08-06  Tom Tromey  <tromey@adacore.com>\n\n\t* annotate.c (annotate_source_line): Use g_source_cache.\n\t* source-cache.c (source_cache::get_plain_source_lines): Change\n\tparameters.  Populate m_offset_cache.\n\t(source_cache::ensure): New method.\n\t(source_cache::get_line_charpos): New method.\n\t(extract_lines): Move lower.  Change parameters.\n\t(source_cache::get_source_lines): Move lower.\n\t* source-cache.h (class source_cache): Update comment.\n\t<get_line_charpos>: New method.\n\t<get_source_lines>: Update comment.\n\t<clear>: Clear m_offset_cache.\n\t<get_plain_source_lines>: Change parameters.\n\t<ensure>: New method\n\t<m_offset_cache>: New member.\n\t* source.c (forget_cached_source_info_for_objfile): Update.\n\t(info_source_command): Use g_source_cache.\n\t(find_source_lines, open_source_file_with_line_charpos): Remove.\n\t(print_source_lines_base, search_command_helper): Use g_source_cache.\n\t* source.h (open_source_file_with_line_charpos): Don't declare.\n\t* symtab.h (struct symtab) <nlines, line_charpos>: Remove.\n\t* tui/tui-source.c (tui_source_window::do_scroll_vertical):\n\tUse g_source_cache.",
    "tree": {
      "sha": "8ac25ea16ebbc5556d5f1e24940e729169d08bb8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8ac25ea16ebbc5556d5f1e24940e729169d08bb8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cb44333d99548bbbf7be06387a31877ee9322ab4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cb44333d99548bbbf7be06387a31877ee9322ab4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cb44333d99548bbbf7be06387a31877ee9322ab4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cb44333d99548bbbf7be06387a31877ee9322ab4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "872dceaaff9b54764b8f510b549497b9d904b136",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/872dceaaff9b54764b8f510b549497b9d904b136",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/872dceaaff9b54764b8f510b549497b9d904b136"
    }
  ],
  "stats": {
    "total": 420,
    "additions": 228,
    "deletions": 192
  },
  "files": [
    {
      "sha": "7f4c3ba5eda6f2915a1946fc47a164efa2b64282",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -1,3 +1,28 @@\n+2019-08-06  Tom Tromey  <tromey@adacore.com>\n+\n+\t* annotate.c (annotate_source_line): Use g_source_cache.\n+\t* source-cache.c (source_cache::get_plain_source_lines): Change\n+\tparameters.  Populate m_offset_cache.\n+\t(source_cache::ensure): New method.\n+\t(source_cache::get_line_charpos): New method.\n+\t(extract_lines): Move lower.  Change parameters.\n+\t(source_cache::get_source_lines): Move lower.\n+\t* source-cache.h (class source_cache): Update comment.\n+\t<get_line_charpos>: New method.\n+\t<get_source_lines>: Update comment.\n+\t<clear>: Clear m_offset_cache.\n+\t<get_plain_source_lines>: Change parameters.\n+\t<ensure>: New method\n+\t<m_offset_cache>: New member.\n+\t* source.c (forget_cached_source_info_for_objfile): Update.\n+\t(info_source_command): Use g_source_cache.\n+\t(find_source_lines, open_source_file_with_line_charpos): Remove.\n+\t(print_source_lines_base, search_command_helper): Use g_source_cache.\n+\t* source.h (open_source_file_with_line_charpos): Don't declare.\n+\t* symtab.h (struct symtab) <nlines, line_charpos>: Remove.\n+\t* tui/tui-source.c (tui_source_window::do_scroll_vertical):\n+\tUse g_source_cache.\n+\n 2019-08-06  Tom Tromey  <tromey@adacore.com>\n \n \t* source-cache.c (source_cache::get_plain_source_lines):"
    },
    {
      "sha": "3011b26eb58109cd461dbce6279ac55939fb0257",
      "filename": "gdb/annotate.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/annotate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/annotate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/annotate.c?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -28,6 +28,7 @@\n #include \"top.h\"\n #include \"source.h\"\n #include \"objfiles.h\"\n+#include \"source-cache.h\"\n \f\n \n /* Prototypes for local functions.  */\n@@ -440,15 +441,15 @@ annotate_source_line (struct symtab *s, int line, int mid_statement,\n {\n   if (annotation_level > 0)\n     {\n-      if (s->line_charpos == nullptr)\n-\topen_source_file_with_line_charpos (s);\n-      if (s->fullname == nullptr)\n+      const std::vector<off_t> *offsets;\n+      if (!g_source_cache.get_line_charpos (s, &offsets))\n \treturn;\n+\n       /* Don't index off the end of the line_charpos array.  */\n-      if (line > s->nlines)\n+      if (line > offsets->size ())\n \treturn;\n \n-      annotate_source (s->fullname, line, s->line_charpos[line - 1],\n+      annotate_source (s->fullname, line, (int) (*offsets)[line - 1],\n \t\t       mid_statement, get_objfile_arch (SYMTAB_OBJFILE (s)),\n \t\t       pc);\n     }"
    },
    {
      "sha": "9039f8fde2a75996d3d9b6642929132516cf1ee3",
      "filename": "gdb/source-cache.c",
      "status": "modified",
      "additions": 135,
      "deletions": 58,
      "changes": 193,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source-cache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source-cache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source-cache.c?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -23,6 +23,8 @@\n #include \"cli/cli-style.h\"\n #include \"symtab.h\"\n #include \"gdbsupport/selftest.h\"\n+#include \"objfiles.h\"\n+#include \"exec.h\"\n \n #ifdef HAVE_SOURCE_HIGHLIGHT\n /* If Gnulib redirects 'open' and 'close' to its replacements\n@@ -46,60 +48,50 @@ source_cache g_source_cache;\n \n /* See source-cache.h.  */\n \n-bool\n-source_cache::get_plain_source_lines (struct symtab *s, std::string *lines)\n+std::string\n+source_cache::get_plain_source_lines (struct symtab *s,\n+\t\t\t\t      const std::string &fullname)\n {\n-  scoped_fd desc (open_source_file_with_line_charpos (s));\n+  scoped_fd desc (open_source_file (s));\n   if (desc.get () < 0)\n-    return false;\n+    perror_with_name (symtab_to_filename_for_display (s));\n \n   struct stat st;\n-\n   if (fstat (desc.get (), &st) < 0)\n     perror_with_name (symtab_to_filename_for_display (s));\n \n-  /* We could cache this in line_charpos... */\n-  lines->resize (st.st_size);\n-  if (myread (desc.get (), &(*lines)[0], lines->size ()) < 0)\n+  std::string lines;\n+  lines.resize (st.st_size);\n+  if (myread (desc.get (), &lines[0], lines.size ()) < 0)\n     perror_with_name (symtab_to_filename_for_display (s));\n \n-  return true;\n-}\n+  time_t mtime = 0;\n+  if (SYMTAB_OBJFILE (s) != NULL && SYMTAB_OBJFILE (s)->obfd != NULL)\n+    mtime = SYMTAB_OBJFILE (s)->mtime;\n+  else if (exec_bfd)\n+    mtime = exec_bfd_mtime;\n \n-/* A helper function for get_plain_source_lines that extracts the\n-   desired source lines from TEXT, putting them into LINES_OUT.  The\n-   arguments are as for get_source_lines.  The return value is the\n-   desired lines.  */\n-static std::string\n-extract_lines (const std::string &text, int first_line, int last_line)\n-{\n-  int lineno = 1;\n-  std::string::size_type pos = 0;\n-  std::string::size_type first_pos = std::string::npos;\n+  if (mtime && mtime < st.st_mtime)\n+    warning (_(\"Source file is more recent than executable.\"));\n \n-  while (pos != std::string::npos && lineno <= last_line)\n+  std::vector<off_t> offsets;\n+  offsets.push_back (0);\n+  for (size_t offset = lines.find ('\\n');\n+       offset != std::string::npos;\n+       offset = lines.find ('\\n', offset))\n     {\n-      std::string::size_type new_pos = text.find ('\\n', pos);\n-\n-      if (lineno == first_line)\n-\tfirst_pos = pos;\n-\n-      pos = new_pos;\n-      if (lineno == last_line || pos == std::string::npos)\n-\t{\n-\t  if (first_pos == std::string::npos)\n-\t    return {};\n-\t  if (pos == std::string::npos)\n-\t    pos = text.size ();\n-\t  else\n-\t    ++pos;\n-\t  return text.substr (first_pos, pos - first_pos);\n-\t}\n-      ++lineno;\n-      ++pos;\n+      ++offset;\n+      /* A newline at the end does not start a new line.  It would\n+\t seem simpler to just strip the newline in this function, but\n+\t then \"list\" won't print the final newline.  */\n+      if (offset != lines.size ())\n+\toffsets.push_back (offset);\n     }\n \n-  return {};\n+  offsets.shrink_to_fit ();\n+  m_offset_cache.emplace (fullname, std::move (offsets));\n+\n+  return lines;\n }\n \n #ifdef HAVE_SOURCE_HIGHLIGHT\n@@ -161,26 +153,31 @@ get_language_name (enum language lang)\n /* See source-cache.h.  */\n \n bool\n-source_cache::get_source_lines (struct symtab *s, int first_line,\n-\t\t\t\tint last_line, std::string *lines)\n+source_cache::ensure (struct symtab *s)\n {\n-  if (first_line < 1 || last_line < 1 || first_line > last_line)\n-    return false;\n-\n   std::string fullname = symtab_to_fullname (s);\n \n-  for (const auto &item : m_source_map)\n+  size_t size = m_source_map.size ();\n+  for (int i = 0; i < size; ++i)\n     {\n-      if (item.fullname == fullname)\n+      if (m_source_map[i].fullname == fullname)\n \t{\n-\t  *lines = extract_lines (item.contents, first_line, last_line);\n+\t  /* This should always hold, because we create the file\n+\t     offsets when reading the file, and never free them\n+\t     without also clearing the contents cache.  */\n+\t  gdb_assert (m_offset_cache.find (fullname)\n+\t\t      != m_offset_cache.end ());\n+\t  /* Not strictly LRU, but at least ensure that the most\n+\t     recently used entry is always the last candidate for\n+\t     deletion.  Note that this property is relied upon by at\n+\t     least one caller.  */\n+\t  if (i != size - 1)\n+\t    std::swap (m_source_map[i], m_source_map[size - 1]);\n \t  return true;\n \t}\n     }\n \n-  std::string contents;\n-  if (!get_plain_source_lines (s, &contents))\n-    return false;\n+  std::string contents = get_plain_source_lines (s, fullname);\n \n #ifdef HAVE_SOURCE_HIGHLIGHT\n   if (source_styling && gdb_stdout->can_emit_style_escape ())\n@@ -215,22 +212,102 @@ source_cache::get_source_lines (struct symtab *s, int first_line,\n   if (m_source_map.size () > MAX_ENTRIES)\n     m_source_map.erase (m_source_map.begin ());\n \n-  *lines = extract_lines (m_source_map.back ().contents,\n-\t\t\t  first_line, last_line);\n   return true;\n }\n \n+/* See source-cache.h.  */\n+\n+bool\n+source_cache::get_line_charpos (struct symtab *s,\n+\t\t\t\tconst std::vector<off_t> **offsets)\n+{\n+  std::string fullname = symtab_to_fullname (s);\n+\n+  auto iter = m_offset_cache.find (fullname);\n+  if (iter == m_offset_cache.end ())\n+    {\n+      ensure (s);\n+      iter = m_offset_cache.find (fullname);\n+      /* cache_source_text ensured this was entered.  */\n+      gdb_assert (iter != m_offset_cache.end ());\n+    }\n+\n+  *offsets = &iter->second;\n+  return true;\n+}\n+\n+/* A helper function that extracts the desired source lines from TEXT,\n+   putting them into LINES_OUT.  The arguments are as for\n+   get_source_lines.  Returns true on success, false if the line\n+   numbers are invalid.  */\n+\n+static bool\n+extract_lines (const std::string &text, int first_line, int last_line,\n+\t       std::string *lines_out)\n+{\n+  int lineno = 1;\n+  std::string::size_type pos = 0;\n+  std::string::size_type first_pos = std::string::npos;\n+\n+  while (pos != std::string::npos && lineno <= last_line)\n+    {\n+      std::string::size_type new_pos = text.find ('\\n', pos);\n+\n+      if (lineno == first_line)\n+\tfirst_pos = pos;\n+\n+      pos = new_pos;\n+      if (lineno == last_line || pos == std::string::npos)\n+\t{\n+\t  /* A newline at the end does not start a new line.  */\n+\t  if (first_pos == std::string::npos\n+\t      || first_pos == text.size ())\n+\t    return false;\n+\t  if (pos == std::string::npos)\n+\t    pos = text.size ();\n+\t  else\n+\t    ++pos;\n+\t  *lines_out = text.substr (first_pos, pos - first_pos);\n+\t  return true;\n+\t}\n+      ++lineno;\n+      ++pos;\n+    }\n+\n+  return false;\n+}\n+\n+/* See source-cache.h.  */\n+\n+bool\n+source_cache::get_source_lines (struct symtab *s, int first_line,\n+\t\t\t\tint last_line, std::string *lines)\n+{\n+  if (first_line < 1 || last_line < 1 || first_line > last_line)\n+    return false;\n+\n+  if (!ensure (s))\n+    return false;\n+\n+  return extract_lines (m_source_map.back ().contents,\n+\t\t\tfirst_line, last_line, lines);\n+}\n+\n #if GDB_SELF_TEST\n namespace selftests\n {\n static void extract_lines_test ()\n {\n   std::string input_text = \"abc\\ndef\\nghi\\njkl\\n\";\n-\n-  SELF_CHECK (extract_lines (input_text, 1, 1) == \"abc\\n\");\n-  SELF_CHECK (extract_lines (input_text, 2, 1) == \"\");\n-  SELF_CHECK (extract_lines (input_text, 1, 2) == \"abc\\ndef\\n\");\n-  SELF_CHECK (extract_lines (\"abc\", 1, 1) == \"abc\");\n+  std::string result;\n+\n+  SELF_CHECK (extract_lines (input_text, 1, 1, &result)\n+\t      && result == \"abc\\n\");\n+  SELF_CHECK (!extract_lines (input_text, 2, 1, &result));\n+  SELF_CHECK (extract_lines (input_text, 1, 2, &result)\n+\t      && result == \"abc\\ndef\\n\");\n+  SELF_CHECK (extract_lines (\"abc\", 1, 1, &result)\n+\t      && result == \"abc\");\n }\n }\n #endif"
    },
    {
      "sha": "b6e8690d12bd28d7b529f5c23aa3115dc7b9a1aa",
      "filename": "gdb/source-cache.h",
      "status": "modified",
      "additions": 41,
      "deletions": 11,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source-cache.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source-cache.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source-cache.h?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -19,12 +19,20 @@\n #ifndef SOURCE_CACHE_H\n #define SOURCE_CACHE_H\n \n-/* This caches highlighted source text, keyed by the source file's\n-   full name.  A size-limited LRU cache is used.\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+/* This caches two things related to source files.\n+\n+   First, it caches highlighted source text, keyed by the source\n+   file's full name.  A size-limited LRU cache is used.\n \n    Highlighting depends on the GNU Source Highlight library.  When not\n-   available, this cache will fall back on reading plain text from the\n-   appropriate file.  */\n+   available or when highlighting fails for some reason, this cache\n+   will instead store the un-highlighted source text.\n+\n+   Second, this will cache the file offsets corresponding to the start\n+   of each line of a source file.  This cache is not size-limited.  */\n class source_cache\n {\n public:\n@@ -33,18 +41,31 @@ class source_cache\n   {\n   }\n \n+  /* This returns the vector of file offsets for the symtab S,\n+     computing the vector first if needed.\n+\n+     On failure, returns false.\n+\n+     On success, returns true and sets *OFFSETS.  This pointer is not\n+     guaranteed to remain valid across other calls to get_source_lines\n+     or get_line_charpos.  */\n+  bool get_line_charpos (struct symtab *s,\n+\t\t\t const std::vector<off_t> **offsets);\n+\n   /* Get the source text for the source file in symtab S.  FIRST_LINE\n      and LAST_LINE are the first and last lines to return; line\n-     numbers are 1-based.  If the file cannot be read, false is\n-     returned.  Otherwise, LINES_OUT is set to the desired text.  The\n-     returned text may include ANSI terminal escapes.  */\n+     numbers are 1-based.  If the file cannot be read, or if the line\n+     numbers are out of range, false is returned.  Otherwise,\n+     LINES_OUT is set to the desired text.  The returned text may\n+     include ANSI terminal escapes.  */\n   bool get_source_lines (struct symtab *s, int first_line,\n \t\t\t int last_line, std::string *lines_out);\n \n   /* Remove all the items from the source cache.  */\n   void clear ()\n   {\n     m_source_map.clear ();\n+    m_offset_cache.clear ();\n   }\n \n private:\n@@ -59,12 +80,21 @@ class source_cache\n   };\n \n   /* A helper function for get_source_lines reads a source file.\n-     Returns false on error.  If no error, the contents of the file\n-     are put into *LINES_OUT, and returns true.  */\n-  bool get_plain_source_lines (struct symtab *s, std::string *lines_out);\n+     Returns the contents of the file; or throws an exception on\n+     error.  This also updates m_offset_cache.  */\n+  std::string get_plain_source_lines (struct symtab *s,\n+\t\t\t\t      const std::string &fullname);\n \n-  /* The contents of the cache.  */\n+  /* A helper function that the data for the given symtab is entered\n+     into both caches.  Returns false on error.  */\n+  bool ensure (struct symtab *s);\n+\n+  /* The contents of the source text cache.  */\n   std::vector<source_text> m_source_map;\n+\n+  /* The file offset cache.  The key is the full name of the source\n+     file.  */\n+  std::unordered_map<std::string, std::vector<off_t>> m_offset_cache;\n };\n \n /* The global source cache.  */"
    },
    {
      "sha": "e0050f1fb8200850d984e2a805037ea0de6f1a51",
      "filename": "gdb/source.c",
      "status": "modified",
      "additions": 18,
      "deletions": 102,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.c?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -357,11 +357,6 @@ forget_cached_source_info_for_objfile (struct objfile *objfile)\n     {\n       for (symtab *s : compunit_filetabs (cu))\n \t{\n-\t  if (s->line_charpos != NULL)\n-\t    {\n-\t      xfree (s->line_charpos);\n-\t      s->line_charpos = NULL;\n-\t    }\n \t  if (s->fullname != NULL)\n \t    {\n \t      xfree (s->fullname);\n@@ -642,9 +637,10 @@ info_source_command (const char *ignore, int from_tty)\n     printf_filtered (_(\"Compilation directory is %s\\n\"), SYMTAB_DIRNAME (s));\n   if (s->fullname)\n     printf_filtered (_(\"Located in %s\\n\"), s->fullname);\n-  if (s->nlines)\n-    printf_filtered (_(\"Contains %d line%s.\\n\"), s->nlines,\n-\t\t     s->nlines == 1 ? \"\" : \"s\");\n+  const std::vector<off_t> *offsets;\n+  if (g_source_cache.get_line_charpos (s, &offsets))\n+    printf_filtered (_(\"Contains %d line%s.\\n\"), (int) offsets->size (),\n+\t\t     offsets->size () == 1 ? \"\" : \"s\");\n \n   printf_filtered (_(\"Source language is %s.\\n\"), language_str (s->language));\n   printf_filtered (_(\"Producer is %s.\\n\"),\n@@ -1123,92 +1119,6 @@ symtab_to_filename_for_display (struct symtab *symtab)\n   else\n     internal_error (__FILE__, __LINE__, _(\"invalid filename_display_string\"));\n }\n-\f\n-/* Create and initialize the table S->line_charpos that records\n-   the positions of the lines in the source file, which is assumed\n-   to be open on descriptor DESC.\n-   All set S->nlines to the number of such lines.  */\n-\n-static void\n-find_source_lines (struct symtab *s, int desc)\n-{\n-  struct stat st;\n-  char *p, *end;\n-  int nlines = 0;\n-  int lines_allocated = 1000;\n-  int *line_charpos;\n-  long mtime = 0;\n-  int size;\n-\n-  gdb_assert (s);\n-  line_charpos = XNEWVEC (int, lines_allocated);\n-  if (fstat (desc, &st) < 0)\n-    perror_with_name (symtab_to_filename_for_display (s));\n-\n-  if (SYMTAB_OBJFILE (s) != NULL && SYMTAB_OBJFILE (s)->obfd != NULL)\n-    mtime = SYMTAB_OBJFILE (s)->mtime;\n-  else if (exec_bfd)\n-    mtime = exec_bfd_mtime;\n-\n-  if (mtime && mtime < st.st_mtime)\n-    warning (_(\"Source file is more recent than executable.\"));\n-\n-  {\n-    /* st_size might be a large type, but we only support source files whose \n-       size fits in an int.  */\n-    size = (int) st.st_size;\n-\n-    /* Use the heap, not the stack, because this may be pretty large,\n-       and we may run into various kinds of limits on stack size.  */\n-    gdb::def_vector<char> data (size);\n-\n-    /* Reassign `size' to result of read for systems where \\r\\n -> \\n.  */\n-    size = myread (desc, data.data (), size);\n-    if (size < 0)\n-      perror_with_name (symtab_to_filename_for_display (s));\n-    end = data.data () + size;\n-    p = &data[0];\n-    line_charpos[0] = 0;\n-    nlines = 1;\n-    while (p != end)\n-      {\n-\tif (*p++ == '\\n'\n-\t/* A newline at the end does not start a new line.  */\n-\t    && p != end)\n-\t  {\n-\t    if (nlines == lines_allocated)\n-\t      {\n-\t\tlines_allocated *= 2;\n-\t\tline_charpos =\n-\t\t  (int *) xrealloc ((char *) line_charpos,\n-\t\t\t\t    sizeof (int) * lines_allocated);\n-\t      }\n-\t    line_charpos[nlines++] = p - data.data ();\n-\t  }\n-      }\n-  }\n-\n-  s->nlines = nlines;\n-  s->line_charpos =\n-    (int *) xrealloc ((char *) line_charpos, nlines * sizeof (int));\n-\n-}\n-\n-\f\n-\n-/* See source.h.  */\n-\n-scoped_fd\n-open_source_file_with_line_charpos (struct symtab *s)\n-{\n-  scoped_fd fd (open_source_file (s));\n-  if (fd.get () < 0)\n-    return fd;\n-\n-  if (s->line_charpos == nullptr)\n-    find_source_lines (s, fd.get ());\n-  return fd;\n-}\n \n \f\n \n@@ -1308,8 +1218,13 @@ print_source_lines_base (struct symtab *s, int line, int stopline,\n \n   std::string lines;\n   if (!g_source_cache.get_source_lines (s, line, stopline - 1, &lines))\n-    error (_(\"Line number %d out of range; %s has %d lines.\"),\n-\t   line, symtab_to_filename_for_display (s), s->nlines);\n+    {\n+      const std::vector<off_t> *offsets = nullptr;\n+      g_source_cache.get_line_charpos (s, &offsets);\n+      error (_(\"Line number %d out of range; %s has %d lines.\"),\n+\t     line, symtab_to_filename_for_display (s),\n+\t     offsets == nullptr ? 0 : (int) offsets->size ());\n+    }\n \n   const char *iter = lines.c_str ();\n   while (nlines-- > 0 && *iter != '\\0')\n@@ -1524,19 +1439,21 @@ search_command_helper (const char *regex, int from_tty, bool forward)\n   if (current_source_symtab == 0)\n     select_source_symtab (0);\n \n-  scoped_fd desc (open_source_file_with_line_charpos (current_source_symtab));\n+  scoped_fd desc (open_source_file (current_source_symtab));\n   if (desc.get () < 0)\n     perror_with_name (symtab_to_filename_for_display (current_source_symtab));\n \n   int line = (forward\n \t      ? last_line_listed + 1\n \t      : last_line_listed - 1);\n \n-  if (line < 1 || line > current_source_symtab->nlines)\n+  const std::vector<off_t> *offsets;\n+  if (line < 1\n+      || !g_source_cache.get_line_charpos (current_source_symtab, &offsets)\n+      || line > offsets->size ())\n     error (_(\"Expression not found\"));\n \n-  if (lseek (desc.get (), current_source_symtab->line_charpos[line - 1], 0)\n-      < 0)\n+  if (lseek (desc.get (), (*offsets)[line - 1], 0) < 0)\n     perror_with_name (symtab_to_filename_for_display (current_source_symtab));\n \n   gdb_file_up stream = desc.to_file (FDOPEN_MODE);\n@@ -1585,8 +1502,7 @@ search_command_helper (const char *regex, int from_tty, bool forward)\n \t  line--;\n \t  if (line < 1)\n \t    break;\n-\t  if (fseek (stream.get (),\n-\t\t     current_source_symtab->line_charpos[line - 1], 0) < 0)\n+\t  if (fseek (stream.get (), (*offsets)[line - 1], 0) < 0)\n \t    {\n \t      const char *filename\n \t\t= symtab_to_filename_for_display (current_source_symtab);"
    },
    {
      "sha": "84cc2fa9922b5b7c53ba66ae0be8bf94f2b2a5e7",
      "filename": "gdb/source.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/source.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.h?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -76,11 +76,6 @@ extern scoped_fd find_and_open_source (const char *filename,\n    negative number for error.  */\n extern scoped_fd open_source_file (struct symtab *s);\n \n-/* Open a source file given a symtab S (by calling open_source_file), then\n-   ensure the line_charpos data is initialised for symtab S before\n-   returning.  */\n-extern scoped_fd open_source_file_with_line_charpos (struct symtab *s);\n-\n extern gdb::unique_xmalloc_ptr<char> rewrite_source_path (const char *path);\n \n extern const char *symtab_to_fullname (struct symtab *s);"
    },
    {
      "sha": "f2d59a9f90bebaf12f4c9adee1b80359a8f8253a",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -1321,16 +1321,6 @@ struct symtab\n \n   const char *filename;\n \n-  /* Total number of lines found in source file.  */\n-\n-  int nlines;\n-\n-  /* line_charpos[N] is the position of the (N-1)th line of the\n-     source file.  \"position\" means something we can lseek() to; it\n-     is not guaranteed to be useful any other way.  */\n-\n-  int *line_charpos;\n-\n   /* Language of this source file.  */\n \n   enum language language;"
    },
    {
      "sha": "619d93745003a8548078850861259f2e6d725737",
      "filename": "gdb/tui/tui-source.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/tui/tui-source.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb44333d99548bbbf7be06387a31877ee9322ab4/gdb/tui/tui-source.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-source.c?ref=cb44333d99548bbbf7be06387a31877ee9322ab4",
      "patch": "@@ -251,7 +251,9 @@ tui_source_window::do_scroll_vertical (int num_to_scroll)\n       l.loa = LOA_LINE;\n       l.u.line_no = content[0].line_or_addr.u.line_no\n \t+ num_to_scroll;\n-      if (l.u.line_no > s->nlines)\n+      const std::vector<off_t> *offsets;\n+      if (g_source_cache.get_line_charpos (s, &offsets)\n+\t  && l.u.line_no > offsets->size ())\n \t/* line = s->nlines - win_info->content_size + 1; */\n \t/* elz: fix for dts 23398.  */\n \tl.u.line_no = content[0].line_or_addr.u.line_no;"
    }
  ]
}