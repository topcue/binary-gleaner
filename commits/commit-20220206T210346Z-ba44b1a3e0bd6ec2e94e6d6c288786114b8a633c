{
  "sha": "ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
  "node_id": "C_kwDOANOeidoAKGJhNDRiMWEzZTBiZDZlYzJlOTRlNmQ2YzI4ODc4NjExNGI4YTYzM2M",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-11-22T03:03:07Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2022-02-06T21:03:46Z"
    },
    "message": "gdb: remove SYMBOL_ACLASS_INDEX macro, add getter/setter\n\nAdd a getter and a setter for a symbol's aclass index.  Remove the\ncorresponding macro and adjust all callers.\n\nChange-Id: Ie8c8d732624cfadb714aba5ddafa3d29409b3d39",
    "tree": {
      "sha": "20520b6490fca5bfd178d09894485f3868bc552f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/20520b6490fca5bfd178d09894485f3868bc552f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "81e32b6a84c54031d31de6ebcf74a91b29d1498a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/81e32b6a84c54031d31de6ebcf74a91b29d1498a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/81e32b6a84c54031d31de6ebcf74a91b29d1498a"
    }
  ],
  "stats": {
    "total": 201,
    "additions": 105,
    "deletions": 96
  },
  "files": [
    {
      "sha": "d4c4226a8d2d43d421b236b13d8b016251dc7392",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -1575,7 +1575,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \tlookup_function_type (decode_function_type (cs, cs->c_type,\n \t\t\t\t\t\t    aux, objfile));\n \n-      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+      sym->set_aclass_index (LOC_BLOCK);\n       if (cs->c_sclass == C_STAT || cs->c_sclass == C_THUMBSTAT\n \t  || cs->c_sclass == C_THUMBSTATFUNC)\n \tadd_symbol_to_list (sym, get_file_symbols ());\n@@ -1592,14 +1592,14 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  break;\n \n \tcase C_AUTO:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_LOCAL;\n+\t  sym->set_aclass_index (LOC_LOCAL);\n \t  add_symbol_to_list (sym, get_local_symbols ());\n \t  break;\n \n \tcase C_THUMBEXT:\n \tcase C_THUMBEXTFUNC:\n \tcase C_EXT:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t  sym->set_aclass_index (LOC_STATIC);\n \t  SET_SYMBOL_VALUE_ADDRESS (sym,\n \t\t\t\t    (CORE_ADDR) cs->c_value\n \t\t\t\t    + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n@@ -1609,7 +1609,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \tcase C_THUMBSTAT:\n \tcase C_THUMBSTATFUNC:\n \tcase C_STAT:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t  sym->set_aclass_index (LOC_STATIC);\n \t  SET_SYMBOL_VALUE_ADDRESS (sym,\n \t\t\t\t    (CORE_ADDR) cs->c_value\n \t\t\t\t    + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n@@ -1629,7 +1629,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \tcase C_GLBLREG:\n #endif\n \tcase C_REG:\n-\t  SYMBOL_ACLASS_INDEX (sym) = coff_register_index;\n+\t  sym->set_aclass_index (coff_register_index);\n \t  SYMBOL_VALUE (sym) = cs->c_value;\n \t  add_symbol_to_list (sym, get_local_symbols ());\n \t  break;\n@@ -1639,20 +1639,20 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  break;\n \n \tcase C_ARG:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_ARG;\n+\t  sym->set_aclass_index (LOC_ARG);\n \t  SYMBOL_IS_ARGUMENT (sym) = 1;\n \t  add_symbol_to_list (sym, get_local_symbols ());\n \t  break;\n \n \tcase C_REGPARM:\n-\t  SYMBOL_ACLASS_INDEX (sym) = coff_register_index;\n+\t  sym->set_aclass_index (coff_register_index);\n \t  SYMBOL_IS_ARGUMENT (sym) = 1;\n \t  SYMBOL_VALUE (sym) = cs->c_value;\n \t  add_symbol_to_list (sym, get_local_symbols ());\n \t  break;\n \n \tcase C_TPDEF:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \n \t  /* If type has no name, give it one.  */\n@@ -1707,7 +1707,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \tcase C_STRTAG:\n \tcase C_UNTAG:\n \tcase C_ENTAG:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n \n \t  /* Some compilers try to be helpful by inventing \"fake\"\n@@ -2098,7 +2098,7 @@ coff_read_enum_type (int index, int length, int lastsym,\n \n \t  name = obstack_strdup (&objfile->objfile_obstack, name);\n \t  sym->set_linkage_name (name);\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t  sym->set_aclass_index (LOC_CONST);\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t  SYMBOL_VALUE (sym) = ms->c_value;\n \t  add_symbol_to_list (sym, symlist);"
    },
    {
      "sha": "dbafe75b831231890faf5a9ddf27bd80216811bd",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -330,7 +330,7 @@ set_symbol_address (struct objfile *of, struct symbol *sym, const char *name)\n   if (msym.minsym != NULL)\n     {\n       SET_SYMBOL_VALUE_ADDRESS (sym, BMSYMBOL_VALUE_ADDRESS (msym));\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+      sym->set_aclass_index (LOC_STATIC);\n       sym->set_section_index (msym.minsym->section_index ());\n     }\n }\n@@ -450,7 +450,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n \n       sym->set_language (language_c, &ccp->of->objfile_obstack);\n       sym->compute_and_set_names (name, false, ccp->of->per_bfd);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+      sym->set_aclass_index (LOC_CONST);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_TYPE (sym) = fip->ptype;\n       add_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n@@ -480,7 +480,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n       sym->set_language (language_c, &objfile->objfile_obstack);\n       sym->compute_and_set_names (name, false, objfile->per_bfd);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+      sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n \n       if (type != nullptr)\n \tSYMBOL_TYPE (sym) = type;\n@@ -491,11 +491,11 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n \t  case CTF_K_STRUCT:\n \t  case CTF_K_UNION:\n \t  case CTF_K_ENUM:\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t    sym->set_aclass_index (LOC_TYPEDEF);\n \t    SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n \t    break;\n \t  case CTF_K_FUNCTION:\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t    sym->set_aclass_index (LOC_STATIC);\n \t    set_symbol_address (objfile, sym, sym->linkage_name ());\n \t    break;\n \t  case CTF_K_CONST:\n@@ -505,7 +505,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n \t  case CTF_K_TYPEDEF:\n \t  case CTF_K_INTEGER:\n \t  case CTF_K_FLOAT:\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t    sym->set_aclass_index (LOC_TYPEDEF);\n \t    SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t    break;\n \t  case CTF_K_POINTER:\n@@ -1171,7 +1171,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n \tOBJSTAT (ccp->of, n_syms++);\n \tSYMBOL_TYPE (sym) = type;\n \tSYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n-\tSYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+\tsym->set_aclass_index (LOC_OPTIMIZED_OUT);\n \tsym->compute_and_set_names (name, false, ccp->of->per_bfd);\n \tadd_symbol_to_list (sym, ccp->builder->get_file_symbols ());\n \tbreak;\n@@ -1207,7 +1207,7 @@ add_stt_entries (struct ctf_context *ccp, int functions)\n       OBJSTAT (ccp->of, n_syms++);\n       SYMBOL_TYPE (sym) = type;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+      sym->set_aclass_index (LOC_STATIC);\n       sym->compute_and_set_names (tname, false, ccp->of->per_bfd);\n       add_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n       set_symbol_address (ccp->of, sym, tname);"
    },
    {
      "sha": "1155efb6df7408e4f6ddedea754eb9a49b2567dc",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -8917,7 +8917,7 @@ fixup_go_packaging (struct dwarf2_cu *cu)\n       /* This is not VAR_DOMAIN because we want a way to ensure a lookup of,\n \t e.g., \"main\" finds the \"main\" module and not C's main().  */\n       SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+      sym->set_aclass_index (LOC_TYPEDEF);\n       SYMBOL_TYPE (sym) = type;\n \n       add_symbol_to_list (sym, cu->get_builder ()->get_global_symbols ());\n@@ -16865,7 +16865,7 @@ mark_common_block_symbol_computed (struct symbol *sym,\n   gdb_assert (ptr - baton->data == baton->size);\n \n   SYMBOL_LOCATION_BATON (sym) = baton;\n-  SYMBOL_ACLASS_INDEX (sym) = dwarf2_locexpr_index;\n+  sym->set_aclass_index (dwarf2_locexpr_index);\n }\n \n /* Create appropriate locally-scoped variables for all the\n@@ -21601,7 +21601,7 @@ var_decode_location (struct attribute *attr, struct symbol *sym,\n      variable has been optimized away.  */\n   if (attr->form_is_block () && attr->as_block ()->size == 0)\n     {\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+      sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n       return;\n     }\n \n@@ -21632,7 +21632,7 @@ var_decode_location (struct attribute *attr, struct symbol *sym,\n \t    SET_SYMBOL_VALUE_ADDRESS\n \t      (sym, read_addr_index_from_leb128 (cu, block->data + 1,\n \t\t\t\t\t\t &dummy));\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t  sym->set_aclass_index (LOC_STATIC);\n \t  fixup_symbol_section (sym, objfile);\n \t  SET_SYMBOL_VALUE_ADDRESS\n \t    (sym,\n@@ -21718,7 +21718,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       /* Default assumptions.\n \t Use the passed type or decode it from the die.  */\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+      sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n       if (type != NULL)\n \tSYMBOL_TYPE (sym) = type;\n       else\n@@ -21760,18 +21760,18 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t      addr = attr->as_address ();\n \t      addr = gdbarch_adjust_dwarf2_addr (gdbarch, addr + baseaddr);\n \t      SET_SYMBOL_VALUE_ADDRESS (sym, addr);\n-\t      SYMBOL_ACLASS_INDEX (sym) = LOC_LABEL;\n+\t      sym->set_aclass_index (LOC_LABEL);\n \t    }\n \t  else\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+\t    sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n \t  SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_core_addr;\n \t  SYMBOL_DOMAIN (sym) = LABEL_DOMAIN;\n \t  add_symbol_to_list (sym, cu->list_in_scope);\n \t  break;\n \tcase DW_TAG_subprogram:\n \t  /* SYMBOL_BLOCK_VALUE (sym) will be filled in later by\n \t     finish_block.  */\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+\t  sym->set_aclass_index (LOC_BLOCK);\n \t  attr2 = dwarf2_attr (die, DW_AT_external, cu);\n \t  if ((attr2 != nullptr && attr2->as_boolean ())\n \t      || cu->per_cu->lang == language_ada\n@@ -21793,7 +21793,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \tcase DW_TAG_inlined_subroutine:\n \t  /* SYMBOL_BLOCK_VALUE (sym) will be filled in later by\n \t     finish_block.  */\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+\t  sym->set_aclass_index (LOC_BLOCK);\n \t  SYMBOL_INLINED (sym) = 1;\n \t  list_to_add = cu->list_in_scope;\n \t  break;\n@@ -21913,7 +21913,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t       ? cu->get_builder ()->get_global_symbols ()\n \t\t       : cu->list_in_scope);\n \n-\t\t  SYMBOL_ACLASS_INDEX (sym) = LOC_UNRESOLVED;\n+\t\t  sym->set_aclass_index (LOC_UNRESOLVED);\n \t\t}\n \t      else if (!die_is_declaration (die, cu))\n \t\t{\n@@ -21963,7 +21963,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \tcase DW_TAG_union_type:\n \tcase DW_TAG_set_type:\n \tcase DW_TAG_enumeration_type:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n \n \t  {\n@@ -22001,14 +22001,14 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  }\n \t  break;\n \tcase DW_TAG_typedef:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t  list_to_add = cu->list_in_scope;\n \t  break;\n \tcase DW_TAG_array_type:\n \tcase DW_TAG_base_type:\n \tcase DW_TAG_subrange_type:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t  list_to_add = cu->list_in_scope;\n \t  break;\n@@ -22031,16 +22031,16 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  break;\n \tcase DW_TAG_imported_declaration:\n \tcase DW_TAG_namespace:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  list_to_add = cu->get_builder ()->get_global_symbols ();\n \t  break;\n \tcase DW_TAG_module:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t  sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_DOMAIN (sym) = MODULE_DOMAIN;\n \t  list_to_add = cu->get_builder ()->get_global_symbols ();\n \t  break;\n \tcase DW_TAG_common_block:\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_COMMON_BLOCK;\n+\t  sym->set_aclass_index (LOC_COMMON_BLOCK);\n \t  SYMBOL_DOMAIN (sym) = COMMON_BLOCK_DOMAIN;\n \t  add_symbol_to_list (sym, cu->list_in_scope);\n \t  break;\n@@ -22238,17 +22238,17 @@ dwarf2_const_value (const struct attribute *attr, struct symbol *sym,\n   if (baton != NULL)\n     {\n       SYMBOL_LOCATION_BATON (sym) = baton;\n-      SYMBOL_ACLASS_INDEX (sym) = dwarf2_locexpr_index;\n+      sym->set_aclass_index (dwarf2_locexpr_index);\n     }\n   else if (bytes != NULL)\n      {\n       SYMBOL_VALUE_BYTES (sym) = bytes;\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST_BYTES;\n+      sym->set_aclass_index (LOC_CONST_BYTES);\n     }\n   else\n     {\n       SYMBOL_VALUE (sym) = value;\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+      sym->set_aclass_index (LOC_CONST);\n     }\n }\n \n@@ -24341,9 +24341,9 @@ dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,\n \tcomplaint (_(\"Location list used without \"\n \t\t     \"specifying the CU base address.\"));\n \n-      SYMBOL_ACLASS_INDEX (sym) = (is_block\n-\t\t\t\t   ? dwarf2_loclist_block_index\n-\t\t\t\t   : dwarf2_loclist_index);\n+      sym->set_aclass_index ((is_block\n+\t\t\t      ? dwarf2_loclist_block_index\n+\t\t\t      : dwarf2_loclist_index));\n       SYMBOL_LOCATION_BATON (sym) = baton;\n     }\n   else\n@@ -24373,9 +24373,9 @@ dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,\n \t  baton->size = 0;\n \t}\n \n-      SYMBOL_ACLASS_INDEX (sym) = (is_block\n-\t\t\t\t   ? dwarf2_locexpr_block_index\n-\t\t\t\t   : dwarf2_locexpr_index);\n+      sym->set_aclass_index ((is_block\n+\t\t\t      ? dwarf2_locexpr_block_index\n+\t\t\t      : dwarf2_locexpr_index));\n       SYMBOL_LOCATION_BATON (sym) = baton;\n     }\n }"
    },
    {
      "sha": "8e7cc46c4dcafaa87a492e338892d590c5061131",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -560,7 +560,7 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n \n       /* The name.  */\n       SYMBOL_DOMAIN (block_name) = VAR_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (block_name) = LOC_BLOCK;\n+      block_name->set_aclass_index (LOC_BLOCK);\n       symbol_set_symtab (block_name, filetab);\n       SYMBOL_TYPE (block_name) = lookup_function_type (block_type);\n       SYMBOL_BLOCK_VALUE (block_name) = new_block;"
    },
    {
      "sha": "aff6c21e2b62ff2966d80f358f122f42fbc37e7e",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -1002,7 +1002,7 @@ language_arch_info::type_and_symbol::alloc_type_symbol\n   symbol->set_section_index (0);\n   SYMBOL_TYPE (symbol) = type;\n   SYMBOL_DOMAIN (symbol) = VAR_DOMAIN;\n-  SYMBOL_ACLASS_INDEX (symbol) = LOC_TYPEDEF;\n+  symbol->set_aclass_index (LOC_TYPEDEF);\n   return symbol;\n }\n "
    },
    {
      "sha": "e0d108935e11b2ee588bf4f1bdb342bb75abd151",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -563,7 +563,7 @@ add_data_symbol (SYMR *sh, union aux_ext *ax, int bigend,\n \t\t struct objfile *objfile, const char *name)\n {\n   SYMBOL_DOMAIN (s) = VAR_DOMAIN;\n-  SYMBOL_ACLASS_INDEX (s) = aclass_index;\n+  s->set_aclass_index (aclass_index);\n   add_symbol (s, top_stack->cur_st, b);\n \n   /* Type could be missing if file is compiled without debugging info.  */\n@@ -681,19 +681,19 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t{\n \tcase scRegister:\n \t  /* Pass by value in register.  */\n-\t  SYMBOL_ACLASS_INDEX (s) = mdebug_register_index;\n+\t  s->set_aclass_index (mdebug_register_index);\n \t  break;\n \tcase scVar:\n \t  /* Pass by reference on stack.  */\n-\t  SYMBOL_ACLASS_INDEX (s) = LOC_REF_ARG;\n+\t  s->set_aclass_index (LOC_REF_ARG);\n \t  break;\n \tcase scVarRegister:\n \t  /* Pass by reference in register.  */\n-\t  SYMBOL_ACLASS_INDEX (s) = mdebug_regparm_index;\n+\t  s->set_aclass_index (mdebug_regparm_index);\n \t  break;\n \tdefault:\n \t  /* Pass by value on stack.  */\n-\t  SYMBOL_ACLASS_INDEX (s) = LOC_ARG;\n+\t  s->set_aclass_index (LOC_ARG);\n \t  break;\n \t}\n       SYMBOL_VALUE (s) = svalue;\n@@ -704,7 +704,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n     case stLabel:\t\t/* label, goes into current block.  */\n       s = new_symbol (name);\n       SYMBOL_DOMAIN (s) = VAR_DOMAIN;\t/* So that it can be used */\n-      SYMBOL_ACLASS_INDEX (s) = LOC_LABEL;\t/* but not misused.  */\n+      s->set_aclass_index (LOC_LABEL);\t/* but not misused.  */\n       SET_SYMBOL_VALUE_ADDRESS (s, (CORE_ADDR) sh->value);\n       SYMBOL_TYPE (s) = objfile_type (objfile)->builtin_int;\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n@@ -745,7 +745,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t}\n       s = new_symbol (name);\n       SYMBOL_DOMAIN (s) = VAR_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (s) = LOC_BLOCK;\n+      s->set_aclass_index (LOC_BLOCK);\n       /* Type of the return value.  */\n       if (SC_IS_UNDEF (sh->sc) || sh->sc == scNil)\n \tt = objfile_type (objfile)->builtin_int;\n@@ -1065,7 +1065,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t\tenum_sym->set_linkage_name\n \t\t  (obstack_strdup (&mdebugread_objfile->objfile_obstack,\n \t\t\t\t   f->name ()));\n-\t\tSYMBOL_ACLASS_INDEX (enum_sym) = LOC_CONST;\n+\t\tenum_sym->set_aclass_index (LOC_CONST);\n \t\tSYMBOL_TYPE (enum_sym) = t;\n \t\tSYMBOL_DOMAIN (enum_sym) = VAR_DOMAIN;\n \t\tSYMBOL_VALUE (enum_sym) = tsym.value;\n@@ -1098,7 +1098,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \n \ts = new_symbol (name);\n \tSYMBOL_DOMAIN (s) = STRUCT_DOMAIN;\n-\tSYMBOL_ACLASS_INDEX (s) = LOC_TYPEDEF;\n+\ts->set_aclass_index (LOC_TYPEDEF);\n \tSYMBOL_VALUE (s) = 0;\n \tSYMBOL_TYPE (s) = t;\n \tadd_symbol (s, top_stack->cur_st, top_stack->cur_block);\n@@ -1155,7 +1155,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t  /* Make up special symbol to contain procedure specific info.  */\n \t  s = new_symbol (MDEBUG_EFI_SYMBOL_NAME);\n \t  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;\n-\t  SYMBOL_ACLASS_INDEX (s) = LOC_CONST;\n+\t  s->set_aclass_index (LOC_CONST);\n \t  SYMBOL_TYPE (s) = objfile_type (mdebugread_objfile)->builtin_void;\n \t  e = OBSTACK_ZALLOC (&mdebugread_objfile->objfile_obstack,\n \t\t\t      mdebug_extra_func_info);\n@@ -1296,7 +1296,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \tbreak;\n       s = new_symbol (name);\n       SYMBOL_DOMAIN (s) = VAR_DOMAIN;\n-      SYMBOL_ACLASS_INDEX (s) = LOC_TYPEDEF;\n+      s->set_aclass_index (LOC_TYPEDEF);\n       SYMBOL_BLOCK_VALUE (s) = top_stack->cur_block;\n       SYMBOL_TYPE (s) = t;\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n@@ -3988,7 +3988,7 @@ mdebug_expand_psymtab (legacy_psymtab *pst, struct objfile *objfile)\n \t\t  struct symbol *s = new_symbol (MDEBUG_EFI_SYMBOL_NAME);\n \n \t\t  SYMBOL_DOMAIN (s) = LABEL_DOMAIN;\n-\t\t  SYMBOL_ACLASS_INDEX (s) = LOC_CONST;\n+\t\t  s->set_aclass_index (LOC_CONST);\n \t\t  SYMBOL_TYPE (s) = objfile_type (objfile)->builtin_void;\n \t\t  SYMBOL_VALUE_BYTES (s) = (gdb_byte *) e;\n \t\t  e->pdr.framereg = -1;"
    },
    {
      "sha": "21f824f6e73ce73c46c6395b0f1deaf2423f5493",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 34,
      "deletions": 34,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -425,7 +425,7 @@ patch_block_stabs (struct pending *symbols, struct pending_stabs *stabs,\n \t\t a N_GSYM stab for it, but no regular (C_EXT) symbol.  */\n \t      sym = new (&objfile->objfile_obstack) symbol;\n \t      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n-\t      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+\t      sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n \t      sym->set_linkage_name\n \t\t(obstack_strndup (&objfile->objfile_obstack, name, pp - name));\n \t      pp += 2;\n@@ -783,7 +783,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t (where type 6 is defined by \"blobs:t6=eblob1:0,blob2:1,;\").  */\n       if (*p != '=')\n \t{\n-\t  SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t  sym->set_aclass_index (LOC_CONST);\n \t  SYMBOL_TYPE (sym) = error_type (&p, objfile);\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t  add_symbol_to_list (sym, get_file_symbols ());\n@@ -806,7 +806,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n \t    SYMBOL_TYPE (sym) = dbl_type;\n \t    SYMBOL_VALUE_BYTES (sym) = dbl_valu;\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST_BYTES;\n+\t    sym->set_aclass_index (LOC_CONST_BYTES);\n \t  }\n \t  break;\n \tcase 'i':\n@@ -820,15 +820,15 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n \t    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_long;\n \t    SYMBOL_VALUE (sym) = atoi (p);\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t    sym->set_aclass_index (LOC_CONST);\n \t  }\n \t  break;\n \n \tcase 'c':\n \t  {\n \t    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_char;\n \t    SYMBOL_VALUE (sym) = atoi (p);\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t    sym->set_aclass_index (LOC_CONST);\n \t  }\n \t  break;\n \n@@ -842,7 +842,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n \t    if (quote != '\\'' && quote != '\"')\n \t      {\n-\t\tSYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t\tsym->set_aclass_index (LOC_CONST);\n \t\tSYMBOL_TYPE (sym) = error_type (&p, objfile);\n \t\tSYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t\tadd_symbol_to_list (sym, get_file_symbols ());\n@@ -867,7 +867,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t      }\n \t    if (*p != quote)\n \t      {\n-\t\tSYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t\tsym->set_aclass_index (LOC_CONST);\n \t\tSYMBOL_TYPE (sym) = error_type (&p, objfile);\n \t\tSYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t\tadd_symbol_to_list (sym, get_file_symbols ());\n@@ -889,7 +889,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t    p++;\n \n \t    SYMBOL_VALUE_BYTES (sym) = string_value;\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST_BYTES;\n+\t    sym->set_aclass_index (LOC_CONST_BYTES);\n \t  }\n \t  break;\n \n@@ -899,7 +899,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t     e.g. \"b:c=e6,0\" for \"const b = blob1\"\n \t     (where type 6 is defined by \"blobs:t6=eblob1:0,blob2:1,;\").  */\n \t  {\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t    sym->set_aclass_index (LOC_CONST);\n \t    SYMBOL_TYPE (sym) = read_type (&p, objfile);\n \n \t    if (*p != ',')\n@@ -920,7 +920,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  break;\n \tdefault:\n \t  {\n-\t    SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+\t    sym->set_aclass_index (LOC_CONST);\n \t    SYMBOL_TYPE (sym) = error_type (&p, objfile);\n \t  }\n \t}\n@@ -931,7 +931,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'C':\n       /* The name of a caught exception.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_LABEL;\n+      sym->set_aclass_index (LOC_LABEL);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       add_symbol_to_list (sym, get_local_symbols ());\n@@ -940,7 +940,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'f':\n       /* A static function definition.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+      sym->set_aclass_index (LOC_BLOCK);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_file_symbols ());\n       /* fall into process_function_types.  */\n@@ -1012,7 +1012,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'F':\n       /* A global function definition.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+      sym->set_aclass_index (LOC_BLOCK);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_global_symbols ());\n       goto process_function_types;\n@@ -1023,7 +1023,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t corresponding linker definition to find the value.\n \t These definitions appear at the end of the namelist.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+      sym->set_aclass_index (LOC_STATIC);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       /* Don't add symbol references to global_sym_chain.\n \t Symbol references don't have valid names and wont't match up with\n@@ -1044,7 +1044,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 's':\n     case 'l':\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_LOCAL;\n+      sym->set_aclass_index (LOC_LOCAL);\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_local_symbols ());\n@@ -1064,7 +1064,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       else\n \tSYMBOL_TYPE (sym) = read_type (&p, objfile);\n \n-      SYMBOL_ACLASS_INDEX (sym) = LOC_ARG;\n+      sym->set_aclass_index (LOC_ARG);\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_IS_ARGUMENT (sym) = 1;\n@@ -1113,7 +1113,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'R':\n       /* Parameter which is in a register.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = stab_register_index;\n+      sym->set_aclass_index (stab_register_index);\n       SYMBOL_IS_ARGUMENT (sym) = 1;\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n@@ -1123,7 +1123,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'r':\n       /* Register variable (either global or local).  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = stab_register_index;\n+      sym->set_aclass_index (stab_register_index);\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       if (within_function)\n@@ -1160,7 +1160,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t\t  && strcmp (prev_sym->linkage_name (),\n \t\t\t     sym->linkage_name ()) == 0)\n \t\t{\n-\t\t  SYMBOL_ACLASS_INDEX (prev_sym) = stab_register_index;\n+\t\t  prev_sym->set_aclass_index (stab_register_index);\n \t\t  /* Use the type from the LOC_REGISTER; that is the type\n \t\t     that is actually in that register.  */\n \t\t  SYMBOL_TYPE (prev_sym) = SYMBOL_TYPE (sym);\n@@ -1178,7 +1178,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'S':\n       /* Static symbol at top level of file.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+      sym->set_aclass_index (LOC_STATIC);\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_file_symbols ());\n@@ -1209,7 +1209,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       if (nameless)\n \treturn NULL;\n \n-      SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+      sym->set_aclass_index (LOC_TYPEDEF);\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       /* C++ vagaries: we may have a type which is derived from\n@@ -1286,7 +1286,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  struct symbol *struct_sym = new (&objfile->objfile_obstack) symbol;\n \n \t  *struct_sym = *sym;\n-\t  SYMBOL_ACLASS_INDEX (struct_sym) = LOC_TYPEDEF;\n+\t  struct_sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_VALUE (struct_sym) = valu;\n \t  SYMBOL_DOMAIN (struct_sym) = STRUCT_DOMAIN;\n \t  if (SYMBOL_TYPE (sym)->name () == 0)\n@@ -1313,7 +1313,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       if (nameless)\n \treturn NULL;\n \n-      SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+      sym->set_aclass_index (LOC_TYPEDEF);\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n       if (SYMBOL_TYPE (sym)->name () == 0)\n@@ -1328,7 +1328,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  struct symbol *typedef_sym = new (&objfile->objfile_obstack) symbol;\n \n \t  *typedef_sym = *sym;\n-\t  SYMBOL_ACLASS_INDEX (typedef_sym) = LOC_TYPEDEF;\n+\t  typedef_sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_VALUE (typedef_sym) = valu;\n \t  SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;\n \t  if (SYMBOL_TYPE (sym)->name () == 0)\n@@ -1342,7 +1342,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'V':\n       /* Static symbol of local scope.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+      sym->set_aclass_index (LOC_STATIC);\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_local_symbols ());\n@@ -1351,7 +1351,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'v':\n       /* Reference parameter */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_REF_ARG;\n+      sym->set_aclass_index (LOC_REF_ARG);\n       SYMBOL_IS_ARGUMENT (sym) = 1;\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n@@ -1361,7 +1361,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n     case 'a':\n       /* Reference parameter which is in a register.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = stab_regparm_index;\n+      sym->set_aclass_index (stab_regparm_index);\n       SYMBOL_IS_ARGUMENT (sym) = 1;\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n@@ -1374,15 +1374,15 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t that Pascal uses it too, but when I tried it Pascal used\n \t \"x:3\" (local symbol) instead.  */\n       SYMBOL_TYPE (sym) = read_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_LOCAL;\n+      sym->set_aclass_index (LOC_LOCAL);\n       SYMBOL_VALUE (sym) = valu;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_local_symbols ());\n       break;\n \n     default:\n       SYMBOL_TYPE (sym) = error_type (&p, objfile);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+      sym->set_aclass_index (LOC_CONST);\n       SYMBOL_VALUE (sym) = 0;\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       add_symbol_to_list (sym, get_file_symbols ());\n@@ -1399,11 +1399,11 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       /* We have to convert LOC_REGISTER to LOC_REGPARM_ADDR (for\n \t variables passed in a register).  */\n       if (SYMBOL_CLASS (sym) == LOC_REGISTER)\n-\tSYMBOL_ACLASS_INDEX (sym) = LOC_REGPARM_ADDR;\n+\tsym->set_aclass_index (LOC_REGPARM_ADDR);\n       /* Likewise for converting LOC_ARG to LOC_REF_ARG (for the 7th\n \t and subsequent arguments on SPARC, for example).  */\n       else if (SYMBOL_CLASS (sym) == LOC_ARG)\n-\tSYMBOL_ACLASS_INDEX (sym) = LOC_REF_ARG;\n+\tsym->set_aclass_index (LOC_REF_ARG);\n     }\n \n   return sym;\n@@ -3592,7 +3592,7 @@ read_enum_type (const char **pp, struct type *type,\n       sym->set_linkage_name (name);\n       sym->set_language (get_current_subfile ()->language,\n \t\t\t &objfile->objfile_obstack);\n-      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+      sym->set_aclass_index (LOC_CONST);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_VALUE (sym) = n;\n       if (n < 0)\n@@ -4260,7 +4260,7 @@ common_block_end (struct objfile *objfile)\n   sym = new (&objfile->objfile_obstack) symbol;\n   /* Note: common_block_name already saved on objfile_obstack.  */\n   sym->set_linkage_name (common_block_name);\n-  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+  sym->set_aclass_index (LOC_BLOCK);\n \n   /* Now we copy all the symbols which have been defined since the BCOMM.  */\n \n@@ -4628,7 +4628,7 @@ scan_file_globals (struct objfile *objfile)\n \n \t  /* Complain about unresolved common block symbols.  */\n \t  if (SYMBOL_CLASS (prev) == LOC_STATIC)\n-\t    SYMBOL_ACLASS_INDEX (prev) = LOC_UNRESOLVED;\n+\t    prev->set_aclass_index (LOC_UNRESOLVED);\n \t  else\n \t    complaint (_(\"%s: common block `%s' from \"\n \t\t\t \"global_sym_chain unresolved\"),"
    },
    {
      "sha": "aa380aa7be2ec71bfdeca0a1938c103d9df79e3a",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 13,
      "deletions": 4,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -1112,7 +1112,7 @@ struct symbol : public general_symbol_info, public allocate_on_obstack\n   symbol ()\n     /* Class-initialization of bitfields is only allowed in C++20.  */\n     : domain (UNDEF_DOMAIN),\n-      aclass_index (0),\n+      m_aclass_index (0),\n       is_objfile_owned (1),\n       is_argument (0),\n       is_inlined (0),\n@@ -1136,6 +1136,16 @@ struct symbol : public general_symbol_info, public allocate_on_obstack\n   symbol (const symbol &) = default;\n   symbol &operator= (const symbol &) = default;\n \n+  unsigned int aclass_index () const\n+  {\n+    return m_aclass_index;\n+  }\n+\n+  void set_aclass_index (unsigned int aclass_index)\n+  {\n+    m_aclass_index = aclass_index;\n+  }\n+\n   /* Data type of value */\n \n   struct type *type = nullptr;\n@@ -1162,7 +1172,7 @@ struct symbol : public general_symbol_info, public allocate_on_obstack\n      table.  The actual enum address_class value is stored there,\n      alongside any per-class ops vectors.  */\n \n-  unsigned int aclass_index : SYMBOL_ACLASS_BITS;\n+  unsigned int m_aclass_index : SYMBOL_ACLASS_BITS;\n \n   /* If non-zero then symbol is objfile-owned, use owner.symtab.\n        Otherwise symbol is arch-owned, use owner.arch.  */\n@@ -1241,8 +1251,7 @@ extern const struct symbol_impl *symbol_impls;\n    \"private\".  */\n \n #define SYMBOL_DOMAIN(symbol)\t(symbol)->domain\n-#define SYMBOL_IMPL(symbol)\t\t(symbol_impls[(symbol)->aclass_index])\n-#define SYMBOL_ACLASS_INDEX(symbol)\t(symbol)->aclass_index\n+#define SYMBOL_IMPL(symbol)\t\t(symbol_impls[(symbol)->aclass_index ()])\n #define SYMBOL_CLASS(symbol)\t\t(SYMBOL_IMPL (symbol).aclass)\n #define SYMBOL_OBJFILE_OWNED(symbol)\t((symbol)->is_objfile_owned)\n #define SYMBOL_IS_ARGUMENT(symbol)\t(symbol)->is_argument"
    },
    {
      "sha": "6458e9f52d0f3d280410c6a510897af0ccbf3f81",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=ba44b1a3e0bd6ec2e94e6d6c288786114b8a633c",
      "patch": "@@ -1574,7 +1574,7 @@ process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)\n       sym->set_linkage_name (SYMNAME_ALLOC (name, symname_alloced));\n       SYMBOL_TYPE (sym) = objfile_type (objfile)->nodebug_text_symbol;\n \n-      SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n+      sym->set_aclass_index (LOC_BLOCK);\n       sym2 = new (&objfile->objfile_obstack) symbol (*sym);\n \n       if (cs->c_sclass == C_EXT || C_WEAKEXT)"
    }
  ]
}