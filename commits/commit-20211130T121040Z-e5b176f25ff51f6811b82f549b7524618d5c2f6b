{
  "sha": "e5b176f25ff51f6811b82f549b7524618d5c2f6b",
  "node_id": "C_kwDOANOeidoAKGU1YjE3NmYyNWZmNTFmNjgxMWI4MmY1NDliNzUyNDYxOGQ1YzJmNmI",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-08-31T13:04:11Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-30T12:10:40Z"
    },
    "message": "gdb: make packet_command function available outside remote.c\n\nIn a later commit I will add a Python API to access the 'maint packet'\nfunctionality, that is, sending a user specified packet to the target.\n\nTo make implementing this easier, this commit refactors how this\ncommand is currently implemented so that the packet_command function\nis now global.\n\nThe new global send_remote_packet function takes an object that is an\nimplementation of an abstract interface.  Two functions within this\ninterface are then called, one just before a packet is sent to the\nremote target, and one when the reply has been received from the\nremote target.  Using an interface object in this way allows (1) for\nthe error checking to be done before the first callback is made, this\nmeans we only print out what packet it being sent once we know we are\ngoing to actually send it, and (2) we don't need to make a copy of the\nreply if all we want to do is print it.\n\nOne user visible changes after this commit are the error\nmessages, which I've changed to be less 'maint packet' command\nfocused, this will make them (I hope) better for when\nsend_remote_packet can be called from Python code.\n\nSo:      \"command can only be used with remote target\"\nBecomes: \"packets can only be sent to a remote target\"\n\nAnd:     \"remote-packet command requires packet text as argument\"\nBecomes: \"a remote packet must not be empty\"\n\nAdditionally, in this commit, I've added support for packet replies\nthat contain binary data.  Before this commit, the code that printed\nthe reply treated the reply as a C string, it assumed that the string\nonly contained printable characters, and had a null character only at\nthe end.\n\nOne way to show the problem with this is if we try to read the auxv\ndata from a remote target, the auxv data is binary, so, before this\ncommit:\n\n  (gdb) target remote :54321\n  ...\n  (gdb) maint packet qXfer:auxv:read::0,1000\n  sending: \"qXfer:auxv:read::0,1000\"\n  received: \"l!\"\n  (gdb)\n\nAnd after this commit:\n\n  (gdb) target remote :54321\n  ...\n  (gdb) maint packet qXfer:auxv:read::0,1000\n  sending: \"qXfer:auxv:read::0,1000\"\n  received: \"l!\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\xfc\\xf7\\xff\\x7f\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xf>\n  (gdb)\n\nThe binary contents of the reply are now printed as escaped hex.",
    "tree": {
      "sha": "2f8edc639e385d0099180fd0a76f300cc25126d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2f8edc639e385d0099180fd0a76f300cc25126d6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e5b176f25ff51f6811b82f549b7524618d5c2f6b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e5b176f25ff51f6811b82f549b7524618d5c2f6b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e5b176f25ff51f6811b82f549b7524618d5c2f6b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e5b176f25ff51f6811b82f549b7524618d5c2f6b/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "0e3b7c25eea80717638617ebafac611ed970def8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0e3b7c25eea80717638617ebafac611ed970def8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0e3b7c25eea80717638617ebafac611ed970def8"
    }
  ],
  "stats": {
    "total": 154,
    "additions": 119,
    "deletions": 35
  },
  "files": [
    {
      "sha": "09c5169e4ed36eccce449692c34ad490bd9c1abf",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=e5b176f25ff51f6811b82f549b7524618d5c2f6b",
      "patch": "@@ -39,6 +39,14 @@ set logging enabled on|off\n show logging enabled\n   These commands set or show whether logging is enabled or disabled.\n \n+* Changed commands\n+\n+maint packet\n+  This command can now print a reply, if the reply includes\n+  non-printable characters.  Any non-printable characters are printed\n+  as escaped hex, e.g. \\x?? where '??' is replaces with the value of\n+  the non-printable character.\n+\n * Python API\n \n   ** New function gdb.add_history(), which takes a gdb.Value object"
    },
    {
      "sha": "738f2e4c0c7eefd1ef85f2c8fdeef4f3e992d9d5",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=e5b176f25ff51f6811b82f549b7524618d5c2f6b",
      "patch": "@@ -39286,6 +39286,9 @@ displays the response packet.  @value{GDBN} supplies the initial\n @samp{$} character, the terminating @samp{#} character, and the\n checksum.\n \n+Any non-printable characters in the reply are printed as escaped hex,\n+e.g. @samp{\\x00}, @samp{\\x01}, etc.\n+\n @kindex maint print architecture\n @item maint print architecture @r{[}@var{file}@r{]}\n Print the entire architecture configuration.  The optional argument"
    },
    {
      "sha": "b4269809b4ed6deca528a7c5f7683644b8815a2e",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 73,
      "deletions": 35,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=e5b176f25ff51f6811b82f549b7524618d5c2f6b",
      "patch": "@@ -956,8 +956,6 @@ class remote_target : public process_stratum_target\n \n   bool vcont_r_supported ();\n \n-  void packet_command (const char *args, int from_tty);\n-\n private: /* data fields */\n \n   /* The remote state.  Don't reference this directly.  Use the\n@@ -1030,8 +1028,6 @@ static int hexnumnstr (char *, ULONGEST, int);\n \n static CORE_ADDR remote_address_masked (CORE_ADDR);\n \n-static void print_packet (const char *);\n-\n static int stub_unpack_int (const char *buff, int fieldlength);\n \n struct packet_config;\n@@ -9495,17 +9491,6 @@ escape_buffer (const char *buf, int n)\n   return std::move (stb.string ());\n }\n \n-/* Display a null-terminated packet on stdout, for debugging, using C\n-   string notation.  */\n-\n-static void\n-print_packet (const char *buf)\n-{\n-  puts_filtered (\"\\\"\");\n-  fputstr_filtered (buf, '\"', gdb_stdout);\n-  puts_filtered (\"\\\"\");\n-}\n-\n int\n remote_target::putpkt (const char *buf)\n {\n@@ -11592,34 +11577,87 @@ remote_target::memory_map ()\n   return result;\n }\n \n-static void\n-packet_command (const char *args, int from_tty)\n+/* Set of callbacks used to implement the 'maint packet' command.  */\n+\n+struct cli_packet_command_callbacks : public send_remote_packet_callbacks\n {\n-  remote_target *remote = get_current_remote_target ();\n+  /* Called before the packet is sent.  BUF is the packet content before\n+     the protocol specific prefix, suffix, and escaping is added.  */\n \n-  if (remote == nullptr)\n-    error (_(\"command can only be used with remote target\"));\n+  void sending (gdb::array_view<const char> &buf) override\n+  {\n+    puts_filtered (\"sending: \");\n+    print_packet (buf);\n+    puts_filtered (\"\\n\");\n+  }\n \n-  remote->packet_command (args, from_tty);\n-}\n+  /* Called with BUF, the reply from the remote target.  */\n+\n+  void received (gdb::array_view<const char> &buf) override\n+  {\n+    puts_filtered (\"received: \\\"\");\n+    print_packet (buf);\n+    puts_filtered (\"\\\"\\n\");\n+  }\n+\n+private:\n+\n+  /* Print BUF o gdb_stdout.  Any non-printable bytes in BUF are printed as\n+     '\\x??' with '??' replaced by the hexadecimal value of the byte.  */\n+\n+  static void\n+  print_packet (gdb::array_view<const char> &buf)\n+  {\n+    string_file stb;\n+\n+    for (int i = 0; i < buf.size (); ++i)\n+      {\n+\tgdb_byte c = buf[i];\n+\tif (isprint (c))\n+\t  fputc_unfiltered (c, &stb);\n+\telse\n+\t  fprintf_unfiltered (&stb, \"\\\\x%02x\", (unsigned char) c);\n+      }\n+\n+    puts_filtered (stb.string ().c_str ());\n+  }\n+};\n+\n+/* See remote.h.  */\n \n void\n-remote_target::packet_command (const char *args, int from_tty)\n+send_remote_packet (gdb::array_view<const char> &buf,\n+\t\t    send_remote_packet_callbacks *callbacks)\n {\n-  if (!args)\n-    error (_(\"remote-packet command requires packet text as argument\"));\n+  if (buf.size () == 0 || buf.data ()[0] == '\\0')\n+    error (_(\"a remote packet must not be empty\"));\n \n-  puts_filtered (\"sending: \");\n-  print_packet (args);\n-  puts_filtered (\"\\n\");\n-  putpkt (args);\n+  remote_target *remote = get_current_remote_target ();\n+  if (remote == nullptr)\n+    error (_(\"packets can only be sent to a remote target\"));\n \n-  remote_state *rs = get_remote_state ();\n+  callbacks->sending (buf);\n \n-  getpkt (&rs->buf, 0);\n-  puts_filtered (\"received: \");\n-  print_packet (rs->buf.data ());\n-  puts_filtered (\"\\n\");\n+  remote->putpkt_binary (buf.data (), buf.size ());\n+  remote_state *rs = remote->get_remote_state ();\n+  int bytes = remote->getpkt_sane (&rs->buf, 0);\n+\n+  if (bytes < 0)\n+    error (_(\"error while fetching packet from remote target\"));\n+\n+  gdb::array_view<const char> view (&rs->buf[0], bytes);\n+  callbacks->received (view);\n+}\n+\n+/* Entry point for the 'maint packet' command.  */\n+\n+static void\n+cli_packet_command (const char *args, int from_tty)\n+{\n+  cli_packet_command_callbacks cb;\n+  gdb::array_view<const char> view\n+    = gdb::make_array_view (args, args == nullptr ? 0 : strlen (args));\n+  send_remote_packet (view, &cb);\n }\n \n #if 0\n@@ -14890,7 +14928,7 @@ Argument is a single section name (default: all loaded sections).\\n\\\n To compare only read-only loaded sections, specify the -r option.\"),\n \t   &cmdlist);\n \n-  add_cmd (\"packet\", class_maintenance, packet_command, _(\"\\\n+  add_cmd (\"packet\", class_maintenance, cli_packet_command, _(\"\\\n Send an arbitrary packet to a remote target.\\n\\\n    maintenance packet TEXT\\n\\\n If GDB is talking to an inferior via the GDB serial protocol, then\\n\\"
    },
    {
      "sha": "0178294ab1d6fc95a49bc4255eb4efc9cf0b2a12",
      "filename": "gdb/remote.h",
      "status": "modified",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/remote.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e5b176f25ff51f6811b82f549b7524618d5c2f6b/gdb/remote.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.h?ref=e5b176f25ff51f6811b82f549b7524618d5c2f6b",
      "patch": "@@ -78,4 +78,39 @@ extern int remote_register_number_and_offset (struct gdbarch *gdbarch,\n extern void remote_notif_get_pending_events (remote_target *remote,\n \t\t\t\t\t     struct notif_client *np);\n extern bool remote_target_is_non_stop_p (remote_target *t);\n+\n+/* An abstract class that represents the set of callbacks that are made\n+   from the send_remote_packet function (declared below).  */\n+\n+struct send_remote_packet_callbacks\n+{\n+  /* The SENDING callback is called once send_remote_packet has performed\n+     its error checking and setup, just before the packet is sent to the\n+     remote target.  BUF is the content of the packet that will be sent\n+     (before any of the protocol specific prefix, suffix, or escaping is\n+     applied).  */\n+\n+  virtual void sending (gdb::array_view<const char> &buf) = 0;\n+\n+  /* The RECEIVED callback is called once a reply has been received from\n+     the remote target.  The content of the reply is in BUF which can't be\n+     modified, and which is not guaranteed to remain valid after the\n+     RECEIVED call has returned.  If you need to preserve the contents of\n+     BUF then a copy should be taken.  */\n+\n+  virtual void received (gdb::array_view<const char> &buf) = 0;\n+};\n+\n+/* Send BUF to the current remote target.  If BUF points to an empty\n+   string, either zero length, or the first character is the null\n+   character, then an error is thrown.  If the current target is not a\n+   remote target then an error is thrown.\n+\n+   Calls CALLBACKS->sending() just before the packet is sent to the remote\n+   target, and calls CALLBACKS->received() with the reply once this is\n+   received from the remote target.  */\n+\n+extern void send_remote_packet (gdb::array_view<const char> &buf,\n+\t\t\t\tsend_remote_packet_callbacks *callbacks);\n+\n #endif"
    }
  ]
}