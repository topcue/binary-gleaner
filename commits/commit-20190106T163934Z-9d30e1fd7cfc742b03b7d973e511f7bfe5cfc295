{
  "sha": "9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWQzMGUxZmQ3Y2ZjNzQyYjAzYjdkOTczZTUxMWY3YmZlNWNmYzI5NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-03T02:22:44Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-06T16:39:34Z"
    },
    "message": "Remove remaining cleanups from c-exp.y\n\nThis removes the remaining cleanups from c-exp.y by moving some\nglobals into c_parse_state, and changing expansion_obstack to be an\nauto_obstack.\n\ngdb/ChangeLog\n2019-01-06  Tom Tromey  <tom@tromey.com>\n\n\t* c-exp.y (struct c_parse_state) <macro_original_text,\n\texpansion_obstack>: New member.\n\t(macro_original_text, expansion_obstack): Remove globals.\n\t(scan_macro_expansion, scanning_macro_expansion)\n\t(finished_macro_expansion): Update.\n\t(scan_macro_cleanup): Remove.\n\t(yylex, c_parse): Update.",
    "tree": {
      "sha": "4de336eda1ecf3edf3648abd361b357d2fa65525",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4de336eda1ecf3edf3648abd361b357d2fa65525"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c65bac3846567a8068fe4aa5cfa79da5b193a1af",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c65bac3846567a8068fe4aa5cfa79da5b193a1af",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c65bac3846567a8068fe4aa5cfa79da5b193a1af"
    }
  ],
  "stats": {
    "total": 103,
    "additions": 46,
    "deletions": 57
  },
  "files": [
    {
      "sha": "8230afc88181b0ecad9465c756b3c4478744e16f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295",
      "patch": "@@ -1,3 +1,13 @@\n+2019-01-06  Tom Tromey  <tom@tromey.com>\n+\n+\t* c-exp.y (struct c_parse_state) <macro_original_text,\n+\texpansion_obstack>: New member.\n+\t(macro_original_text, expansion_obstack): Remove globals.\n+\t(scan_macro_expansion, scanning_macro_expansion)\n+\t(finished_macro_expansion): Update.\n+\t(scan_macro_cleanup): Remove.\n+\t(yylex, c_parse): Update.\n+\n 2019-01-06  Tom Tromey  <tom@tromey.com>\n \n \t* c-exp.y (struct c_parse_state) <strings>: New member."
    },
    {
      "sha": "155fe09f37a7dda191ee03ea2912b755f919541d",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 36,
      "deletions": 57,
      "changes": 93,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=9d30e1fd7cfc742b03b7d973e511f7bfe5cfc295",
      "patch": "@@ -77,6 +77,33 @@ struct c_parse_state\n \n   /* Storage for some strings allocated during the parse.  */\n   std::vector<gdb::unique_xmalloc_ptr<char>> strings;\n+\n+  /* When we find that lexptr (the global var defined in parse.c) is\n+     pointing at a macro invocation, we expand the invocation, and call\n+     scan_macro_expansion to save the old lexptr here and point lexptr\n+     into the expanded text.  When we reach the end of that, we call\n+     end_macro_expansion to pop back to the value we saved here.  The\n+     macro expansion code promises to return only fully-expanded text,\n+     so we don't need to \"push\" more than one level.\n+\n+     This is disgusting, of course.  It would be cleaner to do all macro\n+     expansion beforehand, and then hand that to lexptr.  But we don't\n+     really know where the expression ends.  Remember, in a command like\n+\n+     (gdb) break *ADDRESS if CONDITION\n+\n+     we evaluate ADDRESS in the scope of the current frame, but we\n+     evaluate CONDITION in the scope of the breakpoint's location.  So\n+     it's simply wrong to try to macro-expand the whole thing at once.  */\n+  const char *macro_original_text = nullptr;\n+\n+  /* We save all intermediate macro expansions on this obstack for the\n+     duration of a single parse.  The expansion text may sometimes have\n+     to live past the end of the expansion, due to yacc lookahead.\n+     Rather than try to be clever about saving the data for a single\n+     token, we simply keep it all and delete it after parsing has\n+     completed.  */\n+  auto_obstack expansion_obstack;\n };\n \n /* This is set and cleared in c_parse.  */\n@@ -2427,77 +2454,42 @@ static const struct token ident_tokens[] =\n     {\"typeid\", TYPEID, OP_TYPEID, FLAG_CXX}\n   };\n \n-/* When we find that lexptr (the global var defined in parse.c) is\n-   pointing at a macro invocation, we expand the invocation, and call\n-   scan_macro_expansion to save the old lexptr here and point lexptr\n-   into the expanded text.  When we reach the end of that, we call\n-   end_macro_expansion to pop back to the value we saved here.  The\n-   macro expansion code promises to return only fully-expanded text,\n-   so we don't need to \"push\" more than one level.\n-\n-   This is disgusting, of course.  It would be cleaner to do all macro\n-   expansion beforehand, and then hand that to lexptr.  But we don't\n-   really know where the expression ends.  Remember, in a command like\n-\n-     (gdb) break *ADDRESS if CONDITION\n-\n-   we evaluate ADDRESS in the scope of the current frame, but we\n-   evaluate CONDITION in the scope of the breakpoint's location.  So\n-   it's simply wrong to try to macro-expand the whole thing at once.  */\n-static const char *macro_original_text;\n-\n-/* We save all intermediate macro expansions on this obstack for the\n-   duration of a single parse.  The expansion text may sometimes have\n-   to live past the end of the expansion, due to yacc lookahead.\n-   Rather than try to be clever about saving the data for a single\n-   token, we simply keep it all and delete it after parsing has\n-   completed.  */\n-static struct obstack expansion_obstack;\n \n static void\n scan_macro_expansion (char *expansion)\n {\n   char *copy;\n \n   /* We'd better not be trying to push the stack twice.  */\n-  gdb_assert (! macro_original_text);\n+  gdb_assert (! cpstate->macro_original_text);\n \n   /* Copy to the obstack, and then free the intermediate\n      expansion.  */\n-  copy = (char *) obstack_copy0 (&expansion_obstack, expansion,\n+  copy = (char *) obstack_copy0 (&cpstate->expansion_obstack, expansion,\n \t\t\t\t strlen (expansion));\n   xfree (expansion);\n \n   /* Save the old lexptr value, so we can return to it when we're done\n      parsing the expanded text.  */\n-  macro_original_text = lexptr;\n+  cpstate->macro_original_text = lexptr;\n   lexptr = copy;\n }\n \n static int\n scanning_macro_expansion (void)\n {\n-  return macro_original_text != 0;\n+  return cpstate->macro_original_text != 0;\n }\n \n static void\n finished_macro_expansion (void)\n {\n   /* There'd better be something to pop back to.  */\n-  gdb_assert (macro_original_text);\n+  gdb_assert (cpstate->macro_original_text);\n \n   /* Pop back to the original text.  */\n-  lexptr = macro_original_text;\n-  macro_original_text = 0;\n-}\n-\n-static void\n-scan_macro_cleanup (void *dummy)\n-{\n-  if (macro_original_text)\n-    finished_macro_expansion ();\n-\n-  obstack_free (&expansion_obstack, NULL);\n+  lexptr = cpstate->macro_original_text;\n+  cpstate->macro_original_text = 0;\n }\n \n /* Return true iff the token represents a C++ cast operator.  */\n@@ -3262,7 +3254,7 @@ yylex (void)\n   if (checkpoint > 0)\n     {\n       current.value.sval.ptr\n-\t= (const char *) obstack_copy0 (&expansion_obstack,\n+\t= (const char *) obstack_copy0 (&cpstate->expansion_obstack,\n \t\t\t\t\tcurrent.value.sval.ptr,\n \t\t\t\t\tcurrent.value.sval.length);\n \n@@ -3282,9 +3274,6 @@ yylex (void)\n int\n c_parse (struct parser_state *par_state)\n {\n-  int result;\n-  struct cleanup *back_to;\n-\n   /* Setting up the parser state.  */\n   scoped_restore pstate_restore = make_scoped_restore (&pstate);\n   gdb_assert (par_state != NULL);\n@@ -3305,13 +3294,6 @@ c_parse (struct parser_state *par_state)\n   scoped_restore restore_macro_scope\n     = make_scoped_restore (&expression_macro_scope, macro_scope.get ());\n \n-  /* Initialize macro expansion code.  */\n-  obstack_init (&expansion_obstack);\n-  gdb_assert (! macro_original_text);\n-  /* Note that parsing (within yyparse) freely installs cleanups\n-     assuming they'll be run here (below).  */\n-  back_to = make_cleanup (scan_macro_cleanup, 0);\n-\n   scoped_restore restore_yydebug = make_scoped_restore (&yydebug,\n \t\t\t\t\t\t\tparser_debug);\n \n@@ -3323,10 +3305,7 @@ c_parse (struct parser_state *par_state)\n   popping = 0;\n   name_obstack.clear ();\n \n-  result = yyparse ();\n-  do_cleanups (back_to);\n-\n-  return result;\n+  return yyparse ();\n }\n \n #ifdef YYBISON"
    }
  ]
}