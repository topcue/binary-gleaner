{
  "sha": "9b3e4b5d74a8170a8f9f224c36c651661fc26954",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWIzZTRiNWQ3NGE4MTcwYThmOWYyMjRjMzZjNjUxNjYxZmMyNjk1NA==",
  "commit": {
    "author": {
      "name": "Shahab Vahedi",
      "email": "shahab@synopsys.com",
      "date": "2019-10-31T16:33:08Z"
    },
    "committer": {
      "name": "Shahab Vahedi",
      "email": "shahab@synopsys.com",
      "date": "2021-02-08T12:03:41Z"
    },
    "message": "gdb: Do not interrupt atomic sequences for ARC\n\nWhen stepping over thread-lock related codes (in uClibc), the inferior process\ngets stuck and never manages to enter the critical section:\n\n------8<-------\n 1 size_t fwrite(const void * __restrict ptr, size_t size,\n 2               size_t nmemb, register FILE * __restrict stream)\n 3 {\n 4     size_t retval;\n 5     __STDIO_AUTO_THREADLOCK_VAR;\n 6\n 7 >   __STDIO_AUTO_THREADLOCK(stream);\n 8\n 9     retval = fwrite_unlocked(ptr, size, nmemb, stream);\n10\n11     __STDIO_AUTO_THREADUNLOCK(stream);\n12\n13     return retval;\n14 }\n------>8-------\n\nHere, we are at line 7.  Using the \"next\" command leads no where.\nHowever, setting a breakpoint on line 9 and issuing \"continue\" works.\n\nLooking at the assembly instructions reveals that we're dealing with the\ncritical section entry code [1] that should never be interrupted, in this\ncase by the debugger's implicit breakpoints:\n\n------8<-------\n  ...\n1 add_s   r0,r13,0x38\n2 mov_s   r3,1\n3 llock   r2,[r0]        <-.\n4 brne.nt r2,0,14     --.  |\n5 scond   r3,[r0]       |  |\n6 bne     -10         --|--'\n7 brne_s  r2,0,84     <-'\n  ...\n------>8-------\n\nLines 3 until 5 (inclusive) are supposed to be executed atomically.\nTherefore, GDB should never (implicitly) insert a breakpoint on lines\n4 and 5, else the program will try to acquire the lock again by jumping\nback to line 3 and gets stuck in an infinite loop.\n\nThe solution is to make GDB aware of these patterns so it inserts\nbreakpoints after the sequence -- line 6 in this example.\n\n[1]\nhttps://cgit.uclibc-ng.org/cgi/cgit/uclibc-ng.git/tree/libc/sysdeps/linux/arc/bits/atomic.h#n46\n------8<-------\n  ({\t\t\t\t\t\t\t\t\t\\\n\t__typeof(oldval) prev;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__asm__ __volatile__(\t\t\t\t\t\t\\\n\t\"1:\tllock   %0, [%1]\t\\n\"\t\t\t\t\\\n\t\"\tbrne    %0, %2, 2f\t\\n\"\t\t\t\t\\\n\t\"\tscond   %3, [%1]\t\\n\"\t\t\t\t\\\n\t\"\tbnz     1b\t\t\\n\"\t\t\t\t\\\n\t\"2:\t\t\t\t\\n\"\t\t\t\t\\\n\t: \"=&r\"(prev)\t\t\t\t\t\t\t\\\n\t: \"r\"(mem), \"ir\"(oldval),\t\t\t\t\t\\\n\t  \"r\"(newval) /* can't be \"ir\". scond can't take limm for \"b\" */\\\n\t: \"cc\", \"memory\");\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tprev;\t\t\t\t\t\t\t\t\\\n  })\n------>8-------\n\"llock\" (Load Locked) loads the 32-bit word pointed by the source\noperand.  If the load is completed without any interruption or\nexception, the physical address is remembered, in Lock Physical Address\n(LPA), and the Lock Flag (LF) is set to 1.  LF is a non-architecturally\nvisible flag and is cleared whenever an interrupt or exception takes\nplace.  LF is also cleared (atomically) whenever another process writes\nto the LPA.\n\n\"scond\" (Store Conditional) will write to the destination address if\nand only if the LF is set to 1.  When finished, with or without a write,\nit atomically copies the LF value to ZF (Zero Flag).\n\nThese two instructions together provide the mechanism for entering a\ncritical section.  The code snippet above comes from uClibc:\n-----------------------\n\nv3 (after Tom's remarks[2]):\n handle_atomic_sequence()\n  - no need to initialize the std::vector with \"{}\"\n  - fix typo in comments: \"conditial\" -> \"conditional\"\n  - add braces to the body of \"if\" condition because of the comment line\n arc_linux_software_single_step()\n  - make the performance slightly more efficient by moving a few\n    variables after the likely \"return\" point.\n\nv2 (after Simon's remarks[3]):\n- handle_atomic_sequence() gets a copy of an instruction instead of\n  a reference.\n- handle_atomic_sequence() asserts if the given instruction is an llock.\n\n[2]\nhttps://sourceware.org/pipermail/gdb-patches/2021-February/175805.html\n\n[3]\nhttps://sourceware.org/pipermail/gdb-patches/2021-January/175487.html\n\ngdb/ChangeLog:\n\n\tPR tdep/27369\n\t* arc-linux-tdep.c (handle_atomic_sequence): New.\n\t(arc_linux_software_single_step): Call handle_atomic_sequence().",
    "tree": {
      "sha": "6e3c368c30056571472eb77174c9bf08f6161348",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6e3c368c30056571472eb77174c9bf08f6161348"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9b3e4b5d74a8170a8f9f224c36c651661fc26954",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b3e4b5d74a8170a8f9f224c36c651661fc26954",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9b3e4b5d74a8170a8f9f224c36c651661fc26954",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b3e4b5d74a8170a8f9f224c36c651661fc26954/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "29db1eb3390cd45066680ef865214588afdc0eca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/29db1eb3390cd45066680ef865214588afdc0eca",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/29db1eb3390cd45066680ef865214588afdc0eca"
    }
  ],
  "stats": {
    "total": 83,
    "additions": 82,
    "deletions": 1
  },
  "files": [
    {
      "sha": "e67668d315c505ed92156dd00f68a95ecfde5e05",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b3e4b5d74a8170a8f9f224c36c651661fc26954/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b3e4b5d74a8170a8f9f224c36c651661fc26954/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9b3e4b5d74a8170a8f9f224c36c651661fc26954",
      "patch": "@@ -1,3 +1,9 @@\n+2021-02-08  Shahab Vahedi  <shahab@synopsys.com>\n+\n+\tPR tdep/27369\n+\t* arc-linux-tdep.c (handle_atomic_sequence): New.\n+\t(arc_linux_software_single_step): Call handle_atomic_sequence().\n+\n 2021-02-08  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* python/py-tui.c (gdbpy_tui_window) <is_valid>: New member"
    },
    {
      "sha": "cf18b8d6b03a1c8ca110006d0f1aec18781cb065",
      "filename": "gdb/arc-linux-tdep.c",
      "status": "modified",
      "additions": 76,
      "deletions": 1,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b3e4b5d74a8170a8f9f224c36c651661fc26954/gdb/arc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b3e4b5d74a8170a8f9f224c36c651661fc26954/gdb/arc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-linux-tdep.c?ref=9b3e4b5d74a8170a8f9f224c36c651661fc26954",
      "patch": "@@ -332,6 +332,78 @@ arc_linux_sw_breakpoint_from_kind (struct gdbarch *gdbarch,\n \t  : arc_linux_trap_s_le);\n }\n \n+/* Check for an atomic sequence of instructions beginning with an\n+   LLOCK instruction and ending with a SCOND instruction.\n+\n+   These patterns are hand coded in libc's (glibc and uclibc). Take\n+   a look at [1] for instance:\n+\n+   main+14: llock   r2,[r0]\n+   main+18: brne.nt r2,0,main+30\n+   main+22: scond   r3,[r0]\n+   main+26: bne     main+14\n+   main+30: mov_s   r0,0\n+\n+   If such a sequence is found, attempt to step over it.\n+   A breakpoint is placed at the end of the sequence.\n+\n+   This function expects the INSN to be a \"llock(d)\" instruction.\n+\n+   [1]\n+   https://cgit.uclibc-ng.org/cgi/cgit/uclibc-ng.git/tree/libc/ \\\n+     sysdeps/linux/arc/bits/atomic.h#n46\n+   */\n+\n+static std::vector<CORE_ADDR>\n+handle_atomic_sequence (arc_instruction insn, disassemble_info &di)\n+{\n+  const int atomic_seq_len = 24;    /* Instruction sequence length.  */\n+  std::vector<CORE_ADDR> next_pcs;\n+\n+  /* Sanity check.  */\n+  gdb_assert (insn.insn_class == LLOCK);\n+\n+  /* Data size we are dealing with: LLOCK vs. LLOCKD  */\n+  arc_ldst_data_size llock_data_size_mode = insn.data_size_mode;\n+  /* Indicator if any conditional branch is found in the sequence.  */\n+  bool found_bc = false;\n+  /* Becomes true if \"LLOCK(D) .. SCOND(D)\" sequence is found.  */\n+  bool is_pattern_valid = false;\n+\n+  for (int insn_count = 0; insn_count < atomic_seq_len; ++insn_count)\n+    {\n+      arc_insn_decode (arc_insn_get_linear_next_pc (insn),\n+\t\t       &di, arc_delayed_print_insn, &insn);\n+\n+      if (insn.insn_class == BRCC)\n+        {\n+          /* If more than one conditional branch is found, this is not\n+             the pattern we are interested in.  */\n+          if (found_bc)\n+\t    break;\n+\t  found_bc = true;\n+\t  continue;\n+        }\n+\n+      /* This is almost a happy ending.  */\n+      if (insn.insn_class == SCOND)\n+        {\n+\t  /* SCOND should match the LLOCK's data size.  */\n+\t  if (insn.data_size_mode == llock_data_size_mode)\n+\t    is_pattern_valid = true;\n+\t  break;\n+        }\n+    }\n+\n+  if (is_pattern_valid)\n+    {\n+      /* Get next instruction after scond(d).  There is no limm.  */\n+      next_pcs.push_back (insn.address + insn.length);\n+    }\n+\n+  return next_pcs;\n+}\n+\n /* Implement the \"software_single_step\" gdbarch method.  */\n \n static std::vector<CORE_ADDR>\n@@ -345,8 +417,11 @@ arc_linux_software_single_step (struct regcache *regcache)\n   struct arc_instruction curr_insn;\n   arc_insn_decode (regcache_read_pc (regcache), &di, arc_delayed_print_insn,\n \t\t   &curr_insn);\n-  CORE_ADDR next_pc = arc_insn_get_linear_next_pc (curr_insn);\n \n+  if (curr_insn.insn_class == LLOCK)\n+    return handle_atomic_sequence (curr_insn, di);\n+\n+  CORE_ADDR next_pc = arc_insn_get_linear_next_pc (curr_insn);\n   std::vector<CORE_ADDR> next_pcs;\n \n   /* For instructions with delay slots, the fall thru is not the"
    }
  ]
}