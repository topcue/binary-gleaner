{
  "sha": "6ba0a321037b748f0b1285c44af762021a380bd3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmJhMGEzMjEwMzdiNzQ4ZjBiMTI4NWM0NGFmNzYyMDIxYTM4MGJkMw==",
  "commit": {
    "author": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2020-03-06T21:21:28Z"
    },
    "committer": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2020-03-12T21:28:40Z"
    },
    "message": "Remove deprecated core file functions\n\nThere are no more callers to deprecated_add_core_fns, now that I have\nremoved the usage from CRIS and ARM/NetBSD.  So this patch cleans up\nall the related code and makes corelow.c a lot more readable.\n\ngdb/ChangeLog:\n\n2020-03-12  Christian Biesinger  <cbiesinger@google.com>\n\n\t* corelow.c (sniff_core_bfd): Remove.\n\t(class core_target) <m_core_vec>: Remove.\n\t(core_target::core_target): Update.\n\t(core_file_fns): Remove.\n\t(deprecated_add_core_fns): Remove.\n\t(default_core_sniffer): Remove.\n\t(sniff_core_bfd): Remove.\n\t(default_check_format): Remove.\n\t(gdb_check_format): Remove.\n\t(core_target_open): Update.\n\t(core_target::get_core_register_section): Update.\n\t(get_core_registers_cb): Update.\n\t(core_target::fetch_registers): Update.\n\t* gdbcore.h (struct core_fns): Remove.\n\t(deprecated_add_core_fns): Remove.\n\t(default_core_sniffer): Remove.\n\t(default_check_format): Remove.",
    "tree": {
      "sha": "70e5517b7b4a7638f064247a45f0cb644ef7a677",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/70e5517b7b4a7638f064247a45f0cb644ef7a677"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6ba0a321037b748f0b1285c44af762021a380bd3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ba0a321037b748f0b1285c44af762021a380bd3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6ba0a321037b748f0b1285c44af762021a380bd3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ba0a321037b748f0b1285c44af762021a380bd3/comments",
  "author": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4635ff975351603e64da3cbdeec3b999ee842ac8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4635ff975351603e64da3cbdeec3b999ee842ac8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4635ff975351603e64da3cbdeec3b999ee842ac8"
    }
  ],
  "stats": {
    "total": 258,
    "additions": 41,
    "deletions": 217
  },
  "files": [
    {
      "sha": "2f12ff15f0e0485fc573b781294fc13f22a2f5ec",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ba0a321037b748f0b1285c44af762021a380bd3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ba0a321037b748f0b1285c44af762021a380bd3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6ba0a321037b748f0b1285c44af762021a380bd3",
      "patch": "@@ -1,3 +1,23 @@\n+2020-03-12  Christian Biesinger  <cbiesinger@google.com>\n+\n+\t* corelow.c (sniff_core_bfd): Remove.\n+\t(class core_target) <m_core_vec>: Remove.\n+\t(core_target::core_target): Update.\n+\t(core_file_fns): Remove.\n+\t(deprecated_add_core_fns): Remove.\n+\t(default_core_sniffer): Remove.\n+\t(sniff_core_bfd): Remove.\n+\t(default_check_format): Remove.\n+\t(gdb_check_format): Remove.\n+\t(core_target_open): Update.\n+\t(core_target::get_core_register_section): Update.\n+\t(get_core_registers_cb): Update.\n+\t(core_target::fetch_registers): Update.\n+\t* gdbcore.h (struct core_fns): Remove.\n+\t(deprecated_add_core_fns): Remove.\n+\t(default_core_sniffer): Remove.\n+\t(default_check_format): Remove.\n+\n 2020-03-12  Tom Tromey  <tom@tromey.com>\n \n \t* arm-tdep.c (struct arm_mapping_symbol) <value>: Now a"
    },
    {
      "sha": "b60010453dc446d9f5b466d56ccb6f3a5fb72646",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 21,
      "deletions": 149,
      "changes": 170,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ba0a321037b748f0b1285c44af762021a380bd3/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ba0a321037b748f0b1285c44af762021a380bd3/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=6ba0a321037b748f0b1285c44af762021a380bd3",
      "patch": "@@ -50,9 +50,6 @@\n #define O_LARGEFILE 0\n #endif\n \n-static core_fns *sniff_core_bfd (gdbarch *core_gdbarch,\n-\t\t\t\t bfd *abfd);\n-\n /* The core file target.  */\n \n static const target_info core_target_info = {\n@@ -111,7 +108,6 @@ class core_target final : public process_stratum_target\n \t\t\t\t  const struct regset *regset,\n \t\t\t\t  const char *name,\n \t\t\t\t  int section_min_size,\n-\t\t\t\t  int which,\n \t\t\t\t  const char *human_name,\n \t\t\t\t  bool required);\n \n@@ -125,10 +121,6 @@ class core_target final : public process_stratum_target\n      targets.  */\n   target_section_table m_core_section_table {};\n \n-  /* The core_fns for a core file handler that is prepared to read the\n-     core file currently open on core_bfd.  */\n-  core_fns *m_core_vec = NULL;\n-\n   /* FIXME: kettenis/20031023: Eventually this field should\n      disappear.  */\n   struct gdbarch *m_core_gdbarch = NULL;\n@@ -138,8 +130,10 @@ core_target::core_target ()\n {\n   m_core_gdbarch = gdbarch_from_bfd (core_bfd);\n \n-  /* Find a suitable core file handler to munch on core_bfd */\n-  m_core_vec = sniff_core_bfd (m_core_gdbarch, core_bfd);\n+  if (!m_core_gdbarch\n+      || !gdbarch_iterate_over_regset_sections_p (m_core_gdbarch))\n+    error (_(\"\\\"%s\\\": Core file format not supported\"),\n+\t   bfd_get_filename (core_bfd));\n \n   /* Find the data section */\n   if (build_section_table (core_bfd,\n@@ -154,107 +148,11 @@ core_target::~core_target ()\n   xfree (m_core_section_table.sections);\n }\n \n-/* List of all available core_fns.  On gdb startup, each core file\n-   register reader calls deprecated_add_core_fns() to register\n-   information on each core format it is prepared to read.  */\n-\n-static struct core_fns *core_file_fns = NULL;\n-\n-static int gdb_check_format (bfd *);\n-\n static void add_to_thread_list (bfd *, asection *, void *);\n \n /* An arbitrary identifier for the core inferior.  */\n #define CORELOW_PID 1\n \n-/* Link a new core_fns into the global core_file_fns list.  Called on\n-   gdb startup by the _initialize routine in each core file register\n-   reader, to register information about each format the reader is\n-   prepared to handle.  */\n-\n-void\n-deprecated_add_core_fns (struct core_fns *cf)\n-{\n-  cf->next = core_file_fns;\n-  core_file_fns = cf;\n-}\n-\n-/* The default function that core file handlers can use to examine a\n-   core file BFD and decide whether or not to accept the job of\n-   reading the core file.  */\n-\n-int\n-default_core_sniffer (struct core_fns *our_fns, bfd *abfd)\n-{\n-  int result;\n-\n-  result = (bfd_get_flavour (abfd) == our_fns -> core_flavour);\n-  return (result);\n-}\n-\n-/* Walk through the list of core functions to find a set that can\n-   handle the core file open on ABFD.  Returns pointer to set that is\n-   selected.  */\n-\n-static struct core_fns *\n-sniff_core_bfd (struct gdbarch *core_gdbarch, bfd *abfd)\n-{\n-  struct core_fns *cf;\n-  struct core_fns *yummy = NULL;\n-  int matches = 0;\n-\n-  /* Don't sniff if we have support for register sets in\n-     CORE_GDBARCH.  */\n-  if (core_gdbarch && gdbarch_iterate_over_regset_sections_p (core_gdbarch))\n-    return NULL;\n-\n-  for (cf = core_file_fns; cf != NULL; cf = cf->next)\n-    {\n-      if (cf->core_sniffer (cf, abfd))\n-\t{\n-\t  yummy = cf;\n-\t  matches++;\n-\t}\n-    }\n-  if (matches > 1)\n-    {\n-      warning (_(\"\\\"%s\\\": ambiguous core format, %d handlers match\"),\n-\t       bfd_get_filename (abfd), matches);\n-    }\n-  else if (matches == 0)\n-    error (_(\"\\\"%s\\\": no core file handler recognizes format\"),\n-\t   bfd_get_filename (abfd));\n-\n-  return (yummy);\n-}\n-\n-/* The default is to reject every core file format we see.  Either\n-   BFD has to recognize it, or we have to provide a function in the\n-   core file handler that recognizes it.  */\n-\n-int\n-default_check_format (bfd *abfd)\n-{\n-  return (0);\n-}\n-\n-/* Attempt to recognize core file formats that BFD rejects.  */\n-\n-static int\n-gdb_check_format (bfd *abfd)\n-{\n-  struct core_fns *cf;\n-\n-  for (cf = core_file_fns; cf != NULL; cf = cf->next)\n-    {\n-      if (cf->check_format (abfd))\n-\t{\n-\t  return (1);\n-\t}\n-    }\n-  return (0);\n-}\n-\n /* Close the core target.  */\n \n void\n@@ -413,8 +311,7 @@ core_target_open (const char *arg, int from_tty)\n   if (temp_bfd == NULL)\n     perror_with_name (filename.get ());\n \n-  if (!bfd_check_format (temp_bfd.get (), bfd_core)\n-      && !gdb_check_format (temp_bfd.get ()))\n+  if (!bfd_check_format (temp_bfd.get (), bfd_core))\n     {\n       /* Do it after the err msg */\n       /* FIXME: should be checking for errors from bfd_close (for one\n@@ -568,8 +465,7 @@ core_target::detach (inferior *inf, int from_tty)\n }\n \n /* Try to retrieve registers from a section in core_bfd, and supply\n-   them to m_core_vec->core_read_registers, as the register set\n-   numbered WHICH.\n+   them to REGSET.\n \n    If ptid's lwp member is zero, do the single-threaded\n    thing: look for a section named NAME.  If ptid's lwp\n@@ -588,14 +484,14 @@ core_target::get_core_register_section (struct regcache *regcache,\n \t\t\t\t\tconst struct regset *regset,\n \t\t\t\t\tconst char *name,\n \t\t\t\t\tint section_min_size,\n-\t\t\t\t\tint which,\n \t\t\t\t\tconst char *human_name,\n \t\t\t\t\tbool required)\n {\n+  gdb_assert (regset != nullptr);\n+\n   struct bfd_section *section;\n   bfd_size_type size;\n-  bool variable_size_section = (regset != NULL\n-\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n+  bool variable_size_section = (regset->flags & REGSET_VARIABLE_SIZE);\n \n   thread_section_name section_name (name, regcache->ptid ());\n \n@@ -630,15 +526,7 @@ core_target::get_core_register_section (struct regcache *regcache,\n       return;\n     }\n \n-  if (regset != NULL)\n-    {\n-      regset->supply_regset (regset, regcache, -1, contents.data (), size);\n-      return;\n-    }\n-\n-  gdb_assert (m_core_vec != nullptr);\n-  m_core_vec->core_read_registers (regcache, contents.data (), size, which,\n-\t\t\t\t   (CORE_ADDR) bfd_section_vma (section));\n+  regset->supply_regset (regset, regcache, -1, contents.data (), size);\n }\n \n /* Data passed to gdbarch_iterate_over_regset_sections's callback.  */\n@@ -656,10 +544,11 @@ get_core_registers_cb (const char *sect_name, int supply_size, int collect_size,\n \t\t       const struct regset *regset,\n \t\t       const char *human_name, void *cb_data)\n {\n+  gdb_assert (regset != nullptr);\n+\n   auto *data = (get_core_registers_cb_data *) cb_data;\n   bool required = false;\n-  bool variable_size_section = (regset != NULL\n-\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n+  bool variable_size_section = (regset->flags & REGSET_VARIABLE_SIZE);\n \n   if (!variable_size_section)\n     gdb_assert (supply_size == collect_size);\n@@ -676,11 +565,8 @@ get_core_registers_cb (const char *sect_name, int supply_size, int collect_size,\n \thuman_name = \"floating-point\";\n     }\n \n-  /* The 'which' parameter is only used when no regset is provided.\n-     Thus we just set it to -1. */\n   data->target->get_core_register_section (data->regcache, regset, sect_name,\n-\t\t\t\t\t   supply_size, -1, human_name,\n-\t\t\t\t\t   required);\n+\t\t\t\t\t   supply_size, human_name, required);\n }\n \n /* Get the registers out of a core file.  This is the machine-\n@@ -693,36 +579,22 @@ get_core_registers_cb (const char *sect_name, int supply_size, int collect_size,\n void\n core_target::fetch_registers (struct regcache *regcache, int regno)\n {\n-  int i;\n-  struct gdbarch *gdbarch;\n-\n   if (!(m_core_gdbarch != nullptr\n-\t&& gdbarch_iterate_over_regset_sections_p (m_core_gdbarch))\n-      && (m_core_vec == NULL || m_core_vec->core_read_registers == NULL))\n+\t&& gdbarch_iterate_over_regset_sections_p (m_core_gdbarch)))\n     {\n       fprintf_filtered (gdb_stderr,\n \t\t     \"Can't fetch registers from this type of core file\\n\");\n       return;\n     }\n \n-  gdbarch = regcache->arch ();\n-  if (gdbarch_iterate_over_regset_sections_p (gdbarch))\n-    {\n-      get_core_registers_cb_data data = { this, regcache };\n-      gdbarch_iterate_over_regset_sections (gdbarch,\n-\t\t\t\t\t    get_core_registers_cb,\n-\t\t\t\t\t    (void *) &data, NULL);\n-    }\n-  else\n-    {\n-      get_core_register_section (regcache, NULL,\n-\t\t\t\t \".reg\", 0, 0, \"general-purpose\", 1);\n-      get_core_register_section (regcache, NULL,\n-\t\t\t\t \".reg2\", 0, 2, \"floating-point\", 0);\n-    }\n+  struct gdbarch *gdbarch = regcache->arch ();\n+  get_core_registers_cb_data data = { this, regcache };\n+  gdbarch_iterate_over_regset_sections (gdbarch,\n+\t\t\t\t\tget_core_registers_cb,\n+\t\t\t\t\t(void *) &data, NULL);\n \n   /* Mark all registers not found in the core as unavailable.  */\n-  for (i = 0; i < gdbarch_num_regs (regcache->arch ()); i++)\n+  for (int i = 0; i < gdbarch_num_regs (regcache->arch ()); i++)\n     if (regcache->get_register_status (i) == REG_UNKNOWN)\n       regcache->raw_supply (i, NULL);\n }"
    },
    {
      "sha": "24db21e462c6408fbfd23deeca41146f852964c5",
      "filename": "gdb/gdbcore.h",
      "status": "modified",
      "additions": 0,
      "deletions": 68,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ba0a321037b748f0b1285c44af762021a380bd3/gdb/gdbcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ba0a321037b748f0b1285c44af762021a380bd3/gdb/gdbcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbcore.h?ref=6ba0a321037b748f0b1285c44af762021a380bd3",
      "patch": "@@ -168,69 +168,6 @@ extern const char *gnutarget;\n \n extern void set_gnutarget (const char *);\n \n-/* Structure to keep track of core register reading functions for\n-   various core file types.  */\n-\n-struct core_fns\n-  {\n-\n-    /* BFD flavour that a core file handler is prepared to read.  This\n-       can be used by the handler's core tasting function as a first\n-       level filter to reject BFD's that don't have the right\n-       flavour.  */\n-\n-    enum bfd_flavour core_flavour;\n-\n-    /* Core file handler function to call to recognize corefile\n-       formats that BFD rejects.  Some core file format just don't fit\n-       into the BFD model, or may require other resources to identify\n-       them, that simply aren't available to BFD (such as symbols from\n-       another file).  Returns nonzero if the handler recognizes the\n-       format, zero otherwise.  */\n-\n-    int (*check_format) (bfd *);\n-\n-    /* Core file handler function to call to ask if it can handle a\n-       given core file format or not.  Returns zero if it can't,\n-       nonzero otherwise.  */\n-\n-    int (*core_sniffer) (struct core_fns *, bfd *);\n-\n-    /* Extract the register values out of the core file and supply them\n-       into REGCACHE.\n-\n-       CORE_REG_SECT points to the register values themselves, read into\n-       memory.\n-\n-       CORE_REG_SIZE is the size of that area.\n-\n-       WHICH says which set of registers we are handling:\n-         0 --- integer registers\n-         2 --- floating-point registers, on machines where they are\n-               discontiguous\n-         3 --- extended floating-point registers, on machines where\n-               these are present in yet a third area.  (GNU/Linux uses\n-               this to get at the SSE registers.)\n-\n-       REG_ADDR is the offset from u.u_ar0 to the register values relative to\n-       core_reg_sect.  This is used with old-fashioned core files to locate the\n-       registers in a large upage-plus-stack \".reg\" section.  Original upage\n-       address X is at location core_reg_sect+x+reg_addr.  */\n-\n-    void (*core_read_registers) (struct regcache *regcache,\n-\t\t\t\t gdb_byte *core_reg_sect,\n-\t\t\t\t unsigned core_reg_size,\n-\t\t\t\t int which, CORE_ADDR reg_addr);\n-\n-    /* Finds the next struct core_fns.  They are allocated and\n-       initialized in whatever module implements the functions pointed\n-       to; an initializer calls deprecated_add_core_fns to add them to\n-       the global chain.  */\n-\n-    struct core_fns *next;\n-\n-  };\n-\n /* Build either a single-thread or multi-threaded section name for\n    PTID.\n \n@@ -274,9 +211,4 @@ class thread_section_name\n   std::string m_storage;\n };\n \n-/* Replaced by the \"iterate_over_regset_sections\" gdbarch method.  */\n-extern void deprecated_add_core_fns (struct core_fns *cf);\n-extern int default_core_sniffer (struct core_fns *cf, bfd * abfd);\n-extern int default_check_format (bfd * abfd);\n-\n #endif /* !defined (GDBCORE_H) */"
    }
  ]
}