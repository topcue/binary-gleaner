{
  "sha": "e173ea00c2941af42ea4e2267446d6039a70da6e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTE3M2VhMDBjMjk0MWFmNDJlYTRlMjI2NzQ0NmQ2MDM5YTcwZGE2ZQ==",
  "commit": {
    "author": {
      "name": "Joshua Oreman",
      "email": "oremanj@hudson-trading.com",
      "date": "2019-05-10T23:27:10Z"
    },
    "committer": {
      "name": "Cary Coutant",
      "email": "ccoutant@gmail.com",
      "date": "2019-05-10T23:27:10Z"
    },
    "message": "Fix problem with ICF where diffs in EH frame info is ignored.\n\n\tPR gold/21066\n\t* gc.h (gc_process_relocs): Track relocations in .eh_frame sections\n\twhen ICF is enabled, even though the .eh_frame sections themselves\n\tare not foldable.\n\t* icf.cc (get_section_contents): Change arguments to permit operation\n\ton just part of a section. Include extra identity regions in the\n\treferring section's contents recursively.\n\t(match_sections): Lock object here instead of in get_section_contents\n\tso that get_section_contents can operate recursively.\n\t(Icf::add_ehframe_links): New method.\n\t(Icf::find_identical_sections): Pass .eh_frame sections to\n\tadd_ehframe_links(). Increase default iteration count from 2 to 3\n\tbecause handling exception info typically requires one extra iteration.\n\t* icf.h (Icf::extra_identity_list_): New data member with accessor.\n\t(is_section_foldable_candidate): Include .gcc_except_table sections.\n\t* options.h: Update documentation for new default ICF iteration count.\n\t* testsuite/Makefile.am (icf_test_pr21066): New test case.\n\t* testsuite/Makefile.in: Regenerate.\n\t* testsuite/icf_test_pr21066.cc: New source file.\n\t* testsuite/icf_test_pr21066.sh: New test script.",
    "tree": {
      "sha": "c4e71d797a234be5ce51cc9e18c3d922384e7a7e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c4e71d797a234be5ce51cc9e18c3d922384e7a7e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e173ea00c2941af42ea4e2267446d6039a70da6e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e173ea00c2941af42ea4e2267446d6039a70da6e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e173ea00c2941af42ea4e2267446d6039a70da6e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e173ea00c2941af42ea4e2267446d6039a70da6e/comments",
  "author": {
    "login": "oremanj",
    "id": 4316136,
    "node_id": "MDQ6VXNlcjQzMTYxMzY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4316136?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/oremanj",
    "html_url": "https://github.com/oremanj",
    "followers_url": "https://api.github.com/users/oremanj/followers",
    "following_url": "https://api.github.com/users/oremanj/following{/other_user}",
    "gists_url": "https://api.github.com/users/oremanj/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/oremanj/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/oremanj/subscriptions",
    "organizations_url": "https://api.github.com/users/oremanj/orgs",
    "repos_url": "https://api.github.com/users/oremanj/repos",
    "events_url": "https://api.github.com/users/oremanj/events{/privacy}",
    "received_events_url": "https://api.github.com/users/oremanj/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ccoutant",
    "id": 1442098,
    "node_id": "MDQ6VXNlcjE0NDIwOTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1442098?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ccoutant",
    "html_url": "https://github.com/ccoutant",
    "followers_url": "https://api.github.com/users/ccoutant/followers",
    "following_url": "https://api.github.com/users/ccoutant/following{/other_user}",
    "gists_url": "https://api.github.com/users/ccoutant/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ccoutant/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ccoutant/subscriptions",
    "organizations_url": "https://api.github.com/users/ccoutant/orgs",
    "repos_url": "https://api.github.com/users/ccoutant/repos",
    "events_url": "https://api.github.com/users/ccoutant/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ccoutant/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1367480341749b1498a6c5e7a7b79c7a4ab4ed34",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1367480341749b1498a6c5e7a7b79c7a4ab4ed34",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1367480341749b1498a6c5e7a7b79c7a4ab4ed34"
    }
  ],
  "stats": {
    "total": 472,
    "additions": 438,
    "deletions": 34
  },
  "files": [
    {
      "sha": "5d23e71851c73cdbcb1ef609ddd5d65002ba9ab6",
      "filename": "gold/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/ChangeLog?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -1,3 +1,26 @@\n+2019-05-10  Joshua Oreman  <oremanj@hudson-trading.com>\n+\n+\tPR gold/21066\n+\t* gc.h (gc_process_relocs): Track relocations in .eh_frame sections\n+\twhen ICF is enabled, even though the .eh_frame sections themselves\n+\tare not foldable.\n+\t* icf.cc (get_section_contents): Change arguments to permit operation\n+\ton just part of a section. Include extra identity regions in the\n+\treferring section's contents recursively.\n+\t(match_sections): Lock object here instead of in get_section_contents\n+\tso that get_section_contents can operate recursively.\n+\t(Icf::add_ehframe_links): New method.\n+\t(Icf::find_identical_sections): Pass .eh_frame sections to\n+\tadd_ehframe_links(). Increase default iteration count from 2 to 3\n+\tbecause handling exception info typically requires one extra iteration.\n+\t* icf.h (Icf::extra_identity_list_): New data member with accessor.\n+\t(is_section_foldable_candidate): Include .gcc_except_table sections.\n+\t* options.h: Update documentation for new default ICF iteration count.\n+\t* testsuite/Makefile.am (icf_test_pr21066): New test case.\n+\t* testsuite/Makefile.in: Regenerate.\n+\t* testsuite/icf_test_pr21066.cc: New source file.\n+\t* testsuite/icf_test_pr21066.sh: New test script.\n+\n 2019-02-19  Egeyar Bagcioglu  <egeyar.bagcioglu@oracle.com>\n \n      PR gold/23870"
    },
    {
      "sha": "5f60934487ff044252ae79df0fccbcb9b2989fef",
      "filename": "gold/gc.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/gc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/gc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/gc.h?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -200,7 +200,8 @@ gc_process_relocs(\n   bool check_section_for_function_pointers = false;\n \n   if (parameters->options().icf_enabled()\n-      && is_section_foldable_candidate(src_section_name.c_str()))\n+      && (is_section_foldable_candidate(src_section_name)\n+          || is_prefix_of(\".eh_frame\", src_section_name.c_str())))\n     {\n       is_icf_tracked = true;\n       Section_id src_id(src_obj, src_indx);"
    },
    {
      "sha": "56b6f29ed8eb2f8f9fe26e58c4159ca4fb7d734c",
      "filename": "gold/icf.cc",
      "status": "modified",
      "additions": 239,
      "deletions": 31,
      "changes": 270,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/icf.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/icf.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/icf.cc?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -130,6 +130,26 @@\n // folded causing unpredictable run-time behaviour if the pointers were used\n // in comparisons.\n //\n+// Notes regarding C++ exception handling :\n+// --------------------------------------\n+//\n+// It is possible for two sections to have identical text, identical\n+// relocations, but different exception handling metadata (unwind\n+// information in the .eh_frame section, and/or handler information in\n+// a .gcc_except_table section).  Thus, if a foldable section is\n+// referenced from a .eh_frame FDE, we must include in its checksum\n+// the contents of that FDE as well as of the CIE that the FDE refers\n+// to.  The CIE and FDE in turn probably contain relocations to the\n+// personality routine and LSDA, which are handled like any other\n+// relocation for ICF purposes.  This logic is helped by the fact that\n+// gcc with -ffunction-sections puts each function's LSDA in its own\n+// .gcc_except_table.<functionname> section.  Given sections for two\n+// functions with nontrivial exception handling logic, we will\n+// determine on the first iteration that their .gcc_except_table\n+// sections are identical and can be folded, and on the second\n+// iteration that their .text and .eh_frame contents (including the\n+// now-merged .gcc_except_table relocations for the LSDA) are\n+// identical and can be folded.\n //\n //\n // How to run  : --icf=[safe|all|none]\n@@ -148,6 +168,8 @@\n #include \"elfcpp.h\"\n #include \"int_encoding.h\"\n \n+#include <limits>\n+\n namespace gold\n {\n \n@@ -259,29 +281,35 @@ get_rel_addend(const unsigned char* reloc_addend_ptr,\n // subsequent invocations of this function.\n // Parameters  :\n // FIRST_ITERATION    : true if it is the first invocation.\n+// FIXED_CACHE        : String that stores the portion of the result that\n+//                      does not change from iteration to iteration;\n+//                      written if first_iteration is true, read if it's false.\n // SECN               : Section for which contents are desired.\n-// SECTION_NUM        : Unique section number of this section.\n+// SELF_SECN          : Relocations that target this section will be\n+//                      considered \"relocations to self\" so that recursive\n+//                      functions can be folded. Should normally be the\n+//                      same as `secn` except when processing extra identity\n+//                      regions.\n // NUM_TRACKED_RELOCS : Vector reference to store the number of relocs\n //                      to ICF sections.\n // KEPT_SECTION_ID    : Vector which maps folded sections to kept sections.\n-// SECTION_CONTENTS   : Store the section's text and relocs to non-ICF\n-//                      sections.\n+// START_OFFSET       : Only consider the part of the section at and after\n+//                      this offset.\n+// END_OFFSET         : Only consider the part of the section before this\n+//                      offset.\n \n static std::string\n get_section_contents(bool first_iteration,\n+\t\t     std::string* fixed_cache,\n                      const Section_id& secn,\n-                     unsigned int section_num,\n+\t\t     const Section_id& self_secn,\n                      unsigned int* num_tracked_relocs,\n                      Symbol_table* symtab,\n                      const std::vector<unsigned int>& kept_section_id,\n-                     std::vector<std::string>* section_contents)\n+\t\t     section_offset_type start_offset = 0,\n+\t\t     section_offset_type end_offset =\n+\t\t       std::numeric_limits<section_offset_type>::max())\n {\n-  // Lock the object so we can read from it.  This is only called\n-  // single-threaded from queue_middle_tasks, so it is OK to lock.\n-  // Unfortunately we have no way to pass in a Task token.\n-  const Task* dummy_task = reinterpret_cast<const Task*>(-1);\n-  Task_lock_obj<Object> tl(dummy_task, secn.first);\n-\n   section_size_type plen;\n   const unsigned char* contents = NULL;\n   if (first_iteration)\n@@ -292,9 +320,6 @@ get_section_contents(bool first_iteration,\n   std::string buffer;\n   std::string icf_reloc_buffer;\n \n-  if (num_tracked_relocs)\n-    *num_tracked_relocs = 0;\n-\n   Icf::Reloc_info_list& reloc_info_list = \n     symtab->icf()->reloc_info_list();\n \n@@ -330,6 +355,11 @@ get_section_contents(bool first_iteration,\n \t  Symbol* gsym = *it_s;\n \t  bool is_section_symbol = false;\n \n+\t  // Ignore relocations outside the region we were told to look at\n+\t  if (static_cast<section_offset_type>(*it_o) < start_offset\n+\t      || static_cast<section_offset_type>(*it_o) >= end_offset)\n+\t    continue;\n+\n \t  // A -1 value in the symbol vector indicates a local section symbol.\n \t  if (gsym == reinterpret_cast<Symbol*>(-1))\n \t    {\n@@ -367,7 +397,7 @@ get_section_contents(bool first_iteration,\n           snprintf(addend_str, sizeof(addend_str), \"%llx %llx %llx\",\n                    static_cast<long long>((*it_a).first),\n \t\t   static_cast<long long>((*it_a).second),\n-\t\t   static_cast<unsigned long long>(*it_o));\n+\t\t   static_cast<unsigned long long>(*it_o - start_offset));\n \n \t  // If the symbol pointed to by the reloc is not in an ordinary\n \t  // section or if the symbol type is not FROM_OBJECT, then the\n@@ -390,8 +420,8 @@ get_section_contents(bool first_iteration,\n \n           // If this reloc turns back and points to the same section,\n           // like a recursive call, use a special symbol to mark this.\n-          if (reloc_secn.first == secn.first\n-              && reloc_secn.second == secn.second)\n+          if (reloc_secn.first == self_secn.first\n+              && reloc_secn.second == self_secn.second)\n             {\n               if (first_iteration)\n                 {\n@@ -568,16 +598,48 @@ get_section_contents(bool first_iteration,\n   if (first_iteration)\n     {\n       buffer.append(\"Contents = \");\n-      buffer.append(reinterpret_cast<const char*>(contents), plen);\n+\n+      const unsigned char* slice_end =\n+\tcontents + std::min<section_offset_type>(plen, end_offset);\n+\n+      if (contents + start_offset < slice_end)\n+\t{\n+\t  buffer.append(reinterpret_cast<const char*>(contents + start_offset),\n+\t\t\tslice_end - (contents + start_offset));\n+\t}\n+    }\n+\n+  // Add any extra identity regions.\n+  std::pair<Icf::Extra_identity_list::const_iterator,\n+\t    Icf::Extra_identity_list::const_iterator>\n+    extra_range = symtab->icf()->extra_identity_list().equal_range(secn);\n+  for (Icf::Extra_identity_list::const_iterator it_ext = extra_range.first;\n+       it_ext != extra_range.second; ++it_ext)\n+    {\n+      std::string external_fixed;\n+      std::string external_all =\n+\tget_section_contents(first_iteration, &external_fixed,\n+\t\t\t     it_ext->second.section, self_secn,\n+\t\t\t     num_tracked_relocs, symtab,\n+\t\t\t     kept_section_id, it_ext->second.offset,\n+\t\t\t     it_ext->second.offset + it_ext->second.length);\n+      buffer.append(external_fixed);\n+      icf_reloc_buffer.append(external_all, external_fixed.length(),\n+\t\t\t      std::string::npos);\n+    }\n+\n+  if (first_iteration)\n+    {\n       // Store the section contents that don't change to avoid recomputing\n       // during the next call to this function.\n-      (*section_contents)[section_num] = buffer;\n+      *fixed_cache = buffer;\n     }\n   else\n     {\n       gold_assert(buffer.empty());\n+\n       // Reuse the contents computed in the previous iteration.\n-      buffer.append((*section_contents)[section_num]);\n+      buffer.append(*fixed_cache);\n     }\n \n   buffer.append(icf_reloc_buffer);\n@@ -641,14 +703,22 @@ match_sections(unsigned int iteration_num,\n         continue;\n \n       Section_id secn = id_section[i];\n+\n+      // Lock the object so we can read from it.  This is only called\n+      // single-threaded from queue_middle_tasks, so it is OK to lock.\n+      // Unfortunately we have no way to pass in a Task token.\n+      const Task* dummy_task = reinterpret_cast<const Task*>(-1);\n+      Task_lock_obj<Object> tl(dummy_task, secn.first);\n+\n       std::string this_secn_contents;\n       uint32_t cksum;\n+      std::string* this_secn_cache = &((*section_contents)[i]);\n       if (iteration_num == 1)\n         {\n           unsigned int num_relocs = 0;\n-          this_secn_contents = get_section_contents(true, secn, i, &num_relocs,\n-                                                    symtab, (*kept_section_id),\n-                                                    section_contents);\n+          this_secn_contents = get_section_contents(true, this_secn_cache,\n+\t\t\t\t\t\t    secn, secn, &num_relocs,\n+\t\t\t\t\t\t    symtab, (*kept_section_id));\n           (*num_tracked_relocs)[i] = num_relocs;\n         }\n       else\n@@ -658,9 +728,9 @@ match_sections(unsigned int iteration_num,\n               // This section is already folded into something.\n               continue;\n             }\n-          this_secn_contents = get_section_contents(false, secn, i, NULL,\n-                                                    symtab, (*kept_section_id),\n-                                                    section_contents);\n+          this_secn_contents = get_section_contents(false, this_secn_cache,\n+\t\t\t\t\t\t    secn, secn, NULL,\n+\t\t\t\t\t\t    symtab, (*kept_section_id));\n         }\n \n       const unsigned char* this_secn_contents_array =\n@@ -766,8 +836,115 @@ is_function_ctor_or_dtor(const std::string& section_name)\n   return false;\n }\n \n+// Iterate through the .eh_frame section that has index\n+// `ehframe_shndx` in `object`, adding entries to extra_identity_list_\n+// that will cause the contents of each FDE and its CIE to be included\n+// in the logical ICF identity of the function that the FDE refers to.\n+\n+bool\n+Icf::add_ehframe_links(Relobj* object, unsigned int ehframe_shndx,\n+\t\t       Reloc_info& relocs)\n+{\n+  section_size_type contents_len;\n+  const unsigned char* pcontents = object->section_contents(ehframe_shndx,\n+\t\t\t\t\t\t\t    &contents_len,\n+\t\t\t\t\t\t\t    false);\n+  const unsigned char* p = pcontents;\n+  const unsigned char* pend = pcontents + contents_len;\n+\n+  Sections_reachable_info::iterator it_target = relocs.section_info.begin();\n+  Sections_reachable_info::iterator it_target_end = relocs.section_info.end();\n+  Offset_info::iterator it_offset = relocs.offset_info.begin();\n+  Offset_info::iterator it_offset_end = relocs.offset_info.end();\n+\n+  // Maps section offset to the length of the CIE defined at that offset.\n+  typedef Unordered_map<section_offset_type, section_size_type> Cie_map;\n+  Cie_map cies;\n+\n+  uint32_t (*read_swap_32)(const unsigned char*);\n+  if (object->is_big_endian())\n+    read_swap_32 = &elfcpp::Swap<32, true>::readval;\n+  else\n+    read_swap_32 = &elfcpp::Swap<32, false>::readval;\n+\n+  // TODO: The logic for parsing the CIE/FDE framing is copied from\n+  // Eh_frame::do_add_ehframe_input_section() and might want to be\n+  // factored into a shared helper function.\n+  while (p < pend)\n+    {\n+      if (pend - p < 4)\n+\treturn false;\n+\n+      unsigned int len = read_swap_32(p);\n+      p += 4;\n+      if (len == 0)\n+\t{\n+\t  // We should only find a zero-length entry at the end of the\n+\t  // section.\n+\t  if (p < pend)\n+\t    return false;\n+\t  break;\n+\t}\n+      // We don't support a 64-bit .eh_frame.\n+      if (len == 0xffffffff)\n+\treturn false;\n+      if (static_cast<unsigned int>(pend - p) < len)\n+\treturn false;\n+\n+      const unsigned char* const pentend = p + len;\n+\n+      if (pend - p < 4)\n+\treturn false;\n+\n+      unsigned int id = read_swap_32(p);\n+      p += 4;\n+\n+      if (id == 0)\n+\t{\n+\t  // CIE.\n+\t  cies.insert(std::make_pair(p - pcontents, len - 4));\n+\t}\n+      else\n+\t{\n+\t  // FDE.\n+\t  Cie_map::const_iterator it;\n+\t  it = cies.find((p - pcontents) - (id - 4));\n+\t  if (it == cies.end())\n+\t    return false;\n+\n+\t  // Figure out which section this FDE refers into. The word at `p`\n+\t  // is an address, and we expect to see a relocation there. If not,\n+\t  // this FDE isn't ICF-relevant.\n+\t  while (it_offset != it_offset_end\n+\t\t && it_target != it_target_end\n+\t\t && static_cast<ptrdiff_t>(*it_offset) < (p - pcontents))\n+\t    {\n+\t      ++it_offset;\n+\t      ++it_target;\n+\t    }\n+\t  if (it_offset != it_offset_end\n+\t      && it_target != it_target_end\n+\t      && static_cast<ptrdiff_t>(*it_offset) == (p - pcontents))\n+\t    {\n+\t      // Found a reloc. Add this FDE and its CIE as extra identity\n+\t      // info for the section it refers to.\n+\t      Extra_identity_info rec_fde = {Section_id(object, ehframe_shndx),\n+\t\t\t\t\t     p - pcontents, len - 4};\n+\t      Extra_identity_info rec_cie = {Section_id(object, ehframe_shndx),\n+\t\t\t\t\t     it->first, it->second};\n+\t      extra_identity_list_.insert(std::make_pair(*it_target, rec_fde));\n+\t      extra_identity_list_.insert(std::make_pair(*it_target, rec_cie));\n+\t    }\n+\t}\n+\n+      p = pentend;\n+    }\n+\n+  return true;\n+}\n+\n // This is the main ICF function called in gold.cc.  This does the\n-// initialization and calls match_sections repeatedly (twice by default)\n+// initialization and calls match_sections repeatedly (thrice by default)\n // which computes the crc checksums and detects identical functions.\n \n void\n@@ -792,12 +969,18 @@ Icf::find_identical_sections(const Input_objects* input_objects,\n       // Unfortunately we have no way to pass in a Task token.\n       const Task* dummy_task = reinterpret_cast<const Task*>(-1);\n       Task_lock_obj<Object> tl(dummy_task, *p);\n+      std::vector<unsigned int> eh_frame_ind;\n \n-      for (unsigned int i = 0;i < (*p)->shnum(); ++i)\n+      for (unsigned int i = 0; i < (*p)->shnum(); ++i)\n         {\n \t  const std::string section_name = (*p)->section_name(i);\n           if (!is_section_foldable_candidate(section_name))\n-            continue;\n+\t    {\n+\t      if (is_prefix_of(\".eh_frame\", section_name.c_str()))\n+\t\teh_frame_ind.push_back(i);\n+\t      continue;\n+\t    }\n+\n           if (!(*p)->is_section_included(i))\n             continue;\n           if (parameters->options().gc_sections()\n@@ -822,14 +1005,39 @@ Icf::find_identical_sections(const Input_objects* input_objects,\n           section_contents.push_back(\"\");\n           section_num++;\n         }\n+\n+      for (std::vector<unsigned int>::iterator it_eh_ind = eh_frame_ind.begin();\n+\t   it_eh_ind != eh_frame_ind.end(); ++it_eh_ind)\n+\t{\n+\t  // gc_process_relocs() recorded relocations for this\n+\t  // section even though we can't fold it. We need to\n+\t  // use those relocations to associate other foldable\n+\t  // sections with the FDEs and CIEs that are relevant\n+\t  // to them, so we can avoid merging sections that\n+\t  // don't have identical exception-handling behavior.\n+\n+\t  Section_id sect(*p, *it_eh_ind);\n+\t  Reloc_info_list::iterator it_rel = this->reloc_info_list().find(sect);\n+\t  if (it_rel != this->reloc_info_list().end())\n+\t    {\n+\t      if (!add_ehframe_links(*p, *it_eh_ind, it_rel->second))\n+\t\t{\n+\t\t  gold_warning(_(\"could not parse eh_frame section %s(%s); ICF \"\n+\t\t\t\t \"might not preserve exception handling \"\n+\t\t\t\t \"behavior\"),\n+\t\t\t       (*p)->name().c_str(),\n+\t\t\t       (*p)->section_name(*it_eh_ind).c_str());\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   unsigned int num_iterations = 0;\n \n-  // Default number of iterations to run ICF is 2.\n+  // Default number of iterations to run ICF is 3.\n   unsigned int max_iterations = (parameters->options().icf_iterations() > 0)\n                             ? parameters->options().icf_iterations()\n-                            : 2;\n+                            : 3;\n \n   bool converged = false;\n "
    },
    {
      "sha": "7f8e84182eca7b126abb31976cc6dbe1b61b8de1",
      "filename": "gold/icf.h",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/icf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/icf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/icf.h?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -64,6 +64,19 @@ class Icf\n   typedef Unordered_map<Section_id, Reloc_info,\n                         Section_id_hash> Reloc_info_list;\n \n+  // A region of some other section that should be considered part of\n+  // a section for ICF purposes. This is used to avoid folding sections\n+  // that have identical text and relocations but different .eh_frame\n+  // information.\n+  typedef struct\n+  {\n+\tSection_id section;\n+\tsection_offset_type offset;\n+\tsection_size_type length;\n+  } Extra_identity_info;\n+\n+  typedef std::multimap<Section_id, Extra_identity_info> Extra_identity_list;\n+\n   Icf()\n   : id_section_(), section_id_(), kept_section_id_(),\n     fptr_section_id_(),\n@@ -137,13 +150,23 @@ class Icf\n   reloc_info_list()\n   { return this->reloc_info_list_; }\n \n+  // Returns a map from section to region of a different section that should\n+  // be considered part of the key section for ICF purposes.\n+  Extra_identity_list&\n+  extra_identity_list()\n+  { return this->extra_identity_list_; }\n+\n   // Returns a mapping of each section to a unique integer.\n   Uniq_secn_id_map&\n   section_to_int_map()\n   { return this->section_id_; }\n \n  private:\n \n+  bool\n+  add_ehframe_links(Relobj* object, unsigned int ehframe_shndx,\n+\t\t    Reloc_info& ehframe_relocs);\n+\n   // Maps integers to sections.\n   std::vector<Section_id> id_section_;\n   // Does the reverse.\n@@ -160,17 +183,24 @@ class Icf\n   bool icf_ready_;\n   // This list is populated by gc_process_relocs in gc.h.\n   Reloc_info_list reloc_info_list_;\n+  // Regions of other sections that should be considered part of\n+  // each section for ICF purposes.\n+  Extra_identity_list extra_identity_list_;\n };\n \n // This function returns true if this section corresponds to a function that\n // should be considered by icf as a possible candidate for folding.  Some\n // earlier gcc versions, like 4.0.3, put constructors and destructors in\n // .gnu.linkonce.t sections and hence should be included too.\n+// The mechanism used to safely fold functions referenced by .eh_frame\n+// requires folding .gcc_except_table sections as well; see \"Notes regarding\n+// C++ exception handling\" at the top of icf.cc for an explanation why.\n inline bool\n is_section_foldable_candidate(const std::string& section_name)\n {\n   const char* section_name_cstr = section_name.c_str();\n   return (is_prefix_of(\".text\", section_name_cstr)\n+          || is_prefix_of(\".gcc_except_table\", section_name_cstr)\n           || is_prefix_of(\".gnu.linkonce.t\", section_name_cstr));\n }\n "
    },
    {
      "sha": "f7c127953c2e899b8b93a63e0412ccc7ad5d2c21",
      "filename": "gold/options.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/options.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/options.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/options.h?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -946,7 +946,7 @@ class General_options\n \t      {\"none\", \"all\", \"safe\"});\n \n   DEFINE_uint(icf_iterations, options::TWO_DASHES , '\\0', 0,\n-\t      N_(\"Number of iterations of ICF (default 2)\"), N_(\"COUNT\"));\n+\t      N_(\"Number of iterations of ICF (default 3)\"), N_(\"COUNT\"));\n \n   DEFINE_special(incremental, options::TWO_DASHES, '\\0',\n \t\t N_(\"Do an incremental link if possible; \""
    },
    {
      "sha": "4c26f3355b7efbea0540abce3cf7c1b52d4b11c8",
      "filename": "gold/testsuite/Makefile.am",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/testsuite/Makefile.am?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -278,6 +278,16 @@ icf_test: icf_test.o gcctestdir/ld\n icf_test.map: icf_test\n \t@touch icf_test.map\n \n+check_SCRIPTS += icf_test_pr21066.sh\n+check_DATA += icf_test_pr21066.map\n+MOSTLYCLEANFILES += icf_test_pr21066 icf_test_pr21066.map\n+icf_test_pr21066.o: icf_test_pr21066.cc\n+\t$(CXXCOMPILE) -O0 -c -ffunction-sections -g -o $@ $<\n+icf_test_pr21066: icf_test_pr21066.o gcctestdir/ld\n+\t$(CXXLINK) -o icf_test_pr21066 -Bgcctestdir/ -Wl,--icf=all,-Map,icf_test_pr21066.map icf_test_pr21066.o\n+icf_test_pr21066.map: icf_test_pr21066\n+\t@touch icf_test_pr21066.map\n+\n check_SCRIPTS += icf_keep_unique_test.sh\n check_DATA += icf_keep_unique_test.stdout\n MOSTLYCLEANFILES += icf_keep_unique_test"
    },
    {
      "sha": "dac0db21a3e5817fa6cc783be0fe27880465e1fb",
      "filename": "gold/testsuite/Makefile.in",
      "status": "modified",
      "additions": 18,
      "deletions": 1,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/testsuite/Makefile.in?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -129,7 +129,7 @@ check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tgc_orphan_section_test.sh \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tpr14265.sh pr20717.sh \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tgc_dynamic_list_test.sh \\\n-@GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test.sh \\\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test.sh icf_test_pr21066.sh \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_keep_unique_test.sh \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_safe_test.sh \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_safe_pie_test.sh \\\n@@ -152,6 +152,7 @@ check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tpr14265.stdout pr20717.stdout \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tgc_dynamic_list_test.stdout \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test.map \\\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test_pr21066.map \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_keep_unique_test.stdout \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_safe_test_1.stdout \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_safe_test_2.stdout \\\n@@ -182,6 +183,8 @@ check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tgc_orphan_section_test pr14265 \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\tpr20717 gc_dynamic_list_test \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test icf_test.map \\\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test_pr21066 \\\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_test_pr21066.map \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_keep_unique_test \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_safe_test icf_safe_test.map \\\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\ticf_safe_pie_test \\\n@@ -2705,6 +2708,7 @@ pdfdir = @pdfdir@\n prefix = @prefix@\n program_transform_name = @program_transform_name@\n psdir = @psdir@\n+runstatedir = @runstatedir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n srcdir = @srcdir@\n@@ -5517,6 +5521,13 @@ icf_test.sh.log: icf_test.sh\n \t--log-file $$b.log --trs-file $$b.trs \\\n \t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n \t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n+icf_test_pr21066.sh.log: icf_test_pr21066.sh\n+\t@p='icf_test_pr21066.sh'; \\\n+\tb='icf_test_pr21066.sh'; \\\n+\t$(am__check_pre) $(LOG_DRIVER) --test-name \"$$f\" \\\n+\t--log-file $$b.log --trs-file $$b.trs \\\n+\t$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \\\n+\t\"$$tst\" $(AM_TESTS_FD_REDIRECT)\n icf_keep_unique_test.sh.log: icf_keep_unique_test.sh\n \t@p='icf_keep_unique_test.sh'; \\\n \tb='icf_keep_unique_test.sh'; \\\n@@ -7935,6 +7946,12 @@ uninstall-am:\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\t$(CXXLINK) -o icf_test -Wl,--icf=all,-Map,icf_test.map icf_test.o\n @GCC_TRUE@@NATIVE_LINKER_TRUE@icf_test.map: icf_test\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\t@touch icf_test.map\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@icf_test_pr21066.o: icf_test_pr21066.cc\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\t$(CXXCOMPILE) -O0 -c -ffunction-sections -g -o $@ $<\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@icf_test_pr21066: icf_test_pr21066.o gcctestdir/ld\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\t$(CXXLINK) -o icf_test_pr21066 -Bgcctestdir/ -Wl,--icf=all,-Map,icf_test_pr21066.map icf_test_pr21066.o\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@icf_test_pr21066.map: icf_test_pr21066\n+@GCC_TRUE@@NATIVE_LINKER_TRUE@\t@touch icf_test_pr21066.map\n @GCC_TRUE@@NATIVE_LINKER_TRUE@icf_keep_unique_test.o: icf_keep_unique_test.cc\n @GCC_TRUE@@NATIVE_LINKER_TRUE@\t$(CXXCOMPILE) -O0 -c -ffunction-sections -g -o $@ $<\n @GCC_TRUE@@NATIVE_LINKER_TRUE@icf_keep_unique_test: icf_keep_unique_test.o gcctestdir/ld"
    },
    {
      "sha": "568873d5a88b28c725620e7a97591ae1d7265836",
      "filename": "gold/testsuite/icf_test_pr21066.cc",
      "status": "added",
      "additions": 67,
      "deletions": 0,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/icf_test_pr21066.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/icf_test_pr21066.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/testsuite/icf_test_pr21066.cc?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -0,0 +1,67 @@\n+// icf_test.cc -- a test case for gold\n+\n+// Copyright (C) 2009-2018 Free Software Foundation, Inc.\n+// Test case from PR 21066 submitted by Gandhi Shaheen\n+\n+// This file is part of gold.\n+\n+// This program is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3 of the License, or\n+// (at your option) any later version.\n+\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this program; if not, write to the Free Software\n+// Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+\n+// The goal of this program is to verify if identical code folding\n+// correctly identifies and folds functions.  folded_func must be\n+// folded into kept_func.\n+\n+// Written by Sriraman Tallam <tmsriram@google.com>.\n+\n+#include <stdio.h>\n+\n+struct first_exception {\n+};\n+\n+struct second_exception {\n+};\n+\n+typedef void (*callback_fn_t)();\n+\n+void raise_first_exception()\n+{\n+  throw first_exception();\n+}\n+\n+void raise_second_exception()\n+{\n+  throw second_exception();\n+}\n+\n+template<typename E>\n+void capture_exception_of_type(volatile callback_fn_t f)\n+{\n+  try {\n+    f();\n+  } catch (E& e) {\n+    puts(\"caught expected exception\");\n+  } catch (...) {\n+    puts(\"ERROR: caught unexpected exception\");\n+    throw;\n+  }\n+}\n+\n+int main()\n+{\n+  capture_exception_of_type<first_exception>(raise_first_exception);\n+  capture_exception_of_type<second_exception>(raise_second_exception);\n+  return 0;\n+}"
    },
    {
      "sha": "2f3e85d61170b759cd2db4cfe398c46a94ee52ce",
      "filename": "gold/testsuite/icf_test_pr21066.sh",
      "status": "added",
      "additions": 48,
      "deletions": 0,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/icf_test_pr21066.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e173ea00c2941af42ea4e2267446d6039a70da6e/gold/testsuite/icf_test_pr21066.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/testsuite/icf_test_pr21066.sh?ref=e173ea00c2941af42ea4e2267446d6039a70da6e",
      "patch": "@@ -0,0 +1,48 @@\n+#!/bin/sh\n+\n+# icf_test_pr21066.sh -- regression test for ICF tracking exception handling\n+# metadata differences\n+\n+# Copyright (C) 2009-2018 Free Software Foundation, Inc.\n+# Written by Joshua Oreman <oremanj@hudson-trading.com>, based on icf_test.sh\n+\n+# This file is part of gold.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+# MA 02110-1301, USA.\n+\n+set -e\n+\n+check()\n+{\n+    awk \"\n+BEGIN { discard = 0; }\n+/^Discarded input/ { discard = 1; }\n+/^Memory map/ { discard = 0; }\n+/.*\\\\.text\\\\..*capture_exception_of_type.*($2|$3).*/ {\n+      act[discard] = act[discard] \\\" \\\" \\$0;\n+}\n+END {\n+      # printf \\\"kept\\\" act[0] \\\"\\\\nfolded\\\" act[1] \\\"\\\\n\\\";\n+      if (length(act[0]) != 0 && length(act[1]) != 0)\n+\t{\n+\t  printf \\\"Identical Code Folding improperly folded functions\\\\n\\\"\n+\t  printf \\\"with same code but different .gcc_except_table\\\\n\\\"\n+\t  exit 1;\n+\t}\n+    }\" $1\n+}\n+\n+check icf_test_pr21066.map \"first_exception\" \"second_exception\""
    }
  ]
}