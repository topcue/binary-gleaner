{
  "sha": "04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDQ5MDJiMDk5NWYxMmJhNmY0YmRjN2M4YTJkNGE0NmFmYWU0MzY1ZA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-09-14T20:16:59Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-09-14T21:21:07Z"
    },
    "message": "Rewrite enum_flags, add unit tests, fix problems\n\nThis patch started by adding comprehensive unit tests for enum_flags.\n\nFor the testing part, it adds:\n\n - tests of normal expected uses of the API.\n\n - checks that _invalid_ uses of the API would fail to compile.  I.e.,\n   it validates that enum_flags really is a strong type, and that\n   incorrect mixing of enum types would be caught at compile time.  It\n   pulls that off making use of SFINEA and C++11's decltype/constexpr.\n\nThis revealed many holes in the enum_flags API.  For example, the f1\nassignment below currently incorrectly fails to compile:\n\n enum_flags<flags> f1 = FLAG1;\n enum_flags<flags> f2 = FLAG2 | f1;\n\nThe unit tests also revealed that this useful use case doesn't work:\n\n    enum flag { FLAG1 = 1, FLAG2 = 2 };\n    enum_flags<flag> src = FLAG1;\n    enum_flags<flag> f1 = condition ? src : FLAG2;\n\nIt fails to compile because enum_flags<flag> and flag are convertible\nto each other.\n\nTurns out that making enum_flags be implicitly convertible to the\nbacking raw enum type was not a good idea.\n\nIf we make it convertible to the underlying type instead, we fix that\nternary operator use case, and, we find cases throughout the codebase\nthat should be using the enum_flags but were using the raw backing\nenum instead.  So it's a good change overall.\n\nAlso, several operators were missing.\n\nThese holes and more are plugged by this patch, by reworking how the\nenum_flags operators are implemented, and making use of C++11's\nfeature of being able to delete methods/functions.\n\nThere are cases in gdb/compile/ where we need to call a function in a\nC plugin API that expects the raw enum.  To address cases like that,\nthis adds a \"raw()\" method to enum_flags.  This way we can keep using\nthe safer enum_flags to construct the value, and then be explicit when\nwe need to get at the raw enum.\n\nThis makes most of the enum_flags operators constexpr.  Beyond\nenabling more compiler optimizations and enabling the new unit tests,\nthis has other advantages, like making it possible to use operator|\nwith enum_flags values in switch cases, where only compile-time\nconstants are allowed:\n\n    enum_flags<flags> f = FLAG1 | FLAG2;\n    switch (f)\n      {\n      case FLAG1 | FLAG2:\n\tbreak;\n      }\n\nCurrently that fails to compile.\n\nIt also switches to a different mechanism of enabling the global\noperators.  The current mechanism isn't namespace friendly, the new\none is.\n\nIt also switches to C++11-style SFINAE -- instead of wrapping the\nreturn type in a SFINAE-friently structure, we use an unnamed template\nparameter.  I.e., this:\n\n  template <typename enum_type,\n\t    typename = is_enum_flags_enum_type_t<enum_type>>\n  enum_type\n  operator& (enum_type e1, enum_type e2)\n\ninstead of:\n\n  template <typename enum_type>\n  typename enum_flags_type<enum_type>::type\n  operator& (enum_type e1, enum_type e2)\n\nNote that the static_assert inside operator~() was converted to a\ncouple overloads (signed vs unsigned), because static_assert is too\nlate for SFINAE-based tests, which is important for the CHECK_VALID\nunit tests.\n\nTested with gcc {4.8, 7.1, 9.3} and clang {5.0.2, 10.0.0}.\n\ngdb/ChangeLog:\n\n\t* Makefile.in (SELFTESTS_SRCS): Add\n\tunittests/enum-flags-selftests.c.\n\t* btrace.c (ftrace_update_caller, ftrace_fixup_calle): Use\n\tbtrace_function_flags instead of enum btrace_function_flag.\n\t* compile/compile-c-types.c (convert_qualified): Use\n\tenum_flags::raw.\n\t* compile/compile-cplus-symbols.c (convert_one_symbol)\n\t(convert_symbol_bmsym):\n\t* compile/compile-cplus-types.c (compile_cplus_convert_method)\n\t(compile_cplus_convert_struct_or_union_methods)\n\t(compile_cplus_instance::convert_qualified_base):\n\t* go-exp.y (parse_string_or_char): Add cast to int.\n\t* unittests/enum-flags-selftests.c: New file.\n\t* record-btrace.c (btrace_thread_flag_to_str): Change parameter's\n\ttype to btrace_thread_flags from btrace_thread_flag.\n\t(record_btrace_cancel_resume, record_btrace_step_thread): Change\n\tlocal's type to btrace_thread_flags from btrace_thread_flag.  Add\n\tcast in DEBUG call.\n\ngdbsupport/ChangeLog:\n\n\t* enum-flags.h: Include \"traits.h\".\n\t(DEF_ENUM_FLAGS_TYPE): Declare a function instead of defining a\n\tstructure.\n\t(enum_underlying_type): Update comment.\n\t(namespace enum_flags_detail): New.  Move struct zero_type here.\n\t(EnumIsUnsigned, EnumIsSigned): New.\n\t(class enum_flags): Make most methods constexpr.\n\t(operator&=, operator|=, operator^=): Take an enum_flags instead\n\tof an enum_type.  Make rvalue ref versions deleted.\n\t(operator enum_type()): Delete.\n\t(operator&, operator|, operator^, operator~): Delete, moved out of\n\tclass.\n\t(raw()): New method.\n\t(is_enum_flags_enum_type_t): Declare.\n\t(ENUM_FLAGS_GEN_BINOP, ENUM_FLAGS_GEN_COMPOUND_ASSIGN)\n\t(ENUM_FLAGS_GEN_COMP): New.  Use them to reimplement global\n\toperators.\n\t(operator~): Now constexpr and reimplemented.\n\t(operator<<, operator>>): New deleted functions.\n\t* valid-expr.h (CHECK_VALID_EXPR_5, CHECK_VALID_EXPR_6): New.",
    "tree": {
      "sha": "77b228a70973ea34eaf54b9bfd330b6f22bd3a99",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/77b228a70973ea34eaf54b9bfd330b6f22bd3a99"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1945192cb9a6184fb805d514ce4ca1bc8999b587",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1945192cb9a6184fb805d514ce4ca1bc8999b587",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1945192cb9a6184fb805d514ce4ca1bc8999b587"
    }
  ],
  "stats": {
    "total": 1049,
    "additions": 951,
    "deletions": 98
  },
  "files": [
    {
      "sha": "45c712522674257b3be2e79ed59f0570decd3093",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -1,3 +1,24 @@\n+2020-09-14  Pedro Alves  <pedro@palves.net>\n+\n+\t* Makefile.in (SELFTESTS_SRCS): Add\n+\tunittests/enum-flags-selftests.c.\n+\t* btrace.c (ftrace_update_caller, ftrace_fixup_calle): Use\n+\tbtrace_function_flags instead of enum btrace_function_flag.\n+\t* compile/compile-c-types.c (convert_qualified): Use\n+\tenum_flags::raw.\n+\t* compile/compile-cplus-symbols.c (convert_one_symbol)\n+\t(convert_symbol_bmsym):\n+\t* compile/compile-cplus-types.c (compile_cplus_convert_method)\n+\t(compile_cplus_convert_struct_or_union_methods)\n+\t(compile_cplus_instance::convert_qualified_base):\n+\t* go-exp.y (parse_string_or_char): Add cast to int.\n+\t* unittests/enum-flags-selftests.c: New file.\n+\t* record-btrace.c (btrace_thread_flag_to_str): Change parameter's\n+\ttype to btrace_thread_flags from btrace_thread_flag.\n+\t(record_btrace_cancel_resume, record_btrace_step_thread): Change\n+\tlocal's type to btrace_thread_flags from btrace_thread_flag.  Add\n+\tcast in DEBUG call.\n+\n 2020-09-14  Pedro Alves  <pedro@palves.net>\n \n \t* c-typeprint.c (c_type_print_modifier): Adjust to rename."
    },
    {
      "sha": "dbede7a9cfc2d3faf2b3f73a29687ff4215f9234",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -435,6 +435,7 @@ SELFTESTS_SRCS = \\\n \tunittests/command-def-selftests.c \\\n \tunittests/common-utils-selftests.c \\\n \tunittests/copy_bitwise-selftests.c \\\n+\tunittests/enum-flags-selftests.c \\\n \tunittests/environ-selftests.c \\\n \tunittests/filtered_iterator-selftests.c \\\n \tunittests/format_pieces-selftests.c \\"
    },
    {
      "sha": "9022aedd1c804bd71ba2ce84a76348098b10e53e",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -265,7 +265,7 @@ ftrace_new_function (struct btrace_thread_info *btinfo,\n static void\n ftrace_update_caller (struct btrace_function *bfun,\n \t\t      struct btrace_function *caller,\n-\t\t      enum btrace_function_flag flags)\n+\t\t      btrace_function_flags flags)\n {\n   if (bfun->up != 0)\n     ftrace_debug (bfun, \"updating caller\");\n@@ -283,7 +283,7 @@ static void\n ftrace_fixup_caller (struct btrace_thread_info *btinfo,\n \t\t     struct btrace_function *bfun,\n \t\t     struct btrace_function *caller,\n-\t\t     enum btrace_function_flag flags)\n+\t\t     btrace_function_flags flags)\n {\n   unsigned int prev, next;\n "
    },
    {
      "sha": "6c9135947eac93f23a43731190e123b562024441",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -254,7 +254,8 @@ convert_qualified (compile_c_instance *context, struct type *type)\n   if (TYPE_RESTRICT (type))\n     quals |= GCC_QUALIFIER_RESTRICT;\n \n-  return context->plugin ().build_qualified_type (unqual_converted, quals);\n+  return context->plugin ().build_qualified_type (unqual_converted,\n+\t\t\t\t\t\t  quals.raw ());\n }\n \n /* Convert a complex type to its gcc representation.  */"
    },
    {
      "sha": "6b905f3dfcda58a86952c2c2fb144bf2a3036e73",
      "filename": "gdb/compile/compile-cplus-symbols.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/compile/compile-cplus-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/compile/compile-cplus-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-symbols.c?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -208,7 +208,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n \n \t  /* Define the decl.  */\n \t  instance->plugin ().build_decl\n-\t    (\"variable\", name.c_str (), kind, sym_type,\n+\t    (\"variable\", name.c_str (), kind.raw (), sym_type,\n \t     symbol_name.get (), addr, filename, line);\n \n \t  /* Pop scope for non-local symbols.  */\n@@ -323,7 +323,7 @@ convert_symbol_bmsym (compile_cplus_instance *instance,\n   sym_type = instance->convert_type (type);\n   instance->plugin ().push_namespace (\"\");\n   instance->plugin ().build_decl\n-    (\"minsym\", msym->natural_name (), kind, sym_type, nullptr, addr,\n+    (\"minsym\", msym->natural_name (), kind.raw (), sym_type, nullptr, addr,\n      nullptr, 0);\n   instance->plugin ().pop_binding_level (\"\");\n }"
    },
    {
      "sha": "2d4352f6c2c4f7227e4e53ff109a9bcc89bfb8a3",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -668,7 +668,7 @@ compile_cplus_convert_method (compile_cplus_instance *instance,\n      type and corresponding qualifier flags.  */\n   gcc_type func_type = compile_cplus_convert_func (instance, method_type, true);\n   gcc_type class_type = instance->convert_type (parent_type);\n-  gcc_cp_qualifiers_flags quals = (enum gcc_cp_qualifiers) 0;\n+  gcc_cp_qualifiers_flags quals = 0;\n \n   if (TYPE_CONST (method_type))\n     quals |= GCC_CP_QUALIFIER_CONST;\n@@ -681,7 +681,7 @@ compile_cplus_convert_method (compile_cplus_instance *instance,\n   gcc_cp_ref_qualifiers_flags rquals = GCC_CP_REF_QUAL_NONE;\n \n   return instance->plugin ().build_method_type\n-    (class_type, func_type, quals, rquals);\n+    (class_type, func_type, quals.raw (), rquals.raw ());\n }\n \n /* Convert a member or method pointer represented by TYPE.  */\n@@ -745,7 +745,7 @@ compile_cplus_convert_struct_or_union_methods (compile_cplus_instance *instance,\n \t\t     (sym_kind\n \t\t      | get_method_access_flag (type, i, j)\n \t\t      | GCC_CP_FLAG_VIRTUAL_FUNCTION\n-\t\t      | GCC_CP_FLAG_PURE_VIRTUAL_FUNCTION),\n+\t\t      | GCC_CP_FLAG_PURE_VIRTUAL_FUNCTION).raw (),\n \t\t     method_type, nullptr, 0, nullptr, 0);\n \t\t  continue;\n \t\t}\n@@ -787,7 +787,7 @@ compile_cplus_convert_struct_or_union_methods (compile_cplus_instance *instance,\n \n \t  instance->plugin ().build_decl\n \t    (kind, overloaded_name.get (),\n-\t     sym_kind | get_method_access_flag (type, i, j),\n+\t     (sym_kind | get_method_access_flag (type, i, j)).raw (),\n \t     method_type, nullptr, address, filename, line);\n \t}\n     }\n@@ -1060,7 +1060,7 @@ compile_cplus_instance::convert_qualified_base (gcc_type base,\n   gcc_type result = base;\n \n   if (quals != 0)\n-    result = plugin ().build_qualified_type (base, quals);\n+    result = plugin ().build_qualified_type (base, quals.raw ());\n \n   return result;\n }"
    },
    {
      "sha": "ee1db2b5874220e5405e5013db1a5666624482c5",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -924,7 +924,7 @@ parse_string_or_char (const char *tokptr, const char **outptr,\n     }\n   ++tokptr;\n \n-  value->type = C_STRING | (quote == '\\'' ? C_CHAR : 0); /*FIXME*/\n+  value->type = (int) C_STRING | (quote == '\\'' ? C_CHAR : 0); /*FIXME*/\n   value->ptr = (char *) obstack_base (&tempbuf);\n   value->length = obstack_object_size (&tempbuf);\n "
    },
    {
      "sha": "fd0d13fb25892c33721037eb293f97dded3a98fa",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -1928,7 +1928,7 @@ record_btrace_target::get_tailcall_unwinder ()\n /* Return a human-readable string for FLAG.  */\n \n static const char *\n-btrace_thread_flag_to_str (enum btrace_thread_flag flag)\n+btrace_thread_flag_to_str (btrace_thread_flags flag)\n {\n   switch (flag)\n     {\n@@ -2221,15 +2221,15 @@ record_btrace_target::commit_resume ()\n static void\n record_btrace_cancel_resume (struct thread_info *tp)\n {\n-  enum btrace_thread_flag flags;\n+  btrace_thread_flags flags;\n \n   flags = tp->btrace.flags & (BTHR_MOVE | BTHR_STOP);\n   if (flags == 0)\n     return;\n \n   DEBUG (\"cancel resume thread %s (%s): %x (%s)\",\n \t print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str (), flags,\n+\t target_pid_to_str (tp->ptid).c_str (), flags.raw (),\n \t btrace_thread_flag_to_str (flags));\n \n   tp->btrace.flags &= ~(BTHR_MOVE | BTHR_STOP);\n@@ -2449,15 +2449,15 @@ record_btrace_step_thread (struct thread_info *tp)\n {\n   struct btrace_thread_info *btinfo;\n   struct target_waitstatus status;\n-  enum btrace_thread_flag flags;\n+  btrace_thread_flags flags;\n \n   btinfo = &tp->btrace;\n \n   flags = btinfo->flags & (BTHR_MOVE | BTHR_STOP);\n   btinfo->flags &= ~(BTHR_MOVE | BTHR_STOP);\n \n   DEBUG (\"stepping thread %s (%s): %x (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str (), flags,\n+\t target_pid_to_str (tp->ptid).c_str (), flags.raw (),\n \t btrace_thread_flag_to_str (flags));\n \n   /* We can't step without an execution history.  */"
    },
    {
      "sha": "af585f04ae5932f1210835999a7497fb87ba118f",
      "filename": "gdb/unittests/enum-flags-selftests.c",
      "status": "added",
      "additions": 586,
      "deletions": 0,
      "changes": 586,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/unittests/enum-flags-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdb/unittests/enum-flags-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/enum-flags-selftests.c?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -0,0 +1,586 @@\n+/* Self tests for enum-flags for GDB, the GNU debugger.\n+\n+   Copyright (C) 2016-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"gdbsupport/enum-flags.h\"\n+#include \"gdbsupport/valid-expr.h\"\n+#include \"gdbsupport/selftest.h\"\n+\n+namespace selftests {\n+namespace enum_flags_tests {\n+\n+/* The (real) enum types used in CHECK_VALID.  Their names match the\n+   template parameter names of the templates defined by CHECK_VALID to\n+   make it simpler to use.  They could be named differently.  */\n+\n+/* A \"real enum\".  */\n+enum RE\n+  {\n+    RE_FLAG1 = 1 << 1,\n+    RE_FLAG2 = 1 << 2,\n+  };\n+\n+/* Another \"real enum\".  */\n+enum RE2\n+  {\n+    RE2_FLAG1 = 1 << 1,\n+    RE2_FLAG2 = 1 << 2,\n+  };\n+\n+/* An unsigned \"real enum\".  */\n+enum URE : unsigned\n+  {\n+    URE_FLAG1 = 1 << 1,\n+    URE_FLAG2 = 1 << 2,\n+    URE_FLAG3 = 0xffffffff,\n+  };\n+\n+/* A non-flags enum.  */\n+enum NF\n+  {\n+    NF_FLAG1 = 1 << 1,\n+    NF_FLAG2 = 1 << 2,\n+  };\n+\n+/* The corresponding \"enum flags\" types.  */\n+DEF_ENUM_FLAGS_TYPE (RE, EF);\n+DEF_ENUM_FLAGS_TYPE (RE2, EF2);\n+DEF_ENUM_FLAGS_TYPE (URE, UEF);\n+\n+#if HAVE_IS_TRIVIALLY_COPYABLE\n+\n+/* So that std::vectors of types that have enum_flags fields can\n+   reallocate efficiently memcpy.  */\n+gdb_static_assert (std::is_trivially_copyable<EF>::value);\n+\n+#endif\n+\n+/* A couple globals used as lvalues in the CHECK_VALID expressions\n+   below.  Their names (and types) match the uppercase type names\n+   exposed by CHECK_VALID just to make the expressions easier to\n+   follow.  */\n+static RE re ATTRIBUTE_UNUSED;\n+static EF ef ATTRIBUTE_UNUSED;\n+\n+/* First, compile-time tests that:\n+\n+   - make sure that incorrect operations with mismatching enum types\n+     are caught at compile time.\n+\n+   - make sure that the same operations but involving the right enum\n+     types do compile and that they return the correct type.\n+*/\n+\n+#define CHECK_VALID(VALID, EXPR_TYPE, EXPR)\t\t\\\n+  CHECK_VALID_EXPR_6 (EF, RE, EF2, RE2, UEF, URE, VALID, EXPR_TYPE, EXPR)\n+\n+typedef std::underlying_type<RE>::type und;\n+\n+/* Test construction / conversion from/to different types.  */\n+\n+/* RE/EF -> underlying (explicit) */\n+CHECK_VALID (true,  und,  und (RE ()))\n+CHECK_VALID (true,  und,  und (EF ()))\n+\n+/* RE/EF -> int (explicit) */\n+CHECK_VALID (true,  int,  int (RE ()))\n+CHECK_VALID (true,  int,  int (EF ()))\n+\n+/* other -> RE */\n+\n+/* You can construct a raw enum value from an int explicitly to punch\n+   a hole in the type system if need to.  */\n+CHECK_VALID (true,  RE,   RE (1))\n+CHECK_VALID (true,  RE,   RE (RE2 ()))\n+CHECK_VALID (false, void, RE (EF2 ()))\n+CHECK_VALID (true,  RE,   RE (RE ()))\n+CHECK_VALID (false, void, RE (EF ()))\n+\n+/* other -> EF.  */\n+\n+/* As expected, enum-flags is a stronger type than the backing raw\n+   enum.  Unlike with raw enums, you can't construct an enum flags\n+   from an integer nor from an unrelated enum type explicitly.  Add an\n+   intermediate conversion via the raw enum if you really need it.  */\n+CHECK_VALID (false, void, EF (1))\n+CHECK_VALID (false, void, EF (1u))\n+CHECK_VALID (false, void, EF (RE2 ()))\n+CHECK_VALID (false, void, EF (EF2 ()))\n+CHECK_VALID (true,  EF,   EF (RE ()))\n+CHECK_VALID (true,  EF,   EF (EF ()))\n+\n+/* Test operators.  */\n+\n+/* operator OP (raw_enum, int) */\n+\n+CHECK_VALID (false, void, RE () | 1)\n+CHECK_VALID (false, void, RE () & 1)\n+CHECK_VALID (false, void, RE () ^ 1)\n+\n+/* operator OP (int, raw_enum) */\n+\n+CHECK_VALID (false, void, 1 | RE ())\n+CHECK_VALID (false, void, 1 & RE ())\n+CHECK_VALID (false, void, 1 ^ RE ())\n+\n+/* operator OP (enum_flags, int) */\n+\n+CHECK_VALID (false, void, EF () | 1)\n+CHECK_VALID (false, void, EF () & 1)\n+CHECK_VALID (false, void, EF () ^ 1)\n+\n+/* operator OP (int, enum_flags) */\n+\n+CHECK_VALID (false, void, 1 | EF ())\n+CHECK_VALID (false, void, 1 & EF ())\n+CHECK_VALID (false, void, 1 ^ EF ())\n+\n+/* operator OP (raw_enum, raw_enum) */\n+\n+CHECK_VALID (false, void, RE () | RE2 ())\n+CHECK_VALID (false, void, RE () & RE2 ())\n+CHECK_VALID (false, void, RE () ^ RE2 ())\n+CHECK_VALID (true,  RE,   RE () | RE ())\n+CHECK_VALID (true,  RE,   RE () & RE ())\n+CHECK_VALID (true,  RE,   RE () ^ RE ())\n+\n+/* operator OP (enum_flags, raw_enum) */\n+\n+CHECK_VALID (false, void, EF () | RE2 ())\n+CHECK_VALID (false, void, EF () & RE2 ())\n+CHECK_VALID (false, void, EF () ^ RE2 ())\n+CHECK_VALID (true,  EF,   EF () | RE ())\n+CHECK_VALID (true,  EF,   EF () & RE ())\n+CHECK_VALID (true,  EF,   EF () ^ RE ())\n+\n+/* operator OP= (raw_enum, raw_enum), rvalue ref on the lhs. */\n+\n+CHECK_VALID (false, void, RE () |= RE2 ())\n+CHECK_VALID (false, void, RE () &= RE2 ())\n+CHECK_VALID (false, void, RE () ^= RE2 ())\n+CHECK_VALID (false, void, RE () |= RE ())\n+CHECK_VALID (false, void, RE () &= RE ())\n+CHECK_VALID (false, void, RE () ^= RE ())\n+\n+/* operator OP= (raw_enum, raw_enum), lvalue ref on the lhs. */\n+\n+CHECK_VALID (false, void, re |= RE2 ())\n+CHECK_VALID (false, void, re &= RE2 ())\n+CHECK_VALID (false, void, re ^= RE2 ())\n+CHECK_VALID (true,  RE&,  re |= RE ())\n+CHECK_VALID (true,  RE&,  re &= RE ())\n+CHECK_VALID (true,  RE&,  re ^= RE ())\n+\n+/* operator OP= (enum_flags, raw_enum), rvalue ref on the lhs.  */\n+\n+CHECK_VALID (false, void, EF () |= RE2 ())\n+CHECK_VALID (false, void, EF () &= RE2 ())\n+CHECK_VALID (false, void, EF () ^= RE2 ())\n+CHECK_VALID (false, void, EF () |= RE ())\n+CHECK_VALID (false, void, EF () &= RE ())\n+CHECK_VALID (false, void, EF () ^= RE ())\n+\n+/* operator OP= (enum_flags, raw_enum), lvalue ref on the lhs.  */\n+\n+CHECK_VALID (false, void, ef |= RE2 ())\n+CHECK_VALID (false, void, ef &= RE2 ())\n+CHECK_VALID (false, void, ef ^= RE2 ())\n+CHECK_VALID (true,  EF&,  ef |= EF ())\n+CHECK_VALID (true,  EF&,  ef &= EF ())\n+CHECK_VALID (true,  EF&,  ef ^= EF ())\n+\n+/* operator OP= (enum_flags, enum_flags), rvalue ref on the lhs.  */\n+\n+CHECK_VALID (false, void, EF () |= EF2 ())\n+CHECK_VALID (false, void, EF () &= EF2 ())\n+CHECK_VALID (false, void, EF () ^= EF2 ())\n+CHECK_VALID (false, void, EF () |= EF ())\n+CHECK_VALID (false, void, EF () &= EF ())\n+CHECK_VALID (false, void, EF () ^= EF ())\n+\n+/* operator OP= (enum_flags, enum_flags), lvalue ref on the lhs.  */\n+\n+CHECK_VALID (false, void, ef |= EF2 ())\n+CHECK_VALID (false, void, ef &= EF2 ())\n+CHECK_VALID (false, void, ef ^= EF2 ())\n+CHECK_VALID (true,  EF&,  ef |= EF ())\n+CHECK_VALID (true,  EF&,  ef &= EF ())\n+CHECK_VALID (true,  EF&,  ef ^= EF ())\n+\n+/* operator~ (raw_enum) */\n+\n+CHECK_VALID (false,  void,   ~RE ())\n+CHECK_VALID (true,   URE,    ~URE ())\n+\n+/* operator~ (enum_flags) */\n+\n+CHECK_VALID (false,  void,   ~EF ())\n+CHECK_VALID (true,   UEF,    ~UEF ())\n+\n+/* Check ternary operator.  This exercises implicit conversions.  */\n+\n+CHECK_VALID (true,  EF,   true ? EF () : RE ())\n+CHECK_VALID (true,  EF,   true ? RE () : EF ())\n+\n+/* These are valid, but it's not a big deal since you won't be able to\n+   assign the resulting integer to an enum or an enum_flags without a\n+   cast.\n+\n+   The latter two tests are disabled on older GCCs because they\n+   incorrectly fail with gcc 4.8 and 4.9 at least.  Running the test\n+   outside a SFINAE context shows:\n+\n+    invalid user-defined conversion from \u2018EF\u2019 to \u2018RE2\u2019\n+\n+   They've been confirmed to compile/pass with gcc 5.3, gcc 7.1 and\n+   clang 3.7.  */\n+\n+CHECK_VALID (true,  int,  true ? EF () : EF2 ())\n+CHECK_VALID (true,  int,  true ? EF2 () : EF ())\n+#if GCC_VERSION >= 5003 || defined __clang__\n+CHECK_VALID (true,  int,  true ? EF () : RE2 ())\n+CHECK_VALID (true,  int,  true ? RE2 () : EF ())\n+#endif\n+\n+/* Same, but with an unsigned enum.  */\n+\n+typedef unsigned int uns;\n+\n+CHECK_VALID (true,  uns,  true ? EF () : UEF ())\n+CHECK_VALID (true,  uns,  true ? UEF () : EF ())\n+#if GCC_VERSION >= 5003 || defined __clang__\n+CHECK_VALID (true,  uns,  true ? EF () : URE ())\n+CHECK_VALID (true,  uns,  true ? URE () : EF ())\n+#endif\n+\n+/* Unfortunately this can't work due to the way C++ computes the\n+   return type of the ternary conditional operator.  int isn't\n+   implicitly convertible to the raw enum type, so the type of the\n+   expression is int.  And then int is not implicitly convertible to\n+   enum_flags.\n+\n+   GCC 4.8 fails to compile this test with:\n+     error: operands to ?: have different types \u2018enum_flags<RE>\u2019 and \u2018int\u2019\n+   Confirmed to work with gcc 4.9, 5.3 and clang 3.7.\n+*/\n+#if GCC_VERSION >= 4009 || defined __clang__\n+CHECK_VALID (false, void, true ? EF () : 0)\n+CHECK_VALID (false, void, true ? 0 : EF ())\n+#endif\n+\n+/* Check that the ++/--/<</>>/<<=/>>= operators are deleted.  */\n+\n+CHECK_VALID (false, void, RE ()++)\n+CHECK_VALID (false, void, ++RE ())\n+CHECK_VALID (false, void, --RE ())\n+CHECK_VALID (false, void, RE ()--)\n+\n+CHECK_VALID (false, void, RE () << 1)\n+CHECK_VALID (false, void, RE () >> 1)\n+CHECK_VALID (false, void, EF () << 1)\n+CHECK_VALID (false, void, EF () >> 1)\n+\n+CHECK_VALID (false, void, RE () <<= 1)\n+CHECK_VALID (false, void, RE () >>= 1)\n+CHECK_VALID (false, void, EF () <<= 1)\n+CHECK_VALID (false, void, EF () >>= 1)\n+\n+/* Test comparison operators.  */\n+\n+CHECK_VALID (false, void, EF () == EF2 ())\n+CHECK_VALID (false, void, EF () == RE2 ())\n+CHECK_VALID (false, void, RE () == EF2 ())\n+\n+CHECK_VALID (true,  bool, EF (RE (1)) == EF (RE (1)))\n+CHECK_VALID (true,  bool, EF (RE (1)) == RE (1))\n+CHECK_VALID (true,  bool, RE (1)      == EF (RE (1)))\n+\n+CHECK_VALID (false, void, EF () != EF2 ())\n+CHECK_VALID (false, void, EF () != RE2 ())\n+CHECK_VALID (false, void, RE () != EF2 ())\n+\n+/* On clang, disable -Wenum-compare due to \"error: comparison of two\n+   values with different enumeration types [-Werror,-Wenum-compare]\".\n+   clang doesn't suppress -Wenum-compare in SFINAE contexts.  Not a\n+   big deal since misuses like these in GDB will be caught by -Werror\n+   anyway.  This check is here mainly for completeness.  */\n+#if defined __clang__\n+# pragma GCC diagnostic push\n+# pragma GCC diagnostic ignored \"-Wenum-compare\"\n+#endif\n+CHECK_VALID (true,  bool, RE () == RE2 ())\n+CHECK_VALID (true,  bool, RE () != RE2 ())\n+#if defined __clang__\n+# pragma GCC diagnostic pop\n+#endif\n+\n+CHECK_VALID (true,  bool, EF (RE (1)) != EF (RE (2)))\n+CHECK_VALID (true,  bool, EF (RE (1)) != RE (2))\n+CHECK_VALID (true,  bool, RE (1)      != EF (RE (2)))\n+\n+CHECK_VALID (true,  bool, EF () == 0)\n+\n+/* Check we didn't disable/delete comparison between non-flags enums\n+   and unrelated types by mistake.  */\n+CHECK_VALID (true,  bool, NF (1) == NF (1))\n+CHECK_VALID (true,  bool, NF (1) == int (1))\n+CHECK_VALID (true,  bool, NF (1) == char (1))\n+\n+/* -------------------------------------------------------------------- */\n+\n+/* Follows misc tests that exercise the API.  Some are compile time,\n+   when possible, others are run time.  */\n+\n+enum test_flag\n+  {\n+    FLAG1 = 1 << 1,\n+    FLAG2 = 1 << 2,\n+    FLAG3 = 1 << 3,\n+  };\n+\n+enum test_uflag : unsigned\n+  {\n+    UFLAG1 = 1 << 1,\n+    UFLAG2 = 1 << 2,\n+    UFLAG3 = 1 << 3,\n+  };\n+\n+DEF_ENUM_FLAGS_TYPE (test_flag, test_flags);\n+DEF_ENUM_FLAGS_TYPE (test_uflag, test_uflags);\n+\n+static void\n+self_test ()\n+{\n+  /* Check that default construction works.  */\n+  {\n+    constexpr test_flags f;\n+\n+    gdb_static_assert (f == 0);\n+  }\n+\n+  /* Check that assignment from zero works.  */\n+  {\n+    test_flags f (FLAG1);\n+\n+    SELF_CHECK (f == FLAG1);\n+\n+    f = 0;\n+\n+    SELF_CHECK (f == 0);\n+  }\n+\n+  /* Check that construction from zero works.  */\n+  {\n+    constexpr test_flags zero1 = 0;\n+    constexpr test_flags zero2 (0);\n+    constexpr test_flags zero3 {0};\n+    constexpr test_flags zero4 = {0};\n+\n+    gdb_static_assert (zero1 == 0);\n+    gdb_static_assert (zero2 == 0);\n+    gdb_static_assert (zero3 == 0);\n+    gdb_static_assert (zero4 == 0);\n+  }\n+\n+  /* Check construction from enum value.  */\n+  {\n+    gdb_static_assert (test_flags (FLAG1) == FLAG1);\n+    gdb_static_assert (test_flags (FLAG2) != FLAG1);\n+  }\n+\n+  /* Check copy/assignment.  */\n+  {\n+    constexpr test_flags src = FLAG1;\n+\n+    constexpr test_flags f1 = src;\n+    constexpr test_flags f2 (src);\n+    constexpr test_flags f3 {src};\n+    constexpr test_flags f4 = {src};\n+\n+    gdb_static_assert (f1 == FLAG1);\n+    gdb_static_assert (f2 == FLAG1);\n+    gdb_static_assert (f3 == FLAG1);\n+    gdb_static_assert (f4 == FLAG1);\n+  }\n+\n+  /* Check moving.  */\n+  {\n+    test_flags src = FLAG1;\n+    test_flags dst = 0;\n+\n+    dst = std::move (src);\n+    SELF_CHECK (dst == FLAG1);\n+  }\n+\n+  /* Check construction from an 'or' of multiple bits.  For this to\n+     work, operator| must be overridden to return an enum type.  The\n+     builtin version would return int instead and then the conversion\n+     to test_flags would fail.  */\n+  {\n+    constexpr test_flags f = FLAG1 | FLAG2;\n+    gdb_static_assert (f == (FLAG1 | FLAG2));\n+  }\n+\n+  /* Similarly, check that \"FLAG1 | FLAG2\" on the rhs of an assignment\n+     operator works.  */\n+  {\n+    test_flags f = 0;\n+    f |= FLAG1 | FLAG2;\n+    SELF_CHECK (f == (FLAG1 | FLAG2));\n+\n+    f &= FLAG1 | FLAG2;\n+    SELF_CHECK (f == (FLAG1 | FLAG2));\n+\n+    f ^= FLAG1 | FLAG2;\n+    SELF_CHECK (f == 0);\n+  }\n+\n+  /* Check explicit conversion to int works.  */\n+  {\n+    constexpr int some_bits (FLAG1 | FLAG2);\n+\n+    /* And comparison with int works too.  */\n+    gdb_static_assert (some_bits == (FLAG1 | FLAG2));\n+    gdb_static_assert (some_bits == test_flags (FLAG1 | FLAG2));\n+  }\n+\n+  /* Check operator| and operator|=.  Particularly interesting is\n+     making sure that putting the enum value on the lhs side of the\n+     expression works (FLAG | f).  */\n+  {\n+    test_flags f = FLAG1;\n+    f |= FLAG2;\n+    SELF_CHECK (f == (FLAG1 | FLAG2));\n+  }\n+  {\n+    test_flags f = FLAG1;\n+    f = f | FLAG2;\n+    SELF_CHECK (f == (FLAG1 | FLAG2));\n+  }\n+  {\n+    test_flags f = FLAG1;\n+    f = FLAG2 | f;\n+    SELF_CHECK (f == (FLAG1 | FLAG2));\n+  }\n+\n+  /* Check the &/&= operators.  */\n+  {\n+    test_flags f = FLAG1 & FLAG2;\n+    SELF_CHECK (f == 0);\n+\n+    f = FLAG1 | FLAG2;\n+    f &= FLAG2;\n+    SELF_CHECK (f == FLAG2);\n+\n+    f = FLAG1 | FLAG2;\n+    f = f & FLAG2;\n+    SELF_CHECK (f == FLAG2);\n+\n+    f = FLAG1 | FLAG2;\n+    f = FLAG2 & f;\n+    SELF_CHECK (f == FLAG2);\n+  }\n+\n+  /* Check the ^/^= operators.  */\n+  {\n+    constexpr test_flags f = FLAG1 ^ FLAG2;\n+    gdb_static_assert (f == (FLAG1 ^ FLAG2));\n+  }\n+\n+  {\n+    test_flags f = FLAG1 ^ FLAG2;\n+    f ^= FLAG3;\n+    SELF_CHECK (f == (FLAG1 | FLAG2 | FLAG3));\n+    f = f ^ FLAG3;\n+    SELF_CHECK (f == (FLAG1 | FLAG2));\n+    f = FLAG3 ^ f;\n+    SELF_CHECK (f == (FLAG1 | FLAG2 | FLAG3));\n+  }\n+\n+  /* Check operator~.  Note this only compiles with unsigned\n+     flags.  */\n+  {\n+    constexpr test_uflags f1 = ~UFLAG1;\n+    constexpr test_uflags f2 = ~f1;\n+    gdb_static_assert (f2 == UFLAG1);\n+  }\n+\n+  /* Check the ternary operator.  */\n+\n+  {\n+    /* raw enum, raw enum */\n+    constexpr test_flags f1 = true ? FLAG1 : FLAG2;\n+    gdb_static_assert (f1 == FLAG1);\n+    constexpr test_flags f2 = false ? FLAG1 : FLAG2;\n+    gdb_static_assert (f2 == FLAG2);\n+  }\n+\n+  {\n+    /* enum flags, raw enum */\n+    constexpr test_flags src = FLAG1;\n+    constexpr test_flags f1 = true ? src : FLAG2;\n+    gdb_static_assert (f1 == FLAG1);\n+    constexpr test_flags f2 = false ? src : FLAG2;\n+    gdb_static_assert (f2 == FLAG2);\n+  }\n+\n+  {\n+    /* enum flags, enum flags */\n+    constexpr test_flags src1 = FLAG1;\n+    constexpr test_flags src2 = FLAG2;\n+    constexpr test_flags f1 = true ? src1 : src2;\n+    gdb_static_assert (f1 == src1);\n+    constexpr test_flags f2 = false ? src1 : src2;\n+    gdb_static_assert (f2 == src2);\n+  }\n+\n+  /* Check that we can use flags in switch expressions (requires\n+     unambiguous conversion to integer).  Also check that we can use\n+     operator| in switch cases, where only constants are allowed.\n+     This should work because operator| is constexpr.  */\n+  {\n+    test_flags f = FLAG1 | FLAG2;\n+    bool ok = false;\n+\n+    switch (f)\n+      {\n+      case FLAG1:\n+\tbreak;\n+      case FLAG2:\n+\tbreak;\n+      case FLAG1 | FLAG2:\n+\tok = true;\n+\tbreak;\n+      }\n+\n+    SELF_CHECK (ok);\n+  }\n+}\n+\n+} /* namespace enum_flags_tests */\n+} /* namespace selftests */\n+\n+void _initialize_enum_flags_selftests ();\n+\n+void\n+_initialize_enum_flags_selftests ()\n+{\n+  selftests::register_test (\"enum-flags\",\n+\t\t\t    selftests::enum_flags_tests::self_test);\n+}"
    },
    {
      "sha": "2c35ee709a249478c5c9502c68a755d95ae1a24a",
      "filename": "gdbsupport/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdbsupport/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdbsupport/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/ChangeLog?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -1,3 +1,26 @@\n+2020-09-14  Pedro Alves  <pedro@palves.net>\n+\n+\t* enum-flags.h: Include \"traits.h\".\n+\t(DEF_ENUM_FLAGS_TYPE): Declare a function instead of defining a\n+\tstructure.\n+\t(enum_underlying_type): Update comment.\n+\t(namespace enum_flags_detail): New.  Move struct zero_type here.\n+\t(EnumIsUnsigned, EnumIsSigned): New.\n+\t(class enum_flags): Make most methods constexpr.\n+\t(operator&=, operator|=, operator^=): Take an enum_flags instead\n+\tof an enum_type.  Make rvalue ref versions deleted.\n+\t(operator enum_type()): Delete.\n+\t(operator&, operator|, operator^, operator~): Delete, moved out of\n+\tclass.\n+\t(raw()): New method.\n+\t(is_enum_flags_enum_type_t): Declare.\n+\t(ENUM_FLAGS_GEN_BINOP, ENUM_FLAGS_GEN_COMPOUND_ASSIGN)\n+\t(ENUM_FLAGS_GEN_COMP): New.  Use them to reimplement global\n+\toperators.\n+\t(operator~): Now constexpr and reimplemented.\n+\t(operator<<, operator>>): New deleted functions.\n+\t* valid-expr.h (CHECK_VALID_EXPR_5, CHECK_VALID_EXPR_6): New.\n+\n 2020-09-14  Pedro Alves  <pedro@palves.net>\n \n \t* traits.h (struct nonesuch, struct detector, detected_or)"
    },
    {
      "sha": "d30d90b68d9b8f082d852b365f2b7516b570c01f",
      "filename": "gdbsupport/enum-flags.h",
      "status": "modified",
      "additions": 288,
      "deletions": 82,
      "changes": 370,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdbsupport/enum-flags.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdbsupport/enum-flags.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/enum-flags.h?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -18,6 +18,8 @@\n #ifndef COMMON_ENUM_FLAGS_H\n #define COMMON_ENUM_FLAGS_H\n \n+#include \"traits.h\"\n+\n /* Type-safe wrapper for enum flags.  enum flags are enums where the\n    values are bits that are meant to be ORed together.\n \n@@ -51,23 +53,31 @@\n \n #ifdef __cplusplus\n \n-/* Traits type used to prevent the global operator overloads from\n-   instantiating for non-flag enums.  */\n-template<typename T> struct enum_flags_type {};\n-\n-/* Use this to mark an enum as flags enum.  It defines FLAGS as\n+/* Use this to mark an enum as flags enum.  It defines FLAGS_TYPE as\n    enum_flags wrapper class for ENUM, and enables the global operator\n    overloads for ENUM.  */\n #define DEF_ENUM_FLAGS_TYPE(enum_type, flags_type)\t\\\n   typedef enum_flags<enum_type> flags_type;\t\t\\\n-  template<>\t\t\t\t\t\t\\\n-  struct enum_flags_type<enum_type>\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    typedef enum_flags<enum_type> type;\t\t\t\\\n-  }\n+  void is_enum_flags_enum_type (enum_type *)\n+\n+/* To enable the global enum_flags operators for enum, declare an\n+   \"is_enum_flags_enum_type\" overload that has exactly one parameter,\n+   of type a pointer to that enum class.  E.g.,:\n+\n+     void is_enum_flags_enum_type (enum some_flag *);\n+\n+   The function does not need to be defined, only declared.\n+   DEF_ENUM_FLAGS_TYPE declares this.\n+\n+   A function declaration is preferred over a traits type, because the\n+   former allows calling the DEF_ENUM_FLAGS_TYPE macro inside a\n+   namespace to define the corresponding enum flags type in that\n+   namespace.  The compiler finds the corresponding\n+   is_enum_flags_enum_type function via ADL.  */\n \n-/* Until we can rely on std::underlying type being universally\n-   available (C++11), roll our own for enums.  */\n+/* Note that std::underlying_type<enum_type> is not what we want here,\n+   since that returns unsigned int even when the enum decays to signed\n+   int.  */\n template<int size, bool sign> class integer_for_size { typedef void type; };\n template<> struct integer_for_size<1, 0> { typedef uint8_t type; };\n template<> struct integer_for_size<2, 0> { typedef uint16_t type; };\n@@ -86,128 +96,324 @@ struct enum_underlying_type\n     type;\n };\n \n-template <typename E>\n-class enum_flags\n+namespace enum_flags_detail\n {\n-public:\n-  typedef E enum_type;\n-  typedef typename enum_underlying_type<enum_type>::type underlying_type;\n \n-private:\n-  /* Private type used to support initializing flag types with zero:\n+/* Private type used to support initializing flag types with zero:\n \n-       foo_flags f = 0;\n+   foo_flags f = 0;\n \n-     but not other integers:\n+   but not other integers:\n \n-       foo_flags f = 1;\n+   foo_flags f = 1;\n \n-     The way this works is that we define an implicit constructor that\n-     takes a pointer to this private type.  Since nothing can\n-     instantiate an object of this type, the only possible pointer to\n-     pass to the constructor is the NULL pointer, or, zero.  */\n-  struct zero_type;\n+   The way this works is that we define an implicit constructor that\n+   takes a pointer to this private type.  Since nothing can\n+   instantiate an object of this type, the only possible pointer to\n+   pass to the constructor is the NULL pointer, or, zero.  */\n+struct zero_type;\n \n-  underlying_type\n-  underlying_value () const\n-  {\n-    return m_enum_value;\n-  }\n+/* gdb::Requires trait helpers.  */\n+template <typename enum_type>\n+using EnumIsUnsigned\n+  = std::is_unsigned<typename enum_underlying_type<enum_type>::type>;\n+template <typename enum_type>\n+using EnumIsSigned\n+  = std::is_signed<typename enum_underlying_type<enum_type>::type>;\n+\n+}\n+\n+template <typename E>\n+class enum_flags\n+{\n+public:\n+  typedef E enum_type;\n+  typedef typename enum_underlying_type<enum_type>::type underlying_type;\n \n public:\n   /* Allow default construction.  */\n-  enum_flags ()\n+  constexpr enum_flags ()\n     : m_enum_value ((enum_type) 0)\n   {}\n \n+  /* The default move/copy ctor/assignment do the right thing.  */\n+\n   /* If you get an error saying these two overloads are ambiguous,\n      then you tried to mix values of different enum types.  */\n-  enum_flags (enum_type e)\n+  constexpr enum_flags (enum_type e)\n     : m_enum_value (e)\n   {}\n-  enum_flags (struct enum_flags::zero_type *zero)\n+  constexpr enum_flags (enum_flags_detail::zero_type *zero)\n     : m_enum_value ((enum_type) 0)\n   {}\n \n-  enum_flags &operator&= (enum_type e)\n+  enum_flags &operator&= (enum_flags e) &\n   {\n-    m_enum_value = (enum_type) (underlying_value () & e);\n+    m_enum_value = (enum_type) (m_enum_value & e.m_enum_value);\n     return *this;\n   }\n-  enum_flags &operator|= (enum_type e)\n+  enum_flags &operator|= (enum_flags e) &\n   {\n-    m_enum_value = (enum_type) (underlying_value () | e);\n+    m_enum_value = (enum_type) (m_enum_value | e.m_enum_value);\n     return *this;\n   }\n-  enum_flags &operator^= (enum_type e)\n+  enum_flags &operator^= (enum_flags e) &\n   {\n-    m_enum_value = (enum_type) (underlying_value () ^ e);\n+    m_enum_value = (enum_type) (m_enum_value ^ e.m_enum_value);\n     return *this;\n   }\n \n-  operator enum_type () const\n+  /* Delete rval versions.  */\n+  void operator&= (enum_flags e) && = delete;\n+  void operator|= (enum_flags e) && = delete;\n+  void operator^= (enum_flags e) && = delete;\n+\n+  /* Like raw enums, allow conversion to the underlying type.  */\n+  constexpr operator underlying_type () const\n   {\n     return m_enum_value;\n   }\n \n-  enum_flags operator& (enum_type e) const\n-  {\n-    return (enum_type) (underlying_value () & e);\n-  }\n-  enum_flags operator| (enum_type e) const\n-  {\n-    return (enum_type) (underlying_value () | e);\n-  }\n-  enum_flags operator^ (enum_type e) const\n-  {\n-    return (enum_type) (underlying_value () ^ e);\n-  }\n-  enum_flags operator~ () const\n+  /* Get the underlying value as a raw enum.  */\n+  constexpr enum_type raw () const\n   {\n-    // We only the underlying type to be unsigned when actually using\n-    // operator~ -- if it were not unsigned, undefined behavior could\n-    // result.  However, asserting this in the class itself would\n-    // require too many unnecessary changes to otherwise ok enum\n-    // types.\n-    gdb_static_assert (std::is_unsigned<underlying_type>::value);\n-    return (enum_type) ~underlying_value ();\n+    return m_enum_value;\n   }\n \n+  /* Binary operations involving some unrelated type (which would be a\n+     bug) are implemented as non-members, and deleted.  */\n+\n private:\n   /* Stored as enum_type because GDB knows to print the bit flags\n      neatly if the enum values look like bit flags.  */\n   enum_type m_enum_value;\n };\n \n+template <typename E>\n+using is_enum_flags_enum_type_t\n+  = decltype (is_enum_flags_enum_type (std::declval<E *> ()));\n+\n /* Global operator overloads.  */\n \n-template <typename enum_type>\n-typename enum_flags_type<enum_type>::type\n-operator& (enum_type e1, enum_type e2)\n+/* Generate binary operators.  */\n+\n+#define ENUM_FLAGS_GEN_BINOP(OPERATOR_OP, OP)\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Raw enum on both LHS/RHS.  Returns raw enum type.  */\t\t\\\n+  template <typename enum_type,\t\t\t\t\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_type\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type e1, enum_type e2)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    using underlying = typename enum_flags<enum_type>::underlying_type;\t\\\n+    return (enum_type) (underlying (e1) OP underlying (e2));\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* enum_flags on the LHS.  */\t\t\t\t\t\t\\\n+  template <typename enum_type,\t\t\t\t\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> e1, enum_type e2)\t\t\t\\\n+  { return e1.raw () OP e2; }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* enum_flags on the RHS.  */\t\t\t\t\t\t\\\n+  template <typename enum_type,\t\t\t\t\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type e1, enum_flags<enum_type> e2)\t\t\t\\\n+  { return e1 OP e2.raw (); }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* enum_flags on both LHS/RHS.  */\t\t\t\t\t\\\n+  template <typename enum_type,\t\t\t\t\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> e1, enum_flags<enum_type> e2)\t\\\n+  { return e1.raw () OP e2.raw (); }\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Delete cases involving unrelated types.  */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename unrelated_type,\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type e1, unrelated_type e2) = delete;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename unrelated_type,\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (unrelated_type e1, enum_type e2) = delete;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename unrelated_type,\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> e1, unrelated_type e2) = delete;\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename unrelated_type,\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_flags<enum_type>\t\t\t\t\t\\\n+  OPERATOR_OP (unrelated_type e1, enum_flags<enum_type> e2) = delete;\n+\n+/* Generate non-member compound assignment operators.  Only the raw\n+   enum versions are defined here.  The enum_flags versions are\n+   defined as member functions, simply because it's less code that\n+   way.\n+\n+   Note we delete operators that would allow e.g.,\n+\n+     \"enum_type | 1\" or \"enum_type1 | enum_type2\"\n+\n+   because that would allow a mistake like :\n+     enum flags1 { F1_FLAGS1 = 1 };\n+     enum flags2 { F2_FLAGS2 = 2 };\n+     enum flags1 val;\n+     switch (val) {\n+       case F1_FLAGS1 | F2_FLAGS2:\n+     ...\n+\n+   If you really need to 'or' enumerators of different flag types,\n+   cast to integer first.\n+*/\n+#define ENUM_FLAGS_GEN_COMPOUND_ASSIGN(OPERATOR_OP, OP)\t\t\t\\\n+  /* lval reference version.  */\t\t\t\t\t\\\n+  template <typename enum_type,\t\t\t\t\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_type &\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type &e1, enum_type e2)\t\t\t\t\\\n+  { return e1 = e1 OP e2; }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* rval reference version.  */\t\t\t\t\t\\\n+  template <typename enum_type,\t\t\t\t\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type &&e1, enum_type e2) = delete;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Delete compound assignment from unrelated types.  */\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename other_enum_type,\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  constexpr enum_type &\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type &e1, other_enum_type e2) = delete;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename other_enum_type,\t\t\\\n+\t    typename = is_enum_flags_enum_type_t<enum_type>>\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type &&e1, other_enum_type e2) = delete;\n+\n+ENUM_FLAGS_GEN_BINOP (operator|, |)\n+ENUM_FLAGS_GEN_BINOP (operator&, &)\n+ENUM_FLAGS_GEN_BINOP (operator^, ^)\n+\n+ENUM_FLAGS_GEN_COMPOUND_ASSIGN (operator|=, |)\n+ENUM_FLAGS_GEN_COMPOUND_ASSIGN (operator&=, &)\n+ENUM_FLAGS_GEN_COMPOUND_ASSIGN (operator^=, ^)\n+\n+/* Allow comparison with enum_flags, raw enum, and integers, only.\n+   The latter case allows \"== 0\".  As side effect, it allows comparing\n+   with integer variables too, but that's not a common mistake to\n+   make.  It's important to disable comparison with unrelated types to\n+   prevent accidentally comparing with unrelated enum values, which\n+   are convertible to integer, and thus coupled with enum_flags\n+   convertion to underlying type too, would trigger the built-in 'bool\n+   operator==(unsigned, int)' operator.  */\n+\n+#define ENUM_FLAGS_GEN_COMP(OPERATOR_OP, OP)\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* enum_flags OP enum_flags */\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type>\t\t\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> lhs, enum_flags<enum_type> rhs)\t\\\n+  { return lhs.raw () OP rhs.raw (); }\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* enum_flags OP other */\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type>\t\t\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> lhs, enum_type rhs)\t\t\\\n+  { return lhs.raw () OP rhs; }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type>\t\t\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> lhs, int rhs)\t\t\t\\\n+  { return lhs.raw () OP rhs; }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename U>\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_flags<enum_type> lhs, U rhs) = delete;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* other OP enum_flags */\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type>\t\t\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (enum_type lhs, enum_flags<enum_type> rhs)\t\t\\\n+  { return lhs OP rhs.raw (); }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type>\t\t\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (int lhs, enum_flags<enum_type> rhs)\t\t\t\\\n+  { return lhs OP rhs.raw (); }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  template <typename enum_type, typename U>\t\t\t\t\\\n+  constexpr bool\t\t\t\t\t\t\t\\\n+  OPERATOR_OP (U lhs, enum_flags<enum_type> rhs) = delete;\n+\n+ENUM_FLAGS_GEN_COMP (operator==, ==)\n+ENUM_FLAGS_GEN_COMP (operator!=, !=)\n+\n+/* Unary operators for the raw flags enum.  */\n+\n+/* We require underlying type to be unsigned when using operator~ --\n+   if it were not unsigned, undefined behavior could result.  However,\n+   asserting this in the class itself would require too many\n+   unnecessary changes to usages of otherwise OK enum types.  */\n+template <typename enum_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>,\n+\t  typename\n+\t    = gdb::Requires<enum_flags_detail::EnumIsUnsigned<enum_type>>>\n+constexpr enum_type\n+operator~ (enum_type e)\n {\n-  return enum_flags<enum_type> (e1) & e2;\n+  using underlying = typename enum_flags<enum_type>::underlying_type;\n+  return (enum_type) ~underlying (e);\n }\n \n-template <typename enum_type>\n-typename enum_flags_type<enum_type>::type\n-operator| (enum_type e1, enum_type e2)\n+template <typename enum_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>,\n+\t  typename = gdb::Requires<enum_flags_detail::EnumIsSigned<enum_type>>>\n+constexpr void operator~ (enum_type e) = delete;\n+\n+template <typename enum_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>,\n+\t  typename\n+\t    = gdb::Requires<enum_flags_detail::EnumIsUnsigned<enum_type>>>\n+constexpr enum_flags<enum_type>\n+operator~ (enum_flags<enum_type> e)\n {\n-  return enum_flags<enum_type> (e1) | e2;\n+  using underlying = typename enum_flags<enum_type>::underlying_type;\n+  return (enum_type) ~underlying (e);\n }\n \n-template <typename enum_type>\n-typename enum_flags_type<enum_type>::type\n-operator^ (enum_type e1, enum_type e2)\n-{\n-  return enum_flags<enum_type> (e1) ^ e2;\n-}\n+template <typename enum_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>,\n+\t  typename = gdb::Requires<enum_flags_detail::EnumIsSigned<enum_type>>>\n+constexpr void operator~ (enum_flags<enum_type> e) = delete;\n \n-template <typename enum_type>\n-typename enum_flags_type<enum_type>::type\n-operator~ (enum_type e)\n-{\n-  return ~enum_flags<enum_type> (e);\n-}\n+/* Delete operator<< and operator>>.  */\n+\n+template <typename enum_type, typename any_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>>\n+void operator<< (const enum_type &, const any_type &) = delete;\n+\n+template <typename enum_type, typename any_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>>\n+void operator<< (const enum_flags<enum_type> &, const any_type &) = delete;\n+\n+template <typename enum_type, typename any_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>>\n+void operator>> (const enum_type &, const any_type &) = delete;\n+\n+template <typename enum_type, typename any_type,\n+\t  typename = is_enum_flags_enum_type_t<enum_type>>\n+void operator>> (const enum_flags<enum_type> &, const any_type &) = delete;\n \n #else /* __cplusplus */\n "
    },
    {
      "sha": "459de179266a50c31ca149d4b9c0c68b61cc40d0",
      "filename": "gdbsupport/valid-expr.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdbsupport/valid-expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04902b0995f12ba6f4bdc7c8a2d4a46afae4365d/gdbsupport/valid-expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/valid-expr.h?ref=04902b0995f12ba6f4bdc7c8a2d4a46afae4365d",
      "patch": "@@ -91,4 +91,19 @@\n \t\t\tESC_PARENS (T1, T2, T3, T4),\t\t\t\\\n \t\t\tVALID, EXPR_TYPE, EXPR)\n \n+#define CHECK_VALID_EXPR_5(T1, T2, T3, T4, T5, VALID, EXPR_TYPE, EXPR)\t\\\n+  CHECK_VALID_EXPR_INT (ESC_PARENS (typename T1, typename T2,\t\t\\\n+\t\t\t\t    typename T3, typename T4,\t\t\\\n+\t\t\t\t    typename T5),\t\t\t\\\n+\t\t\tESC_PARENS (T1, T2, T3, T4, T5),\t\t\\\n+\t\t\tVALID, EXPR_TYPE, EXPR)\n+\n+#define CHECK_VALID_EXPR_6(T1, T2, T3, T4, T5, T6,\t\t\t\\\n+\t\t\t   VALID, EXPR_TYPE, EXPR)\t\t\t\\\n+  CHECK_VALID_EXPR_INT (ESC_PARENS (typename T1, typename T2,\t\t\\\n+\t\t\t\t    typename T3, typename T4,\t\t\\\n+\t\t\t\t    typename T5, typename T6),\t\t\\\n+\t\t\tESC_PARENS (T1, T2, T3, T4, T5, T6),\t\t\\\n+\t\t\tVALID, EXPR_TYPE, EXPR)\n+\n #endif /* COMMON_VALID_EXPR_H */"
    }
  ]
}