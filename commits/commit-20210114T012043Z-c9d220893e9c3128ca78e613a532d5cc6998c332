{
  "sha": "c9d220893e9c3128ca78e613a532d5cc6998c332",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzlkMjIwODkzZTljMzEyOGNhNzhlNjEzYTUzMmQ1Y2M2OTk4YzMzMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-01-14T01:20:43Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-14T01:20:43Z"
    },
    "message": "gdb: make the remote target track its own thread resume state\n\nThe next patch moves the target commit_resume method to be a\nprocess_stratum_target-only method.  The only non-process targets that\ncurrently implement the commit_resume method are the btrace and full\nrecord targets.  The only reason they need to do so is to prevent a\ncommit resume from reaching the beneath (process) target if they are\ncurrently replaying.\n\nThis is important if a record target is used on top of the remote target\n(the only process target implementing the commit_resume method).\nCurrently, the remote target checks the `thread_info::executing` flag of\na thread to know if it should commit resume that thread:\n\n    if (!tp->executing || remote_thr->vcont_resumed)\n      continue;\n\nThe `tp->executing` flag is set by infrun when it has asked the target\nstack to resume the thread, and therefore if the thread is executing,\nfrom its point of view.  It _not_ equivalent to whether the remote\ntarget was asked to resume this thread.\n\nIndeed, if infrun asks the target stack to resume some thread while the\nrecord target is replaying, the record target won't forward the resume\nrequest the remote target beneath, because we don't actually want to\nresume the thread on the execution target.  But the `tp->executing` flag\nis still set, because from the point of view of infrun, the thread\nexecutes.  So, if the commit_resume call wasn't intercepted by the\nrecord target as it is today and did reach the remote target, the remote\ntarget would say \"Oh, this thread should be executing and I haven't\nvCont-resumed it!  I must vCont-resume it!\".  But that would be wrong,\nbecause it was never asked to resume this thread, the resume request did\nnot reach it.  This is why the record targets currently need to\nimplement commit_resume: to prevent the beneath target from\ncommit_resuming threads it wasn't asked to resume.\n\nSince commit_resume will become a method on process_stratum_target in\nthe following patch, record targets won't have a chance to intercept the\ncalls and that would result in the remote target commit_resuming threads\nit shouldn't.  To avoid this, this patch makes the remote target track\nits own thread resumption state.  That means, tracking which threads it\nwas asked to resume via target_ops::resume.  Regardless of the context\nof this patch, I think this change makes it easier to understand how\nresume / commit_resume works in the remote target.  It makes the target\nmore self-contained, as it only depends on what it gets asked to do via\nthe target methods, and not on tp->executing, which is a flag maintained\nfrom the point of view of infrun.\n\nI initially made it so this state was only used when the remote target\noperates in non-stop mode, since commit_resume is only used when the\ntarget is non-stop.  However, it's more consistent and it can be useful\nto maintain this state even in all-stop too.  In all-stop, receiving a\nstop notification for one thread means all threads of the target are\nconsidered stopped.\n\nFrom the point of view of the remote target, there are three states a\nthread can be in:\n\n 1. not resumed\n 2. resumed but pending vCont-resume\n 3. resumed\n\nState 2 only exists when the target is non-stop.\n\nAs of this patch, valid state transitions are:\n\n - 1 -> 2 (through the target resume method if in non-stop)\n - 2 -> 3 (through the target commit_resume method if in non-stop)\n - 1 -> 3 (through the target resume method if in all-stop)\n - 3 -> 1 (through a remote stop notification / reporting an event to the\n   event loop)\n\nA subsequent patch will make it possible to go from 2 to 1, in case\ninfrun asks to stop a thread that was resumed but not commit-resumed\nyet.  I don't think it can happen as of now.\n\nIn terms of code, this patch replaces the vcont_resumed field with an\nenumeration that explicitly represents the three states described above.\nThe last_resume_sig and last_resume_step fields are moved to a structure\nwhich is clearly identified as only used when the thread is in the\n\"resumed but pending vCont-resume\" state.\n\ngdb/ChangeLog:\n\n\t* remote.c (enum class resume_state): New.\n\t(struct resumed_pending_vcont_info): New.\n\t(struct remote_thread_info) <resume_state, set_not_resumed,\n\tset_resumed_pending_vcont, resumed_pending_vcont_info,\n\tset_resumed, m_resume_state, m_resumed_pending_vcont_info>:\n\tNew.\n\t<last_resume_step, last_resume_sig, vcont_resumed>: Remove.\n\t(remote_target::remote_add_thread): Adjust.\n\t(remote_target::process_initial_stop_replies): Adjust.\n\t(remote_target::resume): Adjust.\n\t(remote_target::commit_resume): Rely on state in\n\tremote_thread_info and not on tp->executing.\n\t(remote_target::process_stop_reply): Adjust.\n\nChange-Id: I10480919ccb4552faa62575e447a36dbe7c2d523",
    "tree": {
      "sha": "5c80e4e49f23781d576a417f0218b2c6bbd5bc48",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5c80e4e49f23781d576a417f0218b2c6bbd5bc48"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c9d220893e9c3128ca78e613a532d5cc6998c332",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9d220893e9c3128ca78e613a532d5cc6998c332",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c9d220893e9c3128ca78e613a532d5cc6998c332",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9d220893e9c3128ca78e613a532d5cc6998c332/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3eeabe12c3b1550f2341ea114e939e7122109ce5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3eeabe12c3b1550f2341ea114e939e7122109ce5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3eeabe12c3b1550f2341ea114e939e7122109ce5"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 147,
    "deletions": 36
  },
  "files": [
    {
      "sha": "cd4865619c8badc9bb11160c08e9bc78d7c8b013",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c9d220893e9c3128ca78e613a532d5cc6998c332/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c9d220893e9c3128ca78e613a532d5cc6998c332/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c9d220893e9c3128ca78e613a532d5cc6998c332",
      "patch": "@@ -1,3 +1,19 @@\n+2021-01-13  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* remote.c (enum class resume_state): New.\n+\t(struct resumed_pending_vcont_info): New.\n+\t(struct remote_thread_info) <resume_state, set_not_resumed,\n+\tset_resumed_pending_vcont, resumed_pending_vcont_info,\n+\tset_resumed, m_resume_state, m_resumed_pending_vcont_info>:\n+\tNew.\n+\t<last_resume_step, last_resume_sig, vcont_resumed>: Remove.\n+\t(remote_target::remote_add_thread): Adjust.\n+\t(remote_target::process_initial_stop_replies): Adjust.\n+\t(remote_target::resume): Adjust.\n+\t(remote_target::commit_resume): Rely on state in\n+\tremote_thread_info and not on tp->executing.\n+\t(remote_target::process_stop_reply): Adjust.\n+\n 2021-01-13  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* arc-tdep.h (arc_debug_printf): New."
    },
    {
      "sha": "a657902080d7bfa42e23fe7eda876f70971cd7a5",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 131,
      "deletions": 36,
      "changes": 167,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c9d220893e9c3128ca78e613a532d5cc6998c332/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c9d220893e9c3128ca78e613a532d5cc6998c332/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=c9d220893e9c3128ca78e613a532d5cc6998c332",
      "patch": "@@ -1050,6 +1050,38 @@ static struct cmd_list_element *remote_show_cmdlist;\n \n static bool use_range_stepping = true;\n \n+/* From the remote target's point of view, each thread is in one of these three\n+   states.  */\n+enum class resume_state\n+{\n+  /* Not resumed - we haven't been asked to resume this thread.  */\n+  NOT_RESUMED,\n+\n+  /* We have been asked to resume this thread, but haven't sent a vCont action\n+     for it yet.  We'll need to consider it next time commit_resume is\n+     called.  */\n+  RESUMED_PENDING_VCONT,\n+\n+  /* We have been asked to resume this thread, and we have sent a vCont action\n+     for it.  */\n+  RESUMED,\n+};\n+\n+/* Information about a thread's pending vCont-resume.  Used when a thread is in\n+   the remote_resume_state::RESUMED_PENDING_VCONT state.  remote_target::resume\n+   stores this information which is then picked up by\n+   remote_target::commit_resume to know which is the proper action for this\n+   thread to include in the vCont packet.  */\n+struct resumed_pending_vcont_info\n+{\n+  /* True if the last resume call for this thread was a step request, false\n+     if a continue request.  */\n+  bool step;\n+\n+  /* The signal specified in the last resume call for this thread.  */\n+  gdb_signal sig;\n+};\n+\n /* Private data that we'll store in (struct thread_info)->priv.  */\n struct remote_thread_info : public private_thread_info\n {\n@@ -1068,23 +1100,61 @@ struct remote_thread_info : public private_thread_info\n      to stop for a watchpoint.  */\n   CORE_ADDR watch_data_address = 0;\n \n-  /* Fields used by the vCont action coalescing implemented in\n-     remote_resume / remote_commit_resume.  remote_resume stores each\n-     thread's last resume request in these fields, so that a later\n-     remote_commit_resume knows which is the proper action for this\n-     thread to include in the vCont packet.  */\n+  /* Get the thread's resume state.  */\n+  enum resume_state resume_state () const\n+  {\n+    return m_resume_state;\n+  }\n \n-  /* True if the last target_resume call for this thread was a step\n-     request, false if a continue request.  */\n-  int last_resume_step = 0;\n+  /* Put the thread in the NOT_RESUMED state.  */\n+  void set_not_resumed ()\n+  {\n+    m_resume_state = resume_state::NOT_RESUMED;\n+  }\n \n-  /* The signal specified in the last target_resume call for this\n-     thread.  */\n-  gdb_signal last_resume_sig = GDB_SIGNAL_0;\n+  /* Put the thread in the RESUMED_PENDING_VCONT state.  */\n+  void set_resumed_pending_vcont (bool step, gdb_signal sig)\n+  {\n+    m_resume_state = resume_state::RESUMED_PENDING_VCONT;\n+    m_resumed_pending_vcont_info.step = step;\n+    m_resumed_pending_vcont_info.sig = sig;\n+  }\n+\n+  /* Get the information this thread's pending vCont-resumption.\n \n-  /* Whether this thread was already vCont-resumed on the remote\n-     side.  */\n-  int vcont_resumed = 0;\n+     Must only be called if the thread is in the RESUMED_PENDING_VCONT resume\n+     state.  */\n+  const struct resumed_pending_vcont_info &resumed_pending_vcont_info () const\n+  {\n+    gdb_assert (m_resume_state == resume_state::RESUMED_PENDING_VCONT);\n+\n+    return m_resumed_pending_vcont_info;\n+  }\n+\n+  /* Put the thread in the VCONT_RESUMED state.  */\n+  void set_resumed ()\n+  {\n+    m_resume_state = resume_state::RESUMED;\n+  }\n+\n+private:\n+  /* Resume state for this thread.  This is used to implement vCont action\n+     coalescing (only when the target operates in non-stop mode).\n+\n+     remote_target::resume moves the thread to the RESUMED_PENDING_VCONT state,\n+     which notes that this thread must be considered in the next commit_resume\n+     call.\n+\n+     remote_target::commit_resume sends a vCont packet with actions for the\n+     threads in the RESUMED_PENDING_VCONT state and moves them to the\n+     VCONT_RESUMED state.\n+\n+     When reporting a stop to the core for a thread, that thread is moved back\n+     to the NOT_RESUMED state.  */\n+  enum resume_state m_resume_state = resume_state::NOT_RESUMED;\n+\n+  /* Extra info used if the thread is in the RESUMED_PENDING_VCONT state.  */\n+  struct resumed_pending_vcont_info m_resumed_pending_vcont_info;\n };\n \n remote_state::remote_state ()\n@@ -2443,7 +2513,10 @@ remote_target::remote_add_thread (ptid_t ptid, bool running, bool executing)\n   else\n     thread = add_thread (this, ptid);\n \n-  get_remote_thread_info (thread)->vcont_resumed = executing;\n+  /* We start by assuming threads are resumed.  That state then gets updated\n+     when we process a matching stop reply.  */\n+  get_remote_thread_info (thread)->set_resumed ();\n+\n   set_executing (this, ptid, executing);\n   set_running (this, ptid, running);\n \n@@ -4472,7 +4545,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n \n       set_executing (this, event_ptid, false);\n       set_running (this, event_ptid, false);\n-      get_remote_thread_info (evthread)->vcont_resumed = 0;\n+      get_remote_thread_info (evthread)->set_not_resumed ();\n     }\n \n   /* \"Notice\" the new inferiors before anything related to\n@@ -6307,9 +6380,9 @@ remote_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n      individually.  Resuming remote threads directly in target_resume\n      would thus result in sending one packet per thread.  Instead, to\n      minimize roundtrip latency, here we just store the resume\n-     request; the actual remote resumption will be done in\n-     target_commit_resume / remote_commit_resume, where we'll be able\n-     to do vCont action coalescing.  */\n+     request (put the thread in RESUMED_PENDING_VCONT state); the actual remote\n+     resumption will be done in remote_target::commit_resume, where we'll be\n+     able to do vCont action coalescing.  */\n   if (target_is_non_stop_p () && ::execution_direction != EXEC_REVERSE)\n     {\n       remote_thread_info *remote_thr;\n@@ -6319,8 +6392,11 @@ remote_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n       else\n \tremote_thr = get_remote_thread_info (this, ptid);\n \n-      remote_thr->last_resume_step = step;\n-      remote_thr->last_resume_sig = siggnal;\n+      /* We don't expect the core to ask to resume an already resumed (from\n+         its point of view) thread.  */\n+      gdb_assert (remote_thr->resume_state () == resume_state::NOT_RESUMED);\n+\n+      remote_thr->set_resumed_pending_vcont (step, siggnal);\n       return;\n     }\n \n@@ -6339,6 +6415,10 @@ remote_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n   if (!remote_resume_with_vcont (ptid, step, siggnal))\n     remote_resume_with_hc (ptid, step, siggnal);\n \n+  /* Update resumed state tracked by the remote target.  */\n+  for (thread_info *tp : all_non_exited_threads (this, ptid))\n+    get_remote_thread_info (tp)->set_resumed ();\n+\n   /* We are about to start executing the inferior, let's register it\n      with the event loop.  NOTE: this is the one place where all the\n      execution commands end up.  We could alternatively do this in each\n@@ -6562,9 +6642,11 @@ remote_target::commit_resume ()\n \n   for (thread_info *tp : all_non_exited_threads (this))\n     {\n+      remote_thread_info *priv = get_remote_thread_info (tp);\n+\n       /* If a thread of a process is not meant to be resumed, then we\n \t can't wildcard that process.  */\n-      if (!tp->executing)\n+      if (priv->resume_state () == resume_state::NOT_RESUMED)\n \t{\n \t  get_remote_inferior (tp->inf)->may_wildcard_vcont = false;\n \n@@ -6593,24 +6675,24 @@ remote_target::commit_resume ()\n     {\n       remote_thread_info *remote_thr = get_remote_thread_info (tp);\n \n-      if (!tp->executing || remote_thr->vcont_resumed)\n+      /* If the thread was previously vCont-resumed, no need to send a specific\n+\t action for it.  If we didn't receive a resume request for it, don't\n+\t send an action for it either.  */\n+      if (remote_thr->resume_state () != resume_state::RESUMED_PENDING_VCONT)\n \tcontinue;\n \n       gdb_assert (!thread_is_in_step_over_chain (tp));\n \n-      if (!remote_thr->last_resume_step\n-\t  && remote_thr->last_resume_sig == GDB_SIGNAL_0\n-\t  && get_remote_inferior (tp->inf)->may_wildcard_vcont)\n-\t{\n-\t  /* We'll send a wildcard resume instead.  */\n-\t  remote_thr->vcont_resumed = 1;\n-\t  continue;\n-\t}\n+      const resumed_pending_vcont_info &info\n+\t= remote_thr->resumed_pending_vcont_info ();\n \n-      vcont_builder.push_action (tp->ptid,\n-\t\t\t\t remote_thr->last_resume_step,\n-\t\t\t\t remote_thr->last_resume_sig);\n-      remote_thr->vcont_resumed = 1;\n+      /* Check if we need to send a specific action for this thread.  If not,\n+         it will be included in a wildcard resume instead.  */\n+      if (info.step || info.sig != GDB_SIGNAL_0\n+\t  || !get_remote_inferior (tp->inf)->may_wildcard_vcont)\n+\tvcont_builder.push_action (tp->ptid, info.step, info.sig);\n+\n+      remote_thr->set_resumed ();\n     }\n \n   /* Now check whether we can send any process-wide wildcard.  This is\n@@ -7764,7 +7846,20 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n       remote_thr->core = stop_reply->core;\n       remote_thr->stop_reason = stop_reply->stop_reason;\n       remote_thr->watch_data_address = stop_reply->watch_data_address;\n-      remote_thr->vcont_resumed = 0;\n+\n+      if (target_is_non_stop_p ())\n+\t{\n+\t  /* If the target works in non-stop mode, a stop-reply indicates that\n+\t     only this thread stopped.  */\n+\t  remote_thr->set_not_resumed ();\n+\t}\n+      else\n+\t{\n+\t  /* If the target works in all-stop mode, a stop-reply indicates that\n+\t     all the target's threads stopped.  */\n+\t  for (thread_info *tp : all_non_exited_threads (this))\n+\t    get_remote_thread_info (tp)->set_not_resumed ();\n+\t}\n     }\n \n   delete stop_reply;"
    }
  ]
}