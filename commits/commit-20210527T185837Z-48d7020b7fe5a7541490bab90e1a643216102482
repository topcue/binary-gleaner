{
  "sha": "48d7020b7fe5a7541490bab90e1a643216102482",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDhkNzAyMGI3ZmU1YTc1NDE0OTBiYWI5MGUxYTY0MzIxNjEwMjQ4Mg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:37Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:37Z"
    },
    "message": "gdb: add all_bp_locations function\n\nAdd the all_bp_locations function to replace the ALL_BP_LOCATIONS macro.\nFor simplicity, all_bp_locations simply returns a const reference to the\nbp_locations vector.  But the callers just treat it as a range to\niterate on, so if we ever change the breakpoint location storage, we can\nchange the all_bp_locations function to return some other range type,\nand the callers won't need to be changed.\n\ngdb/ChangeLog:\n\n\t* breakpoint.c (ALL_BP_LOCATIONS): Remove, update users to use\n\tall_bp_locations.\n\t(all_bp_locations): New.\n\nChange-Id: Iae71a1ba135c1a5bcdb4658bf3cf9793f0e9f81c",
    "tree": {
      "sha": "0b469080c1e54d845e11fe072dc27efdc3817c47",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0b469080c1e54d845e11fe072dc27efdc3817c47"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/48d7020b7fe5a7541490bab90e1a643216102482",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48d7020b7fe5a7541490bab90e1a643216102482",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/48d7020b7fe5a7541490bab90e1a643216102482",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48d7020b7fe5a7541490bab90e1a643216102482/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5d51cd5d14d12056585cf7525cd82af521e45894",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d51cd5d14d12056585cf7525cd82af521e45894",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5d51cd5d14d12056585cf7525cd82af521e45894"
    }
  ],
  "stats": {
    "total": 90,
    "additions": 32,
    "deletions": 58
  },
  "files": [
    {
      "sha": "b70413b2c212635cc76b359ea90ec4b0564394ae",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48d7020b7fe5a7541490bab90e1a643216102482/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48d7020b7fe5a7541490bab90e1a643216102482/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=48d7020b7fe5a7541490bab90e1a643216102482",
      "patch": "@@ -1,3 +1,9 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* breakpoint.c (ALL_BP_LOCATIONS): Remove, update users to use\n+\tall_bp_locations.\n+\t(all_bp_locations): New.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* breakpoint.c (bp_locations): Change to std::vector, update all"
    },
    {
      "sha": "6dee1a8538fc34c9380baf1e3935cd3867eab585",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 26,
      "deletions": 58,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48d7020b7fe5a7541490bab90e1a643216102482/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48d7020b7fe5a7541490bab90e1a643216102482/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=48d7020b7fe5a7541490bab90e1a643216102482",
      "patch": "@@ -491,15 +491,6 @@ bool target_exact_watchpoints = false;\n \t     B ? (TMP=B->next, 1): 0;\t\\\n \t     B = TMP)\n \n-/* Similar iterator for the low-level breakpoints.  SAFE variant is\n-   not provided so update_global_location_list must not be called\n-   while executing the block of ALL_BP_LOCATIONS.  */\n-\n-#define ALL_BP_LOCATIONS(B,BP_TMP)\t\t\t\t\t\\\n-\tfor (BP_TMP = bp_locations.data ();\t\t\t\t\\\n-\t     BP_TMP < bp_locations.data () + bp_locations.size () && (B = *BP_TMP);\\\n-\t     BP_TMP++)\n-\n /* Iterates through locations with address ADDRESS for the currently selected\n    program space.  BP_LOCP_TMP points to each object.  BP_LOCP_START points\n    to where the loop should start from.\n@@ -556,6 +547,12 @@ all_tracepoints ()\n \n static std::vector<bp_location *> bp_locations;\n \n+static const std::vector<bp_location *> &\n+all_bp_locations ()\n+{\n+  return bp_locations;\n+}\n+\n /* Maximum alignment offset between bp_target_info.PLACED_ADDRESS and\n    ADDRESS for the current elements of BP_LOCATIONS which get a valid\n    result from bp_location_has_shadow.  You can use it for roughly\n@@ -740,7 +737,6 @@ set_condition_evaluation_mode (const char *args, int from_tty,\n   /* Only update the mode if the user picked a different one.  */\n   if (new_mode != old_mode)\n     {\n-      struct bp_location *loc, **loc_tmp;\n       /* If the user switched to a different evaluation mode, we\n \t need to synch the changes with the target as follows:\n \n@@ -752,15 +748,15 @@ set_condition_evaluation_mode (const char *args, int from_tty,\n \t{\n \t  /* Mark everything modified and synch conditions with the\n \t     target.  */\n-\t  ALL_BP_LOCATIONS (loc, loc_tmp)\n+\t  for (bp_location *loc : all_bp_locations ())\n \t    mark_breakpoint_location_modified (loc);\n   \t}\n       else\n \t{\n \t  /* Manually mark non-duplicate locations to synch conditions\n \t     with the target.  We do this to remove all the conditions the\n \t     target knows about.  */\n-\t  ALL_BP_LOCATIONS (loc, loc_tmp)\n+\t  for (bp_location *loc : all_bp_locations ())\n \t    if (is_breakpoint (loc->owner) && loc->inserted)\n \t      loc->needs_update = 1;\n \t}\n@@ -2825,12 +2821,10 @@ insert_bp_location (struct bp_location *bl,\n \t supported, try emulating one with an access watchpoint.  */\n       if (val == 1 && bl->watchpoint_type == hw_read)\n \t{\n-\t  struct bp_location *loc, **loc_temp;\n-\n \t  /* But don't try to insert it, if there's already another\n \t     hw_access location that would be considered a duplicate\n \t     of this one.  */\n-\t  ALL_BP_LOCATIONS (loc, loc_temp)\n+\t  for (bp_location *loc : all_bp_locations ())\n \t    if (loc != bl\n \t\t&& loc->watchpoint_type == hw_access\n \t\t&& watchpoint_locations_match (bl, loc))\n@@ -2895,16 +2889,14 @@ of catchpoint.\"), bl->owner->number);\n void\n breakpoint_program_space_exit (struct program_space *pspace)\n {\n-  struct bp_location *loc, **loc_temp;\n-\n   /* Remove any breakpoint that was set through this program space.  */\n   for (breakpoint *b : all_breakpoints_safe ())\n     if (b->pspace == pspace)\n       delete_breakpoint (b);\n \n   /* Breakpoints set through other program spaces could have locations\n      bound to PSPACE as well.  Remove those.  */\n-  ALL_BP_LOCATIONS (loc, loc_temp)\n+  for (bp_location *loc : all_bp_locations ())\n     {\n       struct bp_location *tmp;\n \n@@ -2958,12 +2950,8 @@ insert_breakpoints (void)\n void\n iterate_over_bp_locations (gdb::function_view<void (bp_location *)> callback)\n {\n-  struct bp_location *loc, **loc_tmp;\n-\n-  ALL_BP_LOCATIONS (loc, loc_tmp)\n-    {\n-      callback (loc);\n-    }\n+  for (bp_location *loc : all_bp_locations ())\n+    callback (loc);\n }\n \n /* This is used when we need to synch breakpoint conditions between GDB and the\n@@ -2973,7 +2961,6 @@ iterate_over_bp_locations (gdb::function_view<void (bp_location *)> callback)\n static void\n update_inserted_breakpoint_locations (void)\n {\n-  struct bp_location *bl, **blp_tmp;\n   int error_flag = 0;\n   int val = 0;\n   int disabled_breaks = 0;\n@@ -2988,7 +2975,7 @@ update_inserted_breakpoint_locations (void)\n \n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n     {\n       /* We only want to update software breakpoints and hardware\n \t breakpoints.  */\n@@ -3029,7 +3016,6 @@ update_inserted_breakpoint_locations (void)\n static void\n insert_breakpoint_locations (void)\n {\n-  struct bp_location *bl, **blp_tmp;\n   int error_flag = 0;\n   int val = 0;\n   int disabled_breaks = 0;\n@@ -3044,7 +3030,7 @@ insert_breakpoint_locations (void)\n \n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n     {\n       if (!should_be_inserted (bl) || (bl->inserted && !bl->needs_update))\n \tcontinue;\n@@ -3129,10 +3115,9 @@ You may have requested too many hardware breakpoints/watchpoints.\\n\");\n int\n remove_breakpoints (void)\n {\n-  struct bp_location *bl, **blp_tmp;\n   int val = 0;\n \n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n   {\n     if (bl->inserted && !is_tracepoint (bl->owner))\n       val |= remove_breakpoint (bl);\n@@ -3167,10 +3152,9 @@ Thread-specific breakpoint %d deleted - thread %s no longer in the thread list.\\\n void\n remove_breakpoints_inf (inferior *inf)\n {\n-  struct bp_location *bl, **blp_tmp;\n   int val;\n \n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n   {\n     if (bl->pspace != inf->pspace)\n       continue;\n@@ -3654,8 +3638,6 @@ breakpoint_event_location_empty_p (const struct breakpoint *b)\n void\n update_breakpoints_after_exec (void)\n {\n-  struct bp_location *bploc, **bplocp_tmp;\n-\n   /* We're about to delete breakpoints from GDB's lists.  If the\n      INSERTED flag is true, GDB will try to lift the breakpoints by\n      writing the breakpoints' \"shadow contents\" back into memory.  The\n@@ -3664,7 +3646,7 @@ update_breakpoints_after_exec (void)\n      breakpoints out as soon as it detects an exec.  We don't do that\n      here instead, because there may be other attempts to delete\n      breakpoints after detecting an exec and before reaching here.  */\n-  ALL_BP_LOCATIONS (bploc, bplocp_tmp)\n+  for (bp_location *bploc : all_bp_locations ())\n     if (bploc->pspace == current_program_space)\n       gdb_assert (!bploc->inserted);\n \n@@ -3775,7 +3757,6 @@ update_breakpoints_after_exec (void)\n int\n detach_breakpoints (ptid_t ptid)\n {\n-  struct bp_location *bl, **blp_tmp;\n   int val = 0;\n   scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n   struct inferior *inf = current_inferior ();\n@@ -3785,7 +3766,7 @@ detach_breakpoints (ptid_t ptid)\n \n   /* Set inferior_ptid; remove_breakpoint_1 uses this global.  */\n   inferior_ptid = ptid;\n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n   {\n     if (bl->pspace != inf->pspace)\n       continue;\n@@ -3980,9 +3961,7 @@ remove_breakpoint (struct bp_location *bl)\n void\n mark_breakpoints_out (void)\n {\n-  struct bp_location *bl, **blp_tmp;\n-\n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n     if (bl->pspace == current_program_space)\n       bl->inserted = 0;\n }\n@@ -4114,10 +4093,9 @@ breakpoint_init_inferior (enum inf_context context)\n enum breakpoint_here\n breakpoint_here_p (const address_space *aspace, CORE_ADDR pc)\n {\n-  struct bp_location *bl, **blp_tmp;\n   int any_breakpoint_here = 0;\n \n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n     {\n       if (bl->loc_type != bp_loc_software_breakpoint\n \t  && bl->loc_type != bp_loc_hardware_breakpoint)\n@@ -4148,9 +4126,7 @@ int\n breakpoint_in_range_p (const address_space *aspace,\n \t\t       CORE_ADDR addr, ULONGEST len)\n {\n-  struct bp_location *bl, **blp_tmp;\n-\n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n     {\n       if (bl->loc_type != bp_loc_software_breakpoint\n \t  && bl->loc_type != bp_loc_hardware_breakpoint)\n@@ -7620,9 +7596,7 @@ create_and_insert_solib_event_breakpoint (struct gdbarch *gdbarch, CORE_ADDR add\n void\n disable_breakpoints_in_shlibs (void)\n {\n-  struct bp_location *loc, **locp_tmp;\n-\n-  ALL_BP_LOCATIONS (loc, locp_tmp)\n+  for (bp_location *loc : all_bp_locations ())\n   {\n     /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */\n     struct breakpoint *b = loc->owner;\n@@ -7653,10 +7627,9 @@ disable_breakpoints_in_shlibs (void)\n static void\n disable_breakpoints_in_unloaded_shlib (struct so_list *solib)\n {\n-  struct bp_location *loc, **locp_tmp;\n   int disabled_shlib_breaks = 0;\n \n-  ALL_BP_LOCATIONS (loc, locp_tmp)\n+  for (bp_location *loc : all_bp_locations ())\n   {\n     /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */\n     struct breakpoint *b = loc->owner;\n@@ -11660,12 +11633,10 @@ bp_location_is_less_than (const bp_location *a, const bp_location *b)\n static void\n bp_locations_target_extensions_update (void)\n {\n-  struct bp_location *bl, **blp_tmp;\n-\n   bp_locations_placed_address_before_address_max = 0;\n   bp_locations_shadow_len_after_address_max = 0;\n \n-  ALL_BP_LOCATIONS (bl, blp_tmp)\n+  for (bp_location *bl : all_bp_locations ())\n     {\n       CORE_ADDR start, end, addr;\n \n@@ -12095,8 +12066,7 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   awp_loc_first = NULL;\n   rwp_loc_first = NULL;\n \n-  bp_location *loc, **locp;\n-  ALL_BP_LOCATIONS (loc, locp)\n+  for (bp_location *loc : all_bp_locations ())\n     {\n       /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always\n \t non-NULL.  */\n@@ -15311,9 +15281,7 @@ pc_at_non_inline_function (const address_space *aspace, CORE_ADDR pc,\n void\n breakpoint_free_objfile (struct objfile *objfile)\n {\n-  struct bp_location **locp, *loc;\n-\n-  ALL_BP_LOCATIONS (loc, locp)\n+  for (bp_location *loc : all_bp_locations ())\n     if (loc->symtab != NULL && SYMTAB_OBJFILE (loc->symtab) == objfile)\n       loc->symtab = NULL;\n }"
    }
  ]
}