{
  "sha": "2b272f449e8664977d0aafba82c416b27b5f2d6f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmIyNzJmNDQ5ZTg2NjQ5NzdkMGFhZmJhODJjNDE2YjI3YjVmMmQ2Zg==",
  "commit": {
    "author": {
      "name": "Martin Liska",
      "email": "mliska@suse.cz",
      "date": "2020-08-15T17:47:01Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-20T01:23:40Z"
    },
    "message": "Use libiberty hash in gas/macro.c.\n\n\t* config/tc-iq2000.c (iq2000_add_macro): Use htab hash table.\n\t* macro.c (struct hash_control): Use htab.\n\t(macro_init): Likewise.\n\t(do_formals): Likewise.\n\t(free_macro): Likewise.\n\t(define_macro): Likewise.\n\t(sub_actual): Likewise.\n\t(macro_expand_body): Likewise.\n\t(macro_expand): Likewise.\n\t(check_macro): Likewise.\n\t(delete_macro): Likewise.\n\t(expand_irp): Likewise.\n\t* macro.h (struct macro_hash_entry): New struct.\n\t(hash_macro_entry): New.\n\t(eq_macro_entry): Likewise.\n\t(macro_entry_alloc): Likewise.\n\t(macro_entry_find): Likewise.\n\t(struct formal_hash_entry): Likewise.\n\t(hash_formal_entry): Likewise.\n\t(eq_formal_entry): Likewise.\n\t(formal_entry_alloc): Likewise.\n\t(formal_entry_find): Likewise.",
    "tree": {
      "sha": "7ea3e404d7c0b07aeac6fb4f3ae2e142d23fd534",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7ea3e404d7c0b07aeac6fb4f3ae2e142d23fd534"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2b272f449e8664977d0aafba82c416b27b5f2d6f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b272f449e8664977d0aafba82c416b27b5f2d6f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2b272f449e8664977d0aafba82c416b27b5f2d6f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b272f449e8664977d0aafba82c416b27b5f2d6f/comments",
  "author": {
    "login": "marxin",
    "id": 2658545,
    "node_id": "MDQ6VXNlcjI2NTg1NDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/marxin",
    "html_url": "https://github.com/marxin",
    "followers_url": "https://api.github.com/users/marxin/followers",
    "following_url": "https://api.github.com/users/marxin/following{/other_user}",
    "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/marxin/subscriptions",
    "organizations_url": "https://api.github.com/users/marxin/orgs",
    "repos_url": "https://api.github.com/users/marxin/repos",
    "events_url": "https://api.github.com/users/marxin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/marxin/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "abebb03c3af215d7542f5e6b71d78823b15220d5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abebb03c3af215d7542f5e6b71d78823b15220d5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/abebb03c3af215d7542f5e6b71d78823b15220d5"
    }
  ],
  "stats": {
    "total": 198,
    "additions": 159,
    "deletions": 39
  },
  "files": [
    {
      "sha": "e474edd12e489abc10c61b424c90de9bb80b6640",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=2b272f449e8664977d0aafba82c416b27b5f2d6f",
      "patch": "@@ -1,3 +1,28 @@\n+2020-08-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* config/tc-iq2000.c (iq2000_add_macro): Use htab hash table.\n+\t* macro.c (struct hash_control): Use htab.\n+\t(macro_init): Likewise.\n+\t(do_formals): Likewise.\n+\t(free_macro): Likewise.\n+\t(define_macro): Likewise.\n+\t(sub_actual): Likewise.\n+\t(macro_expand_body): Likewise.\n+\t(macro_expand): Likewise.\n+\t(check_macro): Likewise.\n+\t(delete_macro): Likewise.\n+\t(expand_irp): Likewise.\n+\t* macro.h (struct macro_hash_entry): New struct.\n+\t(hash_macro_entry): New.\n+\t(eq_macro_entry): Likewise.\n+\t(macro_entry_alloc): Likewise.\n+\t(macro_entry_find): Likewise.\n+\t(struct formal_hash_entry): Likewise.\n+\t(hash_formal_entry): Likewise.\n+\t(eq_formal_entry): Likewise.\n+\t(formal_entry_alloc): Likewise.\n+\t(formal_entry_find): Likewise.\n+\n 2020-08-20  Martin Liska  <mliska@suse.cz>\n \n \t* as.h: Include hashtab.h."
    },
    {
      "sha": "3df89949f2d1f6cead8c0d6b4b6b6280722544ad",
      "filename": "gas/config/tc-iq2000.c",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/config/tc-iq2000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/config/tc-iq2000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-iq2000.c?ref=2b272f449e8664977d0aafba82c416b27b5f2d6f",
      "patch": "@@ -106,7 +106,7 @@ struct iq2000_hi_fixup\n static struct iq2000_hi_fixup * iq2000_hi_fixup_list;\n \n /* Macro hash table, which we will add to.  */\n-extern struct hash_control *macro_hash;\n+extern struct htab *macro_hash;\n \f\n const char *md_shortopts = \"\";\n struct option md_longopts[] =\n@@ -246,7 +246,10 @@ iq2000_add_macro (const char *  name,\n       formal_entry ** p = &macro->formals;\n \n       macro->formal_count = 0;\n-      macro->formal_hash = hash_new ();\n+      macro->formal_hash = htab_create_alloc (7, hash_formal_entry,\n+\t\t\t\t\t      eq_formal_entry,\n+\t\t\t\t\t      NULL, xcalloc, free);\n+\n \n       while (*arguments != NULL)\n \t{\n@@ -272,8 +275,9 @@ iq2000_add_macro (const char *  name,\n \t    sb_add_string (& formal->name, *arguments);\n \n \t  /* Add to macro's hash table.  */\n-\t  hash_jam (macro->formal_hash, sb_terminate (& formal->name), formal);\n-\n+\t  htab_insert (macro->formal_hash,\n+\t\t       formal_entry_alloc (sb_terminate (& formal->name),\n+\t\t\t\t\t   formal));\n \t  formal->index = macro->formal_count;\n \t  macro->formal_count++;\n \t  *p = formal;\n@@ -285,7 +289,7 @@ iq2000_add_macro (const char *  name,\n \n   sb_add_string (&macro_name, name);\n   namestr = sb_terminate (&macro_name);\n-  hash_jam (macro_hash, namestr, macro);\n+  htab_insert (macro_hash, macro_entry_alloc (namestr, macro));\n \n   macro_defined = 1;\n }"
    },
    {
      "sha": "d99430ea4d54a9eb58e284319caf40a822702835",
      "filename": "gas/macro.c",
      "status": "modified",
      "additions": 33,
      "deletions": 32,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/macro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/macro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/macro.c?ref=2b272f449e8664977d0aafba82c416b27b5f2d6f",
      "patch": "@@ -44,7 +44,7 @@\n \n /* The macro hash table.  */\n \n-struct hash_control *macro_hash;\n+struct htab *macro_hash;\n \n /* Whether any macros have been defined.  */\n \n@@ -76,7 +76,8 @@ void\n macro_init (int alternate, int mri, int strip_at,\n \t    size_t (*exp) (const char *, size_t, sb *, offsetT *))\n {\n-  macro_hash = hash_new ();\n+  macro_hash = htab_create_alloc (16, hash_macro_entry, eq_macro_entry,\n+\t\t\t\t  NULL, xcalloc, free);\n   macro_defined = 0;\n   macro_alternate = alternate;\n   macro_mri = mri;\n@@ -566,8 +567,8 @@ do_formals (macro_entry *macro, size_t idx, sb *in)\n \t}\n \n       /* Add to macro's hash table.  */\n-      if (! hash_find (macro->formal_hash, name))\n-\thash_jam (macro->formal_hash, name, formal);\n+      if (formal_entry_find (macro->formal_hash, name) == NULL)\n+\thtab_insert (macro->formal_hash, formal_entry_alloc (name, formal));\n       else\n \tas_bad_where (macro->file,\n \t\t      macro->line,\n@@ -605,13 +606,13 @@ do_formals (macro_entry *macro, size_t idx, sb *in)\n       sb_add_string (&formal->name, name);\n \n       /* Add to macro's hash table.  */\n-      if (hash_find (macro->formal_hash, name))\n+      if (formal_entry_find (macro->formal_hash, name))\n \tas_bad_where (macro->file,\n \t\t      macro->line,\n \t\t      _(\"Reserved word `%s' used as parameter in macro `%s'\"),\n \t\t      name,\n \t\t      macro->name);\n-      hash_jam (macro->formal_hash, name, formal);\n+      htab_insert (macro->formal_hash, formal_entry_alloc (name, formal));\n \n       formal->index = NARG_INDEX;\n       *p = formal;\n@@ -635,7 +636,7 @@ free_macro (macro_entry *macro)\n       formal = formal->next;\n       del_formal (f);\n     }\n-  hash_die (macro->formal_hash);\n+  htab_delete (macro->formal_hash);\n   sb_kill (&macro->sub);\n   free (macro);\n }\n@@ -662,7 +663,8 @@ define_macro (size_t idx, sb *in, sb *label,\n \n   macro->formal_count = 0;\n   macro->formals = 0;\n-  macro->formal_hash = hash_new_sized (7);\n+  macro->formal_hash = htab_create_alloc (7, hash_formal_entry, eq_formal_entry,\n+\t\t\t\t\t  NULL, xcalloc, free);\n \n   idx = sb_skip_white (idx, in);\n   if (! buffer_and_nest (\"MACRO\", \"ENDM\", &macro->sub, get_line))\n@@ -707,10 +709,10 @@ define_macro (size_t idx, sb *in, sb *label,\n   /* And stick it in the macro hash table.  */\n   for (idx = 0; idx < name.len; idx++)\n     name.ptr[idx] = TOLOWER (name.ptr[idx]);\n-  if (hash_find (macro_hash, macro->name))\n+  if (macro_entry_find (macro_hash, macro->name))\n     error = _(\"Macro `%s' was already defined\");\n   if (!error)\n-    error = hash_jam (macro_hash, macro->name, (void *) macro);\n+    htab_insert (macro_hash, macro_entry_alloc (macro->name, macro));\n \n   if (namep != NULL)\n     *namep = macro->name;\n@@ -740,7 +742,7 @@ get_apost_token (size_t idx, sb *in, sb *name, int kind)\n /* Substitute the actual value for a formal parameter.  */\n \n static size_t\n-sub_actual (size_t start, sb *in, sb *t, struct hash_control *formal_hash,\n+sub_actual (size_t start, sb *in, sb *t, struct htab *formal_hash,\n \t    int kind, sb *out, int copyifnotthere)\n {\n   size_t src;\n@@ -754,7 +756,7 @@ sub_actual (size_t start, sb *in, sb *t, struct hash_control *formal_hash,\n       && (src == start || in->ptr[src - 1] != '@'))\n     ptr = NULL;\n   else\n-    ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (t));\n+    ptr = formal_entry_find (formal_hash, sb_terminate (t));\n   if (ptr)\n     {\n       if (ptr->actual.len)\n@@ -790,7 +792,7 @@ sub_actual (size_t start, sb *in, sb *t, struct hash_control *formal_hash,\n \n static const char *\n macro_expand_body (sb *in, sb *out, formal_entry *formals,\n-\t\t   struct hash_control *formal_hash, const macro_entry *macro)\n+\t\t   struct htab *formal_hash, const macro_entry *macro)\n {\n   sb t;\n   size_t src = 0;\n@@ -912,7 +914,7 @@ macro_expand_body (sb *in, sb *out, formal_entry *formals,\n \n \t\t  src = get_token (src, in, &f->name);\n \t\t  name = sb_terminate (&f->name);\n-\t\t  if (! hash_find (formal_hash, name))\n+\t\t  if (formal_entry_find (formal_hash, name) == NULL)\n \t\t    {\n \t\t      static int loccnt;\n \t\t      char buf[20];\n@@ -924,9 +926,7 @@ macro_expand_body (sb *in, sb *out, formal_entry *formals,\n \t\t      sprintf (buf, IS_ELF ? \".LL%04x\" : \"LL%04x\", ++loccnt);\n \t\t      sb_add_string (&f->actual, buf);\n \n-\t\t      err = hash_jam (formal_hash, name, f);\n-\t\t      if (err != NULL)\n-\t\t\tbreak;\n+\t\t      htab_insert (formal_hash, formal_entry_alloc (name, f));\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -966,7 +966,7 @@ macro_expand_body (sb *in, sb *out, formal_entry *formals,\n \n \t  sb_reset (&t);\n \t  src = get_token (src + 2, in, &t);\n-\t  ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (&t));\n+\t  ptr = formal_entry_find (formal_hash, sb_terminate (&t));\n \t  if (ptr == NULL)\n \t    {\n \t      /* FIXME: We should really return a warning string here,\n@@ -1010,7 +1010,8 @@ macro_expand_body (sb *in, sb *out, formal_entry *formals,\n \n       f = loclist->next;\n       name = sb_terminate (&loclist->name);\n-      hash_delete (formal_hash, name, f == NULL);\n+      formal_hash_entry_t needle = { name, NULL };\n+      htab_remove_elt (formal_hash, &needle);\n       del_formal (loclist);\n       loclist = f;\n     }\n@@ -1095,7 +1096,7 @@ macro_expand (size_t idx, sb *in, macro_entry *m, sb *out)\n \t    }\n \n \t  /* Lookup the formal in the macro's list.  */\n-\t  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));\n+\t  ptr = formal_entry_find (m->formal_hash, sb_terminate (&t));\n \t  if (!ptr)\n \t    {\n \t      as_bad (_(\"Parameter named `%s' does not exist for macro `%s'\"),\n@@ -1193,7 +1194,7 @@ macro_expand (size_t idx, sb *in, macro_entry *m, sb *out)\n \n \t  sb_reset (&t);\n \t  sb_add_string (&t, macro_strip_at ? \"$NARG\" : \"NARG\");\n-\t  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));\n+\t  ptr = formal_entry_find (m->formal_hash, sb_terminate (&t));\n \t  sprintf (buffer, \"%d\", narg);\n \t  sb_add_string (&ptr->actual, buffer);\n \t}\n@@ -1253,7 +1254,7 @@ check_macro (const char *line, sb *expand,\n   for (cls = copy; *cls != '\\0'; cls ++)\n     *cls = TOLOWER (*cls);\n \n-  macro = (macro_entry *) hash_find (macro_hash, copy);\n+  macro = macro_entry_find (macro_hash, copy);\n   free (copy);\n \n   if (macro == NULL)\n@@ -1294,14 +1295,14 @@ delete_macro (const char *name)\n   /* We can only ask hash_delete to free memory if we are deleting\n      macros in reverse order to their definition.\n      So just clear out the entry.  */\n-  if ((macro = (macro_entry *) hash_find (macro_hash, copy)) != NULL)\n+  macro = macro_entry_find (macro_hash, copy);\n+  if (macro)\n     {\n-      hash_jam (macro_hash, copy, NULL);\n+      htab_insert (macro_hash, macro_entry_alloc (copy, NULL));\n       free_macro (macro);\n     }\n   else\n     as_warn (_(\"Attempt to purge non-existing macro `%s'\"), copy);\n-  free (copy);\n }\n \n /* Handle the MRI IRP and IRPC pseudo-ops.  These are handled as a\n@@ -1313,8 +1314,8 @@ expand_irp (int irpc, size_t idx, sb *in, sb *out, size_t (*get_line) (sb *))\n {\n   sb sub;\n   formal_entry f;\n-  struct hash_control *h;\n-  const char *err;\n+  struct htab *h;\n+  const char *err = NULL;\n \n   idx = sb_skip_white (idx, in);\n \n@@ -1330,10 +1331,10 @@ expand_irp (int irpc, size_t idx, sb *in, sb *out, size_t (*get_line) (sb *))\n   if (f.name.len == 0)\n     return _(\"missing model parameter\");\n \n-  h = hash_new ();\n-  err = hash_jam (h, sb_terminate (&f.name), &f);\n-  if (err != NULL)\n-    return err;\n+  h = htab_create_alloc (16, hash_formal_entry, eq_formal_entry,\n+\t\t\t NULL, xcalloc, free);\n+\n+  htab_insert (h, formal_entry_alloc (sb_terminate (&f.name), &f));\n \n   f.index = 1;\n   f.next = NULL;\n@@ -1392,7 +1393,7 @@ expand_irp (int irpc, size_t idx, sb *in, sb *out, size_t (*get_line) (sb *))\n \t}\n     }\n \n-  hash_die (h);\n+  htab_delete (h);\n   sb_kill (&f.actual);\n   sb_kill (&f.def);\n   sb_kill (&f.name);"
    },
    {
      "sha": "532642e803ed68894a7d4751de81e432665cd0c7",
      "filename": "gas/macro.h",
      "status": "modified",
      "additions": 92,
      "deletions": 2,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/macro.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b272f449e8664977d0aafba82c416b27b5f2d6f/gas/macro.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/macro.h?ref=2b272f449e8664977d0aafba82c416b27b5f2d6f",
      "patch": "@@ -63,7 +63,7 @@ typedef struct macro_struct\n   sb sub;\t\t\t\t/* Substitution text.  */\n   int formal_count;\t\t\t/* Number of formal args.  */\n   formal_entry *formals;\t\t/* Pointer to list of formal_structs.  */\n-  struct hash_control *formal_hash;\t/* Hash table of formals.  */\n+  struct htab *formal_hash;\t\t/* Hash table of formals.  */\n   const char *name;\t\t\t/* Macro name.  */\n   const char *file;\t\t\t\t/* File the macro was defined in.  */\n   unsigned int line;\t\t\t/* Line number of definition.  */\n@@ -79,7 +79,97 @@ extern int macro_nest;\n \n /* The macro hash table.  */\n \n-extern struct hash_control *macro_hash;\n+extern struct htab *macro_hash;\n+\n+struct macro_hash_entry\n+{\n+  const char *name;\n+  macro_entry *macro;\n+};\n+\n+typedef struct macro_hash_entry macro_hash_entry_t;\n+\n+/* Hash function for a macro_hash_entry.  */\n+\n+static inline hashval_t\n+hash_macro_entry (const void *e)\n+{\n+  const macro_hash_entry_t *entry = (const macro_hash_entry_t *) e;\n+  return htab_hash_string (entry->name);\n+}\n+\n+/* Equality function for a macro_hash_entry.  */\n+\n+static inline int\n+eq_macro_entry (const void *a, const void *b)\n+{\n+  const macro_hash_entry_t *ea = (const macro_hash_entry_t *) a;\n+  const macro_hash_entry_t *eb = (const macro_hash_entry_t *) b;\n+\n+  return strcmp (ea->name, eb->name) == 0;\n+}\n+\n+static inline macro_hash_entry_t *\n+macro_entry_alloc (const char *name, macro_entry *macro)\n+{\n+  macro_hash_entry_t *entry = XNEW (macro_hash_entry_t);\n+  entry->name = name;\n+  entry->macro = macro;\n+  return entry;\n+}\n+\n+static inline macro_entry *\n+macro_entry_find (htab_t table, const char *name)\n+{\n+  macro_hash_entry_t needle = { name, NULL };\n+  macro_hash_entry_t *entry = htab_find (table, &needle);\n+  return entry != NULL ? entry->macro : NULL;\n+}\n+\n+struct formal_hash_entry\n+{\n+  const char *name;\n+  formal_entry *formal;\n+};\n+\n+typedef struct formal_hash_entry formal_hash_entry_t;\n+\n+/* Hash function for a macro_hash_entry.  */\n+\n+static inline hashval_t\n+hash_formal_entry (const void *e)\n+{\n+  const formal_hash_entry_t *entry = (const formal_hash_entry_t *) e;\n+  return htab_hash_string (entry->name);\n+}\n+\n+/* Equality function for a formal_hash_entry.  */\n+\n+static inline int\n+eq_formal_entry (const void *a, const void *b)\n+{\n+  const formal_hash_entry_t *ea = (const formal_hash_entry_t *) a;\n+  const formal_hash_entry_t *eb = (const formal_hash_entry_t *) b;\n+\n+  return strcmp (ea->name, eb->name) == 0;\n+}\n+\n+static inline formal_hash_entry_t *\n+formal_entry_alloc (const char *name, formal_entry *formal)\n+{\n+  formal_hash_entry_t *entry = XNEW (formal_hash_entry_t);\n+  entry->name = name;\n+  entry->formal = formal;\n+  return entry;\n+}\n+\n+static inline formal_entry *\n+formal_entry_find (htab_t table, const char *name)\n+{\n+  formal_hash_entry_t needle = { name, NULL };\n+  formal_hash_entry_t *entry = htab_find (table, &needle);\n+  return entry != NULL ? entry->formal : NULL;\n+}\n \n extern int buffer_and_nest (const char *, const char *, sb *,\n \t\t\t    size_t (*) (sb *));"
    }
  ]
}