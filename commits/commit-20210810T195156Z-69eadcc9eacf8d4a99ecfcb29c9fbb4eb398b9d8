{
  "sha": "69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjllYWRjYzllYWNmOGQ0YTk5ZWNmY2IyOWM5ZmJiNGViMzk4YjlkOA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-05T16:21:35Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-10T19:51:56Z"
    },
    "message": "gdb: iterate only on vfork parent threads in handle_vfork_child_exec_or_exit\n\nI spotted what I think is a buglet in proceed_after_vfork_done.  After a\nvfork child exits or execs, we resume all the threads of the parent.  To\ndo so, we iterate on all threads using iterate_over_threads with the\nproceed_after_vfork_done callback.  Each thread is resumed if the\nfollowing condition is true:\n\n    if (thread->ptid.pid () == pid\n\t&& thread->state == THREAD_RUNNING\n\t&& !thread->executing\n\t&& !thread->stop_requested\n\t&& thread->stop_signal () == GDB_SIGNAL_0)\n\nwhere `pid` is the pid of the vfork parent.  This is not multi-target\naware: since it only filters on pid, if there is an inferior with the\nsame pid in another target, we could end up resuming a thread of that\nother inferior.  The chances of the stars aligning for this to happen\nare tiny, but still.\n\nFix that by iterating only on the vfork parent's threads, instead of on\nall threads.  This is more efficient, as we iterate on just the required\nthreads (inferiors have their own thread list), and we can drop the pid\ncheck.  The resulting code is also more straightforward in my opinion,\nso it's a win-win.\n\nChange-Id: I14647da72e2bf65592e82fbe6efb77a413a4be3a",
    "tree": {
      "sha": "dd3d3a4e13eb3430473b106249c068307da288de",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dd3d3a4e13eb3430473b106249c068307da288de"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3ee0cd9e55368d162aea19a42369f3ee2a1356f3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3ee0cd9e55368d162aea19a42369f3ee2a1356f3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3ee0cd9e55368d162aea19a42369f3ee2a1356f3"
    }
  ],
  "stats": {
    "total": 29,
    "additions": 12,
    "deletions": 17
  },
  "files": [
    {
      "sha": "5ee650fa464581237278b513fc9ce9ac7c91a743",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 12,
      "deletions": 17,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=69eadcc9eacf8d4a99ecfcb29c9fbb4eb398b9d8",
      "patch": "@@ -855,17 +855,13 @@ follow_inferior_reset_breakpoints (void)\n   insert_breakpoints ();\n }\n \n-/* The child has exited or execed: resume threads of the parent the\n-   user wanted to be executing.  */\n+/* The child has exited or execed: resume THREAD, a thread of the parent,\n+   if it was meant to be executing.  */\n \n-static int\n-proceed_after_vfork_done (struct thread_info *thread,\n-\t\t\t  void *arg)\n+static void\n+proceed_after_vfork_done (thread_info *thread)\n {\n-  int pid = * (int *) arg;\n-\n-  if (thread->ptid.pid () == pid\n-      && thread->state == THREAD_RUNNING\n+  if (thread->state == THREAD_RUNNING\n       && !thread->executing\n       && !thread->stop_requested\n       && thread->stop_signal () == GDB_SIGNAL_0)\n@@ -877,8 +873,6 @@ proceed_after_vfork_done (struct thread_info *thread,\n       clear_proceed_status (0);\n       proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT);\n     }\n-\n-  return 0;\n }\n \n /* Called whenever we notice an exec or exit event, to handle\n@@ -891,7 +885,7 @@ handle_vfork_child_exec_or_exit (int exec)\n \n   if (inf->vfork_parent)\n     {\n-      int resume_parent = -1;\n+      inferior *resume_parent = nullptr;\n \n       /* This exec or exit marks the end of the shared memory region\n \t between the parent and the child.  Break the bonds.  */\n@@ -969,7 +963,7 @@ handle_vfork_child_exec_or_exit (int exec)\n \t  inf->removable = 1;\n \t  set_current_program_space (inf->pspace);\n \n-\t  resume_parent = vfork_parent->pid;\n+\t  resume_parent = vfork_parent;\n \t}\n       else\n \t{\n@@ -995,21 +989,22 @@ handle_vfork_child_exec_or_exit (int exec)\n \t  inf->symfile_flags = SYMFILE_NO_READ;\n \t  clone_program_space (inf->pspace, vfork_parent->pspace);\n \n-\t  resume_parent = vfork_parent->pid;\n+\t  resume_parent = vfork_parent;\n \t}\n \n       gdb_assert (current_program_space == inf->pspace);\n \n-      if (non_stop && resume_parent != -1)\n+      if (non_stop && resume_parent != nullptr)\n \t{\n \t  /* If the user wanted the parent to be running, let it go\n \t     free now.  */\n \t  scoped_restore_current_thread restore_thread;\n \n \t  infrun_debug_printf (\"resuming vfork parent process %d\",\n-\t\t\t       resume_parent);\n+\t\t\t       resume_parent->pid);\n \n-\t  iterate_over_threads (proceed_after_vfork_done, &resume_parent);\n+\t  for (thread_info *thread : resume_parent->threads ())\n+\t    proceed_after_vfork_done (thread);\n \t}\n     }\n }"
    }
  ]
}