{
  "sha": "3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2U5ZjFjYTE0OGNhMmVjZjZjZDAwOGVkMjY3OGE0Y2JlMjUzNjIwYg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-06-25T18:23:04Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-06-25T18:23:05Z"
    },
    "message": "Remove dwarf2_cu::language\n\ndwarf2_cu has a 'language' value, but dwarf2_per_cu_data also holds a\nvalue of this same type.  There doesn't seem to be any reason to keep\ntwo copies of this value.  This patch removes the field from\ndwarf2_cu, and arranges to set the value in the per-CU object instead.\n\nNote that the value must still be set when expanding the full CU.\nThis is needed because the CUs will not be scanned when a DWARF index\nis in use.\n\ngdb/ChangeLog\n2021-06-25  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (process_psymtab_comp_unit): Don't set 'lang'.\n\t(scan_partial_symbols, partial_die_parent_scope)\n\t(add_partial_symbol, add_partial_subprogram)\n\t(compute_delayed_physnames, rust_union_quirks)\n\t(process_full_comp_unit, process_full_type_unit)\n\t(process_imported_unit_die, process_die, dw2_linkage_name)\n\t(dwarf2_compute_name, dwarf2_physname, read_import_statement)\n\t(read_file_scope, queue_and_load_dwo_tu, read_func_scope)\n\t(read_variable, dwarf2_get_subprogram_pc_bounds)\n\t(dwarf2_attach_fields_to_type, dwarf2_add_member_fn)\n\t(dwarf2_attach_fn_fields_to_type)\n\t(quirk_ada_thick_pointer_struct, read_structure_type)\n\t(handle_struct_member_die, process_structure_scope)\n\t(read_array_type, read_array_order, prototyped_function_p)\n\t(read_subroutine_type, dwarf2_init_complex_target_type)\n\t(read_base_type, read_subrange_type, read_unspecified_type)\n\t(load_partial_dies, partial_die_info::fixup, set_cu_language)\n\t(new_symbol, need_gnat_info, determine_prefix, typename_concat)\n\t(dwarf2_canonicalize_name, follow_die_offset)\n\t(prepare_one_comp_unit): Update.\n\t* dwarf2/cu.c (dwarf2_cu::start_symtab): Update.",
    "tree": {
      "sha": "07ec34c8c35c5db55e6d2f15329c71311b2e296d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/07ec34c8c35c5db55e6d2f15329c71311b2e296d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bf1dcdb3910e003c29c278ddb48eb56cfd045138",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf1dcdb3910e003c29c278ddb48eb56cfd045138",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bf1dcdb3910e003c29c278ddb48eb56cfd045138"
    }
  ],
  "stats": {
    "total": 324,
    "additions": 176,
    "deletions": 148
  },
  "files": [
    {
      "sha": "dc3b5f6b77d5f6d2941d9261fdd9e5f5eb4c7764",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
      "patch": "@@ -1,3 +1,27 @@\n+2021-06-25  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (process_psymtab_comp_unit): Don't set 'lang'.\n+\t(scan_partial_symbols, partial_die_parent_scope)\n+\t(add_partial_symbol, add_partial_subprogram)\n+\t(compute_delayed_physnames, rust_union_quirks)\n+\t(process_full_comp_unit, process_full_type_unit)\n+\t(process_imported_unit_die, process_die, dw2_linkage_name)\n+\t(dwarf2_compute_name, dwarf2_physname, read_import_statement)\n+\t(read_file_scope, queue_and_load_dwo_tu, read_func_scope)\n+\t(read_variable, dwarf2_get_subprogram_pc_bounds)\n+\t(dwarf2_attach_fields_to_type, dwarf2_add_member_fn)\n+\t(dwarf2_attach_fn_fields_to_type)\n+\t(quirk_ada_thick_pointer_struct, read_structure_type)\n+\t(handle_struct_member_die, process_structure_scope)\n+\t(read_array_type, read_array_order, prototyped_function_p)\n+\t(read_subroutine_type, dwarf2_init_complex_target_type)\n+\t(read_base_type, read_subrange_type, read_unspecified_type)\n+\t(load_partial_dies, partial_die_info::fixup, set_cu_language)\n+\t(new_symbol, need_gnat_info, determine_prefix, typename_concat)\n+\t(dwarf2_canonicalize_name, follow_die_offset)\n+\t(prepare_one_comp_unit): Update.\n+\t* dwarf2/cu.c (dwarf2_cu::start_symtab): Update.\n+\n 2021-06-25  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (read_file_scope): Don't call set_cu_language."
    },
    {
      "sha": "2a90ba8a7b5126af79b1d3618fb174b5ddf48c7b",
      "filename": "gdb/dwarf2/cu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/dwarf2/cu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/dwarf2/cu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/cu.c?ref=3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
      "patch": "@@ -60,7 +60,7 @@ dwarf2_cu::start_symtab (const char *name, const char *comp_dir,\n \n   m_builder.reset (new struct buildsym_compunit\n \t\t   (this->per_objfile->objfile,\n-\t\t    name, comp_dir, language, low_pc));\n+\t\t    name, comp_dir, per_cu->lang, low_pc));\n \n   list_in_scope = get_builder ()->get_file_symbols ();\n "
    },
    {
      "sha": "a4e5630e365a9671ddf05093f19d424e132dc610",
      "filename": "gdb/dwarf2/cu.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/dwarf2/cu.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/dwarf2/cu.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/cu.h?ref=3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
      "patch": "@@ -103,7 +103,6 @@ struct dwarf2_cu\n   gdb::optional<CORE_ADDR> base_address;\n \n   /* The language we are debugging.  */\n-  enum language language = language_unknown;\n   const struct language_defn *language_defn = nullptr;\n \n   const char *producer = nullptr;"
    },
    {
      "sha": "cb3f9e0a2b521d88d9b2b49896d642283178489a",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 151,
      "deletions": 146,
      "changes": 297,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=3e9f1ca148ca2ecf6cd008ed2678a4cbe253620b",
      "patch": "@@ -7044,8 +7044,6 @@ process_psymtab_comp_unit (dwarf2_per_cu_data *this_cu,\n \t\t\t\t      reader.comp_unit_die,\n \t\t\t\t      pretend_language);\n \n-  this_cu->lang = reader.cu->language;\n-\n   /* Age out any secondary CUs.  */\n   per_objfile->age_comp_units ();\n }\n@@ -7561,7 +7559,7 @@ scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,\n \t    case DW_TAG_subprogram:\n \t    case DW_TAG_inlined_subroutine:\n \t      add_partial_subprogram (pdi, lowpc, highpc, set_addrmap, cu);\n-\t      if (cu->language == language_cplus)\n+\t      if (cu->per_cu->lang == language_cplus)\n \t\tscan_partial_symbols (pdi->die_child, lowpc, highpc,\n \t\t\t\t      set_addrmap, cu);\n \t      break;\n@@ -7582,8 +7580,9 @@ scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,\n \t\t{\n \t\t  add_partial_symbol (pdi, cu);\n \t\t}\n-\t      if ((cu->language == language_rust\n-\t\t   || cu->language == language_cplus) && pdi->has_children)\n+\t      if ((cu->per_cu->lang == language_rust\n+\t\t   || cu->per_cu->lang == language_cplus)\n+\t\t  && pdi->has_children)\n \t\tscan_partial_symbols (pdi->die_child, lowpc, highpc,\n \t\t\t\t      set_addrmap, cu);\n \t      break;\n@@ -7622,7 +7621,7 @@ scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,\n \t\t/* Go read the partial unit, if needed.  */\n \t\tif (per_cu->v.psymtab == NULL)\n \t\t  process_psymtab_comp_unit (per_cu, cu->per_objfile, true,\n-\t\t\t\t\t     cu->language);\n+\t\t\t\t\t     cu->per_cu->lang);\n \n \t\tcu->per_cu->imported_symtabs_push (per_cu);\n \t      }\n@@ -7697,7 +7696,7 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n   /* GCC 4.0 and 4.1 had a bug (PR c++/28460) where they generated bogus\n      DW_TAG_namespace DIEs with a name of \"::\" for the global namespace.\n      Work around this problem here.  */\n-  if (cu->language == language_cplus\n+  if (cu->per_cu->lang == language_cplus\n       && parent->tag == DW_TAG_namespace\n       && strcmp (parent->name (cu), \"::\") == 0\n       && grandparent_scope == NULL)\n@@ -7718,7 +7717,7 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n       || parent->tag == DW_TAG_interface_type\n       || parent->tag == DW_TAG_union_type\n       || parent->tag == DW_TAG_enumeration_type\n-      || (cu->language == language_fortran\n+      || (cu->per_cu->lang == language_fortran\n \t  && parent->tag == DW_TAG_subprogram\n \t  && pdi->tag == DW_TAG_subprogram))\n     {\n@@ -7808,7 +7807,8 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \n   partial_symbol psymbol;\n   memset (&psymbol, 0, sizeof (psymbol));\n-  psymbol.ginfo.set_language (cu->language, &objfile->objfile_obstack);\n+  psymbol.ginfo.set_language (cu->per_cu->lang,\n+\t\t\t      &objfile->objfile_obstack);\n   psymbol.ginfo.set_section_index (-1);\n \n   /* The code below indicates that the psymbol should be installed by\n@@ -7822,8 +7822,8 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n       addr = (gdbarch_adjust_dwarf2_addr (gdbarch, pdi->lowpc + baseaddr)\n \t      - baseaddr);\n       if (pdi->is_external\n-\t  || cu->language == language_ada\n-\t  || (cu->language == language_fortran\n+\t  || cu->per_cu->lang == language_ada\n+\t  || (cu->per_cu->lang == language_fortran\n \t      && pdi->die_parent != NULL\n \t      && pdi->die_parent->tag == DW_TAG_subprogram))\n \t{\n@@ -7842,7 +7842,7 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n       psymbol.ginfo.value.address = addr;\n \n       if (pdi->main_subprogram && actual_name != NULL)\n-\tset_objfile_main_name (objfile, actual_name, cu->language);\n+\tset_objfile_main_name (objfile, actual_name, cu->per_cu->lang);\n       break;\n     case DW_TAG_constant:\n       psymbol.domain = VAR_DOMAIN;\n@@ -7947,14 +7947,14 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \t static vs. global.  */\n       psymbol.domain = STRUCT_DOMAIN;\n       psymbol.aclass = LOC_TYPEDEF;\n-      where = (cu->language == language_cplus\n+      where = (cu->per_cu->lang == language_cplus\n \t       ? psymbol_placement::GLOBAL\n \t       : psymbol_placement::STATIC);\n       break;\n     case DW_TAG_enumerator:\n       psymbol.domain = VAR_DOMAIN;\n       psymbol.aclass = LOC_CONST;\n-      where = (cu->language == language_cplus\n+      where = (cu->per_cu->lang == language_cplus\n \t       ? psymbol_placement::GLOBAL\n \t       : psymbol_placement::STATIC);\n       break;\n@@ -7966,7 +7966,8 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n     {\n       if (built_actual_name != nullptr)\n \tactual_name = objfile->intern (actual_name);\n-      if (pdi->linkage_name == nullptr || cu->language == language_ada)\n+      if (pdi->linkage_name == nullptr\n+\t  || cu->per_cu->lang == language_ada)\n \tpsymbol.ginfo.set_linkage_name (actual_name);\n       else\n \t{\n@@ -8078,7 +8079,8 @@ add_partial_subprogram (struct partial_die_info *pdi,\n   if (! pdi->has_children)\n     return;\n \n-  if (cu->language == language_ada || cu->language == language_fortran)\n+  if (cu->per_cu->lang == language_ada\n+      || cu->per_cu->lang == language_fortran)\n     {\n       pdi = pdi->die_child;\n       while (pdi != NULL)\n@@ -8686,7 +8688,7 @@ compute_delayed_physnames (struct dwarf2_cu *cu)\n   /* Only C++ delays computing physnames.  */\n   if (cu->method_list.empty ())\n     return;\n-  gdb_assert (cu->language == language_cplus);\n+  gdb_assert (cu->per_cu->lang == language_cplus);\n \n   for (const delayed_method_info &mi : cu->method_list)\n     {\n@@ -9115,7 +9117,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n static void\n rust_union_quirks (struct dwarf2_cu *cu)\n {\n-  gdb_assert (cu->language == language_rust);\n+  gdb_assert (cu->per_cu->lang == language_rust);\n   for (type *type_ : cu->rust_unions)\n     quirk_rust_enum (type_, cu->per_objfile->objfile);\n   /* We don't need this any more.  */\n@@ -9288,9 +9290,6 @@ process_full_comp_unit (dwarf2_cu *cu, enum language pretend_language)\n   /* Clear the list here in case something was left over.  */\n   cu->method_list.clear ();\n \n-  cu->language = pretend_language;\n-  cu->language_defn = language_def (cu->language);\n-\n   dwarf2_find_base_address (cu->dies, cu);\n \n   /* Before we start reading the top-level DIE, ensure it has a valid tag\n@@ -9312,15 +9311,15 @@ process_full_comp_unit (dwarf2_cu *cu, enum language pretend_language)\n   process_die (cu->dies, cu);\n \n   /* For now fudge the Go package.  */\n-  if (cu->language == language_go)\n+  if (cu->per_cu->lang == language_go)\n     fixup_go_packaging (cu);\n \n   /* Now that we have processed all the DIEs in the CU, all the types\n      should be complete, and it should now be safe to compute all of the\n      physnames.  */\n   compute_delayed_physnames (cu);\n \n-  if (cu->language == language_rust)\n+  if (cu->per_cu->lang == language_rust)\n     rust_union_quirks (cu);\n \n   /* Some compilers don't define a DW_AT_high_pc attribute for the\n@@ -9349,9 +9348,9 @@ process_full_comp_unit (dwarf2_cu *cu, enum language pretend_language)\n       /* Set symtab language to language from DW_AT_language.  If the\n \t compilation is from a C file generated by language preprocessors, do\n \t not set the language if it was already deduced by start_subfile.  */\n-      if (!(cu->language == language_c\n+      if (!(cu->per_cu->lang == language_c\n \t    && COMPUNIT_FILETABS (cust)->language != language_unknown))\n-\tCOMPUNIT_FILETABS (cust)->language = cu->language;\n+\tCOMPUNIT_FILETABS (cust)->language = cu->per_cu->lang;\n \n       /* GCC-4.0 has started to support -fvar-tracking.  GCC-3.x still can\n \t produce DW_AT_location with location lists but it can be possibly\n@@ -9401,22 +9400,19 @@ process_full_type_unit (dwarf2_cu *cu,\n   /* Clear the list here in case something was left over.  */\n   cu->method_list.clear ();\n \n-  cu->language = pretend_language;\n-  cu->language_defn = language_def (cu->language);\n-\n   /* The symbol tables are set up in read_type_unit_scope.  */\n   process_die (cu->dies, cu);\n \n   /* For now fudge the Go package.  */\n-  if (cu->language == language_go)\n+  if (cu->per_cu->lang == language_go)\n     fixup_go_packaging (cu);\n \n   /* Now that we have processed all the DIEs in the CU, all the types\n      should be complete, and it should now be safe to compute all of the\n      physnames.  */\n   compute_delayed_physnames (cu);\n \n-  if (cu->language == language_rust)\n+  if (cu->per_cu->lang == language_rust)\n     rust_union_quirks (cu);\n \n   /* TUs share symbol tables.\n@@ -9437,9 +9433,9 @@ process_full_type_unit (dwarf2_cu *cu,\n \t     compilation is from a C file generated by language preprocessors,\n \t     do not set the language if it was already deduced by\n \t     start_subfile.  */\n-\t  if (!(cu->language == language_c\n+\t  if (!(cu->per_cu->lang == language_c\n \t\t&& COMPUNIT_FILETABS (cust)->language != language_c))\n-\t    COMPUNIT_FILETABS (cust)->language = cu->language;\n+\t    COMPUNIT_FILETABS (cust)->language = cu->per_cu->lang;\n \t}\n     }\n   else\n@@ -9487,9 +9483,10 @@ process_imported_unit_die (struct die_info *die, struct dwarf2_cu *cu)\n \treturn;\n \n       /* If necessary, add it to the queue and load its DIEs.  */\n-      if (maybe_queue_comp_unit (cu, per_cu, per_objfile, cu->language))\n+      if (maybe_queue_comp_unit (cu, per_cu, per_objfile,\n+\t\t\t\t cu->per_cu->lang))\n \tload_full_comp_unit (per_cu, per_objfile, per_objfile->get_cu (per_cu),\n-\t\t\t     false, cu->language);\n+\t\t\t     false, cu->per_cu->lang);\n \n       cu->per_cu->imported_symtabs_push (per_cu);\n     }\n@@ -9547,7 +9544,7 @@ process_die (struct die_info *die, struct dwarf2_cu *cu)\n       break;\n     case DW_TAG_subprogram:\n       /* Nested subprograms in Fortran get a prefix.  */\n-      if (cu->language == language_fortran\n+      if (cu->per_cu->lang == language_fortran\n \t  && die->parent != NULL\n \t  && die->parent->tag == DW_TAG_subprogram)\n \tcu->processing_has_namespace_info = true;\n@@ -9590,7 +9587,7 @@ process_die (struct die_info *die, struct dwarf2_cu *cu)\n       /* We only need to handle this case for Ada -- in other\n \t languages, it's normal for the compiler to emit a typedef\n \t instead.  */\n-      if (cu->language != language_ada)\n+      if (cu->per_cu->lang != language_ada)\n \tbreak;\n       /* FALLTHROUGH */\n     case DW_TAG_base_type:\n@@ -9622,7 +9619,7 @@ process_die (struct die_info *die, struct dwarf2_cu *cu)\n     case DW_TAG_imported_module:\n       cu->processing_has_namespace_info = true;\n       if (die->child != NULL && (die->tag == DW_TAG_imported_declaration\n-\t\t\t\t || cu->language != language_fortran))\n+\t\t\t\t || cu->per_cu->lang != language_fortran))\n \tcomplaint (_(\"Tag '%s' has unexpected children\"),\n \t\t   dwarf_tag_name (die->tag));\n       read_import_statement (die, cu);\n@@ -9734,7 +9731,7 @@ dw2_linkage_name (struct die_info *die, struct dwarf2_cu *cu)\n \n   /* rustc emits invalid values for DW_AT_linkage_name.  Ignore these.\n      See https://github.com/rust-lang/rust/issues/32925.  */\n-  if (cu->language == language_rust && linkage_name != NULL\n+  if (cu->per_cu->lang == language_rust && linkage_name != NULL\n       && strchr (linkage_name, '{') != NULL)\n     linkage_name = NULL;\n \n@@ -9766,15 +9763,17 @@ dwarf2_compute_name (const char *name,\n   if (name == NULL)\n     name = dwarf2_name (die, cu);\n \n+  enum language lang = cu->per_cu->lang;\n+\n   /* For Fortran GDB prefers DW_AT_*linkage_name for the physname if present\n      but otherwise compute it by typename_concat inside GDB.\n      FIXME: Actually this is not really true, or at least not always true.\n      It's all very confusing.  compute_and_set_names doesn't try to demangle\n      Fortran names because there is no mangling standard.  So new_symbol\n      will set the demangled name to the result of dwarf2_full_name, and it is\n      the demangled name that GDB uses if it exists.  */\n-  if (cu->language == language_ada\n-      || (cu->language == language_fortran && physname))\n+  if (lang == language_ada\n+      || (lang == language_fortran && physname))\n     {\n       /* For Ada unit, we prefer the linkage name over the name, as\n \t the former contains the exported name, which the user expects\n@@ -9789,9 +9788,9 @@ dwarf2_compute_name (const char *name,\n \n   /* These are the only languages we know how to qualify names in.  */\n   if (name != NULL\n-      && (cu->language == language_cplus\n-\t  || cu->language == language_fortran || cu->language == language_d\n-\t  || cu->language == language_rust))\n+      && (lang == language_cplus\n+\t  || lang == language_fortran || lang == language_d\n+\t  || lang == language_rust))\n     {\n       if (die_needs_namespace (die, cu))\n \t{\n@@ -9832,12 +9831,11 @@ dwarf2_compute_name (const char *name,\n \t     templates; two instantiated function templates are allowed to\n \t     differ only by their return types, which we do not add here.  */\n \n-\t  if (cu->language == language_cplus && strchr (name, '<') == NULL)\n+\t  if (lang == language_cplus && strchr (name, '<') == NULL)\n \t    {\n \t      struct attribute *attr;\n \t      struct die_info *child;\n \t      int first = 1;\n-\t      const language_defn *cplus_lang = language_def (cu->language);\n \n \t      die->building_fullname = 1;\n \n@@ -9872,8 +9870,8 @@ dwarf2_compute_name (const char *name,\n \n \t\t  if (child->tag == DW_TAG_template_type_param)\n \t\t    {\n-\t\t      cplus_lang->print_type (type, \"\", &buf, -1, 0,\n-\t\t\t\t\t      &type_print_raw_options);\n+\t\t      cu->language_defn->print_type (type, \"\", &buf, -1, 0,\n+\t\t\t\t\t\t     &type_print_raw_options);\n \t\t      continue;\n \t\t    }\n \n@@ -9893,7 +9891,7 @@ dwarf2_compute_name (const char *name,\n \t\t  if (type->has_no_signedness ())\n \t\t    /* GDB prints characters as NUMBER 'CHAR'.  If that's\n \t\t       changed, this can use value_print instead.  */\n-\t\t    cplus_lang->printchar (value, type, &buf);\n+\t\t    cu->language_defn->printchar (value, type, &buf);\n \t\t  else\n \t\t    {\n \t\t      struct value_print_options opts;\n@@ -9939,14 +9937,14 @@ dwarf2_compute_name (const char *name,\n \t     information, if PHYSNAME.  */\n \n \t  if (physname && die->tag == DW_TAG_subprogram\n-\t      && cu->language == language_cplus)\n+\t      && lang == language_cplus)\n \t    {\n \t      struct type *type = read_type_die (die, cu);\n \n-\t      c_type_print_args (type, &buf, 1, cu->language,\n+\t      c_type_print_args (type, &buf, 1, lang,\n \t\t\t\t &type_print_raw_options);\n \n-\t      if (cu->language == language_cplus)\n+\t      if (lang == language_cplus)\n \t\t{\n \t\t  /* Assume that an artificial first parameter is\n \t\t     \"this\", but do not crash if it is not.  RealView\n@@ -9963,7 +9961,7 @@ dwarf2_compute_name (const char *name,\n \n \t  const std::string &intermediate_name = buf.string ();\n \n-\t  if (cu->language == language_cplus)\n+\t  if (lang == language_cplus)\n \t    canonical_name\n \t      = dwarf2_canonicalize_name (intermediate_name.c_str (), cu,\n \t\t\t\t\t  objfile);\n@@ -10014,16 +10012,15 @@ dwarf2_physname (const char *name, struct die_info *die, struct dwarf2_cu *cu)\n   if (!die_needs_namespace (die, cu))\n     return dwarf2_compute_name (name, die, cu, 1);\n \n-  if (cu->language != language_rust)\n+  if (cu->per_cu->lang != language_rust)\n     mangled = dw2_linkage_name (die, cu);\n \n   /* DW_AT_linkage_name is missing in some cases - depend on what GDB\n      has computed.  */\n   gdb::unique_xmalloc_ptr<char> demangled;\n   if (mangled != NULL)\n     {\n-\n-      if (language_def (cu->language)->store_sym_names_in_linkage_form_p ())\n+      if (cu->language_defn->store_sym_names_in_linkage_form_p ())\n \t{\n \t  /* Do nothing (do not demangle the symbol name).  */\n \t}\n@@ -10157,7 +10154,7 @@ read_namespace_alias (struct die_info *die, struct dwarf2_cu *cu)\n static struct using_direct **\n using_directives (struct dwarf2_cu *cu)\n {\n-  if (cu->language == language_ada\n+  if (cu->per_cu->lang == language_ada\n       && cu->get_builder ()->outermost_context_p ())\n     return cu->get_builder ()->get_global_using_directives ();\n   else\n@@ -10248,12 +10245,15 @@ read_import_statement (struct die_info *die, struct dwarf2_cu *cu)\n   else if (strlen (imported_name_prefix) > 0)\n     canonical_name = obconcat (&objfile->objfile_obstack,\n \t\t\t       imported_name_prefix,\n-\t\t\t       (cu->language == language_d ? \".\" : \"::\"),\n+\t\t\t       (cu->per_cu->lang == language_d\n+\t\t\t\t? \".\"\n+\t\t\t\t: \"::\"),\n \t\t\t       imported_name, (char *) NULL);\n   else\n     canonical_name = imported_name;\n \n-  if (die->tag == DW_TAG_imported_module && cu->language == language_fortran)\n+  if (die->tag == DW_TAG_imported_module\n+      && cu->per_cu->lang == language_fortran)\n     for (child_die = die->child; child_die && child_die->tag;\n \t child_die = child_die->sibling)\n       {\n@@ -10494,7 +10494,7 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)\n   struct die_info *child_die;\n   CORE_ADDR baseaddr;\n \n-  prepare_one_comp_unit (cu, die, cu->language);\n+  prepare_one_comp_unit (cu, die, cu->per_cu->lang);\n   baseaddr = objfile->text_section_offset ();\n \n   get_scope_pc_bounds (die, &lowpc, &highpc, cu);\n@@ -12701,7 +12701,7 @@ queue_and_load_dwo_tu (void **slot, void *info)\n \t a real dependency of PER_CU on SIG_TYPE.  That is detected later\n \t while processing PER_CU.  */\n       if (maybe_queue_comp_unit (NULL, sig_type, cu->per_objfile,\n-\t\t\t\t cu->language))\n+\t\t\t\t cu->per_cu->lang))\n \tload_full_type_unit (sig_type, cu->per_objfile);\n       cu->per_cu->imported_symtabs_push (sig_type);\n     }\n@@ -12989,7 +12989,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n   if (dwarf2_flag_true_p (die, DW_AT_main_subprogram, cu))\n     set_objfile_main_name (objfile, newobj->name->linkage_name (),\n-\t\t\t   cu->language);\n+\t\t\t   cu->per_cu->lang);\n \n   /* If there is a location expression for DW_AT_frame_base, record\n      it.  */\n@@ -13034,7 +13034,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n   /* If we have a DW_AT_specification, we might need to import using\n      directives from the context of the specification DIE.  See the\n      comment in determine_prefix.  */\n-  if (cu->language == language_cplus\n+  if (cu->per_cu->lang == language_cplus\n       && dwarf2_attr (die, DW_AT_specification, cu))\n     {\n       struct dwarf2_cu *spec_cu = cu;\n@@ -13062,10 +13062,10 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t\t\t     cstk.static_link, lowpc, highpc);\n \n   /* For C++, set the block's scope.  */\n-  if ((cu->language == language_cplus\n-       || cu->language == language_fortran\n-       || cu->language == language_d\n-       || cu->language == language_rust)\n+  if ((cu->per_cu->lang == language_cplus\n+       || cu->per_cu->lang == language_fortran\n+       || cu->per_cu->lang == language_d\n+       || cu->per_cu->lang == language_rust)\n       && cu->processing_has_namespace_info)\n     block_set_scope (block, determine_prefix (die, cu),\n \t\t     &objfile->objfile_obstack);\n@@ -13541,7 +13541,7 @@ read_variable (struct die_info *die, struct dwarf2_cu *cu)\n {\n   struct rust_vtable_symbol *storage = NULL;\n \n-  if (cu->language == language_rust)\n+  if (cu->per_cu->lang == language_rust)\n     {\n       struct type *containing_type = rust_containing_type (die, cu);\n \n@@ -14047,7 +14047,7 @@ dwarf2_get_subprogram_pc_bounds (struct die_info *die,\n \n   /* If the language does not allow nested subprograms (either inside\n      subprograms or lexical blocks), we're done.  */\n-  if (cu->language != language_ada)\n+  if (cu->per_cu->lang != language_ada)\n     return;\n \n   /* Check all the children of the given DIE.  If it contains nested\n@@ -14814,7 +14814,7 @@ dwarf2_attach_fields_to_type (struct field_info *fip, struct type *type,\n   type->set_fields\n     ((struct field *) TYPE_ZALLOC (type, sizeof (struct field) * nfields));\n \n-  if (fip->non_public_fields && cu->language != language_ada)\n+  if (fip->non_public_fields && cu->per_cu->lang != language_ada)\n     {\n       ALLOCATE_CPLUS_STRUCT_TYPE (type);\n \n@@ -14833,7 +14833,7 @@ dwarf2_attach_fields_to_type (struct field_info *fip, struct type *type,\n \n   /* If the type has baseclasses, allocate and clear a bit vector for\n      TYPE_FIELD_VIRTUAL_BITS.  */\n-  if (!fip->baseclasses.empty () && cu->language != language_ada)\n+  if (!fip->baseclasses.empty () && cu->per_cu->lang != language_ada)\n     {\n       int num_bytes = B_BYTES (fip->baseclasses.size ());\n       unsigned char *pointer;\n@@ -14859,12 +14859,12 @@ dwarf2_attach_fields_to_type (struct field_info *fip, struct type *type,\n       switch (field.accessibility)\n \t{\n \tcase DW_ACCESS_private:\n-\t  if (cu->language != language_ada)\n+\t  if (cu->per_cu->lang != language_ada)\n \t    SET_TYPE_FIELD_PRIVATE (type, i);\n \t  break;\n \n \tcase DW_ACCESS_protected:\n-\t  if (cu->language != language_ada)\n+\t  if (cu->per_cu->lang != language_ada)\n \t    SET_TYPE_FIELD_PROTECTED (type, i);\n \t  break;\n \n@@ -14885,7 +14885,7 @@ dwarf2_attach_fields_to_type (struct field_info *fip, struct type *type,\n \t    {\n \t    case DW_VIRTUALITY_virtual:\n \t    case DW_VIRTUALITY_pure_virtual:\n-\t      if (cu->language == language_ada)\n+\t      if (cu->per_cu->lang == language_ada)\n \t\terror (_(\"unexpected virtuality in component of Ada type\"));\n \t      SET_TYPE_FIELD_VIRTUAL (type, i);\n \t      break;\n@@ -14936,7 +14936,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n   const char *fieldname;\n   struct type *this_type;\n \n-  if (cu->language == language_ada)\n+  if (cu->per_cu->lang == language_ada)\n     error (_(\"unexpected member function in Ada type\"));\n \n   /* Get name of member function.  */\n@@ -14969,7 +14969,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n   fnp = &flp->fnfields.back ();\n \n   /* Delay processing of the physname until later.  */\n-  if (cu->language == language_cplus)\n+  if (cu->per_cu->lang == language_cplus)\n     add_to_method_list (type, i, flp->fnfields.size () - 1, fieldname,\n \t\t\tdie, cu);\n   else\n@@ -15124,7 +15124,7 @@ static void\n dwarf2_attach_fn_fields_to_type (struct field_info *fip, struct type *type,\n \t\t\t\t struct dwarf2_cu *cu)\n {\n-  if (cu->language == language_ada)\n+  if (cu->per_cu->lang == language_ada)\n     error (_(\"unexpected member functions in Ada type\"));\n \n   ALLOCATE_CPLUS_STRUCT_TYPE (type);\n@@ -15267,7 +15267,7 @@ static void\n quirk_ada_thick_pointer_struct (struct die_info *die, struct dwarf2_cu *cu,\n \t\t\t\tstruct type *type)\n {\n-  gdb_assert (cu->language == language_ada);\n+  gdb_assert (cu->per_cu->lang == language_ada);\n \n   /* Check for a structure with two children.  */\n   if (type->code () != TYPE_CODE_STRUCT || type->num_fields () != 2)\n@@ -15446,9 +15446,9 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n   name = dwarf2_name (die, cu);\n   if (name != NULL)\n     {\n-      if (cu->language == language_cplus\n-\t  || cu->language == language_d\n-\t  || cu->language == language_rust)\n+      if (cu->per_cu->lang == language_cplus\n+\t  || cu->per_cu->lang == language_d\n+\t  || cu->per_cu->lang == language_rust)\n \t{\n \t  const char *full_name = dwarf2_full_name (name, die, cu);\n \n@@ -15480,7 +15480,7 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n       type->set_code (TYPE_CODE_STRUCT);\n     }\n \n-  if (cu->language == language_cplus && die->tag == DW_TAG_class_type)\n+  if (cu->per_cu->lang == language_cplus && die->tag == DW_TAG_class_type)\n     type->set_is_declared_class (true);\n \n   /* Store the calling convention in the type if it's available in\n@@ -15691,7 +15691,7 @@ handle_struct_member_die (struct die_info *child_die, struct type *type,\n       /* Rust doesn't have member functions in the C++ sense.\n \t However, it does emit ordinary functions as children\n \t of a struct DIE.  */\n-      if (cu->language == language_rust)\n+      if (cu->per_cu->lang == language_rust)\n \tread_func_scope (child_die, cu);\n       else\n \t{\n@@ -15852,7 +15852,8 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n       /* Copy fi.nested_types_list linked list elements content into the\n \t allocated array TYPE_NESTED_TYPES_ARRAY (type).  */\n-      if (!fi.nested_types_list.empty () && cu->language != language_ada)\n+      if (!fi.nested_types_list.empty ()\n+\t  && cu->per_cu->lang != language_ada)\n \t{\n \t  int count = fi.nested_types_list.size ();\n \n@@ -15868,9 +15869,9 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n     }\n \n   quirk_gcc_member_function_pointer (type, objfile);\n-  if (cu->language == language_rust && die->tag == DW_TAG_union_type)\n+  if (cu->per_cu->lang == language_rust && die->tag == DW_TAG_union_type)\n     cu->rust_unions.push_back (type);\n-  else if (cu->language == language_ada)\n+  else if (cu->per_cu->lang == language_ada)\n     quirk_ada_thick_pointer_struct (die, cu, type);\n \n   /* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its\n@@ -16573,7 +16574,7 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n   maybe_set_alignment (cu, die, type);\n \n   struct type *replacement_type = nullptr;\n-  if (cu->language == language_ada)\n+  if (cu->per_cu->lang == language_ada)\n     {\n       replacement_type = quirk_ada_thick_pointer (die, cu, type);\n       if (replacement_type != nullptr)\n@@ -16610,7 +16611,7 @@ read_array_order (struct die_info *die, struct dwarf2_cu *cu)\n      FIXME: dsl/2004-8-20: If G77 is ever fixed, this will also need\n      version checking.  */\n \n-  if (cu->language == language_fortran\n+  if (cu->per_cu->lang == language_fortran\n       && cu->producer && strstr (cu->producer, \"GNU F77\"))\n     {\n       return DW_ORD_row_major;\n@@ -17349,9 +17350,9 @@ prototyped_function_p (struct die_info *die, struct dwarf2_cu *cu)\n      languages that allow unprototyped functions (Eg: Objective C).\n      For all other languages, assume that functions are always\n      prototyped.  */\n-  if (cu->language != language_c\n-      && cu->language != language_objc\n-      && cu->language != language_opencl)\n+  if (cu->per_cu->lang != language_c\n+      && cu->per_cu->lang != language_objc\n+      && cu->per_cu->lang != language_opencl)\n     return 1;\n \n   /* RealView does not emit DW_AT_prototyped.  We can not distinguish\n@@ -17476,7 +17477,8 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n \t      /* RealView does not mark THIS as const, which the testsuite\n \t\t expects.  GCC marks THIS as const in method definitions,\n \t\t but not in the class specifications (GCC PR 43053).  */\n-\t      if (cu->language == language_cplus && !TYPE_CONST (arg_type)\n+\t      if (cu->per_cu->lang == language_cplus\n+\t\t  && !TYPE_CONST (arg_type)\n \t\t  && TYPE_FIELD_ARTIFICIAL (ftype, iparams))\n \t\t{\n \t\t  int is_this = 0;\n@@ -17911,7 +17913,7 @@ dwarf2_init_complex_target_type (struct dwarf2_cu *cu,\n   /* Try to find a suitable floating point builtin type of size BITS.\n      We're going to use the name of this type as the name for the complex\n      target type that we are about to create.  */\n-  switch (cu->language)\n+  switch (cu->per_cu->lang)\n     {\n     case language_fortran:\n       switch (bits)\n@@ -18001,7 +18003,7 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n     }\n \n   if ((encoding == DW_ATE_signed_fixed || encoding == DW_ATE_unsigned_fixed)\n-      && cu->language == language_ada\n+      && cu->per_cu->lang == language_ada\n       && has_zero_over_zero_small_attribute (die, cu))\n     {\n       /* brobecker/2018-02-24: This is a fixed point type for which\n@@ -18023,7 +18025,7 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n      than an \"else if\".  */\n   const char *gnat_encoding_suffix = nullptr;\n   if ((encoding == DW_ATE_signed || encoding == DW_ATE_unsigned)\n-      && cu->language == language_ada\n+      && cu->per_cu->lang == language_ada\n       && name != nullptr)\n     {\n       gnat_encoding_suffix = gnat_encoded_fixed_point_type_info (name);\n@@ -18080,26 +18082,28 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \ttype = dwarf2_init_integer_type (cu, objfile, bits, 0, name);\n \tbreak;\n       case DW_ATE_unsigned:\n-\tif (cu->language == language_fortran\n+\tif (cu->per_cu->lang == language_fortran\n \t    && name\n \t    && startswith (name, \"character(\"))\n \t  type = init_character_type (objfile, bits, 1, name);\n \telse\n \t  type = dwarf2_init_integer_type (cu, objfile, bits, 1, name);\n \tbreak;\n       case DW_ATE_signed_char:\n-\tif (cu->language == language_ada || cu->language == language_m2\n-\t    || cu->language == language_pascal\n-\t    || cu->language == language_fortran)\n+\tif (cu->per_cu->lang == language_ada\n+\t    || cu->per_cu->lang == language_m2\n+\t    || cu->per_cu->lang == language_pascal\n+\t    || cu->per_cu->lang == language_fortran)\n \t  type = init_character_type (objfile, bits, 0, name);\n \telse\n \t  type = dwarf2_init_integer_type (cu, objfile, bits, 0, name);\n \tbreak;\n       case DW_ATE_unsigned_char:\n-\tif (cu->language == language_ada || cu->language == language_m2\n-\t    || cu->language == language_pascal\n-\t    || cu->language == language_fortran\n-\t    || cu->language == language_rust)\n+\tif (cu->per_cu->lang == language_ada\n+\t    || cu->per_cu->lang == language_m2\n+\t    || cu->per_cu->lang == language_pascal\n+\t    || cu->per_cu->lang == language_fortran\n+\t    || cu->per_cu->lang == language_rust)\n \t  type = init_character_type (objfile, bits, 1, name);\n \telse\n \t  type = dwarf2_init_integer_type (cu, objfile, bits, 1, name);\n@@ -18394,7 +18398,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   /* Set LOW_DEFAULT_IS_VALID if current language and DWARF version allow\n      omitting DW_AT_lower_bound.  */\n-  switch (cu->language)\n+  switch (cu->per_cu->lang)\n     {\n     case language_c:\n     case language_cplus:\n@@ -18530,7 +18534,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n     range_type->bounds ()->flag_upper_bound_is_count = 1;\n \n   /* Ada expects an empty array on no boundary attributes.  */\n-  if (attr == NULL && cu->language != language_ada)\n+  if (attr == NULL && cu->per_cu->lang != language_ada)\n     range_type->bounds ()->high.set_undefined ();\n \n   name = dwarf2_name (die, cu);\n@@ -18563,7 +18567,7 @@ read_unspecified_type (struct die_info *die, struct dwarf2_cu *cu)\n      of the type is deferred to a different unit.  When encountering\n      such a type, we treat it as a stub, and try to resolve it later on,\n      when needed.  */\n-  if (cu->language == language_ada)\n+  if (cu->per_cu->lang == language_ada)\n     type->set_is_stub (true);\n \n   return set_die_type (die, type, cu);\n@@ -18863,7 +18867,7 @@ load_partial_dies (const struct die_reader_specs *reader,\n       /* Check for template arguments.  We never save these; if\n \t they're seen, we just mark the parent, and go on our way.  */\n       if (parent_die != NULL\n-\t  && cu->language == language_cplus\n+\t  && cu->per_cu->lang == language_cplus\n \t  && (abbrev->tag == DW_TAG_template_type_param\n \t      || abbrev->tag == DW_TAG_template_value_param))\n \t{\n@@ -18880,7 +18884,7 @@ load_partial_dies (const struct die_reader_specs *reader,\n       /* We only recurse into c++ subprograms looking for template arguments.\n \t Skip their other children.  */\n       if (!load_all\n-\t  && cu->language == language_cplus\n+\t  && cu->per_cu->lang == language_cplus\n \t  && parent_die != NULL\n \t  && parent_die->tag == DW_TAG_subprogram\n \t  && abbrev->tag != DW_TAG_inlined_subroutine)\n@@ -18894,7 +18898,7 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t later variables referencing them via DW_AT_specification (for\n \t static members).  */\n       if (!load_all\n-\t  && !is_type_tag_for_partial (abbrev->tag, cu->language)\n+\t  && !is_type_tag_for_partial (abbrev->tag, cu->per_cu->lang)\n \t  && abbrev->tag != DW_TAG_constant\n \t  && abbrev->tag != DW_TAG_enumerator\n \t  && abbrev->tag != DW_TAG_subprogram\n@@ -19051,17 +19055,17 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t      || last_die->tag == DW_TAG_namespace\n \t      || last_die->tag == DW_TAG_module\n \t      || last_die->tag == DW_TAG_enumeration_type\n-\t      || (cu->language == language_cplus\n+\t      || (cu->per_cu->lang == language_cplus\n \t\t  && last_die->tag == DW_TAG_subprogram\n \t\t  && (last_die->raw_name == NULL\n \t\t      || strchr (last_die->raw_name, '<') == NULL))\n-\t      || (cu->language != language_c\n+\t      || (cu->per_cu->lang != language_c\n \t\t  && (last_die->tag == DW_TAG_class_type\n \t\t      || last_die->tag == DW_TAG_interface_type\n \t\t      || last_die->tag == DW_TAG_structure_type\n \t\t      || last_die->tag == DW_TAG_union_type))\n-\t      || ((cu->language == language_ada\n-\t\t   || cu->language == language_fortran)\n+\t      || ((cu->per_cu->lang == language_ada\n+\t\t   || cu->per_cu->lang == language_fortran)\n \t\t  && (last_die->tag == DW_TAG_subprogram\n \t\t      || last_die->tag == DW_TAG_lexical_block))))\n \t{\n@@ -19237,7 +19241,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t     information, we support this practice for backward\n \t     compatibility.  */\n \t  if (attr.constant_value (0) == DW_CC_program\n-\t      && cu->language == language_fortran)\n+\t      && cu->per_cu->lang == language_fortran)\n \t    main_subprogram = 1;\n \t  break;\n \tcase DW_AT_inline:\n@@ -19289,7 +19293,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n      of the order in which the name and linkage name were emitted.\n      Really, though, this is just a workaround for the fact that gdb\n      doesn't store both the name and the linkage name.  */\n-  if (cu->language == language_ada && linkage_name != nullptr)\n+  if (cu->per_cu->lang == language_ada && linkage_name != nullptr)\n     raw_name = linkage_name;\n \n   if (high_pc_relative)\n@@ -19555,7 +19559,7 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n   /* If there is no parent die to provide a namespace, and there are\n      children, see if we can determine the namespace from their linkage\n      name.  */\n-  if (cu->language == language_cplus\n+  if (cu->per_cu->lang == language_cplus\n       && !cu->per_objfile->per_bfd->types.empty ()\n       && die_parent == NULL\n       && has_children\n@@ -21541,16 +21545,16 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       OBJSTAT (objfile, n_syms++);\n \n       /* Cache this symbol's name and the name's demangled form (if any).  */\n-      sym->set_language (cu->language, &objfile->objfile_obstack);\n+      sym->set_language (cu->per_cu->lang, &objfile->objfile_obstack);\n       /* Fortran does not have mangling standard and the mangling does differ\n \t between gfortran, iFort etc.  */\n       const char *physname\n-\t= (cu->language == language_fortran\n+\t= (cu->per_cu->lang == language_fortran\n \t   ? dwarf2_full_name (name, die, cu)\n \t   : dwarf2_physname (name, die, cu));\n       const char *linkagename = dw2_linkage_name (die, cu);\n \n-      if (linkagename == nullptr || cu->language == language_ada)\n+      if (linkagename == nullptr || cu->per_cu->lang == language_ada)\n \tsym->set_linkage_name (physname);\n       else\n \t{\n@@ -21617,8 +21621,8 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n \t  attr2 = dwarf2_attr (die, DW_AT_external, cu);\n \t  if ((attr2 != nullptr && attr2->as_boolean ())\n-\t      || cu->language == language_ada\n-\t      || cu->language == language_fortran)\n+\t      || cu->per_cu->lang == language_ada\n+\t      || cu->per_cu->lang == language_fortran)\n \t    {\n \t      /* Subprograms marked external are stored as a global symbol.\n \t\t Ada and Fortran subprograms, whether marked external or\n@@ -21683,7 +21687,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \n \t      /* Fortran explicitly imports any global symbols to the local\n \t\t scope by DW_TAG_common_block.  */\n-\t      if (cu->language == language_fortran && die->parent\n+\t      if (cu->per_cu->lang == language_fortran && die->parent\n \t\t  && die->parent->tag == DW_TAG_common_block)\n \t\tattr2 = NULL;\n \n@@ -21737,7 +21741,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \n \t      /* Fortran explicitly imports any global symbols to the local\n \t\t scope by DW_TAG_common_block.  */\n-\t      if (cu->language == language_fortran && die->parent\n+\t      if (cu->per_cu->lang == language_fortran && die->parent\n \t\t  && die->parent->tag == DW_TAG_common_block)\n \t\t{\n \t\t  /* SYMBOL_CLASS doesn't matter here because\n@@ -21823,16 +21827,16 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\tbuildsym_compunit *builder = cu->get_builder ();\n \t\tlist_to_add\n \t\t  = (cu->list_in_scope == builder->get_file_symbols ()\n-\t\t     && cu->language == language_cplus\n+\t\t     && cu->per_cu->lang == language_cplus\n \t\t     ? builder->get_global_symbols ()\n \t\t     : cu->list_in_scope);\n \n \t\t/* The semantics of C++ state that \"struct foo {\n \t\t   ... }\" also defines a typedef for \"foo\".  */\n-\t\tif (cu->language == language_cplus\n-\t\t    || cu->language == language_ada\n-\t\t    || cu->language == language_d\n-\t\t    || cu->language == language_rust)\n+\t\tif (cu->per_cu->lang == language_cplus\n+\t\t    || cu->per_cu->lang == language_ada\n+\t\t    || cu->per_cu->lang == language_d\n+\t\t    || cu->per_cu->lang == language_rust)\n \t\t  {\n \t\t    /* The symbol's name is already allocated along\n \t\t       with this objfile, so we don't need to\n@@ -21867,7 +21871,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \n \t    list_to_add\n \t      = (cu->list_in_scope == cu->get_builder ()->get_file_symbols ()\n-\t\t && cu->language == language_cplus\n+\t\t && cu->per_cu->lang == language_cplus\n \t\t ? cu->get_builder ()->get_global_symbols ()\n \t\t : cu->list_in_scope);\n \t  }\n@@ -21910,7 +21914,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       /* For the benefit of old versions of GCC, check for anonymous\n \t namespaces based on the demangled name.  */\n       if (!cu->processing_has_namespace_info\n-\t  && cu->language == language_cplus)\n+\t  && cu->per_cu->lang == language_cplus)\n \tcp_scan_for_anonymous_namespaces (cu->get_builder (), sym, objfile);\n     }\n   return (sym);\n@@ -22122,7 +22126,7 @@ need_gnat_info (struct dwarf2_cu *cu)\n {\n   /* Assume that the Ada compiler was GNAT, which always produces\n      the auxiliary information.  */\n-  return (cu->language == language_ada);\n+  return (cu->per_cu->lang == language_ada);\n }\n \n /* Return the auxiliary type of the die in question using its\n@@ -22497,9 +22501,10 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n   struct type *parent_type;\n   const char *retval;\n \n-  if (cu->language != language_cplus\n-      && cu->language != language_fortran && cu->language != language_d\n-      && cu->language != language_rust)\n+  if (cu->per_cu->lang != language_cplus\n+      && cu->per_cu->lang != language_fortran\n+      && cu->per_cu->lang != language_d\n+      && cu->per_cu->lang != language_rust)\n     return \"\";\n \n   retval = anonymous_struct_prefix (die, cu);\n@@ -22587,7 +22592,7 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \t/* GCC 4.0 and 4.1 had a bug (PR c++/28460) where they generated bogus\n \t   DW_TAG_namespace DIEs with a name of \"::\" for the global namespace.\n \t   Work around this problem here.  */\n-\tif (cu->language == language_cplus\n+\tif (cu->per_cu->lang == language_cplus\n \t    && strcmp (parent_type->name (), \"::\") == 0)\n \t  return \"\";\n \t/* We give a name to even anonymous namespaces.  */\n@@ -22608,7 +22613,7 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n       case DW_TAG_compile_unit:\n       case DW_TAG_partial_unit:\n \t/* gcc-4.5 -gdwarf-4 can drop the enclosing namespace.  Cope.  */\n-\tif (cu->language == language_cplus\n+\tif (cu->per_cu->lang == language_cplus\n \t    && !per_objfile->per_bfd->types.empty ()\n \t    && die->child != NULL\n \t    && (die->tag == DW_TAG_class_type\n@@ -22623,7 +22628,7 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n       case DW_TAG_subprogram:\n \t/* Nested subroutines in Fortran get a prefix with the name\n \t   of the parent's subroutine.  */\n-\tif (cu->language == language_fortran)\n+\tif (cu->per_cu->lang == language_fortran)\n \t  {\n \t    if ((die->tag ==  DW_TAG_subprogram)\n \t\t&& (dwarf2_name (parent, cu) != NULL))\n@@ -22662,7 +22667,7 @@ typename_concat (struct obstack *obs, const char *prefix, const char *suffix,\n   if (suffix == NULL || suffix[0] == '\\0'\n       || prefix == NULL || prefix[0] == '\\0')\n     sep = \"\";\n-  else if (cu->language == language_d)\n+  else if (cu->per_cu->lang == language_d)\n     {\n       /* For D, the 'main' function could be defined in any module, but it\n \t should never be prefixed.  */\n@@ -22674,7 +22679,7 @@ typename_concat (struct obstack *obs, const char *prefix, const char *suffix,\n       else\n \tsep = \".\";\n     }\n-  else if (cu->language == language_fortran && physname)\n+  else if (cu->per_cu->lang == language_fortran && physname)\n     {\n       /* This is gfortran specific mangling.  Normally DW_AT_linkage_name or\n \t DW_AT_MIPS_linkage_name is preferred and used instead.  */\n@@ -22715,7 +22720,7 @@ static const char *\n dwarf2_canonicalize_name (const char *name, struct dwarf2_cu *cu,\n \t\t\t  struct objfile *objfile)\n {\n-  if (name && cu->language == language_cplus)\n+  if (name && cu->per_cu->lang == language_cplus)\n     {\n       gdb::unique_xmalloc_ptr<char> canon_name\n \t= cp_canonicalize_string (name);\n@@ -23094,10 +23099,10 @@ follow_die_offset (sect_offset sect_off, int offset_in_dwz,\n \t Even if maybe_queue_comp_unit doesn't require us to load the CU's DIEs,\n \t it doesn't mean they are currently loaded.  Since we require them\n \t to be loaded, we must check for ourselves.  */\n-      if (maybe_queue_comp_unit (cu, per_cu, per_objfile, cu->language)\n+      if (maybe_queue_comp_unit (cu, per_cu, per_objfile, cu->per_cu->lang)\n \t  || per_objfile->get_cu (per_cu) == nullptr)\n \tload_full_comp_unit (per_cu, per_objfile, per_objfile->get_cu (per_cu),\n-\t\t\t     false, cu->language);\n+\t\t\t     false, cu->per_cu->lang);\n \n       target_cu = per_objfile->get_cu (per_cu);\n       gdb_assert (target_cu != nullptr);\n@@ -24417,19 +24422,19 @@ prepare_one_comp_unit (struct dwarf2_cu *cu, struct die_info *comp_unit_die,\n \t attribute is not standardised yet.  As a workaround for the\n \t language detection we fall back to the DW_AT_producer\n \t string.  */\n-      cu->language = language_opencl;\n+      cu->per_cu->lang = language_opencl;\n     }\n   else if (cu->producer != nullptr\n \t   && strstr (cu->producer, \"GNU Go \") != NULL)\n     {\n       /* Similar hack for Go.  */\n-      cu->language = language_go;\n+      cu->per_cu->lang = language_go;\n     }\n   else if (attr != nullptr)\n-    cu->language = dwarf_lang_to_enum_language (attr->constant_value (0));\n+    cu->per_cu->lang = dwarf_lang_to_enum_language (attr->constant_value (0));\n   else\n-    cu->language = pretend_language;\n-  cu->language_defn = language_def (cu->language);\n+    cu->per_cu->lang = pretend_language;\n+  cu->language_defn = language_def (cu->per_cu->lang);\n }\n \n /* See read.h.  */"
    }
  ]
}