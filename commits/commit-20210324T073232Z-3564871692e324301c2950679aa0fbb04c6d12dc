{
  "sha": "3564871692e324301c2950679aa0fbb04c6d12dc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzU2NDg3MTY5MmUzMjQzMDFjMjk1MDY3OWFhMGZiYjA0YzZkMTJkYw==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-24T07:32:32Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-24T07:32:32Z"
    },
    "message": "x86: derive mandatory prefix attribute from base opcode\n\nJust like is already done for legacy encoded insns, record the mandatory\nprefix information in the respective opcode modifier field. Do this\nwithout changing the source table, but rather by deriving the values from\ntheir existing source representation.",
    "tree": {
      "sha": "dae616f226e7169fd83208a080480c97a04f01ac",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dae616f226e7169fd83208a080480c97a04f01ac"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3564871692e324301c2950679aa0fbb04c6d12dc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3564871692e324301c2950679aa0fbb04c6d12dc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3564871692e324301c2950679aa0fbb04c6d12dc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3564871692e324301c2950679aa0fbb04c6d12dc/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "311845694b1fd27ab869bbadd5d07969a62099f4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/311845694b1fd27ab869bbadd5d07969a62099f4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/311845694b1fd27ab869bbadd5d07969a62099f4"
    }
  ],
  "stats": {
    "total": 10191,
    "additions": 5091,
    "deletions": 5100
  },
  "files": [
    {
      "sha": "72d48d747d0a07420549357ba2ee41cd7c61c7f9",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3564871692e324301c2950679aa0fbb04c6d12dc/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3564871692e324301c2950679aa0fbb04c6d12dc/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=3564871692e324301c2950679aa0fbb04c6d12dc",
      "patch": "@@ -1,3 +1,18 @@\n+2021-03-24  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (md_begin): Add assertion.\n+\t(build_vex_prefix): Drop implied prefix calculation.\n+\t(build_evex_prefix): Likewise.\n+\t(optimize_encoding): Adjust opcode checks.\n+\t(load_insn_p): Also check opcodeprefix.\n+\t(match_template): Also check opcodespace.\n+\t(process_suffix): Likewise.\n+\t(process_operands): Likewise.\n+\t(output_insn): Likewise. Also check isprefix when discaring\n+\tstandalone LOCK.\n+\t* config/tc-i386-intel.c (i386_intel_operand): Also check\n+\topcodespace.\n+\n 2021-03-24  Jan Beulich  <jbeulich@suse.com>\n \n \t* config/tc-i386.c (parse_insn): Recognize pseudo prefixes by"
    },
    {
      "sha": "9b7f429c9a3aa96abc5858582e949dd71f6c848c",
      "filename": "gas/config/tc-i386-intel.c",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3564871692e324301c2950679aa0fbb04c6d12dc/gas/config/tc-i386-intel.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3564871692e324301c2950679aa0fbb04c6d12dc/gas/config/tc-i386-intel.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386-intel.c?ref=3564871692e324301c2950679aa0fbb04c6d12dc",
      "patch": "@@ -642,7 +642,8 @@ i386_intel_operand (char *operand_string, int got_a_float)\n     return 0;\n \n   if (intel_state.op_modifier != O_absent\n-      && current_templates->start->base_opcode != 0x8d /* lea */)\n+      && (current_templates->start->opcode_modifier.opcodespace != SPACE_BASE\n+          || current_templates->start->base_opcode != 0x8d /* lea */))\n     {\n       i.types[this_operand].bitfield.unspecified = 0;\n \n@@ -666,7 +667,8 @@ i386_intel_operand (char *operand_string, int got_a_float)\n \t  if ((current_templates->start->name[0] == 'l'\n \t       && current_templates->start->name[2] == 's'\n \t       && current_templates->start->name[3] == 0)\n-\t      || current_templates->start->base_opcode == 0x62 /* bound */)\n+\t      || (current_templates->start->opcode_modifier.opcodespace == SPACE_BASE\n+\t\t  && current_templates->start->base_opcode == 0x62 /* bound */))\n \t    suffix = WORD_MNEM_SUFFIX;\n \t  else if (flag_code != CODE_32BIT\n \t\t   && (current_templates->start->opcode_modifier.jump == JUMP\n@@ -696,7 +698,8 @@ i386_intel_operand (char *operand_string, int got_a_float)\n \n \tcase O_qword_ptr: /* O_mmword_ptr */\n \t  i.types[this_operand].bitfield.qword = 1;\n-\t  if (current_templates->start->base_opcode == 0x62 /* bound */\n+\t  if ((current_templates->start->opcode_modifier.opcodespace == SPACE_BASE\n+\t       && current_templates->start->base_opcode == 0x62 /* bound */)\n \t      || got_a_float == 1)\t/* \"f...\" */\n \t    suffix = LONG_MNEM_SUFFIX;\n \t  else"
    },
    {
      "sha": "9773b023e9f3cb50e43143a62309d4cb0c3db231",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 42,
      "deletions": 70,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3564871692e324301c2950679aa0fbb04c6d12dc/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3564871692e324301c2950679aa0fbb04c6d12dc/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=3564871692e324301c2950679aa0fbb04c6d12dc",
      "patch": "@@ -3065,6 +3065,8 @@ md_begin (void)\n \n     while (1)\n       {\n+\tgas_assert (optab->opcode_length == 4\n+\t\t    || !(optab->base_opcode >> (8 * optab->opcode_length)));\n \t++optab;\n \tif (optab->name == NULL\n \t    || strcmp (optab->name, (optab - 1)->name) != 0)\n@@ -3588,7 +3590,6 @@ static void\n build_vex_prefix (const insn_template *t)\n {\n   unsigned int register_specifier;\n-  unsigned int implied_prefix;\n   unsigned int vector_length;\n   unsigned int w;\n \n@@ -3696,24 +3697,6 @@ build_vex_prefix (const insn_template *t)\n \t  }\n     }\n \n-  switch ((i.tm.base_opcode >> (i.tm.opcode_length << 3)) & 0xff)\n-    {\n-    case 0:\n-      implied_prefix = 0;\n-      break;\n-    case DATA_PREFIX_OPCODE:\n-      implied_prefix = 1;\n-      break;\n-    case REPE_PREFIX_OPCODE:\n-      implied_prefix = 2;\n-      break;\n-    case REPNE_PREFIX_OPCODE:\n-      implied_prefix = 3;\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n   /* Check the REX.W bit and VEXW.  */\n   if (i.tm.opcode_modifier.vexw == VEXWIG)\n     w = (vexwig == vexw1 || (i.rex & REX_W)) ? 1 : 0;\n@@ -3739,7 +3722,7 @@ build_vex_prefix (const insn_template *t)\n       i.vex.bytes[1] = (r << 7\n \t\t\t| register_specifier << 3\n \t\t\t| vector_length << 2\n-\t\t\t| implied_prefix);\n+\t\t\t| i.tm.opcode_modifier.opcodeprefix);\n     }\n   else\n     {\n@@ -3769,7 +3752,7 @@ build_vex_prefix (const insn_template *t)\n       i.vex.bytes[2] = (w << 7\n \t\t\t| register_specifier << 3\n \t\t\t| vector_length << 2\n-\t\t\t| implied_prefix);\n+\t\t\t| i.tm.opcode_modifier.opcodeprefix);\n     }\n }\n \n@@ -3792,8 +3775,7 @@ is_any_vex_encoding (const insn_template *t)\n static void\n build_evex_prefix (void)\n {\n-  unsigned int register_specifier;\n-  unsigned int implied_prefix, w;\n+  unsigned int register_specifier, w;\n   rex_byte vrex_used = 0;\n \n   /* Check register specifier.  */\n@@ -3822,24 +3804,6 @@ build_evex_prefix (void)\n \tvrex_used |= REX_X;\n     }\n \n-  switch ((i.tm.base_opcode >> 8) & 0xff)\n-    {\n-    case 0:\n-      implied_prefix = 0;\n-      break;\n-    case DATA_PREFIX_OPCODE:\n-      implied_prefix = 1;\n-      break;\n-    case REPE_PREFIX_OPCODE:\n-      implied_prefix = 2;\n-      break;\n-    case REPNE_PREFIX_OPCODE:\n-      implied_prefix = 3;\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n   /* 4 byte EVEX prefix.  */\n   i.vex.length = 4;\n   i.vex.bytes[0] = 0x62;\n@@ -3882,11 +3846,11 @@ build_evex_prefix (void)\n   else\n     w = (flag_code == CODE_64BIT ? i.rex & REX_W : evexwig == evexw1) ? 1 : 0;\n \n-  /* Encode the U bit.  */\n-  implied_prefix |= 0x4;\n-\n   /* The third byte of the EVEX prefix.  */\n-  i.vex.bytes[2] = (w << 7 | register_specifier << 3 | implied_prefix);\n+  i.vex.bytes[2] = ((w << 7)\n+\t\t    | (register_specifier << 3)\n+\t\t    | 4 /* Encode the U bit.  */\n+\t\t    | i.tm.opcode_modifier.opcodeprefix);\n \n   /* The fourth byte of the EVEX prefix.  */\n   /* The zeroing-masking bit.  */\n@@ -4192,19 +4156,15 @@ optimize_encoding (void)\n \t\t       || (i.tm.operand_types[2].bitfield.zmmword\n \t\t\t   && i.types[2].bitfield.ymmword))))\n \t   && ((i.tm.base_opcode == 0x55\n-\t\t|| i.tm.base_opcode == 0x6655\n-\t\t|| i.tm.base_opcode == 0x66df\n \t\t|| i.tm.base_opcode == 0x57\n-\t\t|| i.tm.base_opcode == 0x6657\n-\t\t|| i.tm.base_opcode == 0x66ef\n-\t\t|| i.tm.base_opcode == 0x66f8\n-\t\t|| i.tm.base_opcode == 0x66f9\n-\t\t|| i.tm.base_opcode == 0x66fa\n-\t\t|| i.tm.base_opcode == 0x66fb\n+\t\t|| i.tm.base_opcode == 0xdf\n+\t\t|| i.tm.base_opcode == 0xef\n+\t\t|| i.tm.base_opcode == 0xf8\n+\t\t|| i.tm.base_opcode == 0xf9\n+\t\t|| i.tm.base_opcode == 0xfa\n+\t\t|| i.tm.base_opcode == 0xfb\n \t\t|| i.tm.base_opcode == 0x42\n-\t\t|| i.tm.base_opcode == 0x6642\n-\t\t|| i.tm.base_opcode == 0x47\n-\t\t|| i.tm.base_opcode == 0x6647)\n+\t\t|| i.tm.base_opcode == 0x47)\n \t       && i.tm.extension_opcode == None))\n     {\n       /* Optimize: -O1:\n@@ -4257,7 +4217,7 @@ optimize_encoding (void)\n \t}\n       else if (i.tm.operand_types[0].bitfield.class == RegMask)\n \t{\n-\t  i.tm.base_opcode &= 0xff;\n+\t  i.tm.opcode_modifier.opcodeprefix = PREFIX_NONE;\n \t  i.tm.opcode_modifier.vexw = VEXW0;\n \t}\n       else\n@@ -4276,11 +4236,9 @@ optimize_encoding (void)\n \t   && !i.mask\n \t   && !i.broadcast\n \t   && is_evex_encoding (&i.tm)\n-\t   && ((i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0x666f\n-\t       || (i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0xf36f\n-\t       || (i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0xf26f\n-\t       || (i.tm.base_opcode & ~4) == 0x66db\n-\t       || (i.tm.base_opcode & ~4) == 0x66eb)\n+\t   && ((i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0x6f\n+\t       || (i.tm.base_opcode & ~4) == 0xdb\n+\t       || (i.tm.base_opcode & ~4) == 0xeb)\n \t   && i.tm.extension_opcode == None)\n     {\n       /* Optimize: -O1:\n@@ -4331,13 +4289,14 @@ optimize_encoding (void)\n \t    i.types[j].bitfield.disp8 = vex_disp8;\n \t    break;\n \t  }\n-      if ((i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0xf26f)\n-\ti.tm.base_opcode ^= 0xf36f ^ 0xf26f;\n+      if ((i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0x6f\n+\t  && i.tm.opcode_modifier.opcodeprefix == PREFIX_0XF2)\n+\ti.tm.opcode_modifier.opcodeprefix = PREFIX_0XF3;\n       i.tm.opcode_modifier.vex\n \t= i.types[0].bitfield.ymmword ? VEX256 : VEX128;\n       i.tm.opcode_modifier.vexw = VEXW0;\n       /* VPAND, VPOR, and VPXOR are commutative.  */\n-      if (i.reg_operands == 3 && i.tm.base_opcode != 0x66df)\n+      if (i.reg_operands == 3 && i.tm.base_opcode != 0xdf)\n \ti.tm.opcode_modifier.commutative = 1;\n       i.tm.opcode_modifier.evex = 0;\n       i.tm.opcode_modifier.masking = 0;\n@@ -4395,6 +4354,7 @@ load_insn_p (void)\n       if (i.tm.base_opcode == 0xae\n \t  && i.tm.opcode_modifier.vex\n \t  && i.tm.opcode_modifier.opcodespace == SPACE_0F\n+\t  && i.tm.opcode_modifier.opcodeprefix == PREFIX_NONE\n \t  && i.tm.extension_opcode == 2)\n \treturn 1;\n     }\n@@ -6388,7 +6348,9 @@ match_template (char mnem_suffix)\n \t}\n \n       /* Force 0x8b encoding for \"mov foo@GOT, %eax\".  */\n-      if (i.reloc[0] == BFD_RELOC_386_GOT32 && t->base_opcode == 0xa0)\n+      if (i.reloc[0] == BFD_RELOC_386_GOT32\n+\t  && t->base_opcode == 0xa0\n+\t  && t->opcode_modifier.opcodespace == SPACE_BASE)\n \tcontinue;\n \n       /* We check register size if needed.  */\n@@ -6415,6 +6377,7 @@ match_template (char mnem_suffix)\n \t     zero-extend %eax to %rax.  */\n \t  if (flag_code == CODE_64BIT\n \t      && t->base_opcode == 0x90\n+\t      && t->opcode_modifier.opcodespace == SPACE_BASE\n \t      && i.types[0].bitfield.instance == Accum\n \t      && i.types[0].bitfield.dword\n \t      && i.types[1].bitfield.instance == Accum\n@@ -6425,6 +6388,7 @@ match_template (char mnem_suffix)\n \t  if (flag_code != CODE_64BIT\n \t      && i.hle_prefix\n \t      && t->base_opcode == 0xa0\n+\t      && t->opcode_modifier.opcodespace == SPACE_BASE\n \t      && i.types[0].bitfield.instance == Accum\n \t      && (i.flags[1] & Operand_Mem))\n \t    continue;\n@@ -6780,7 +6744,9 @@ process_suffix (void)\n \t ambiguity checking below.  The suffix will be replaced afterwards\n \t to represent the destination (register).  */\n       if (((i.tm.base_opcode | 8) == 0xfbe && i.tm.opcode_modifier.w)\n-\t  || (i.tm.base_opcode == 0x63 && i.tm.cpu_flags.bitfield.cpu64))\n+\t  || (i.tm.base_opcode == 0x63\n+\t      && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n+\t      && i.tm.cpu_flags.bitfield.cpu64))\n \t--i.operands;\n \n       /* crc32 needs REX.W set regardless of suffix / source operand size.  */\n@@ -7028,6 +6994,7 @@ process_suffix (void)\n \t    i.suffix = SHORT_MNEM_SUFFIX;\n \t  else if ((i.tm.base_opcode | 8) == 0xfbe\n \t\t   || (i.tm.base_opcode == 0x63\n+\t\t       && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n \t\t       && i.tm.cpu_flags.bitfield.cpu64))\n \t    /* handled below */;\n \t  else if (evex)\n@@ -7042,7 +7009,9 @@ process_suffix (void)\n     }\n \n   if ((i.tm.base_opcode | 8) == 0xfbe\n-      || (i.tm.base_opcode == 0x63 && i.tm.cpu_flags.bitfield.cpu64))\n+      || (i.tm.base_opcode == 0x63\n+\t  && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n+\t  && i.tm.cpu_flags.bitfield.cpu64))\n     {\n       /* In Intel syntax, movsx/movzx must have a \"suffix\" (checked above).\n \t In AT&T syntax, if there is no suffix (warned about above), the default\n@@ -7741,6 +7710,7 @@ process_operands (void)\n \n   if ((i.seg[0] || i.prefix[SEG_PREFIX])\n       && i.tm.base_opcode == 0x8d /* lea */\n+      && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n       && !is_any_vex_encoding(&i.tm))\n     {\n       if (!quiet_warnings)\n@@ -9244,7 +9214,8 @@ output_insn (void)\n \t  || i.tm.cpu_flags.bitfield.cpupopcnt\n \t  /* LAHF-SAHF insns in 64-bit mode.  */\n \t  || (flag_code == CODE_64BIT\n-\t      && (i.tm.base_opcode | 1) == 0x9f))\n+\t      && (i.tm.base_opcode | 1) == 0x9f\n+\t      && i.tm.opcode_modifier.opcodespace == SPACE_BASE))\n \tx86_isa_1_used |= GNU_PROPERTY_X86_ISA_1_V2;\n       if (i.tm.cpu_flags.bitfield.cpuavx\n \t  || i.tm.cpu_flags.bitfield.cpuavx2\n@@ -9354,7 +9325,8 @@ output_insn (void)\n \t assembler ignore LOCK prefix and serves as a workaround.  */\n       if (omit_lock_prefix)\n \t{\n-\t  if (i.tm.base_opcode == LOCK_PREFIX_OPCODE)\n+\t  if (i.tm.base_opcode == LOCK_PREFIX_OPCODE\n+\t      && i.tm.opcode_modifier.isprefix)\n \t    return;\n \t  i.prefix[LOCK_PREFIX] = 0;\n \t}"
    },
    {
      "sha": "442124cb535159c437f57dc248cb822f15fc74b5",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3564871692e324301c2950679aa0fbb04c6d12dc/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3564871692e324301c2950679aa0fbb04c6d12dc/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=3564871692e324301c2950679aa0fbb04c6d12dc",
      "patch": "@@ -1,3 +1,16 @@\n+2021-03-24  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* i386-gen.c (process_i386_opcode_modifier): Return void. New\n+\tparameter \"prefix\". Drop local variable \"regular_encoding\".\n+\tRecord prefix setting / check for consistency.\n+\t(output_i386_opcode): Parse opcode_length and base_opcode\n+\tearlier. Derive prefix encoding. Drop no longer applicable\n+\tconsistency checking. Adjust process_i386_opcode_modifier()\n+\tinvocation.\n+\t(process_i386_opcodes): Adjust process_i386_opcode_modifier()\n+\tinvocation.\n+\t* i386-tbl.h: Re-generate.\n+\n 2021-03-24  Jan Beulich  <jbeulich@suse.com>\n \n \t* i386-gen.c (process_i386_opcode_modifier): Drop IsPrefix"
    },
    {
      "sha": "6530a54f6339a6eb576be1b735dbbf1e342f8a39",
      "filename": "opcodes/i386-gen.c",
      "status": "modified",
      "additions": 41,
      "deletions": 53,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3564871692e324301c2950679aa0fbb04c6d12dc/opcodes/i386-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3564871692e324301c2950679aa0fbb04c6d12dc/opcodes/i386-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-gen.c?ref=3564871692e324301c2950679aa0fbb04c6d12dc",
      "patch": "@@ -1175,12 +1175,12 @@ adjust_broadcast_modifier (char **opnd)\n   return bcst_type;\n }\n \n-static int\n-process_i386_opcode_modifier (FILE *table, char *mod, char **opnd, int lineno)\n+static void\n+process_i386_opcode_modifier (FILE *table, char *mod, unsigned int prefix,\n+\t\t\t      char **opnd, int lineno)\n {\n   char *str, *next, *last;\n   bitfield modifiers [ARRAY_SIZE (opcode_modifiers)];\n-  unsigned int regular_encoding = 1;\n \n   active_isstring = 0;\n \n@@ -1199,18 +1199,7 @@ process_i386_opcode_modifier (FILE *table, char *mod, char **opnd, int lineno)\n \t    {\n \t      int val = 1;\n \t      if (strcasecmp(str, \"Broadcast\") == 0)\n-\t\t{\n-\t\t  val = adjust_broadcast_modifier (opnd);\n-\t\t  regular_encoding = 0;\n-\t\t}\n-\t      else if (strcasecmp(str, \"Vex\") == 0\n-\t\t       || strncasecmp(str, \"Vex=\", 4) == 0\n-\t\t       || strcasecmp(str, \"EVex\") == 0\n-\t\t       || strncasecmp(str, \"EVex=\", 5) == 0\n-\t\t       || strncasecmp(str, \"Disp8MemShift=\", 14) == 0\n-\t\t       || strncasecmp(str, \"Masking=\", 8) == 0\n-\t\t       || strcasecmp(str, \"SAE\") == 0)\n-\t\tregular_encoding = 0;\n+\t\tval = adjust_broadcast_modifier (opnd);\n \n \t      set_bitfield (str, modifiers, val, ARRAY_SIZE (modifiers),\n \t\t\t    lineno);\n@@ -1231,6 +1220,19 @@ process_i386_opcode_modifier (FILE *table, char *mod, char **opnd, int lineno)\n \t    }\n \t}\n \n+      if (prefix)\n+\t{\n+\t  if (!modifiers[OpcodePrefix].value)\n+\t    modifiers[OpcodePrefix].value = prefix;\n+\t  else if (modifiers[OpcodePrefix].value != prefix)\n+\t    fail (_(\"%s:%d: Conflicting prefix specifications\\n\"),\n+\t\t  filename, lineno);\n+\t  else\n+\t    fprintf (stderr,\n+\t\t     _(\"%s:%d: Warning: redundant prefix specification\\n\"),\n+\t\t     filename, lineno);\n+\t}\n+\n       if (have_w && !bwlq_suf)\n \tfail (\"%s: %d: stray W modifier\\n\", filename, lineno);\n       if (have_w && !(bwlq_suf & 1))\n@@ -1242,8 +1244,6 @@ process_i386_opcode_modifier (FILE *table, char *mod, char **opnd, int lineno)\n \t\t filename, lineno);\n     }\n   output_opcode_modifier (table, modifiers, ARRAY_SIZE (modifiers));\n-\n-  return regular_encoding;\n }\n \n enum stage {\n@@ -1355,9 +1355,10 @@ static void\n output_i386_opcode (FILE *table, const char *name, char *str,\n \t\t    char *last, int lineno)\n {\n-  unsigned int i;\n-  char *base_opcode, *extension_opcode, *opcode_length;\n+  unsigned int i, prefix = 0;\n+  char *base_opcode, *extension_opcode, *opcode_length, *end;\n   char *cpu_flags, *opcode_modifier, *operand_types [MAX_OPERANDS];\n+  unsigned long int opcode, length;\n \n   /* Find base_opcode.  */\n   base_opcode = next_field (str, ',', &str, last);\n@@ -1407,46 +1408,33 @@ output_i386_opcode (FILE *table, const char *name, char *str,\n \t}\n     }\n \n-  fprintf (table, \"  { \\\"%s\\\", %s, %s, %s, %u,\\n\",\n-\t   name, base_opcode, extension_opcode, opcode_length, i);\n+  length = strtoul (opcode_length, &end, 0);\n+  opcode = strtoul (base_opcode, &end, 0);\n \n-  if (process_i386_opcode_modifier (table, opcode_modifier,\n-\t\t\t\t    operand_types, lineno))\n+  /* Transform prefixes encoded in the opcode into opcode modifier\n+     representation.  */\n+  if (length < 4)\n     {\n-      char *end;\n-      unsigned long int length = strtoul (opcode_length, &end, 0);\n-      unsigned long int opcode = strtoul (base_opcode, &end, 0);\n-      switch (length)\n+      switch (opcode >> (8 * length))\n \t{\n-\tcase 4:\n-\t  break;\n-\tcase 3:\n-\t  if ((opcode >> 24) != 0)\n-\t    fail (_(\"%s: %s: (base_opcode >> 24) != 0: %s\\n\"),\n-\t\t  filename, name, base_opcode);\n-\t  break;\n-\tcase 2:\n-\t  if ((opcode >> 16) != 0)\n-\t    fail (_(\"%s: %s: (base_opcode >> 16) != 0: %s\\n\"),\n-\t\t  filename, name, base_opcode);\n-\t  break;\n-\tcase 1:\n-\t  if ((opcode >> 8) != 0)\n-\t    fail (_(\"%s: %s: (base_opcode >> 8) != 0: %s\\n\"),\n-\t\t  filename, name, base_opcode);\n-\t  break;\n-\tcase 0:\n-\t  if (opcode != 0)\n-\t    fail (_(\"%s: %s: base_opcode != 0: %s\\n\"),\n-\t\t  filename, name, base_opcode);\n-\t  break;\n+\tcase 0: break;\n+\tcase 0x66: prefix = PREFIX_0X66; break;\n+\tcase 0xF3: prefix = PREFIX_0XF3; break;\n+\tcase 0xF2: prefix = PREFIX_0XF2; break;\n \tdefault:\n-\t  fail (_(\"%s: %s: invalid opcode length: %s\\n\"),\n-\t\tfilename, name, opcode_length);\n-\t  break;\n+\t  fail (_(\"%s:%d: %s: Unexpected opcode prefix %02lx\\n\"),\n+\t\tfilename, lineno, name, opcode >> (8 * length));\n \t}\n+\n+      opcode &= (1UL << (8 * length)) - 1;\n     }\n \n+  fprintf (table, \"  { \\\"%s\\\", 0x%0*lx%s, %s, %lu, %u,\\n\",\n+\t   name, 2 * (int)length, opcode, end, extension_opcode, length, i);\n+\n+  process_i386_opcode_modifier (table, opcode_modifier, prefix,\n+\t\t\t\toperand_types, lineno);\n+\n   process_i386_cpu_flag (table, cpu_flags, 0, \",\", \"    \", lineno);\n \n   fprintf (table, \"    { \");\n@@ -1836,7 +1824,7 @@ process_i386_opcodes (FILE *table)\n \n   fprintf (table, \"  { NULL, 0, 0, 0, 0,\\n\");\n \n-  process_i386_opcode_modifier (table, \"0\", NULL, -1);\n+  process_i386_opcode_modifier (table, \"0\", 0, NULL, -1);\n \n   process_i386_cpu_flag (table, \"0\", 0, \",\", \"    \", -1);\n "
    },
    {
      "sha": "00c651c0cb0328a5e2bd8cd82c966289667fa742",
      "filename": "opcodes/i386-tbl.h",
      "status": "modified",
      "additions": 4974,
      "deletions": 4974,
      "changes": 9948,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3564871692e324301c2950679aa0fbb04c6d12dc/opcodes/i386-tbl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3564871692e324301c2950679aa0fbb04c6d12dc/opcodes/i386-tbl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-tbl.h?ref=3564871692e324301c2950679aa0fbb04c6d12dc"
    }
  ]
}