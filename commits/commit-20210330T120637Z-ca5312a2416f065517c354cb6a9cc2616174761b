{
  "sha": "ca5312a2416f065517c354cb6a9cc2616174761b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2E1MzEyYTI0MTZmMDY1NTE3YzM1NGNiNmE5Y2MyNjE2MTc0NzYxYg==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-30T12:06:37Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-30T12:06:37Z"
    },
    "message": "x86: integrate rc_op into struct _i386_insn\n\nThere's no need for the extra level of indirection and the extra storage\nneeded for the pointer, pointing from one piece of static data to\nanother. Key checking of rounding being in effect off of the type field\nof the structure instead.",
    "tree": {
      "sha": "a0427a1ffe474a87db92f432fc85f142e921eb90",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a0427a1ffe474a87db92f432fc85f142e921eb90"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ca5312a2416f065517c354cb6a9cc2616174761b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ca5312a2416f065517c354cb6a9cc2616174761b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ca5312a2416f065517c354cb6a9cc2616174761b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ca5312a2416f065517c354cb6a9cc2616174761b/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5273a3cd48b4c1c9fbf8c3ba0157394b2045e63f"
    }
  ],
  "stats": {
    "total": 93,
    "additions": 50,
    "deletions": 43
  },
  "files": [
    {
      "sha": "8bdc39204898137048add952ebc200bbd8110631",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ca5312a2416f065517c354cb6a9cc2616174761b/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ca5312a2416f065517c354cb6a9cc2616174761b/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=ca5312a2416f065517c354cb6a9cc2616174761b",
      "patch": "@@ -1,3 +1,17 @@\n+2021-03-30  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (rc_op): Delete.\n+\t(struct Rounding_Operation): Move ...\n+\t(struct _i386_insn): ... here. Change field \"rounding\".\n+\t(build_evex_prefix): Adjust rounding processing.\n+\t(swap_2_operands): Likewise.\n+\t(check_VecOperands): Likewise.\n+\t(RC_SAE_immediate): Likewise.\n+\t(optimize_encoding): Adjust check for rounding.\n+\t(build_modrm_byte): Likewise.\n+\t(output_imm): Likewise.\n+\t(md_assemble): Initialize rounding type.\n+\n 2021-03-30  Jan Beulich  <jbeulich@suse.com>\n \n \t* config/tc-i386.c (broadcast_op): Delete."
    },
    {
      "sha": "ba130138531e080e9ab56b5853cf15472885cf86",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 36,
      "deletions": 43,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ca5312a2416f065517c354cb6a9cc2616174761b/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ca5312a2416f065517c354cb6a9cc2616174761b/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=ca5312a2416f065517c354cb6a9cc2616174761b",
      "patch": "@@ -216,22 +216,6 @@ static const reg_entry bad_reg = { \"<bad>\", OPERAND_TYPE_NONE, 0, 0,\n \n static const reg_entry *reg_k0;\n \n-/* This struct describes rounding control and SAE in the instruction.  */\n-struct RC_Operation\n-{\n-  enum rc_type\n-    {\n-      rne = 0,\n-      rd,\n-      ru,\n-      rz,\n-      saeonly\n-    } type;\n-  unsigned int operand;\n-};\n-\n-static struct RC_Operation rc_op;\n-\n /* VEX prefix.  */\n typedef struct\n {\n@@ -380,7 +364,20 @@ struct _i386_insn\n     } mask;\n \n     /* Rounding control and SAE attributes.  */\n-    struct RC_Operation *rounding;\n+    struct RC_Operation\n+    {\n+      enum rc_type\n+\t{\n+\t  rc_none = -1,\n+\t  rne,\n+\t  rd,\n+\t  ru,\n+\t  rz,\n+\t  saeonly\n+\t} type;\n+\n+      unsigned int operand;\n+    } rounding;\n \n     /* Broadcasting attributes.\n \n@@ -3876,7 +3873,7 @@ build_evex_prefix (void)\n     i.vex.bytes[3] |= 0x80;\n \n   /* Don't always set the broadcast bit if there is no RC.  */\n-  if (!i.rounding)\n+  if (i.rounding.type == rc_none)\n     {\n       /* Encode the vector length.  */\n       unsigned int vec_length;\n@@ -3955,13 +3952,10 @@ build_evex_prefix (void)\n       if (i.broadcast.type)\n \ti.vex.bytes[3] |= 0x10;\n     }\n+  else if (i.rounding.type != saeonly)\n+    i.vex.bytes[3] |= 0x10 | (i.rounding.type << 5);\n   else\n-    {\n-      if (i.rounding->type != saeonly)\n-\ti.vex.bytes[3] |= 0x10 | (i.rounding->type << 5);\n-      else\n-\ti.vex.bytes[3] |= 0x10 | (evexrcig << 5);\n-    }\n+    i.vex.bytes[3] |= 0x10 | (evexrcig << 5);\n \n   if (i.mask.reg)\n     i.vex.bytes[3] |= i.mask.reg->reg_num;\n@@ -4166,7 +4160,7 @@ optimize_encoding (void)\n \t   && !i.types[2].bitfield.xmmword\n \t   && (i.tm.opcode_modifier.vex\n \t       || ((!i.mask.reg || i.mask.zeroing)\n-\t\t   && !i.rounding\n+\t\t   && i.rounding.type == rc_none\n \t\t   && is_evex_encoding (&i.tm)\n \t\t   && (i.vec_encoding != vex_encoding_evex\n \t\t       || cpu_arch_isa_flags.bitfield.cpuavx512vl\n@@ -4666,6 +4660,7 @@ md_assemble (char *line)\n \n   /* Initialize globals.  */\n   memset (&i, '\\0', sizeof (i));\n+  i.rounding.type = rc_none;\n   for (j = 0; j < MAX_OPERANDS; j++)\n     i.reloc[j] = NO_RELOC;\n   memset (disp_expressions, '\\0', sizeof (disp_expressions));\n@@ -5476,12 +5471,12 @@ swap_2_operands (unsigned int xchg1, unsigned int xchg2)\n       else if (i.broadcast.operand == xchg2)\n \ti.broadcast.operand = xchg1;\n     }\n-  if (i.rounding)\n+  if (i.rounding.type != rc_none)\n     {\n-      if (i.rounding->operand == xchg1)\n-\ti.rounding->operand = xchg2;\n-      else if (i.rounding->operand == xchg2)\n-\ti.rounding->operand = xchg1;\n+      if (i.rounding.operand == xchg1)\n+\ti.rounding.operand = xchg2;\n+      else if (i.rounding.operand == xchg2)\n+\ti.rounding.operand = xchg1;\n     }\n }\n \n@@ -6026,10 +6021,10 @@ check_VecOperands (const insn_template *t)\n     }\n \n   /* Check RC/SAE.  */\n-  if (i.rounding)\n+  if (i.rounding.type != rc_none)\n     {\n       if (!t->opcode_modifier.sae\n-\t  || (i.rounding->type != saeonly && !t->opcode_modifier.staticrounding))\n+\t  || (i.rounding.type != saeonly && !t->opcode_modifier.staticrounding))\n \t{\n \t  i.error = unsupported_rc_sae;\n \t  return 1;\n@@ -6038,7 +6033,7 @@ check_VecOperands (const insn_template *t)\n \t them is rounding, the rounding operand should be the last\n \t immediate operand.  */\n       if (i.imm_operands > 1\n-\t  && i.rounding->operand != i.imm_operands - 1)\n+\t  && i.rounding.operand != i.imm_operands - 1)\n \t{\n \t  i.error = rc_sae_operand_not_last_imm;\n \t  return 1;\n@@ -7925,7 +7920,7 @@ build_modrm_byte (void)\n \t\t\t  && i.imm_operands == 1\n \t\t\t  && (i.types[0].bitfield.imm8\n \t\t\t      || i.types[i.operands - 1].bitfield.imm8\n-\t\t\t      || i.rounding)));\n+\t\t\t      || i.rounding.type != rc_none)));\n \t  if (i.imm_operands == 2)\n \t    source = 2;\n \t  else\n@@ -7966,7 +7961,7 @@ build_modrm_byte (void)\n \t  /* RC/SAE operand could be between DEST and SRC.  That happens\n \t     when one operand is GPR and the other one is XMM/YMM/ZMM\n \t     register.  */\n-\t  if (i.rounding && i.rounding->operand == dest)\n+\t  if (i.rounding.type != rc_none && i.rounding.operand == dest)\n \t    dest++;\n \n \t  if (i.tm.opcode_modifier.vexvvvv == VEXXDS)\n@@ -9866,7 +9861,7 @@ output_imm (fragS *insn_start_frag, offsetT insn_start_off)\n   for (n = 0; n < i.operands; n++)\n     {\n       /* Skip SAE/RC Imm operand in EVEX.  They are already handled.  */\n-      if (i.rounding && n == i.rounding->operand)\n+      if (i.rounding.type != rc_none && n == i.rounding.operand)\n \tcontinue;\n \n       if (operand_type_check (i.types[n], imm))\n@@ -11185,17 +11180,15 @@ RC_SAE_immediate (const char *imm_start)\n     {\n       if (!strncmp (pstr, RC_NamesTable[j].name, RC_NamesTable[j].len))\n \t{\n-\t  if (!i.rounding)\n-\t    {\n-\t      rc_op.type = RC_NamesTable[j].type;\n-\t      rc_op.operand = this_operand;\n-\t      i.rounding = &rc_op;\n-\t    }\n-\t  else\n+\t  if (i.rounding.type != rc_none)\n \t    {\n \t      as_bad (_(\"duplicated `%s'\"), imm_start);\n \t      return 0;\n \t    }\n+\n+\t  i.rounding.type = RC_NamesTable[j].type;\n+\t  i.rounding.operand = this_operand;\n+\n \t  pstr += RC_NamesTable[j].len;\n \t  match_found = 1;\n \t  break;"
    }
  ]
}