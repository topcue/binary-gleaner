{
  "sha": "f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjVlOWM5YmRlMDRhZTUyYjkyMDI3Yjc4YzljYTIwMDU1ZjFhZmI3OA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-06-27T12:51:10Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-07-01T10:05:59Z"
    },
    "message": "libctf: deduplicate and sort the string table\n\nctf.h states:\n\n> [...] the CTF string table does not contain any duplicated strings.\n\nUnfortunately this is entirely untrue: libctf has before now made no\nattempt whatsoever to deduplicate the string table. It computes the\nstring table's length on the fly as it adds new strings to the dynamic\nCTF file, and ctf_update() just writes each string to the table and\nnotes the current write position as it traverses the dynamic CTF file's\ndata structures and builds the final CTF buffer.  There is no global\nview of the strings and no deduplication.\n\nFix this by erasing the ctf_dtvstrlen dead-reckoning length, and adding\na new dynhash table ctf_str_atoms that maps unique strings to a list\nof references to those strings: a reference is a simple uint32_t * to\nsome value somewhere in the under-construction CTF buffer that needs\nupdating to note the string offset when the strtab is laid out.\n\nAdding a string is now a simple matter of calling ctf_str_add_ref(),\nwhich adds a new atom to the atoms table, if one doesn't already exist,\nand adding the location of the reference to this atom to the refs list\nattached to the atom: this works reliably as long as one takes care to\nonly call ctf_str_add_ref() once the final location of the offset is\nknown (so you can't call it on a temporary structure and then memcpy()\nthat structure into place in the CTF buffer, because the ref will still\npoint to the old location: ctf_update() changes accordingly).\n\nGenerating the CTF string table is a matter of calling\nctf_str_write_strtab(), which counts the length and number of elements\nin the atoms table using the ctf_dynhash_iter() function we just added,\npopulating an array of pointers into the atoms table and sorting it into\norder (to help compressors), then traversing this table and emitting it,\nupdating the refs to each atom as we go.  The only complexity here is\narranging to keep the null string at offset zero, since a lot of code in\nlibctf depends on being able to leave strtab references at 0 to indicate\n'no name'.  Once the table is constructed and the refs updated, we know\nhow long it is, so we can realloc() the partial CTF buffer we allocated\nearlier and can copy the table on to the end of it (and purge the refs\nbecause they're not needed any more and have been invalidated by the\nrealloc() call in any case).\n\nThe net effect of all this is a reduction in uncompressed strtab sizes\nof about 30% (perhaps a quarter to a half of all strings across the\nLinux kernel are eliminated as duplicates). Of course, duplicated\nstrings are highly redundant, so the space saving after compression is\nonly about 20%: when the other non-strtab sections are factored in, CTF\nsizes shrink by about 10%.\n\nNo change in externally-visible API or file format (other than the\nreduction in pointless redundancy).\n\nlibctf/\n\t* ctf-impl.h: (struct ctf_strs_writable): New, non-const version of\n\tstruct ctf_strs.\n\t(struct ctf_dtdef): Note that dtd_data.ctt_name is unpopulated.\n\t(struct ctf_str_atom): New, disambiguated single string.\n\t(struct ctf_str_atom_ref): New, points to some other location that\n\treferences this string's offset.\n\t(struct ctf_file): New members ctf_str_atoms and ctf_str_num_refs.\n\tRemove member ctf_dtvstrlen: we no longer track the total strlen\n\tas we add strings.\n\t(ctf_str_create_atoms): Declare new function in ctf-string.c.\n\t(ctf_str_free_atoms): Likewise.\n\t(ctf_str_add): Likewise.\n\t(ctf_str_add_ref): Likewise.\n\t(ctf_str_purge_refs): Likewise.\n\t(ctf_str_write_strtab): Likewise.\n\t(ctf_realloc): Declare new function in ctf-util.c.\n\n\t* ctf-open.c (ctf_bufopen): Create the atoms table.\n\t(ctf_file_close): Destroy it.\n\t* ctf-create.c (ctf_update): Copy-and-free it on update.  No longer\n\tspecial-case the position of the parname string.  Construct the\n\tstrtab by calling ctf_str_add_ref and ctf_str_write_strtab after the\n\trest of each buffer element is constructed, not via open-coding:\n\trealloc the CTF buffer and append the strtab to it.  No longer\n\tmaintain ctf_dtvstrlen.  Sort the variable entry table later, after\n\tstrtab construction.\n\t(ctf_copy_membnames): Remove: integrated into ctf_copy_{s,l,e}members.\n\t(ctf_copy_smembers): Drop the string offset: call ctf_str_add_ref\n\tafter buffer element construction instead.\n\t(ctf_copy_lmembers): Likewise.\n\t(ctf_copy_emembers): Likewise.\n\t(ctf_create): No longer maintain the ctf_dtvstrlen.\n\t(ctf_dtd_delete): Likewise.\n\t(ctf_dvd_delete): Likewise.\n\t(ctf_add_generic): Likewise.\n\t(ctf_add_enumerator): Likewise.\n\t(ctf_add_member_offset): Likewise.\n\t(ctf_add_variable): Likewise.\n\t(membadd): Likewise.\n\t* ctf-util.c (ctf_realloc): New, wrapper around realloc that aborts\n\tif there are active ctf_str_num_refs.\n\t(ctf_strraw): Move to ctf-string.c.\n\t(ctf_strptr): Likewise.\n\t* ctf-string.c: New file, strtab manipulation.\n\n\t* Makefile.am (libctf_a_SOURCES): Add it.\n\t* Makefile.in: Regenerate.",
    "tree": {
      "sha": "99f8b4e2e938d6195ca0ad6842e2a3a9676da6bb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/99f8b4e2e938d6195ca0ad6842e2a3a9676da6bb"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9658dc39630b8ac4e849fb529a53902da5fc2b1f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9658dc39630b8ac4e849fb529a53902da5fc2b1f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9658dc39630b8ac4e849fb529a53902da5fc2b1f"
    }
  ],
  "stats": {
    "total": 658,
    "additions": 520,
    "deletions": 138
  },
  "files": [
    {
      "sha": "d07d5dc2e5f83f899b9b277cb4197d3bb5f2155c",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -1,3 +1,54 @@\n+2019-06-28  Nick Alcock <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h: (struct ctf_strs_writable): New, non-const version of\n+\tstruct ctf_strs.\n+\t(struct ctf_dtdef): Note that dtd_data.ctt_name is unpopulated.\n+\t(struct ctf_str_atom): New, disambiguated single string.\n+\t(struct ctf_str_atom_ref): New, points to some other location that\n+\treferences this string's offset.\n+\t(struct ctf_file): New members ctf_str_atoms and ctf_str_num_refs.\n+\tRemove member ctf_dtvstrlen: we no longer track the total strlen\n+\tas we add strings.\n+\t(ctf_str_create_atoms): Declare new function in ctf-string.c.\n+\t(ctf_str_free_atoms): Likewise.\n+\t(ctf_str_add): Likewise.\n+\t(ctf_str_add_ref): Likewise.\n+\t(ctf_str_rollback): Likewise.\n+\t(ctf_str_purge_refs): Likewise.\n+\t(ctf_str_write_strtab): Likewise.\n+\t(ctf_realloc): Declare new function in ctf-util.c.\n+\n+\t* ctf-open.c (ctf_bufopen): Create the atoms table.\n+\t(ctf_file_close): Destroy it.\n+\t* ctf-create.c (ctf_update): Copy-and-free it on update.  No longer\n+\tspecial-case the position of the parname string.  Construct the\n+\tstrtab by calling ctf_str_add_ref and ctf_str_write_strtab after the\n+\trest of each buffer element is constructed, not via open-coding:\n+\trealloc the CTF buffer and append the strtab to it.  No longer\n+\tmaintain ctf_dtvstrlen.  Sort the variable entry table later, after\n+\tstrtab construction.\n+\t(ctf_copy_membnames): Remove: integrated into ctf_copy_{s,l,e}members.\n+\t(ctf_copy_smembers): Drop the string offset: call ctf_str_add_ref\n+\tafter buffer element construction instead.\n+\t(ctf_copy_lmembers): Likewise.\n+\t(ctf_copy_emembers): Likewise.\n+\t(ctf_create): No longer maintain the ctf_dtvstrlen.\n+\t(ctf_dtd_delete): Likewise.\n+\t(ctf_dvd_delete): Likewise.\n+\t(ctf_add_generic): Likewise.\n+\t(ctf_add_enumerator): Likewise.\n+\t(ctf_add_member_offset): Likewise.\n+\t(ctf_add_variable): Likewise.\n+\t(membadd): Likewise.\n+\t* ctf-util.c (ctf_realloc): New, wrapper around realloc that aborts\n+\tif there are active ctf_str_num_refs.\n+\t(ctf_strraw): Move to ctf-string.c.\n+\t(ctf_strptr): Likewise.\n+\t* ctf-string.c: New file, strtab manipulation.\n+\n+\t* Makefile.am (libctf_a_SOURCES): Add it.\n+\t* Makefile.in: Regenerate.\n+\n 2019-06-28  Nick Alcock <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (ctf_hash_iter_f): New."
    },
    {
      "sha": "43fc78a4124124e36a15dd012258213fd1940b4a",
      "filename": "libctf/Makefile.am",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.am?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -34,7 +34,7 @@ noinst_LIBRARIES = libctf.a\n \n libctf_a_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c ctf-error.c \\\n \t\t   ctf-hash.c ctf-labels.c ctf-lookup.c ctf-open.c ctf-open-bfd.c \\\n-\t\t   ctf-subr.c ctf-types.c ctf-util.c\n+\t\t   ctf-string.c ctf-subr.c ctf-types.c ctf-util.c\n if NEED_CTF_QSORT_R\n libctf_a_SOURCES += ctf-qsort_r.c\n endif"
    },
    {
      "sha": "c898eb494199c7ba4e056d80014692db48eafa90",
      "filename": "libctf/Makefile.in",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.in?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -132,14 +132,15 @@ libctf_a_AR = $(AR) $(ARFLAGS)\n libctf_a_LIBADD =\n am__libctf_a_SOURCES_DIST = ctf-archive.c ctf-dump.c ctf-create.c \\\n \tctf-decl.c ctf-error.c ctf-hash.c ctf-labels.c ctf-lookup.c \\\n-\tctf-open.c ctf-open-bfd.c ctf-subr.c ctf-types.c ctf-util.c \\\n-\tctf-qsort_r.c\n+\tctf-open.c ctf-open-bfd.c ctf-string.c ctf-subr.c ctf-types.c \\\n+\tctf-util.c ctf-qsort_r.c\n @NEED_CTF_QSORT_R_TRUE@am__objects_1 = ctf-qsort_r.$(OBJEXT)\n am_libctf_a_OBJECTS = ctf-archive.$(OBJEXT) ctf-dump.$(OBJEXT) \\\n \tctf-create.$(OBJEXT) ctf-decl.$(OBJEXT) ctf-error.$(OBJEXT) \\\n \tctf-hash.$(OBJEXT) ctf-labels.$(OBJEXT) ctf-lookup.$(OBJEXT) \\\n-\tctf-open.$(OBJEXT) ctf-open-bfd.$(OBJEXT) ctf-subr.$(OBJEXT) \\\n-\tctf-types.$(OBJEXT) ctf-util.$(OBJEXT) $(am__objects_1)\n+\tctf-open.$(OBJEXT) ctf-open-bfd.$(OBJEXT) ctf-string.$(OBJEXT) \\\n+\tctf-subr.$(OBJEXT) ctf-types.$(OBJEXT) ctf-util.$(OBJEXT) \\\n+\t$(am__objects_1)\n libctf_a_OBJECTS = $(am_libctf_a_OBJECTS)\n AM_V_P = $(am__v_P_@AM_V@)\n am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n@@ -331,7 +332,7 @@ AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @\n noinst_LIBRARIES = libctf.a\n libctf_a_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c \\\n \tctf-error.c ctf-hash.c ctf-labels.c ctf-lookup.c ctf-open.c \\\n-\tctf-open-bfd.c ctf-subr.c ctf-types.c ctf-util.c \\\n+\tctf-open-bfd.c ctf-string.c ctf-subr.c ctf-types.c ctf-util.c \\\n \t$(am__append_1)\n all: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n@@ -412,6 +413,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-open-bfd.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-open.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-qsort_r.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-string.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-subr.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-types.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-util.Po@am__quote@"
    },
    {
      "sha": "6ab0cf3b88e429e61f48516e03206a885e1fabb9",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 75,
      "deletions": 108,
      "changes": 183,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -29,10 +29,8 @@\n \n /* To create an empty CTF container, we just declare a zeroed header and call\n    ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new container r/w\n-   and initialize the dynamic members.  We set dtvstrlen to 1 to reserve the\n-   first byte of the string table for a \\0 byte, and we start assigning type\n-   IDs at 1 because type ID 0 is used as a sentinel and a not-found\n-   indicator.  */\n+   and initialize the dynamic members.  We start assigning type IDs at 1 because\n+   type ID 0 is used as a sentinel and a not-found indicator.  */\n \n ctf_file_t *\n ctf_create (int *errp)\n@@ -82,7 +80,6 @@ ctf_create (int *errp)\n   fp->ctf_dtbyname = dtbyname;\n   fp->ctf_dthash = dthash;\n   fp->ctf_dvhash = dvhash;\n-  fp->ctf_dtvstrlen = 1;\n   fp->ctf_dtnextid = 1;\n   fp->ctf_dtoldid = 0;\n   fp->ctf_snapshots = 0;\n@@ -101,94 +98,76 @@ ctf_create (int *errp)\n }\n \n static unsigned char *\n-ctf_copy_smembers (ctf_dtdef_t *dtd, uint32_t soff, unsigned char *t)\n+ctf_copy_smembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n   ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n   ctf_member_t ctm;\n \n   for (; dmd != NULL; dmd = ctf_list_next (dmd))\n     {\n-      if (dmd->dmd_name)\n-\t{\n-\t  ctm.ctm_name = soff;\n-\t  soff += strlen (dmd->dmd_name) + 1;\n-\t}\n-      else\n-\tctm.ctm_name = 0;\n+      ctf_member_t *copied;\n \n+      ctm.ctm_name = 0;\n       ctm.ctm_type = (uint32_t) dmd->dmd_type;\n       ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n \n       memcpy (t, &ctm, sizeof (ctm));\n+      copied = (ctf_member_t *) t;\n+      if (dmd->dmd_name)\n+\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctm_name);\n+\n       t += sizeof (ctm);\n     }\n \n   return t;\n }\n \n static unsigned char *\n-ctf_copy_lmembers (ctf_dtdef_t *dtd, uint32_t soff, unsigned char *t)\n+ctf_copy_lmembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n   ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n   ctf_lmember_t ctlm;\n \n   for (; dmd != NULL; dmd = ctf_list_next (dmd))\n     {\n-      if (dmd->dmd_name)\n-\t{\n-\t  ctlm.ctlm_name = soff;\n-\t  soff += strlen (dmd->dmd_name) + 1;\n-\t}\n-      else\n-\tctlm.ctlm_name = 0;\n+      ctf_lmember_t *copied;\n \n+      ctlm.ctlm_name = 0;\n       ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n       ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n       ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n \n       memcpy (t, &ctlm, sizeof (ctlm));\n+      copied = (ctf_lmember_t *) t;\n+      if (dmd->dmd_name)\n+\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctlm_name);\n+\n       t += sizeof (ctlm);\n     }\n \n   return t;\n }\n \n static unsigned char *\n-ctf_copy_emembers (ctf_dtdef_t *dtd, uint32_t soff, unsigned char *t)\n+ctf_copy_emembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n   ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n   ctf_enum_t cte;\n \n   for (; dmd != NULL; dmd = ctf_list_next (dmd))\n     {\n-      cte.cte_name = soff;\n+      ctf_enum_t *copied;\n+\n       cte.cte_value = dmd->dmd_value;\n-      soff += strlen (dmd->dmd_name) + 1;\n       memcpy (t, &cte, sizeof (cte));\n+      copied = (ctf_enum_t *) t;\n+      ctf_str_add_ref (fp, dmd->dmd_name, &copied->cte_name);\n       t += sizeof (cte);\n     }\n \n   return t;\n }\n \n-static unsigned char *\n-ctf_copy_membnames (ctf_dtdef_t *dtd, unsigned char *s)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  size_t len;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      if (dmd->dmd_name == NULL)\n-\tcontinue;\t\t\t/* Skip anonymous members.  */\n-      len = strlen (dmd->dmd_name) + 1;\n-      memcpy (s, dmd->dmd_name, len);\n-      s += len;\n-    }\n-\n-  return s;\n-}\n-\n /* Sort a newly-constructed static variable array.  */\n \n static int\n@@ -220,15 +199,16 @@ int\n ctf_update (ctf_file_t *fp)\n {\n   ctf_file_t ofp, *nfp;\n-  ctf_header_t hdr;\n+  ctf_header_t hdr, *hdrp;\n   ctf_dtdef_t *dtd;\n   ctf_dvdef_t *dvd;\n   ctf_varent_t *dvarents;\n+  ctf_strs_writable_t strtab;\n \n-  unsigned char *s, *s0, *t;\n+  unsigned char *t;\n   unsigned long i;\n   size_t buf_size, type_size, nvars;\n-  void *buf;\n+  unsigned char *buf, *newbuf;\n   int err;\n \n   if (!(fp->ctf_flags & LCTF_RDWR))\n@@ -247,9 +227,6 @@ ctf_update (ctf_file_t *fp)\n   hdr.cth_magic = CTF_MAGIC;\n   hdr.cth_version = CTF_VERSION;\n \n-  if (fp->ctf_flags & LCTF_CHILD)\n-    hdr.cth_parname = 1;\t\t/* parname added just below.  */\n-\n   /* Iterate through the dynamic type definition list and compute the\n      size of the CTF type section we will need to generate.  */\n \n@@ -298,15 +275,13 @@ ctf_update (ctf_file_t *fp)\n   for (nvars = 0, dvd = ctf_list_next (&fp->ctf_dvdefs);\n        dvd != NULL; dvd = ctf_list_next (dvd), nvars++);\n \n-  /* Fill in the string table and type offset and size, compute the size\n-     of the entire CTF buffer we need, and then allocate a new buffer and\n-     memcpy the finished header to the start of the buffer.  */\n+  /* Compute the size of the CTF buffer we need, sans only the string table,\n+     then allocate a new buffer and memcpy the finished header to the start of\n+     the buffer.  (We will adjust this later with strtab length info.)  */\n \n   hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n   hdr.cth_stroff = hdr.cth_typeoff + type_size;\n-  hdr.cth_strlen = fp->ctf_dtvstrlen;\n-  if (fp->ctf_parname != NULL)\n-    hdr.cth_strlen += strlen (fp->ctf_parname) + 1;\n+  hdr.cth_strlen = 0;\n \n   buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n \n@@ -315,70 +290,55 @@ ctf_update (ctf_file_t *fp)\n \n   memcpy (buf, &hdr, sizeof (ctf_header_t));\n   t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_varoff;\n-  s = s0 = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff;\n-\n-  s[0] = '\\0';\n-  s++;\n \n-  if (fp->ctf_parname != NULL)\n-    {\n-      memcpy (s, fp->ctf_parname, strlen (fp->ctf_parname) + 1);\n-      s += strlen (fp->ctf_parname) + 1;\n-    }\n+  hdrp = (ctf_header_t *) buf;\n+  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n+    ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n \n-  /* Work over the variable list, translating everything into\n-     ctf_varent_t's and filling out the string table, then sort the buffer\n-     of ctf_varent_t's.  */\n+  /* Work over the variable list, translating everything into ctf_varent_t's and\n+     prepping the string table.  */\n \n   dvarents = (ctf_varent_t *) t;\n   for (i = 0, dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n        dvd = ctf_list_next (dvd), i++)\n     {\n       ctf_varent_t *var = &dvarents[i];\n-      size_t len = strlen (dvd->dvd_name) + 1;\n \n-      var->ctv_name = (uint32_t) (s - s0);\n+      ctf_str_add_ref (fp, dvd->dvd_name, &var->ctv_name);\n       var->ctv_type = dvd->dvd_type;\n-      memcpy (s, dvd->dvd_name, len);\n-      s += len;\n     }\n   assert (i == nvars);\n \n-  ctf_qsort_r (dvarents, nvars, sizeof (ctf_varent_t), ctf_sort_var, s0);\n   t += sizeof (ctf_varent_t) * nvars;\n \n   assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_typeoff);\n \n-  /* We now take a final lap through the dynamic type definition list and\n-     copy the appropriate type records and strings to the output buffer.  */\n+  /* We now take a final lap through the dynamic type definition list and copy\n+     the appropriate type records to the output buffer, noting down the\n+     strings as we go.  */\n \n   for (dtd = ctf_list_next (&fp->ctf_dtdefs);\n        dtd != NULL; dtd = ctf_list_next (dtd))\n     {\n-\n       uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n       uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n \n       ctf_array_t cta;\n       uint32_t encoding;\n       size_t len;\n+      ctf_stype_t *copied;\n \n-      if (dtd->dtd_name != NULL)\n-\t{\n-\t  dtd->dtd_data.ctt_name = (uint32_t) (s - s0);\n-\t  len = strlen (dtd->dtd_name) + 1;\n-\t  memcpy (s, dtd->dtd_name, len);\n-\t  s += len;\n-\t}\n-      else\n-\tdtd->dtd_data.ctt_name = 0;\n+      dtd->dtd_data.ctt_name = 0;\n \n       if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n \tlen = sizeof (ctf_stype_t);\n       else\n \tlen = sizeof (ctf_type_t);\n \n       memcpy (t, &dtd->dtd_data, len);\n+      copied = (ctf_stype_t *) t;  /* name is at the start: constant offset.  */\n+      if (dtd->dtd_name)\n+\tctf_str_add_ref (fp, dtd->dtd_name, &copied->ctt_name);\n       t += len;\n \n       switch (kind)\n@@ -432,24 +392,47 @@ ctf_update (ctf_file_t *fp)\n \tcase CTF_K_STRUCT:\n \tcase CTF_K_UNION:\n \t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n-\t    t = ctf_copy_smembers (dtd, (uint32_t) (s - s0), t);\n+\t    t = ctf_copy_smembers (fp, dtd, t);\n \t  else\n-\t    t = ctf_copy_lmembers (dtd, (uint32_t) (s - s0), t);\n-\t  s = ctf_copy_membnames (dtd, s);\n+\t    t = ctf_copy_lmembers (fp, dtd, t);\n \t  break;\n \n \tcase CTF_K_ENUM:\n-\t  t = ctf_copy_emembers (dtd, (uint32_t) (s - s0), t);\n-\t  s = ctf_copy_membnames (dtd, s);\n+\t  t = ctf_copy_emembers (fp, dtd, t);\n \t  break;\n \t}\n     }\n   assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff);\n \n+  /* Construct the final string table and fill out all the string refs with the\n+     final offsets.  Then purge the refs list, because we're about to move this\n+     strtab onto the end of the buf, invalidating all the offsets.  */\n+  strtab = ctf_str_write_strtab (fp);\n+  ctf_str_purge_refs (fp);\n+\n+  /* Now the string table is constructed, we can sort the buffer of\n+     ctf_varent_t's.  */\n+  ctf_qsort_r (dvarents, nvars, sizeof (ctf_varent_t), ctf_sort_var,\n+\t       strtab.cts_strs);\n+\n+  if ((newbuf = ctf_realloc (fp, buf, buf_size + strtab.cts_len)) == NULL)\n+    {\n+      ctf_free (buf);\n+      ctf_free (strtab.cts_strs);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+  buf = newbuf;\n+  memcpy (buf + buf_size, strtab.cts_strs, strtab.cts_len);\n+  hdrp = (ctf_header_t *) buf;\n+  hdrp->cth_strlen = strtab.cts_len;\n+  buf_size += hdrp->cth_strlen;\n+  ctf_free (strtab.cts_strs);\n+\n   /* Finally, we are ready to ctf_simple_open() the new container.  If this\n      is successful, we then switch nfp and fp and free the old container.  */\n \n-  if ((nfp = ctf_simple_open (buf, buf_size, NULL, 0, 0, NULL, 0, &err)) == NULL)\n+  if ((nfp = ctf_simple_open ((char *) buf, buf_size, NULL, 0, 0, NULL,\n+\t\t\t      0, &err)) == NULL)\n     {\n       ctf_free (buf);\n       return (ctf_set_errno (fp, err));\n@@ -466,7 +449,6 @@ ctf_update (ctf_file_t *fp)\n   nfp->ctf_dtbyname = fp->ctf_dtbyname;\n   nfp->ctf_dvhash = fp->ctf_dvhash;\n   nfp->ctf_dvdefs = fp->ctf_dvdefs;\n-  nfp->ctf_dtvstrlen = fp->ctf_dtvstrlen;\n   nfp->ctf_dtnextid = fp->ctf_dtnextid;\n   nfp->ctf_dtoldid = fp->ctf_dtnextid - 1;\n   nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n@@ -476,6 +458,9 @@ ctf_update (ctf_file_t *fp)\n \n   fp->ctf_dtbyname = NULL;\n   fp->ctf_dthash = NULL;\n+  ctf_str_free_atoms (nfp);\n+  nfp->ctf_str_atoms = fp->ctf_str_atoms;\n+  fp->ctf_str_atoms = NULL;\n   memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n \n   fp->ctf_dvhash = NULL;\n@@ -559,10 +544,7 @@ ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n \t   dmd != NULL; dmd = nmd)\n \t{\n \t  if (dmd->dmd_name != NULL)\n-\t    {\n-\t      fp->ctf_dtvstrlen -= strlen (dmd->dmd_name) + 1;\n \t      ctf_free (dmd->dmd_name);\n-\t    }\n \t  nmd = ctf_list_next (dmd);\n \t  ctf_free (dmd);\n \t}\n@@ -579,8 +561,6 @@ ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n       name = ctf_prefixed_name (kind, dtd->dtd_name);\n       ctf_dynhash_remove (fp->ctf_dtbyname, name);\n       free (name);\n-\n-      fp->ctf_dtvstrlen -= strlen (dtd->dtd_name) + 1;\n       ctf_free (dtd->dtd_name);\n     }\n \n@@ -638,8 +618,6 @@ void\n ctf_dvd_delete (ctf_file_t *fp, ctf_dvdef_t *dvd)\n {\n   ctf_dynhash_remove (fp->ctf_dvhash, dvd->dvd_name);\n-\n-  fp->ctf_dtvstrlen -= strlen (dvd->dvd_name) + 1;\n   ctf_free (dvd->dvd_name);\n \n   ctf_list_delete (&fp->ctf_dvdefs, dvd);\n@@ -763,9 +741,6 @@ ctf_add_generic (ctf_file_t *fp, uint32_t flag, const char *name,\n   dtd->dtd_name = s;\n   dtd->dtd_type = type;\n \n-  if (s != NULL)\n-    fp->ctf_dtvstrlen += strlen (s) + 1;\n-\n   if (ctf_dtd_insert (fp, dtd) < 0)\n     {\n       ctf_free (dtd);\n@@ -1272,7 +1247,6 @@ ctf_add_enumerator (ctf_file_t *fp, ctf_id_t enid, const char *name,\n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n   ctf_list_append (&dtd->dtd_u.dtu_members, dmd);\n \n-  fp->ctf_dtvstrlen += strlen (s) + 1;\n   fp->ctf_flags |= LCTF_DIRTY;\n \n   return 0;\n@@ -1392,9 +1366,6 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n   ctf_list_append (&dtd->dtd_u.dtu_members, dmd);\n \n-  if (s != NULL)\n-    fp->ctf_dtvstrlen += strlen (s) + 1;\n-\n   fp->ctf_flags |= LCTF_DIRTY;\n   return 0;\n }\n@@ -1456,7 +1427,6 @@ ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n       return -1;\t\t\t/* errno is set for us.  */\n     }\n \n-  fp->ctf_dtvstrlen += strlen (name) + 1;\n   fp->ctf_flags |= LCTF_DIRTY;\n   return 0;\n }\n@@ -1536,9 +1506,6 @@ membadd (const char *name, ctf_id_t type, unsigned long offset, void *arg)\n \n   ctf_list_append (&ctb->ctb_dtd->dtd_u.dtu_members, dmd);\n \n-  if (s != NULL)\n-    ctb->ctb_file->ctf_dtvstrlen += strlen (s) + 1;\n-\n   ctb->ctb_file->ctf_flags |= LCTF_DIRTY;\n   return 0;\n }"
    },
    {
      "sha": "b51118cc6f371c4f59f7bf1583a01afe9b16575b",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 41,
      "deletions": 2,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -71,6 +71,12 @@ typedef struct ctf_strs\n   size_t cts_len;\t\t/* Size of string table in bytes.  */\n } ctf_strs_t;\n \n+typedef struct ctf_strs_writable\n+{\n+  char *cts_strs;\t\t/* Base address of string table.  */\n+  size_t cts_len;\t\t/* Size of string table in bytes.  */\n+} ctf_strs_writable_t;\n+\n typedef struct ctf_dmodel\n {\n   const char *ctd_name;\t\t/* Data model name.  */\n@@ -147,7 +153,7 @@ typedef struct ctf_dtdef\n   ctf_list_t dtd_list;\t\t/* List forward/back pointers.  */\n   char *dtd_name;\t\t/* Name associated with definition (if any).  */\n   ctf_id_t dtd_type;\t\t/* Type identifier for this definition.  */\n-  ctf_type_t dtd_data;\t\t/* Type node (see <ctf.h>).  */\n+  ctf_type_t dtd_data;\t\t/* Type node: name left unpopulated.  */\n   union\n   {\n     ctf_list_t dtu_members;\t/* struct, union, or enum */\n@@ -173,6 +179,30 @@ typedef struct ctf_bundle\n   ctf_dtdef_t *ctb_dtd;\t\t/* CTF dynamic type definition (if any).  */\n } ctf_bundle_t;\n \n+/* Atoms associate strings with a list of the CTF items that reference that\n+   string, so that ctf_update() can instantiate all the strings using the\n+   ctf_str_atoms and then reassociate them with the real string later.\n+\n+   Strings can be interned into ctf_str_atom without having refs associated\n+   with them, for values that are returned to callers, etc.  Items are only\n+   removed from this table on ctf_close(), but on every ctf_update(), all the\n+   csa_refs in all entries are purged.  */\n+\n+typedef struct ctf_str_atom\n+{\n+  const char *csa_str;\t\t/* Backpointer to string (hash key).  */\n+  ctf_list_t csa_refs;\t\t/* This string's refs.  */\n+  unsigned long csa_snapshot_id; /* Snapshot ID at time of creation.  */\n+} ctf_str_atom_t;\n+\n+/* The refs of a single string in the atoms table.  */\n+\n+typedef struct ctf_str_atom_ref\n+{\n+  ctf_list_t caf_list;\t\t/* List forward/back pointers.  */\n+  uint32_t *caf_ref;\t\t/* A single ref to this string.  */\n+} ctf_str_atom_ref_t;\n+\n /* The ctf_file is the structure used to represent a CTF container to library\n    clients, who see it only as an opaque pointer.  Modifications can therefore\n    be made freely to this structure without regard to client versioning.  The\n@@ -198,6 +228,8 @@ struct ctf_file\n   ctf_hash_t *ctf_names;\t    /* Hash table of remaining type names.  */\n   ctf_lookup_t ctf_lookups[5];\t    /* Pointers to hashes for name lookup.  */\n   ctf_strs_t ctf_str[2];\t    /* Array of string table base and bounds.  */\n+  ctf_dynhash_t *ctf_str_atoms;\t  /* Hash table of ctf_str_atoms_t.  */\n+  uint64_t ctf_str_num_refs;\t  /* Number of refs to cts_str_atoms.  */\n   const unsigned char *ctf_base;  /* Base of CTF header + uncompressed buffer.  */\n   const unsigned char *ctf_buf;\t  /* Uncompressed CTF data buffer.  */\n   size_t ctf_size;\t\t  /* Size of CTF header + uncompressed data.  */\n@@ -223,7 +255,6 @@ struct ctf_file\n   ctf_list_t ctf_dtdefs;\t  /* List of dynamic type definitions.  */\n   ctf_dynhash_t *ctf_dvhash;\t  /* Hash of dynamic variable mappings.  */\n   ctf_list_t ctf_dvdefs;\t  /* List of dynamic variable definitions.  */\n-  size_t ctf_dtvstrlen;\t\t  /* Total length of dynamic type+var strings.  */\n   unsigned long ctf_dtnextid;\t  /* Next dynamic type id to assign.  */\n   unsigned long ctf_dtoldid;\t  /* Oldest id that has been committed.  */\n   unsigned long ctf_snapshots;\t  /* ctf_snapshot() plus ctf_update() count.  */\n@@ -341,6 +372,13 @@ extern char *ctf_decl_buf (ctf_decl_t *cd);\n \n extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n extern const char *ctf_strptr (ctf_file_t *, uint32_t);\n+extern int ctf_str_create_atoms (ctf_file_t *);\n+extern void ctf_str_free_atoms (ctf_file_t *);\n+extern const char *ctf_str_add (ctf_file_t *, const char *);\n+extern const char *ctf_str_add_ref (ctf_file_t *, const char *, uint32_t *);\n+extern void ctf_str_rollback (ctf_file_t *, ctf_snapshot_id_t);\n+extern void ctf_str_purge_refs (ctf_file_t *);\n+extern ctf_strs_writable_t ctf_str_write_strtab (ctf_file_t *);\n \n extern struct ctf_archive *ctf_arc_open_internal (const char *, int *);\n extern struct ctf_archive *ctf_arc_bufopen (const void *, size_t, int *);\n@@ -356,6 +394,7 @@ extern ssize_t ctf_pread (int fd, void *buf, ssize_t count, off_t offset);\n _libctf_malloc_\n extern void *ctf_alloc (size_t);\n extern void ctf_free (void *);\n+extern void *ctf_realloc (ctf_file_t *, void *, size_t);\n \n _libctf_malloc_\n extern char *ctf_strdup (const char *);"
    },
    {
      "sha": "8fc854ae6704f9f386db6bc5fbed3327964b08fa",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -1373,6 +1373,7 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n   memset (fp, 0, sizeof (ctf_file_t));\n   ctf_set_version (fp, &hp, hp.cth_version);\n+  ctf_str_create_atoms (fp);\n \n   if (_libctf_unlikely_ (hp.cth_version < CTF_VERSION_2))\n     fp->ctf_parmax = CTF_MAX_PTYPE_V1;\n@@ -1528,6 +1529,7 @@ ctf_file_close (ctf_file_t *fp)\n       ctf_dvd_delete (fp, dvd);\n     }\n   ctf_dynhash_destroy (fp->ctf_dvhash);\n+  ctf_str_free_atoms (fp);\n \n   ctf_free (fp->ctf_tmp_typeslice);\n "
    },
    {
      "sha": "27bd7c2bbaf8dd671b18b3af3bf57dd7b867ab61",
      "filename": "libctf/ctf-string.c",
      "status": "added",
      "additions": 330,
      "deletions": 0,
      "changes": 330,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -0,0 +1,330 @@\n+/* CTF string table management.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+\n+/* Convert an encoded CTF string name into a pointer to a C string by looking\n+  up the appropriate string table buffer and then adding the offset.  */\n+const char *\n+ctf_strraw (ctf_file_t *fp, uint32_t name)\n+{\n+  ctf_strs_t *ctsp = &fp->ctf_str[CTF_NAME_STID (name)];\n+\n+  if (ctsp->cts_strs != NULL && CTF_NAME_OFFSET (name) < ctsp->cts_len)\n+    return (ctsp->cts_strs + CTF_NAME_OFFSET (name));\n+\n+  /* String table not loaded or corrupt offset.  */\n+  return NULL;\n+}\n+\n+/* Return a guaranteed-non-NULL pointer to the string with the given CTF\n+   name.  */\n+const char *\n+ctf_strptr (ctf_file_t *fp, uint32_t name)\n+{\n+  const char *s = ctf_strraw (fp, name);\n+  return (s != NULL ? s : \"(?)\");\n+}\n+\n+/* Remove all refs to a given atom.  */\n+static void\n+ctf_str_purge_atom_refs (ctf_str_atom_t *atom)\n+{\n+  ctf_str_atom_ref_t *ref, *next;\n+\n+  for (ref = ctf_list_next (&atom->csa_refs); ref != NULL; ref = next)\n+    {\n+      next = ctf_list_next (ref);\n+      ctf_list_delete (&atom->csa_refs, ref);\n+      ctf_free (ref);\n+    }\n+}\n+\n+/* Free an atom (only called on ctf_close().)  */\n+static void\n+ctf_str_free_atom (void *a)\n+{\n+  ctf_str_atom_t *atom = a;\n+\n+  ctf_str_purge_atom_refs (atom);\n+  ctf_free (atom);\n+}\n+\n+/* Create the atoms table.  There is always at least one atom in it, the null\n+   string.  */\n+int\n+ctf_str_create_atoms (ctf_file_t *fp)\n+{\n+  fp->ctf_str_atoms = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\t\t  ctf_free, ctf_str_free_atom);\n+  if (fp->ctf_str_atoms == NULL)\n+    return -ENOMEM;\n+\n+  ctf_str_add (fp, \"\");\n+  return 0;\n+}\n+\n+/* Destroy the atoms table.  */\n+void\n+ctf_str_free_atoms (ctf_file_t *fp)\n+{\n+  ctf_dynhash_destroy (fp->ctf_str_atoms);\n+}\n+\n+/* Add a string to the atoms table and return it, or return an existing string\n+   if present, copying the passed-in string.  Returns NULL only when out of\n+   memory (and do not touch the passed-in string in that case).  Possibly\n+   augment the ref list with the passed-in ref.  */\n+static const char *\n+ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n+\t\t\t  int add_ref, uint32_t *ref)\n+{\n+  char *newstr = NULL;\n+  ctf_str_atom_t *atom = NULL;\n+  ctf_str_atom_ref_t *aref = NULL;\n+\n+  atom = ctf_dynhash_lookup (fp->ctf_str_atoms, str);\n+\n+  if (add_ref)\n+    {\n+      if ((aref = ctf_alloc (sizeof (struct ctf_str_atom_ref))) == NULL)\n+\treturn NULL;\n+      aref->caf_ref = ref;\n+    }\n+\n+  if (atom)\n+    {\n+      if (add_ref)\n+\t{\n+\t  ctf_list_append (&atom->csa_refs, aref);\n+\t  fp->ctf_str_num_refs++;\n+\t}\n+      return atom->csa_str;\n+    }\n+\n+  if ((atom = ctf_alloc (sizeof (struct ctf_str_atom))) == NULL)\n+    goto oom;\n+  memset (atom, 0, sizeof (struct ctf_str_atom));\n+\n+  if ((newstr = ctf_strdup (str)) == NULL)\n+    goto oom;\n+\n+  if (ctf_dynhash_insert (fp->ctf_str_atoms, newstr, atom) < 0)\n+    goto oom;\n+\n+  atom->csa_str = newstr;\n+  atom->csa_snapshot_id = fp->ctf_snapshots;\n+  if (add_ref)\n+    {\n+      ctf_list_append (&atom->csa_refs, aref);\n+      fp->ctf_str_num_refs++;\n+    }\n+  return newstr;\n+\n+ oom:\n+  ctf_free (atom);\n+  ctf_free (aref);\n+  ctf_free (newstr);\n+  return NULL;\n+}\n+\n+/* Add a string to the atoms table and return it, without augmenting the ref\n+   list for this string.  */\n+const char *\n+ctf_str_add (ctf_file_t *fp, const char *str)\n+{\n+  if (str)\n+    return ctf_str_add_ref_internal (fp, str, FALSE, 0);\n+  return NULL;\n+}\n+\n+/* A ctf_dynhash_iter_remove() callback that removes atoms later than a given\n+   snapshot ID.  */\n+static int\n+ctf_str_rollback_atom (void *key _libctf_unused_, void *value, void *arg)\n+{\n+  ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n+  ctf_snapshot_id_t *id = (ctf_snapshot_id_t *) arg;\n+\n+  return (atom->csa_snapshot_id > id->snapshot_id);\n+}\n+\n+/* Roll back, deleting all atoms created after a particular ID.  */\n+void\n+ctf_str_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n+{\n+  ctf_dynhash_iter_remove (fp->ctf_str_atoms, ctf_str_rollback_atom, &id);\n+}\n+\n+/* Like ctf_str_add(), but additionally augment the atom's refs list with the\n+   passed-in ref, whether or not the string is already present.  There is no\n+   attempt to deduplicate the refs list (but duplicates are harmless).  */\n+const char *\n+ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n+{\n+  if (str)\n+    return ctf_str_add_ref_internal (fp, str, TRUE, ref);\n+  return NULL;\n+}\n+\n+/* An adaptor around ctf_purge_atom_refs.  */\n+static void\n+ctf_str_purge_one_atom_refs (void *key _libctf_unused_, void *value,\n+\t\t\t     void *arg _libctf_unused_)\n+{\n+  ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n+  ctf_str_purge_atom_refs (atom);\n+}\n+\n+/* Remove all the recorded refs from the atoms table.  */\n+void\n+ctf_str_purge_refs (ctf_file_t *fp)\n+{\n+  if (fp->ctf_str_num_refs > 0)\n+    ctf_dynhash_iter (fp->ctf_str_atoms, ctf_str_purge_one_atom_refs, NULL);\n+  fp->ctf_str_num_refs = 0;\n+}\n+\n+/* Update a list of refs to the specified value. */\n+static void\n+ctf_str_update_refs (ctf_str_atom_t *refs, uint32_t value)\n+{\n+  ctf_str_atom_ref_t *ref;\n+\n+  for (ref = ctf_list_next (&refs->csa_refs); ref != NULL;\n+       ref = ctf_list_next (ref))\n+      *(ref->caf_ref) = value;\n+}\n+\n+/* State shared across the strtab write process.  */\n+typedef struct ctf_strtab_write_state\n+{\n+  /* Strtab we are writing, and the number of strings in it.  */\n+  ctf_strs_writable_t *strtab;\n+  size_t strtab_count;\n+\n+  /* Pointers to (existing) atoms in the atoms table, for qsorting.  */\n+  ctf_str_atom_t **sorttab;\n+\n+  /* Loop counter for sorttab population.  */\n+  size_t i;\n+\n+  /* The null-string atom (skipped during population).  */\n+  ctf_str_atom_t *nullstr;\n+} ctf_strtab_write_state_t;\n+\n+/* Count the number of entries in the strtab, and its length.  */\n+static void\n+ctf_str_count_strtab (void *key _libctf_unused_, void *value,\n+\t      void *arg)\n+{\n+  ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n+  ctf_strtab_write_state_t *s = (ctf_strtab_write_state_t *) arg;\n+\n+  s->strtab->cts_len += strlen (atom->csa_str) + 1;\n+  s->strtab_count++;\n+}\n+\n+/* Populate the sorttab with pointers to the strtab atoms.  */\n+static void\n+ctf_str_populate_sorttab (void *key _libctf_unused_, void *value,\n+\t\t  void *arg)\n+{\n+  ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n+  ctf_strtab_write_state_t *s = (ctf_strtab_write_state_t *) arg;\n+\n+  /* Skip the null string.  */\n+  if (s->nullstr == atom)\n+    return;\n+\n+  s->sorttab[s->i++] = atom;\n+}\n+\n+/* Sort the strtab.  */\n+static int\n+ctf_str_sort_strtab (const void *a, const void *b)\n+{\n+  ctf_str_atom_t **one = (ctf_str_atom_t **) a;\n+  ctf_str_atom_t **two = (ctf_str_atom_t **) b;\n+\n+  return (strcmp ((*one)->csa_str, (*two)->csa_str));\n+}\n+\n+/* Write out and return a strtab containing all strings with recorded refs,\n+   adjusting the refs to refer to the corresponding string.  The returned\n+   strtab may be NULL on error.  */\n+ctf_strs_writable_t\n+ctf_str_write_strtab (ctf_file_t *fp)\n+{\n+  ctf_strs_writable_t strtab;\n+  ctf_str_atom_t *nullstr;\n+  uint32_t cur_stroff = 0;\n+  ctf_strtab_write_state_t s;\n+  ctf_str_atom_t **sorttab;\n+  size_t i;\n+\n+  memset (&strtab, 0, sizeof (struct ctf_strs_writable));\n+  memset (&s, 0, sizeof (struct ctf_strtab_write_state));\n+  s.strtab = &strtab;\n+\n+  nullstr = ctf_dynhash_lookup (fp->ctf_str_atoms, \"\");\n+  if (!nullstr)\n+    {\n+      ctf_dprintf (\"Internal error: null string not found in strtab.\\n\");\n+      strtab.cts_strs = NULL;\n+      return strtab;\n+    }\n+\n+  ctf_dynhash_iter (fp->ctf_str_atoms, ctf_str_count_strtab, &s);\n+\n+  ctf_dprintf (\"%lu bytes of strings in strtab.\\n\",\n+\t       (unsigned long) strtab.cts_len);\n+\n+  /* Sort the strtab.  Force the null string to be first.  */\n+  sorttab = calloc (s.strtab_count, sizeof (ctf_str_atom_t *));\n+  if (!sorttab)\n+      return strtab;\n+\n+  sorttab[0] = nullstr;\n+  s.i = 1;\n+  s.sorttab = sorttab;\n+  s.nullstr = nullstr;\n+  ctf_dynhash_iter (fp->ctf_str_atoms, ctf_str_populate_sorttab, &s);\n+\n+  qsort (&sorttab[1], s.strtab_count - 1, sizeof (ctf_str_atom_t *),\n+\t ctf_str_sort_strtab);\n+\n+  if ((strtab.cts_strs = ctf_alloc (strtab.cts_len)) == NULL)\n+    {\n+      free (sorttab);\n+      return strtab;\n+    }\n+\n+  /* Update the strtab, and all refs.  */\n+  for (i = 0; i < s.strtab_count; i++)\n+    {\n+      strcpy (&strtab.cts_strs[cur_stroff], sorttab[i]->csa_str);\n+      ctf_str_update_refs (sorttab[i], cur_stroff);\n+      cur_stroff += strlen (sorttab[i]->csa_str) + 1;\n+    }\n+  free (sorttab);\n+\n+  return strtab;\n+}"
    },
    {
      "sha": "b813c0d41411c570e3aeec4965742b8942be533e",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 13,
      "deletions": 22,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5e9c9bde04ae52b92027b78c9ca20055f1afb78/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=f5e9c9bde04ae52b92027b78c9ca20055f1afb78",
      "patch": "@@ -95,28 +95,6 @@ ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst)\n   return dst;\n }\n \n-/* Convert an encoded CTF string name into a pointer to a C string by looking\n-  up the appropriate string table buffer and then adding the offset.  */\n-\n-const char *\n-ctf_strraw (ctf_file_t *fp, uint32_t name)\n-{\n-  ctf_strs_t *ctsp = &fp->ctf_str[CTF_NAME_STID (name)];\n-\n-  if (ctsp->cts_strs != NULL && CTF_NAME_OFFSET (name) < ctsp->cts_len)\n-    return (ctsp->cts_strs + CTF_NAME_OFFSET (name));\n-\n-  /* String table not loaded or corrupt offset.  */\n-  return NULL;\n-}\n-\n-const char *\n-ctf_strptr (ctf_file_t *fp, uint32_t name)\n-{\n-  const char *s = ctf_strraw (fp, name);\n-  return (s != NULL ? s : \"(?)\");\n-}\n-\n /* Same as strdup(3C), but use ctf_alloc() to do the memory allocation. */\n \n _libctf_malloc_ char *\n@@ -154,6 +132,19 @@ ctf_str_append (char *s, const char *append)\n   return s;\n }\n \n+/* A realloc() that fails noisily if called with any ctf_str_num_users.  */\n+void *\n+ctf_realloc (ctf_file_t *fp, void *ptr, size_t size)\n+{\n+  if (fp->ctf_str_num_refs > 0)\n+    {\n+      ctf_dprintf (\"%p: attempt to realloc() string table with %lu active refs\\n\",\n+\t\t   (void *) fp, (unsigned long) fp->ctf_str_num_refs);\n+      return NULL;\n+    }\n+  return realloc (ptr, size);\n+}\n+\n /* Store the specified error code into errp if it is non-NULL, and then\n    return NULL for the benefit of the caller.  */\n "
    }
  ]
}