{
  "sha": "801e2396c64dc755b708e981454d927bb953783d",
  "node_id": "C_kwDOANOeidoAKDgwMWUyMzk2YzY0ZGM3NTViNzA4ZTk4MTQ1NGQ5MjdiYjk1Mzc4M2Q",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-14T23:49:05Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-17T21:53:44Z"
    },
    "message": "Do not generate gdbarch.h\n\nNow that gdbarch.h has been split, we no longer need the generator\ncode in gdbarch.sh, so remove it.",
    "tree": {
      "sha": "adfea31594ac9d3f838dced33f54b07191dd1567",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/adfea31594ac9d3f838dced33f54b07191dd1567"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/801e2396c64dc755b708e981454d927bb953783d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/801e2396c64dc755b708e981454d927bb953783d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/801e2396c64dc755b708e981454d927bb953783d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/801e2396c64dc755b708e981454d927bb953783d/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2b7c3f1dc0fb7158ec019018d61927f364243fbc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b7c3f1dc0fb7158ec019018d61927f364243fbc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2b7c3f1dc0fb7158ec019018d61927f364243fbc"
    }
  ],
  "stats": {
    "total": 377,
    "additions": 0,
    "deletions": 377
  },
  "files": [
    {
      "sha": "1acfda4be38ba06858cafc72963585d7b8c5098c",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 0,
      "deletions": 377,
      "changes": 377,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/801e2396c64dc755b708e981454d927bb953783d/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/801e2396c64dc755b708e981454d927bb953783d/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=801e2396c64dc755b708e981454d927bb953783d",
      "patch": "@@ -1286,383 +1286,6 @@ cat <<EOF\n EOF\n }\n \n-#\n-# The .h file\n-#\n-\n-exec > new-gdbarch.h\n-copyright | sed 1,3d | grep -v 'was created'\n-cat <<EOF\n-#ifndef GDBARCH_H\n-#define GDBARCH_H\n-\n-#include <vector>\n-#include \"frame.h\"\n-#include \"dis-asm.h\"\n-#include \"gdb_obstack.h\"\n-#include \"infrun.h\"\n-#include \"osabi.h\"\n-#include \"displaced-stepping.h\"\n-\n-struct floatformat;\n-struct ui_file;\n-struct value;\n-struct objfile;\n-struct obj_section;\n-struct minimal_symbol;\n-struct regcache;\n-struct reggroup;\n-struct regset;\n-struct disassemble_info;\n-struct target_ops;\n-struct obstack;\n-struct bp_target_info;\n-struct target_desc;\n-struct symbol;\n-struct syscall;\n-struct agent_expr;\n-struct axs_value;\n-struct stap_parse_info;\n-struct expr_builder;\n-struct ravenscar_arch_ops;\n-struct mem_range;\n-struct syscalls_info;\n-struct thread_info;\n-struct ui_out;\n-struct inferior;\n-\n-#include \"regcache.h\"\n-\n-struct gdbarch_tdep {};\n-\n-/* The architecture associated with the inferior through the\n-   connection to the target.\n-\n-   The architecture vector provides some information that is really a\n-   property of the inferior, accessed through a particular target:\n-   ptrace operations; the layout of certain RSP packets; the solib_ops\n-   vector; etc.  To differentiate architecture accesses to\n-   per-inferior/target properties from\n-   per-thread/per-frame/per-objfile properties, accesses to\n-   per-inferior/target properties should be made through this\n-   gdbarch.  */\n-\n-/* This is a convenience wrapper for 'current_inferior ()->gdbarch'.  */\n-extern struct gdbarch *target_gdbarch (void);\n-\n-/* Callback type for the 'iterate_over_objfiles_in_search_order'\n-   gdbarch  method.  */\n-\n-typedef int (iterate_over_objfiles_in_search_order_cb_ftype)\n-  (struct objfile *objfile, void *cb_data);\n-\n-/* Callback type for regset section iterators.  The callback usually\n-   invokes the REGSET's supply or collect method, to which it must\n-   pass a buffer - for collects this buffer will need to be created using\n-   COLLECT_SIZE, for supply the existing buffer being read from should\n-   be at least SUPPLY_SIZE.  SECT_NAME is a BFD section name, and HUMAN_NAME\n-   is used for diagnostic messages.  CB_DATA should have been passed\n-   unchanged through the iterator.  */\n-\n-typedef void (iterate_over_regset_sections_cb)\n-  (const char *sect_name, int supply_size, int collect_size,\n-   const struct regset *regset, const char *human_name, void *cb_data);\n-\n-/* For a function call, does the function return a value using a\n-   normal value return or a structure return - passing a hidden\n-   argument pointing to storage.  For the latter, there are two\n-   cases: language-mandated structure return and target ABI\n-   structure return.  */\n-\n-enum function_call_return_method\n-{\n-  /* Standard value return.  */\n-  return_method_normal = 0,\n-\n-  /* Language ABI structure return.  This is handled\n-     by passing the return location as the first parameter to\n-     the function, even preceding \"this\".  */\n-  return_method_hidden_param,\n-\n-  /* Target ABI struct return.  This is target-specific; for instance,\n-     on ia64 the first argument is passed in out0 but the hidden\n-     structure return pointer would normally be passed in r8.  */\n-  return_method_struct,\n-};\n-\n-enum class memtag_type\n-{\n-  /* Logical tag, the tag that is stored in unused bits of a pointer to a\n-     virtual address.  */\n-  logical = 0,\n-\n-  /* Allocation tag, the tag that is associated with every granule of memory in\n-     the physical address space.  Allocation tags are used to validate memory\n-     accesses via pointers containing logical tags.  */\n-  allocation,\n-};\n-\n-/* Callback types for 'read_core_file_mappings' gdbarch method.  */\n-\n-using read_core_file_mappings_pre_loop_ftype =\n-  gdb::function_view<void (ULONGEST count)>;\n-\n-using read_core_file_mappings_loop_ftype =\n-  gdb::function_view<void (int num,\n-\t\t\t   ULONGEST start,\n-\t\t\t   ULONGEST end,\n-\t\t\t   ULONGEST file_ofs,\n-\t\t\t   const char *filename,\n-\t\t\t   const bfd_build_id *build_id)>;\n-EOF\n-# close it off\n-cat <<EOF\n-\n-#include \"gdbarch-gen.h\"\n-\n-extern struct gdbarch_tdep *gdbarch_tdep (struct gdbarch *gdbarch);\n-\n-\n-/* Mechanism for co-ordinating the selection of a specific\n-   architecture.\n-\n-   GDB targets (*-tdep.c) can register an interest in a specific\n-   architecture.  Other GDB components can register a need to maintain\n-   per-architecture data.\n-\n-   The mechanisms below ensures that there is only a loose connection\n-   between the set-architecture command and the various GDB\n-   components.  Each component can independently register their need\n-   to maintain architecture specific data with gdbarch.\n-\n-   Pragmatics:\n-\n-   Previously, a single TARGET_ARCHITECTURE_HOOK was provided.  It\n-   didn't scale.\n-\n-   The more traditional mega-struct containing architecture specific\n-   data for all the various GDB components was also considered.  Since\n-   GDB is built from a variable number of (fairly independent)\n-   components it was determined that the global aproach was not\n-   applicable.  */\n-\n-\n-/* Register a new architectural family with GDB.\n-\n-   Register support for the specified ARCHITECTURE with GDB.  When\n-   gdbarch determines that the specified architecture has been\n-   selected, the corresponding INIT function is called.\n-\n-   --\n-\n-   The INIT function takes two parameters: INFO which contains the\n-   information available to gdbarch about the (possibly new)\n-   architecture; ARCHES which is a list of the previously created\n-   \\`\\`struct gdbarch'' for this architecture.\n-\n-   The INFO parameter is, as far as possible, be pre-initialized with\n-   information obtained from INFO.ABFD or the global defaults.\n-\n-   The ARCHES parameter is a linked list (sorted most recently used)\n-   of all the previously created architures for this architecture\n-   family.  The (possibly NULL) ARCHES->gdbarch can used to access\n-   values from the previously selected architecture for this\n-   architecture family.\n-\n-   The INIT function shall return any of: NULL - indicating that it\n-   doesn't recognize the selected architecture; an existing \\`\\`struct\n-   gdbarch'' from the ARCHES list - indicating that the new\n-   architecture is just a synonym for an earlier architecture (see\n-   gdbarch_list_lookup_by_info()); a newly created \\`\\`struct gdbarch''\n-   - that describes the selected architecture (see gdbarch_alloc()).\n-\n-   The DUMP_TDEP function shall print out all target specific values.\n-   Care should be taken to ensure that the function works in both the\n-   multi-arch and non- multi-arch cases.  */\n-\n-struct gdbarch_list\n-{\n-  struct gdbarch *gdbarch;\n-  struct gdbarch_list *next;\n-};\n-\n-struct gdbarch_info\n-{\n-  gdbarch_info ()\n-    /* Ensure the union is zero-initialized.  Relies on the fact that there's\n-       no member larger than TDESC_DATA.  */\n-    : tdesc_data ()\n-  {}\n-\n-  const struct bfd_arch_info *bfd_arch_info = nullptr;\n-\n-  enum bfd_endian byte_order = BFD_ENDIAN_UNKNOWN;\n-\n-  enum bfd_endian byte_order_for_code = BFD_ENDIAN_UNKNOWN;\n-\n-  bfd *abfd = nullptr;\n-\n-  union\n-    {\n-      /* Architecture-specific target description data.  Numerous targets\n-\t need only this, so give them an easy way to hold it.  */\n-      struct tdesc_arch_data *tdesc_data;\n-\n-      /* SPU file system ID.  This is a single integer, so using the\n-\t generic form would only complicate code.  Other targets may\n-\t reuse this member if suitable.  */\n-      int *id;\n-    };\n-\n-  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;\n-\n-  const struct target_desc *target_desc = nullptr;\n-};\n-\n-typedef struct gdbarch *(gdbarch_init_ftype) (struct gdbarch_info info, struct gdbarch_list *arches);\n-typedef void (gdbarch_dump_tdep_ftype) (struct gdbarch *gdbarch, struct ui_file *file);\n-\n-/* DEPRECATED - use gdbarch_register() */\n-extern void register_gdbarch_init (enum bfd_architecture architecture, gdbarch_init_ftype *);\n-\n-extern void gdbarch_register (enum bfd_architecture architecture,\n-\t\t\t      gdbarch_init_ftype *,\n-\t\t\t      gdbarch_dump_tdep_ftype *);\n-\n-\n-/* Return a vector of the valid architecture names.  Since architectures are\n-   registered during the _initialize phase this function only returns useful\n-   information once initialization has been completed.  */\n-\n-extern std::vector<const char *> gdbarch_printable_names ();\n-\n-\n-/* Helper function.  Search the list of ARCHES for a GDBARCH that\n-   matches the information provided by INFO.  */\n-\n-extern struct gdbarch_list *gdbarch_list_lookup_by_info (struct gdbarch_list *arches, const struct gdbarch_info *info);\n-\n-\n-/* Helper function.  Create a preliminary \\`\\`struct gdbarch''.  Perform\n-   basic initialization using values obtained from the INFO and TDEP\n-   parameters.  set_gdbarch_*() functions are called to complete the\n-   initialization of the object.  */\n-\n-extern struct gdbarch *gdbarch_alloc (const struct gdbarch_info *info, struct gdbarch_tdep *tdep);\n-\n-\n-/* Helper function.  Free a partially-constructed \\`\\`struct gdbarch''.\n-   It is assumed that the caller freeds the \\`\\`struct\n-   gdbarch_tdep''.  */\n-\n-extern void gdbarch_free (struct gdbarch *);\n-\n-/* Get the obstack owned by ARCH.  */\n-\n-extern obstack *gdbarch_obstack (gdbarch *arch);\n-\n-/* Helper function.  Allocate memory from the \\`\\`struct gdbarch''\n-   obstack.  The memory is freed when the corresponding architecture\n-   is also freed.  */\n-\n-#define GDBARCH_OBSTACK_CALLOC(GDBARCH, NR, TYPE) \\\n-  obstack_calloc<TYPE> (gdbarch_obstack ((GDBARCH)), (NR))\n-\n-#define GDBARCH_OBSTACK_ZALLOC(GDBARCH, TYPE) \\\n-  obstack_zalloc<TYPE> (gdbarch_obstack ((GDBARCH)))\n-\n-/* Duplicate STRING, returning an equivalent string that's allocated on the\n-   obstack associated with GDBARCH.  The string is freed when the corresponding\n-   architecture is also freed.  */\n-\n-extern char *gdbarch_obstack_strdup (struct gdbarch *arch, const char *string);\n-\n-/* Helper function.  Force an update of the current architecture.\n-\n-   The actual architecture selected is determined by INFO, \\`\\`(gdb) set\n-   architecture'' et.al., the existing architecture and BFD's default\n-   architecture.  INFO should be initialized to zero and then selected\n-   fields should be updated.\n-\n-   Returns non-zero if the update succeeds.  */\n-\n-extern int gdbarch_update_p (struct gdbarch_info info);\n-\n-\n-/* Helper function.  Find an architecture matching info.\n-\n-   INFO should have relevant fields set, and then finished using\n-   gdbarch_info_fill.\n-\n-   Returns the corresponding architecture, or NULL if no matching\n-   architecture was found.  */\n-\n-extern struct gdbarch *gdbarch_find_by_info (struct gdbarch_info info);\n-\n-\n-/* Helper function.  Set the target gdbarch to \"gdbarch\".  */\n-\n-extern void set_target_gdbarch (struct gdbarch *gdbarch);\n-\n-\n-/* Register per-architecture data-pointer.\n-\n-   Reserve space for a per-architecture data-pointer.  An identifier\n-   for the reserved data-pointer is returned.  That identifer should\n-   be saved in a local static variable.\n-\n-   Memory for the per-architecture data shall be allocated using\n-   gdbarch_obstack_zalloc.  That memory will be deleted when the\n-   corresponding architecture object is deleted.\n-\n-   When a previously created architecture is re-selected, the\n-   per-architecture data-pointer for that previous architecture is\n-   restored.  INIT() is not re-called.\n-\n-   Multiple registrarants for any architecture are allowed (and\n-   strongly encouraged).  */\n-\n-struct gdbarch_data;\n-\n-typedef void *(gdbarch_data_pre_init_ftype) (struct obstack *obstack);\n-extern struct gdbarch_data *gdbarch_data_register_pre_init (gdbarch_data_pre_init_ftype *init);\n-typedef void *(gdbarch_data_post_init_ftype) (struct gdbarch *gdbarch);\n-extern struct gdbarch_data *gdbarch_data_register_post_init (gdbarch_data_post_init_ftype *init);\n-\n-extern void *gdbarch_data (struct gdbarch *gdbarch, struct gdbarch_data *);\n-\n-\n-/* Set the dynamic target-system-dependent parameters (architecture,\n-   byte-order, ...) using information found in the BFD.  */\n-\n-extern void set_gdbarch_from_file (bfd *);\n-\n-\n-/* Initialize the current architecture to the \"first\" one we find on\n-   our list.  */\n-\n-extern void initialize_current_architecture (void);\n-\n-/* gdbarch trace variable */\n-extern unsigned int gdbarch_debug;\n-\n-extern void gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file);\n-\n-/* Return the number of cooked registers (raw + pseudo) for ARCH.  */\n-\n-static inline int\n-gdbarch_num_cooked_regs (gdbarch *arch)\n-{\n-  return gdbarch_num_regs (arch) + gdbarch_num_pseudo_regs (arch);\n-}\n-\n-#endif\n-EOF\n-\n-exec 1>&2\n-../move-if-change new-gdbarch.h gdbarch.h\n-rm -f new-gdbarch.h\n-\n exec > new-gdbarch-gen.h\n copyright\n "
    }
  ]
}