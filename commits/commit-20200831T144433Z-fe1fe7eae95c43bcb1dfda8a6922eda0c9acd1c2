{
  "sha": "fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmUxZmU3ZWFlOTVjNDNiY2IxZGZkYThhNjkyMmVkYTBjOWFjZDFjMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-08-31T14:44:33Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-08-31T14:44:33Z"
    },
    "message": "gdb: remove NULL_TYPE\n\nThe NULL_TYPE macro is not very useful... remove it and just use\nnullptr.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (NULL_TYPE): Remove, change all uses to nullptr.\n\nChange-Id: Ic6215921413dad5649192b012f1a41d0a650a644",
    "tree": {
      "sha": "48f9597e8e198437fbc4489d9efc70f7f8204167",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/48f9597e8e198437fbc4489d9efc70f7f8204167"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "06de2e0da24a0f0fdc9b38f8308ec909453c4ee8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/06de2e0da24a0f0fdc9b38f8308ec909453c4ee8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/06de2e0da24a0f0fdc9b38f8308ec909453c4ee8"
    }
  ],
  "stats": {
    "total": 339,
    "additions": 169,
    "deletions": 170
  },
  "files": [
    {
      "sha": "8cb475d367a0bdb5eb1d88da02312dca33cafae6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -1,3 +1,7 @@\n+2020-08-31  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (NULL_TYPE): Remove, change all uses to nullptr.\n+\n 2020-08-29  Pedro Alves  <pedro@palves.net>\n \n \t* progspace.c (print_program_space): Use all_inferiors.  Switch to"
    },
    {
      "sha": "e405cd23d211a1f5d514aa2c98790486582326e8",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 48,
      "deletions": 48,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -9147,7 +9147,7 @@ ada_enum_name (const char *name)\n static struct value *\n evaluate_subexp_type (struct expression *exp, int *pos)\n {\n-  return evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+  return evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n }\n \n /* If VAL is wrapped in an aligner or subtype wrapper, return the\n@@ -10133,7 +10133,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       return ada_evaluate_subexp (type, exp, pos, noside);\n \n     case BINOP_ASSIGN:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (exp->elts[*pos].opcode == OP_AGGREGATE)\n \t{\n \t  arg1 = assign_aggregate (arg1, arg1, exp, pos, noside);\n@@ -10221,8 +10221,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n     case BINOP_DIV:\n     case BINOP_REM:\n     case BINOP_MOD:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -10243,7 +10243,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n     case BINOP_EQUAL:\n     case BINOP_NOTEQUAL:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n@@ -10260,7 +10260,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       return value_from_longest (type, (LONGEST) tem);\n \n     case UNOP_NEG:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       else if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1)))\n@@ -10289,8 +10289,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       {\n         struct value *val;\n \n-        arg1 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-        *pos = pc;\n+\targ1 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+\t*pos = pc;\n         val = evaluate_subexp_standard (expect_type, exp, pos, noside);\n \n         return value_cast (value_type (arg1), val);\n@@ -10341,7 +10341,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t\t a fixed type would result in the loss of that type name,\n \t\t thus preventing us from printing the name of the ancestor\n \t\t type in the type description.  */\n-\t      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_NORMAL);\n+\t      arg1 = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n \n \t      if (type->code () != TYPE_CODE_REF)\n \t\t{\n@@ -10404,8 +10404,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       else\n         {\n           for (tem = 0; tem <= nargs; tem += 1)\n-            argvec[tem] = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-          argvec[tem] = 0;\n+\t    argvec[tem] = evaluate_subexp (nullptr, exp, pos, noside);\n+\t  argvec[tem] = 0;\n \n           if (noside == EVAL_SKIP)\n             goto nosideret;\n@@ -10534,12 +10534,12 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n     case TERNOP_SLICE:\n       {\n-        struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-        struct value *low_bound_val =\n-          evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-        struct value *high_bound_val =\n-          evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-        LONGEST low_bound;\n+\tstruct value *array = evaluate_subexp (nullptr, exp, pos, noside);\n+\tstruct value *low_bound_val\n+\t  = evaluate_subexp (nullptr, exp, pos, noside);\n+\tstruct value *high_bound_val\n+\t  = evaluate_subexp (nullptr, exp, pos, noside);\n+\tLONGEST low_bound;\n         LONGEST high_bound;\n \n         low_bound_val = coerce_ref (low_bound_val);\n@@ -10617,7 +10617,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n     case UNOP_IN_RANGE:\n       (*pos) += 2;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type = check_typedef (exp->elts[pc + 1].type);\n \n       if (noside == EVAL_SKIP)\n@@ -10649,8 +10649,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n     case BINOP_IN_BOUNDS:\n       (*pos) += 2;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       if (noside == EVAL_SKIP)\n         goto nosideret;\n@@ -10681,9 +10681,9 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n                                 || value_equal (arg2, arg1)));\n \n     case TERNOP_IN_RANGE:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg3 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       if (noside == EVAL_SKIP)\n         goto nosideret;\n@@ -10706,14 +10706,14 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n         if (exp->elts[*pos].opcode == OP_TYPE)\n           {\n-            evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n-            arg1 = NULL;\n+\t    evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n+\t    arg1 = NULL;\n             type_arg = check_typedef (exp->elts[pc + 2].type);\n           }\n         else\n           {\n-            arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-            type_arg = NULL;\n+\t    arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+\t    type_arg = NULL;\n           }\n \n         if (exp->elts[*pos].opcode != OP_LONG)\n@@ -10843,7 +10843,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       }\n \n     case OP_ATR_TAG:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n \n@@ -10854,9 +10854,9 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n     case OP_ATR_MIN:\n     case OP_ATR_MAX:\n-      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -10872,8 +10872,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       {\n         struct type *type_arg = check_typedef (exp->elts[pc + 2].type);\n \n-        evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n-        if (noside == EVAL_SKIP)\n+\tevaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n+\tif (noside == EVAL_SKIP)\n           goto nosideret;\n \n         if (!ada_is_modular_type (type_arg))\n@@ -10885,8 +10885,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n \n     case OP_ATR_POS:\n-      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       type = builtin_type (exp->gdbarch)->builtin_int;\n@@ -10896,7 +10896,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \treturn value_pos_atr (type, arg1);\n \n     case OP_ATR_SIZE:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type = value_type (arg1);\n \n       /* If the argument is a reference, then dereference its type, since\n@@ -10914,8 +10914,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n                                    TARGET_CHAR_BIT * TYPE_LENGTH (type));\n \n     case OP_ATR_VAL:\n-      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type = exp->elts[pc + 2].type;\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n@@ -10925,8 +10925,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n         return value_val_atr (type, arg1);\n \n     case BINOP_EXP:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -10944,14 +10944,14 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t}\n \n     case UNOP_PLUS:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       else\n         return arg1;\n \n     case UNOP_ABS:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       unop_promote (exp->language_defn, exp->gdbarch, &arg1);\n@@ -10962,7 +10962,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n     case UNOP_IND:\n       preeval_pos = *pos;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       type = ada_check_typedef (value_type (arg1));\n@@ -10991,8 +10991,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t\t   || type->code () == TYPE_CODE_PTR)\n \t\t  && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0))\n \t\t{\n-\t\t  arg1 = evaluate_subexp (NULL_TYPE, exp, &preeval_pos,\n-\t\t\t\t\t  EVAL_NORMAL);\n+\t\t  arg1\n+\t\t    = evaluate_subexp (nullptr, exp, &preeval_pos, EVAL_NORMAL);\n \t\t  type = value_type (ada_value_ind (arg1));\n \t\t}\n \t      else\n@@ -11046,7 +11046,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       tem = longest_to_int (exp->elts[pc + 1].longconst);\n       (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n       preeval_pos = *pos;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n         goto nosideret;\n       if (noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -11065,8 +11065,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n               if (type == NULL)\n \t\t{\n-\t\t  arg1 = evaluate_subexp (NULL_TYPE, exp, &preeval_pos,\n-\t\t\t\t\t  EVAL_NORMAL);\n+\t\t  arg1\n+\t\t    = evaluate_subexp (nullptr, exp, &preeval_pos, EVAL_NORMAL);\n \t\t  arg1 = ada_value_struct_elt (arg1,\n \t\t\t\t\t       &exp->elts[pc + 2].string,\n \t\t\t\t\t       0);"
    },
    {
      "sha": "51b51865f43e0ecfa42287cb5e9751da44bb2414",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 83,
      "deletions": 85,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -135,7 +135,7 @@ evaluate_expression (struct expression *exp)\n {\n   int pc = 0;\n \n-  return evaluate_subexp (NULL_TYPE, exp, &pc, EVAL_NORMAL);\n+  return evaluate_subexp (nullptr, exp, &pc, EVAL_NORMAL);\n }\n \n /* Evaluate an expression, avoiding all memory references\n@@ -146,7 +146,7 @@ evaluate_type (struct expression *exp)\n {\n   int pc = 0;\n \n-  return evaluate_subexp (NULL_TYPE, exp, &pc, EVAL_AVOID_SIDE_EFFECTS);\n+  return evaluate_subexp (nullptr, exp, &pc, EVAL_AVOID_SIDE_EFFECTS);\n }\n \n /* Evaluate a subexpression, avoiding all memory references and\n@@ -155,7 +155,7 @@ evaluate_type (struct expression *exp)\n struct value *\n evaluate_subexpression_type (struct expression *exp, int subexp)\n {\n-  return evaluate_subexp (NULL_TYPE, exp, &subexp, EVAL_AVOID_SIDE_EFFECTS);\n+  return evaluate_subexp (nullptr, exp, &subexp, EVAL_AVOID_SIDE_EFFECTS);\n }\n \n /* Find the current value of a watchpoint on EXP.  Return the value in\n@@ -200,7 +200,7 @@ fetch_subexp_value (struct expression *exp, int *pc, struct value **valp,\n \n   try\n     {\n-      result = evaluate_subexp (NULL_TYPE, exp, pc, EVAL_NORMAL);\n+      result = evaluate_subexp (nullptr, exp, pc, EVAL_NORMAL);\n     }\n   catch (const gdb_exception &ex)\n     {\n@@ -362,7 +362,7 @@ init_array_element (struct value *array, struct value *element,\n     }\n   else\n     {\n-      index = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));\n+      index = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n       if (index < low_bound || index > high_bound)\n \terror (_(\"tuple index out of range\"));\n       memcpy (value_contents_raw (array) + (index - low_bound) * element_size,\n@@ -386,12 +386,12 @@ value_f90_subarray (struct value *array,\n   if (range_type == LOW_BOUND_DEFAULT || range_type == BOTH_BOUND_DEFAULT)\n     low_bound = range->bounds ()->low.const_val ();\n   else\n-    low_bound = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));\n+    low_bound = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n \n   if (range_type == HIGH_BOUND_DEFAULT || range_type == BOTH_BOUND_DEFAULT)\n     high_bound = range->bounds ()->high.const_val ();\n   else\n-    high_bound = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));\n+    high_bound = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n \n   return value_slice (array, low_bound, high_bound - low_bound + 1);\n }\n@@ -864,15 +864,15 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t}\n       else\n \t{\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \t}\n \n       /* If the function is a virtual function, then the aggregate\n \t value (providing the structure) plays its part by providing\n \t the vtable.  Otherwise, it is just along for the ride: call\n \t the function directly.  */\n \n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       type *a1_type = check_typedef (value_type (arg1));\n       if (noside == EVAL_SKIP)\n@@ -941,7 +941,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t}\n       else\n \t{\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \n \t  /* Check to see if the operator '->' has been overloaded.\n \t     If the operator has been overloaded replace arg2 with the\n@@ -1243,7 +1243,7 @@ skip_undetermined_arglist (int nargs, struct expression *exp, int *pos,\n \t\t\t   enum noside noside)\n {\n   for (int i = 0; i < nargs; ++i)\n-    evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+    evaluate_subexp (nullptr, exp, pos, noside);\n }\n \n /* Return true if type is integral or reference to integral */\n@@ -1444,9 +1444,9 @@ evaluate_subexp_standard (struct type *expect_type,\n       tem2 = longest_to_int (exp->elts[pc + 1].longconst);\n       tem3 = longest_to_int (exp->elts[pc + 2].longconst);\n       nargs = tem3 - tem2 + 1;\n-      type = expect_type ? check_typedef (expect_type) : NULL_TYPE;\n+      type = expect_type ? check_typedef (expect_type) : nullptr;\n \n-      if (expect_type != NULL_TYPE && noside != EVAL_SKIP\n+      if (expect_type != nullptr && noside != EVAL_SKIP\n \t  && type->code () == TYPE_CODE_STRUCT)\n \t{\n \t  struct value *rec = allocate_value (expect_type);\n@@ -1455,7 +1455,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  return evaluate_struct_tuple (rec, exp, pos, noside, nargs);\n \t}\n \n-      if (expect_type != NULL_TYPE && noside != EVAL_SKIP\n+      if (expect_type != nullptr && noside != EVAL_SKIP\n \t  && type->code () == TYPE_CODE_ARRAY)\n \t{\n \t  struct type *range_type = type->index_type ();\n@@ -1503,7 +1503,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  return array;\n \t}\n \n-      if (expect_type != NULL_TYPE && noside != EVAL_SKIP\n+      if (expect_type != nullptr && noside != EVAL_SKIP\n \t  && type->code () == TYPE_CODE_SET)\n \t{\n \t  struct value *set = allocate_value (expect_type);\n@@ -1581,11 +1581,10 @@ evaluate_subexp_standard (struct type *expect_type,\n \n     case TERNOP_SLICE:\n       {\n-\tstruct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\tstruct value *array = evaluate_subexp (nullptr, exp, pos, noside);\n \tint lowbound\n-\t  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));\n-\tint upper\n-\t  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));\n+\t  = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n+\tint upper = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n \n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n@@ -1594,16 +1593,16 @@ evaluate_subexp_standard (struct type *expect_type,\n \n     case TERNOP_COND:\n       /* Skip third and second args to evaluate the first one.  */\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (value_logical_not (arg1))\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n-\t  return evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n+\t  return evaluate_subexp (nullptr, exp, pos, noside);\n \t}\n       else\n \t{\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n+\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n \t  return arg2;\n \t}\n \n@@ -1929,7 +1928,7 @@ evaluate_subexp_standard (struct type *expect_type,\n       (*pos) += 2;\n \n       /* First determine the type code we are dealing with.  */\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type = check_typedef (value_type (arg1));\n       code = type->code ();\n \n@@ -2023,15 +2022,15 @@ evaluate_subexp_standard (struct type *expect_type,\n       /* We have a complex number, There should be 2 floating \n          point numbers that compose it.  */\n       (*pos) += 2;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       return value_literal_complex (arg1, arg2, exp->elts[pc + 1].type);\n \n     case STRUCTOP_STRUCT:\n       tem = longest_to_int (exp->elts[pc + 1].longconst);\n       (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       arg3 = value_struct_elt (&arg1, NULL, &exp->elts[pc + 2].string,\n@@ -2043,7 +2042,7 @@ evaluate_subexp_standard (struct type *expect_type,\n     case STRUCTOP_PTR:\n       tem = longest_to_int (exp->elts[pc + 1].longconst);\n       (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n \n@@ -2100,9 +2099,9 @@ evaluate_subexp_standard (struct type *expect_type,\n       if (op == STRUCTOP_MEMBER)\n \targ1 = evaluate_subexp_for_address (exp, pos, noside);\n       else\n-\targ1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n \n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2162,14 +2161,15 @@ evaluate_subexp_standard (struct type *expect_type,\n \treturn value_concat (arg1, arg2);\n \n     case BINOP_ASSIGN:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       /* Special-case assignments where the left-hand-side is a\n \t convenience variable -- in these, don't bother setting an\n \t expected type.  This avoids a weird case where re-assigning a\n \t string or array to an internal variable could error with \"Too\n \t many array elements\".  */\n       arg2 = evaluate_subexp (VALUE_LVAL (arg1) == lval_internalvar\n-\t\t\t      ? NULL_TYPE : value_type (arg1),\n+\t\t\t\t? nullptr\n+\t\t\t\t: value_type (arg1),\n \t\t\t      exp, pos, noside);\n \n       if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -2181,7 +2181,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \n     case BINOP_ASSIGN_MODIFY:\n       (*pos) += 2;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)\n \treturn arg1;\n@@ -2265,8 +2265,8 @@ evaluate_subexp_standard (struct type *expect_type,\n     case BINOP_BITWISE_AND:\n     case BINOP_BITWISE_IOR:\n     case BINOP_BITWISE_XOR:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       if (binop_user_defined_p (op, arg1, arg2))\n@@ -2308,8 +2308,8 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_SUBSCRIPT:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       if (binop_user_defined_p (op, arg1, arg2))\n@@ -2444,61 +2444,61 @@ evaluate_subexp_standard (struct type *expect_type,\n       }\n \n     case BINOP_LOGICAL_AND:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  evaluate_subexp (nullptr, exp, pos, noside);\n \t  return eval_skip_value (exp);\n \t}\n \n       oldpos = *pos;\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n       *pos = oldpos;\n \n       if (binop_user_defined_p (op, arg1, arg2))\n \t{\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \t  return value_x_binop (arg1, arg2, op, OP_NULL, noside);\n \t}\n       else\n \t{\n \t  tem = value_logical_not (arg1);\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t  (tem ? EVAL_SKIP : noside));\n+\t  arg2\n+\t    = evaluate_subexp (nullptr, exp, pos, (tem ? EVAL_SKIP : noside));\n \t  type = language_bool_type (exp->language_defn, exp->gdbarch);\n \t  return value_from_longest (type,\n \t\t\t     (LONGEST) (!tem && !value_logical_not (arg2)));\n \t}\n \n     case BINOP_LOGICAL_OR:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  evaluate_subexp (nullptr, exp, pos, noside);\n \t  return eval_skip_value (exp);\n \t}\n \n       oldpos = *pos;\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n       *pos = oldpos;\n \n       if (binop_user_defined_p (op, arg1, arg2))\n \t{\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \t  return value_x_binop (arg1, arg2, op, OP_NULL, noside);\n \t}\n       else\n \t{\n \t  tem = value_logical_not (arg1);\n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t  (!tem ? EVAL_SKIP : noside));\n+\t  arg2\n+\t    = evaluate_subexp (nullptr, exp, pos, (!tem ? EVAL_SKIP : noside));\n \t  type = language_bool_type (exp->language_defn, exp->gdbarch);\n \t  return value_from_longest (type,\n \t\t\t     (LONGEST) (!tem || !value_logical_not (arg2)));\n \t}\n \n     case BINOP_EQUAL:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2515,7 +2515,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_NOTEQUAL:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2532,7 +2532,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_LESS:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2549,7 +2549,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_GTR:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2566,7 +2566,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_GEQ:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2583,7 +2583,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_LEQ:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -2600,8 +2600,8 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case BINOP_REPEAT:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n+      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       type = check_typedef (value_type (arg2));\n@@ -2617,11 +2617,11 @@ evaluate_subexp_standard (struct type *expect_type,\n \treturn value_repeat (arg1, longest_to_int (value_as_long (arg2)));\n \n     case BINOP_COMMA:\n-      evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-      return evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      evaluate_subexp (nullptr, exp, pos, noside);\n+      return evaluate_subexp (nullptr, exp, pos, noside);\n \n     case UNOP_PLUS:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       if (unop_user_defined_p (op, arg1))\n@@ -2633,7 +2633,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n       \n     case UNOP_NEG:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       if (unop_user_defined_p (op, arg1))\n@@ -2647,7 +2647,7 @@ evaluate_subexp_standard (struct type *expect_type,\n     case UNOP_COMPLEMENT:\n       /* C++: check for and handle destructor names.  */\n \n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       if (unop_user_defined_p (UNOP_COMPLEMENT, arg1))\n@@ -2659,7 +2659,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n \n     case UNOP_LOGICAL_NOT:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       if (unop_user_defined_p (op, arg1))\n@@ -2715,7 +2715,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \n       if (noside == EVAL_SKIP)\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n+\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n \t  return eval_skip_value (exp);\n \t}\n       else\n@@ -2729,15 +2729,15 @@ evaluate_subexp_standard (struct type *expect_type,\n     case UNOP_SIZEOF:\n       if (noside == EVAL_SKIP)\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n+\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n \t  return eval_skip_value (exp);\n \t}\n       return evaluate_subexp_for_sizeof (exp, pos, noside);\n \n     case UNOP_ALIGNOF:\n       {\n-\ttype = value_type (evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t\t    EVAL_AVOID_SIDE_EFFECTS));\n+\ttype = value_type (\n+\t  evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS));\n \t/* FIXME: This should be size_t.  */\n \tstruct type *size_type = builtin_type (exp->gdbarch)->builtin_int;\n \tULONGEST align = type_align (type);\n@@ -2915,16 +2915,15 @@ evaluate_subexp_standard (struct type *expect_type,\n     case OP_DECLTYPE:\n       if (noside == EVAL_SKIP)\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n+\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n \t  return eval_skip_value (exp);\n \t}\n       else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n \t  enum exp_opcode sub_op = exp->elts[*pos].opcode;\n \t  struct value *result;\n \n-\t  result = evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t    EVAL_AVOID_SIDE_EFFECTS);\n+\t  result = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n \n \t  /* 'decltype' has special semantics for lvalues.  */\n \t  if (op == OP_DECLTYPE\n@@ -2956,10 +2955,9 @@ evaluate_subexp_standard (struct type *expect_type,\n \tenum exp_opcode sub_op = exp->elts[*pos].opcode;\n \n \tif (sub_op == OP_TYPE || sub_op == OP_DECLTYPE || sub_op == OP_TYPEOF)\n-\t  result = evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t    EVAL_AVOID_SIDE_EFFECTS);\n+\t  result = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n \telse\n-\t  result = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  result = evaluate_subexp (nullptr, exp, pos, noside);\n \n \tif (noside != EVAL_NORMAL)\n \t  return allocate_value (cplus_typeid_type (exp->gdbarch));\n@@ -3008,7 +3006,7 @@ evaluate_subexp_for_address (struct expression *exp, int *pos,\n     {\n     case UNOP_IND:\n       (*pos)++;\n-      x = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      x = evaluate_subexp (nullptr, exp, pos, noside);\n \n       /* We can't optimize out \"&*\" if there's a user-defined operator*.  */\n       if (unop_user_defined_p (op, x))\n@@ -3022,17 +3020,17 @@ evaluate_subexp_for_address (struct expression *exp, int *pos,\n     case UNOP_MEMVAL:\n       (*pos) += 3;\n       return value_cast (lookup_pointer_type (exp->elts[pc + 1].type),\n-\t\t\t evaluate_subexp (NULL_TYPE, exp, pos, noside));\n+\t\t\t evaluate_subexp (nullptr, exp, pos, noside));\n \n     case UNOP_MEMVAL_TYPE:\n       {\n \tstruct type *type;\n \n \t(*pos) += 1;\n-\tx = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+\tx = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n \ttype = value_type (x);\n \treturn value_cast (lookup_pointer_type (type),\n-\t\t\t   evaluate_subexp (NULL_TYPE, exp, pos, noside));\n+\t\t\t   evaluate_subexp (nullptr, exp, pos, noside));\n       }\n \n     case OP_VAR_VALUE:\n@@ -3089,7 +3087,7 @@ evaluate_subexp_for_address (struct expression *exp, int *pos,\n \n     default:\n     default_case:\n-      x = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      x = evaluate_subexp (nullptr, exp, pos, noside);\n     default_case_after_eval:\n       if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n@@ -3150,7 +3148,7 @@ evaluate_subexp_with_coercion (struct expression *exp,\n       /* FALLTHROUGH */\n \n     default:\n-      return evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      return evaluate_subexp (nullptr, exp, pos, noside);\n     }\n }\n \n@@ -3182,7 +3180,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n          create a value unnecessarily.  */\n     case UNOP_IND:\n       (*pos)++;\n-      val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+      val = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n       type = check_typedef (value_type (val));\n       if (type->code () != TYPE_CODE_PTR\n \t  && !TYPE_IS_REFERENCE (type)\n@@ -3208,7 +3206,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n       type = SYMBOL_TYPE (exp->elts[pc + 2].symbol);\n       if (is_dynamic_type (type))\n \t{\n-\t  val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_NORMAL);\n+\t  val = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n \t  type = value_type (val);\n \t  if (type->code () == TYPE_CODE_ARRAY\n               && is_dynamic_type (type->index_type ())\n@@ -3245,7 +3243,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \t{\n \t  int npc = (*pos) + 1;\n \n-\t  val = evaluate_subexp (NULL_TYPE, exp, &npc, EVAL_AVOID_SIDE_EFFECTS);\n+\t  val = evaluate_subexp (nullptr, exp, &npc, EVAL_AVOID_SIDE_EFFECTS);\n \t  type = check_typedef (value_type (val));\n \t  if (type->code () == TYPE_CODE_ARRAY)\n \t    {\n@@ -3257,7 +3255,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \t\t     is a variable length type.  */\n \t\t  if (type->bounds ()->flag_bound_evaluated)\n \t\t    {\n-\t\t      val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_NORMAL);\n+\t\t      val = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n \t\t      return value_from_longest\n \t\t\t(size_type, (LONGEST) TYPE_LENGTH (value_type (val)));\n \t\t    }\n@@ -3268,7 +3266,7 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n       /* Fall through.  */\n \n     default:\n-      val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n+      val = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n       type = value_type (val);\n       break;\n     }"
    },
    {
      "sha": "54d56f0d78170e7c2eefbdf9e168944846a77582",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -136,7 +136,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       return evaluate_subexp_standard (expect_type, exp, pos, noside);\n \n     case UNOP_ABS:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       type = value_type (arg1);\n@@ -159,7 +159,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       error (_(\"ABS of type %s not supported\"), TYPE_SAFE_NAME (type));\n \n     case BINOP_MOD:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n@@ -193,7 +193,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \n     case UNOP_FORTRAN_CEILING:\n       {\n-\targ1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n \ttype = value_type (arg1);\n@@ -208,7 +208,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \n     case UNOP_FORTRAN_FLOOR:\n       {\n-\targ1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n \ttype = value_type (arg1);\n@@ -223,7 +223,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \n     case BINOP_FORTRAN_MODULO:\n       {\n-\targ1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n \targ2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n \tif (noside == EVAL_SKIP)\n \t  return eval_skip_value (exp);\n@@ -260,7 +260,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       }\n \n     case BINOP_FORTRAN_CMPLX:\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);"
    },
    {
      "sha": "b02f6674bf5a83172239f216460d99af11e187e1",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -1148,8 +1148,6 @@ struct type\n   struct main_type *main_type;\n };\n \n-#define\tNULL_TYPE ((struct type *) 0)\n-\n struct fn_fieldlist\n {\n "
    },
    {
      "sha": "ff2cfd001d16e8be915799840f818933180ad2b6",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 17,
      "deletions": 18,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -739,7 +739,7 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n        scalar-to-vector widening.  */\n     case BINOP_ASSIGN:\n       (*pos)++;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type1 = value_type (arg1);\n       arg2 = evaluate_subexp (type1, exp, pos, noside);\n \n@@ -784,7 +784,7 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n     case BINOP_GEQ:\n     case BINOP_LEQ:\n       (*pos)++;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n \n       if (noside == EVAL_SKIP)\n@@ -796,7 +796,7 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n     /* Handle the logical unary operator not(!).  */\n     case UNOP_LOGICAL_NOT:\n       (*pos)++;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       if (noside == EVAL_SKIP)\n \treturn value_from_longest (builtin_type (exp->gdbarch)->\n@@ -808,11 +808,11 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n     case BINOP_LOGICAL_AND:\n     case BINOP_LOGICAL_OR:\n       (*pos)++;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n \n       if (noside == EVAL_SKIP)\n \t{\n-\t  evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  evaluate_subexp (nullptr, exp, pos, noside);\n \n \t  return value_from_longest (builtin_type (exp->gdbarch)->\n \t\t\t\t     builtin_int, 1);\n@@ -826,16 +826,15 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t     Therefore we evaluate it once using EVAL_AVOID_SIDE_EFFECTS.  */\n \t  int oldpos = *pos;\n \n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t  EVAL_AVOID_SIDE_EFFECTS);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n \t  *pos = oldpos;\n \t  type1 = check_typedef (value_type (arg1));\n \t  type2 = check_typedef (value_type (arg2));\n \n \t  if ((type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n \t      || (type2->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type2)))\n \t    {\n-\t      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n \n \t      return opencl_relop (exp, arg1, arg2, op);\n \t    }\n@@ -850,8 +849,8 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t      if (op == BINOP_LOGICAL_OR)\n \t\ttmp = !tmp;\n \n-\t      arg2 = evaluate_subexp (NULL_TYPE, exp, pos,\n-\t\t\t\t      tmp ? EVAL_SKIP : noside);\n+\t      arg2\n+\t\t= evaluate_subexp (nullptr, exp, pos, tmp ? EVAL_SKIP : noside);\n \t      type1 = language_bool_type (exp->language_defn, exp->gdbarch);\n \n \t      if (op == BINOP_LOGICAL_AND)\n@@ -866,7 +865,7 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n     /* Handle the ternary selection operator.  */\n     case TERNOP_COND:\n       (*pos)++;\n-      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       type1 = check_typedef (value_type (arg1));\n       if (type1->code () == TYPE_CODE_ARRAY && TYPE_VECTOR (type1))\n \t{\n@@ -875,8 +874,8 @@ evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n \t  int t2_is_vec, t3_is_vec, i;\n \t  LONGEST lowb1, lowb2, lowb3, highb1, highb2, highb3;\n \n-\t  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-\t  arg3 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n+\t  arg3 = evaluate_subexp (nullptr, exp, pos, noside);\n \t  type2 = check_typedef (value_type (arg2));\n \t  type3 = check_typedef (value_type (arg3));\n \t  t2_is_vec\n@@ -942,15 +941,15 @@ Cannot perform conditional operation on vectors with different sizes\"));\n \t  if (value_logical_not (arg1))\n \t    {\n \t      /* Skip the second operand.  */\n-\t      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n+\t      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n \n-\t      return evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\t      return evaluate_subexp (nullptr, exp, pos, noside);\n \t    }\n \t  else\n \t    {\n \t      /* Skip the third operand.  */\n-\t      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-\t      evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);\n+\t      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n+\t      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n \n \t      return arg2;\n \t    }\n@@ -963,7 +962,7 @@ Cannot perform conditional operation on vectors with different sizes\"));\n \tint tem = longest_to_int (exp->elts[pc + 1].longconst);\n \n \t(*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-\targ1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n \ttype1 = check_typedef (value_type (arg1));\n \n \tif (noside == EVAL_SKIP)"
    },
    {
      "sha": "a590f9d6b4eae94d9a0aa80cb5273b7eb260e79b",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=fe1fe7eae95c43bcb1dfda8a6922eda0c9acd1c2",
      "patch": "@@ -1014,12 +1014,12 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n \n   /* Evaluate the argument to STRUCTOP_STRUCT, then find its\n      type in order to look up the method.  */\n-  arg0 = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+  arg0 = evaluate_subexp (nullptr, exp, pos, noside);\n \n   if (noside == EVAL_SKIP)\n     {\n       for (i = 0; i < num_args; ++i)\n-\tevaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\tevaluate_subexp (nullptr, exp, pos, noside);\n       return arg0;\n     }\n \n@@ -1056,7 +1056,7 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n   function = address_of_variable (sym.symbol, block);\n \n   for (i = 0; i < num_args; ++i)\n-    args[i + 1] = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+    args[i + 1] = evaluate_subexp (nullptr, exp, pos, noside);\n \n   if (noside == EVAL_AVOID_SIDE_EFFECTS)\n     result = value_zero (TYPE_TARGET_TYPE (fn_type), not_lval);\n@@ -1084,10 +1084,10 @@ rust_range (struct expression *exp, int *pos, enum noside noside)\n \n   if (kind == HIGH_BOUND_DEFAULT || kind == NONE_BOUND_DEFAULT\n       || kind == NONE_BOUND_DEFAULT_EXCLUSIVE)\n-    low = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+    low = evaluate_subexp (nullptr, exp, pos, noside);\n   if (kind == LOW_BOUND_DEFAULT || kind == LOW_BOUND_DEFAULT_EXCLUSIVE\n       || kind == NONE_BOUND_DEFAULT || kind == NONE_BOUND_DEFAULT_EXCLUSIVE)\n-    high = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+    high = evaluate_subexp (nullptr, exp, pos, noside);\n   bool inclusive = (kind == NONE_BOUND_DEFAULT || kind == LOW_BOUND_DEFAULT);\n \n   if (noside == EVAL_SKIP)\n@@ -1216,8 +1216,8 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n   int want_slice = 0;\n \n   ++*pos;\n-  lhs = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n-  rhs = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+  lhs = evaluate_subexp (nullptr, exp, pos, noside);\n+  rhs = evaluate_subexp (nullptr, exp, pos, noside);\n \n   if (noside == EVAL_SKIP)\n     return lhs;\n@@ -1396,7 +1396,7 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \tstruct value *value;\n \n \t++*pos;\n-\tvalue = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\tvalue = evaluate_subexp (nullptr, exp, pos, noside);\n \tif (noside == EVAL_SKIP)\n \t  {\n \t    /* Preserving the type is enough.  */\n@@ -1527,9 +1527,9 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n         pc = (*pos)++;\n         field_number = longest_to_int (exp->elts[pc + 1].longconst);\n         (*pos) += 2;\n-        lhs = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\tlhs = evaluate_subexp (nullptr, exp, pos, noside);\n \n-        type = value_type (lhs);\n+\ttype = value_type (lhs);\n \n \tif (type->code () == TYPE_CODE_STRUCT)\n \t  {\n@@ -1599,7 +1599,7 @@ tuple structs, and tuple-like enum variants\"));\n         pc = (*pos)++;\n         tem = longest_to_int (exp->elts[pc + 1].longconst);\n         (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-        lhs = evaluate_subexp (NULL_TYPE, exp, pos, noside);\n+\tlhs = evaluate_subexp (nullptr, exp, pos, noside);\n \n \tconst char *field_name = &exp->elts[pc + 2].string;\n         type = value_type (lhs);"
    }
  ]
}