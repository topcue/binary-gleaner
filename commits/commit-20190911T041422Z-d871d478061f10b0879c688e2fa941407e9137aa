{
  "sha": "d871d478061f10b0879c688e2fa941407e9137aa",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDg3MWQ0NzgwNjFmMTBiMDg3OWM2ODhlMmZhOTQxNDA3ZTkxMzdhYQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-09T13:37:35Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-11T04:14:22Z"
    },
    "message": "Move elf32.em and elf-generic.em functions\n\nMany ELF linker targets support multiple \"emulations\" and thus have\nmultiple copies of elf32.em being compiled and linked into ld.  This\npatch moves much of elf32.em and elf-generic.em into files which will\nbe compiled just once, resulting in a 20% decrease in ld size for\n--enable-targets=all.\n\n\t* Makefile.am (ALL_EMUL_EXTRA_OFILES): Add ldelf and ldelfgen.\n\t(CFILES, HFILES, EXTRA_ld_new_SOURCES): Likewise.\n\t* configure.tgt: Formatting.\n\t(targ_extra_ofiles): Init to ldelf.o ldelfgen.o, reset to just\n\tldelfgen.o for generic ELF targets, and empty for non-ELF.\n\t* emultempl/aarch64elf.em (gldaarch64_layout_sections_again): Use\n\tldelf_map_segments.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, aarch64_for_each_input_file_wrapper),\n\t(aarch64_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/alphaelf.em (alpha_after_parse): Use ldelf_map_segments.\n\t* emultempl/armelf.em (gldarm_layout_sections_again): Likewise.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, arm_for_each_input_file_wrapper),\n\t(arm_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/cr16elf.em (cr16elf_after_parse): Use ldelf_map_segments.\n\t* emultempl/crxelf.em (crxelf_after_parse): Likewise.  Delete\n\tdeclaration.\n\t* emultempl/cskyelf.em (gldcsky_layout_sections_again): Use\n\tldelf_map_segments.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, csky_for_each_input_file_wrapper),\n\t(csky_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/genelf.em: Include ldelfgen.h.\n\t(gld${EMULATION_NAME}_before_allocation): Use ldelf_map_segments.\n\t* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.\n\t(hppaelf_layout_sections_again): Likewise.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, hppa_for_each_input_file_wrapper),\n\t(hppa_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/ia64elf.em (ia64elf_after_parse): Use ldelf_map_segments.\n\t* emultempl/m68hc1xelf.em (real_func),\n\t(m68hc11_for_each_input_file_wrapper),\n\t(m68hc11_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/metagelf.em (metagelf_layout_sections_again): Use\n\tldelf_map_segments.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, metag_for_each_input_file_wrapper),\n\t(metag_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/mipself.em (real_func),\n\t(mips_for_each_input_file_wrapper),\n\t(mips_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/mmo.em: Don't include elf-bfd.h, do include ldelfgen.h.\n\t(gld${EMULATION_NAME}_after_allocation): Use ldelf_map_segments.\n\t* emultempl/nds32elf.em (nds32_elf_after_parse): Use ldelf_after_parse.\n\t(nds32_elf_after_allocation): Comment fix.\n\t* emultempl/nios2elf.em (nios2elf_layout_sections_again): Use\n\tldelf_map_segments.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, nios2_for_each_input_file_wrapper),\n\t(nios2_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t* emultempl/ppc32elf.em (gld${EMULATION_NAME}_load_symbols): Delete\n\tdeclaration.\n\t(ppc_recognized_file): Call ldelf_load_symbols.\n\t* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.\n\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n\t(real_func, ppc_for_each_input_file_wrapper),\n\t(ppc_lang_for_each_input_file): Delete.\n\t(lang_for_each_input_file): Don't define.\n\t(gld${EMULATION_NAME}_load_symbols): Don't declare.\n\t(ppc64_recognized_file): Call ldelf_load_symbols.\n\t* emultempl/riscvelf.em (gld${EMULATION_NAME}_after_allocation):\n\tUse ldelf_map_segments.\n\t* emultempl/spuelf.em (spu_place_special_section): Use\n\tldelf_place_orphan.\n\t* emultempl/tic6xdsbt.em (gld${EMULATION_NAME}_after_allocation):\n\tUse ldelf_map_segments.\n\t* emultempl/vms.em: Include ldelfgen.h.\n\t(gld${EMULATION_NAME}_after_allocation): Use ldelf_map_segments.\n\t* emultempl/elf32.em: Remove unnecessary headers, include ldelf.h\n\tand ldelfgen.h.  Move much of file content to..\n\t* ldelf.c: ..here.  New file.\n\t* ldelf.h: New file.\n\t* emultempl/elf-generic.em: Move gld${EMULATION_NAME}_map_segments..\n\t* ldelfgen.c: ..to here.\n\t* ldelfgen.h: New file.\n\t* ldlang.c (lang_for_each_input_file): Adjust to only call func\n\ton real files.\n\t(lang_for_each_file): Likewise.\n\t* po/SRC-POTFILES.in: Regenerate.\n\t* Makefile.in: Regenerate.",
    "tree": {
      "sha": "4f564ccc452de8255f2eecfecfb931de03ad2093",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4f564ccc452de8255f2eecfecfb931de03ad2093"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d871d478061f10b0879c688e2fa941407e9137aa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d871d478061f10b0879c688e2fa941407e9137aa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d871d478061f10b0879c688e2fa941407e9137aa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d871d478061f10b0879c688e2fa941407e9137aa/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cb7f4b298e5e0a3ab4fb6b13aa89e970478597bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cb7f4b298e5e0a3ab4fb6b13aa89e970478597bc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cb7f4b298e5e0a3ab4fb6b13aa89e970478597bc"
    }
  ],
  "stats": {
    "total": 5629,
    "additions": 2925,
    "deletions": 2704
  },
  "files": [
    {
      "sha": "18d2c051d4290262695bc3eb420cc803feb754b0",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 92,
      "deletions": 0,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -1,3 +1,95 @@\n+2019-09-11  Alan Modra  <amodra@gmail.com>\n+\n+\t* Makefile.am (ALL_EMUL_EXTRA_OFILES): Add ldelf and ldelfgen.\n+\t(CFILES, HFILES, EXTRA_ld_new_SOURCES): Likewise.\n+\t* configure.tgt: Formatting.\n+\t(targ_extra_ofiles): Init to ldelf.o ldelfgen.o, reset to just\n+\tldelfgen.o for generic ELF targets, and empty for non-ELF.\n+\t* emultempl/aarch64elf.em (gldaarch64_layout_sections_again): Use\n+\tldelf_map_segments.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, aarch64_for_each_input_file_wrapper),\n+\t(aarch64_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/alphaelf.em (alpha_after_parse): Use ldelf_map_segments.\n+\t* emultempl/armelf.em (gldarm_layout_sections_again): Likewise.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, arm_for_each_input_file_wrapper),\n+\t(arm_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/cr16elf.em (cr16elf_after_parse): Use ldelf_map_segments.\n+\t* emultempl/crxelf.em (crxelf_after_parse): Likewise.  Delete\n+\tdeclaration.\n+\t* emultempl/cskyelf.em (gldcsky_layout_sections_again): Use\n+\tldelf_map_segments.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, csky_for_each_input_file_wrapper),\n+\t(csky_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/genelf.em: Include ldelfgen.h.\n+\t(gld${EMULATION_NAME}_before_allocation): Use ldelf_map_segments.\n+\t* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.\n+\t(hppaelf_layout_sections_again): Likewise.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, hppa_for_each_input_file_wrapper),\n+\t(hppa_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/ia64elf.em (ia64elf_after_parse): Use ldelf_map_segments.\n+\t* emultempl/m68hc1xelf.em (real_func),\n+\t(m68hc11_for_each_input_file_wrapper),\n+\t(m68hc11_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/metagelf.em (metagelf_layout_sections_again): Use\n+\tldelf_map_segments.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, metag_for_each_input_file_wrapper),\n+\t(metag_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/mipself.em (real_func),\n+\t(mips_for_each_input_file_wrapper),\n+\t(mips_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/mmo.em: Don't include elf-bfd.h, do include ldelfgen.h.\n+\t(gld${EMULATION_NAME}_after_allocation): Use ldelf_map_segments.\n+\t* emultempl/nds32elf.em (nds32_elf_after_parse): Use ldelf_after_parse.\n+\t(nds32_elf_after_allocation): Comment fix.\n+\t* emultempl/nios2elf.em (nios2elf_layout_sections_again): Use\n+\tldelf_map_segments.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, nios2_for_each_input_file_wrapper),\n+\t(nios2_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t* emultempl/ppc32elf.em (gld${EMULATION_NAME}_load_symbols): Delete\n+\tdeclaration.\n+\t(ppc_recognized_file): Call ldelf_load_symbols.\n+\t* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.\n+\t(gld${EMULATION_NAME}_after_allocation): Likewise.\n+\t(real_func, ppc_for_each_input_file_wrapper),\n+\t(ppc_lang_for_each_input_file): Delete.\n+\t(lang_for_each_input_file): Don't define.\n+\t(gld${EMULATION_NAME}_load_symbols): Don't declare.\n+\t(ppc64_recognized_file): Call ldelf_load_symbols.\n+\t* emultempl/riscvelf.em (gld${EMULATION_NAME}_after_allocation):\n+\tUse ldelf_map_segments.\n+\t* emultempl/spuelf.em (spu_place_special_section): Use\n+\tldelf_place_orphan.\n+\t* emultempl/tic6xdsbt.em (gld${EMULATION_NAME}_after_allocation):\n+\tUse ldelf_map_segments.\n+\t* emultempl/vms.em: Include ldelfgen.h.\n+\t(gld${EMULATION_NAME}_after_allocation): Use ldelf_map_segments.\n+\t* emultempl/elf32.em: Remove unnecessary headers, include ldelf.h\n+\tand ldelfgen.h.  Move much of file content to..\n+\t* ldelf.c: ..here.  New file.\n+\t* ldelf.h: New file.\n+\t* emultempl/elf-generic.em: Move gld${EMULATION_NAME}_map_segments..\n+\t* ldelfgen.c: ..to here.\n+\t* ldelfgen.h: New file.\n+\t* ldlang.c (lang_for_each_input_file): Adjust to only call func\n+\ton real files.\n+\t(lang_for_each_file): Likewise.\n+\t* po/SRC-POTFILES.in: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\n 2019-09-11  Alan Modra  <amodra@gmail.com>\n \n \t* ldmisc.c: Don't #include elf-bfd.h or coff-bfd.h."
    },
    {
      "sha": "c56559dbfa243f89f4cb37687801d1d7cdebd5cc",
      "filename": "ld/Makefile.am",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/Makefile.am?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -467,20 +467,22 @@ ALL_64_EMULATIONS = $(ALL_64_EMULATION_SOURCES:.c=.@OBJEXT@)\n \n ALL_EMUL_EXTRA_OFILES = \\\n \tdeffilep.@OBJEXT@ \\\n-\tpe-dll.@OBJEXT@\n+\tpe-dll.@OBJEXT@ \\\n+\tldelf.@OBJEXT@ \\\n+\tldelfgen.@OBJEXT@\n \n ALL_64_EMUL_EXTRA_OFILES = \\\n \tpep-dll.@OBJEXT@\n \n CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \\\n \tldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \\\n \tmri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c \\\n-\t$(PLUGIN_C) ldbuildid.c\n+\t$(PLUGIN_C) ldbuildid.c ldelf.c ldelfgen.c\n \n HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \\\n \tldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \\\n \tldwrite.h mri.h deffile.h pe-dll.h pep-dll.h \\\n-\telf-hints-local.h $(PLUGIN_H) ldbuildid.h\n+\telf-hints-local.h $(PLUGIN_H) ldbuildid.h ldelf.h ldelfgen.h\n \n GENERATED_CFILES = ldgram.c ldlex.c deffilep.c\n GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h\n@@ -951,7 +953,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)\n # We need this for automake to use YLWRAP.\n EXTRA_ld_new_SOURCES = deffilep.y ldlex.l\n # Allow dependency tracking to work for these files, too.\n-EXTRA_ld_new_SOURCES += pep-dll.c pe-dll.c\n+EXTRA_ld_new_SOURCES += pep-dll.c pe-dll.c ldelf.c ldelfgen.c\n \n ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \\\n \tldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C) \\"
    },
    {
      "sha": "d509f62bd25f1cd5378ae934b3297df879023a44",
      "filename": "ld/Makefile.in",
      "status": "modified",
      "additions": 10,
      "deletions": 5,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/Makefile.in?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -952,20 +952,22 @@ ALL_64_EMULATION_SOURCES = \\\n ALL_64_EMULATIONS = $(ALL_64_EMULATION_SOURCES:.c=.@OBJEXT@)\n ALL_EMUL_EXTRA_OFILES = \\\n \tdeffilep.@OBJEXT@ \\\n-\tpe-dll.@OBJEXT@\n+\tpe-dll.@OBJEXT@ \\\n+\tldelf.@OBJEXT@ \\\n+\tldelfgen.@OBJEXT@\n \n ALL_64_EMUL_EXTRA_OFILES = \\\n \tpep-dll.@OBJEXT@\n \n CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \\\n \tldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \\\n \tmri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c \\\n-\t$(PLUGIN_C) ldbuildid.c\n+\t$(PLUGIN_C) ldbuildid.c ldelf.c ldelfgen.c\n \n HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \\\n \tldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \\\n \tldwrite.h mri.h deffile.h pe-dll.h pep-dll.h \\\n-\telf-hints-local.h $(PLUGIN_H) ldbuildid.h\n+\telf-hints-local.h $(PLUGIN_H) ldbuildid.h ldelf.h ldelfgen.h\n \n GENERATED_CFILES = ldgram.c ldlex.c deffilep.c\n GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h\n@@ -991,8 +993,9 @@ GEN_DEPENDS = $(srcdir)/genscripts.sh stringify.sed\n # Allow dependency tracking to work for these files, too.\n \n # Dependency tracking for the generated emulation files.\n-EXTRA_ld_new_SOURCES = deffilep.y ldlex.l pep-dll.c pe-dll.c \\\n-\t$(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES)\n+EXTRA_ld_new_SOURCES = deffilep.y ldlex.l pep-dll.c pe-dll.c ldelf.c \\\n+\tldelfgen.c $(ALL_EMULATION_SOURCES) \\\n+\t$(ALL_64_EMULATION_SOURCES)\n ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \\\n \tldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c $(PLUGIN_C) \\\n \tldbuildid.c\n@@ -1491,6 +1494,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldbuildid.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldcref.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldctor.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldelf.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldelfgen.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldemul.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldexp.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldfile.Po@am__quote@"
    },
    {
      "sha": "608db3057eaec216a9195a2f5415b7a9c7ff783c",
      "filename": "ld/configure.tgt",
      "status": "modified",
      "additions": 466,
      "deletions": 207,
      "changes": 673,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/configure.tgt?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -36,7 +36,7 @@\n \n targ_extra_emuls=\n targ_extra_libpath=\n-targ_extra_ofiles=\n+targ_extra_ofiles=\"ldelf.o ldelfgen.o\"\n targ64_extra_emuls=\n targ64_extra_libpath=\n \n@@ -46,43 +46,63 @@ targ64_extra_libpath=\n # break the alpha sorting.\n case \"${targ}\" in\n aarch64_be-*-elf)\ttarg_emul=aarch64elfb\n-\t\t\ttarg_extra_emuls=\"aarch64elf aarch64elf32 aarch64elf32b armelfb armelf\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elf aarch64elf32 aarch64elf32b armelfb armelf\"\n+\t\t\t;;\n aarch64-*-elf | aarch64-*-rtems*)\n \t\t\ttarg_emul=aarch64elf\n-\t\t\ttarg_extra_emuls=\"aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb\"\n+\t\t\t;;\n aarch64-*-cloudabi*)\ttarg_emul=aarch64cloudabi\n-\t\t\ttarg_extra_emuls=aarch64cloudabib ;;\n+\t\t\ttarg_extra_emuls=aarch64cloudabib\n+\t\t\t;;\n aarch64-*-freebsd*)\ttarg_emul=aarch64fbsd\n-\t\t\ttarg_extra_emuls=\"aarch64fbsdb aarch64elf\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64fbsdb aarch64elf\"\n+\t\t\t;;\n aarch64-*-fuchsia*)\ttarg_emul=aarch64elf\n-\t\t\ttarg_extra_emuls=\"aarch64elfb armelf armelfb\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elfb armelf armelfb\"\n+\t\t\t;;\n aarch64_be-*-linux-gnu_ilp32)\n \t\t\ttarg_emul=aarch64linux32b\n \t\t\ttarg_extra_libpath=\"aarch64linuxb aarch64linux aarch64linux32 armelfb_linux_eabi armelf_linux_eabi\"\n-\t\t\ttarg_extra_emuls=\"aarch64elfb aarch64elf aarch64elf32 aarch64elf32b armelfb armelf $targ_extra_libpath\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elfb aarch64elf aarch64elf32 aarch64elf32b armelfb armelf $targ_extra_libpath\"\n+\t\t\t;;\n aarch64-*-linux-gnu_ilp32)\n \t\t\ttarg_emul=aarch64linux32\n \t\t\ttarg_extra_libpath=\"aarch64linux aarch64linuxb aarch64linux32b armelfb_linux_eabi armelf_linux_eabi\"\n-\t\t\ttarg_extra_emuls=\"aarch64elf aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb $targ_extra_libpath\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elf aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb $targ_extra_libpath\"\n+\t\t\t;;\n aarch64_be-*-linux*)\ttarg_emul=aarch64linuxb\n \t\t\ttarg_extra_libpath=\"aarch64linux aarch64linux32 aarch64linux32b armelfb_linux_eabi armelf_linux_eabi\"\n-\t\t\ttarg_extra_emuls=\"aarch64elfb aarch64elf aarch64elf32 aarch64elf32b armelfb armelf $targ_extra_libpath\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elfb aarch64elf aarch64elf32 aarch64elf32b armelfb armelf $targ_extra_libpath\"\n+\t\t\t;;\n aarch64-*-linux*)\ttarg_emul=aarch64linux\n \t\t\ttarg_extra_libpath=\"aarch64linuxb aarch64linux32 aarch64linux32b armelfb_linux_eabi armelf_linux_eabi\"\n-\t\t\ttarg_extra_emuls=\"aarch64elf aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb $targ_extra_libpath\" ;;\n+\t\t\ttarg_extra_emuls=\"aarch64elf aarch64elf32 aarch64elf32b aarch64elfb armelf armelfb $targ_extra_libpath\"\n+\t\t\t;;\n alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf64alpha_fbsd\n \t\t\ttarg_extra_emuls=\"elf64alpha alpha\"\n-\t\t\ttdir_alpha=`echo ${targ_alias} | sed -e 's/freebsd/freebsdecoff/'` ;;\n-alpha*-*-linux*ecoff*)\ttarg_emul=alpha targ_extra_emuls=elf64alpha\n-\t\t\ttdir_elf64alpha=`echo ${targ_alias} | sed -e 's/ecoff//'` ;;\n-alpha*-*-linux-*)\ttarg_emul=elf64alpha targ_extra_emuls=alpha\n-\t\t\ttdir_alpha=`echo ${targ_alias} | sed -e 's/linux\\(-gnu\\)*/linux\\1ecoff/'` ;;\n-alpha*-*-osf*)\t\ttarg_emul=alpha ;;\n-alpha*-*-gnu*)\t\ttarg_emul=elf64alpha ;;\n-alpha*-*-netbsd*)\ttarg_emul=elf64alpha_nbsd ;;\n-alpha*-*-openbsd*)\ttarg_emul=elf64alpha ;;\n+\t\t\ttdir_alpha=`echo ${targ_alias} | sed -e 's/freebsd/freebsdecoff/'`\n+\t\t\t;;\n+alpha*-*-linux*ecoff*)\ttarg_emul=alpha\n+\t\t\ttarg_extra_emuls=elf64alpha\n+\t\t\ttdir_elf64alpha=`echo ${targ_alias} | sed -e 's/ecoff//'`\n+\t\t\t;;\n+alpha*-*-linux-*)\ttarg_emul=elf64alpha\n+\t\t\ttarg_extra_emuls=alpha\n+\t\t\ttdir_alpha=`echo ${targ_alias} | sed -e 's/linux\\(-gnu\\)*/linux\\1ecoff/'`\n+\t\t\t;;\n+alpha*-*-osf*)\t\ttarg_emul=alpha\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+alpha*-*-gnu*)\t\ttarg_emul=elf64alpha\n+\t\t\t;;\n+alpha*-*-netbsd*)\ttarg_emul=elf64alpha_nbsd\n+\t\t\t;;\n+alpha*-*-openbsd*)\ttarg_emul=elf64alpha\n+\t\t\t;;\n alpha*-*-*vms*)\t\ttarg_emul=alphavms\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n arc*-*-elf*)\t\ttarg_emul=arcelf\n \t\t\ttarg_extra_emuls=\"arcelf_prof arclinux arclinux_nps arclinux_prof arcv2elf arcv2elfx\"\n@@ -97,29 +117,45 @@ arc*-*-linux*)\t\tcase \"${with_cpu}\" in\n \t\t\tesac\n \t\t\ttarg_extra_emuls=\"${targ_extra_emuls} arclinux_prof arcelf arcelf_prof arcv2elf arcv2elfx\"\n \t\t\t;;\n-arm*-*-cegcc*)\t\ttarg_emul=arm_wince_pe ; targ_extra_ofiles=\"deffilep.o pe-dll.o\"\n-\t\t\tLIB_PATH='${tooldir}/lib/w32api' ;;\n+arm*-*-cegcc*)\t\ttarg_emul=arm_wince_pe\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\tLIB_PATH='${tooldir}/lib/w32api'\n+\t\t\t;;\n arm-wince-pe | arm-*-wince | arm*-*-mingw32ce*)\n-\t\t\ttarg_emul=arm_wince_pe ; targ_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n-arm-*-pe)\t\ttarg_emul=armpe ; targ_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n+\t\t\ttarg_emul=arm_wince_pe\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n+arm-*-pe)\t\ttarg_emul=armpe\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n arm*b-*-freebsd*)\ttarg_emul=armelfb_fbsd\n-\t\t\ttarg_extra_emuls=\"armelf_fbsd armelf\" ;;\n+\t\t\ttarg_extra_emuls=\"armelf_fbsd armelf\"\n+\t\t\t;;\n arm*-*-freebsd* | arm-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=armelf_fbsd\n-\t\t\ttarg_extra_emuls=\"armelfb_fbsd armelf\" ;;\n+\t\t\ttarg_extra_emuls=\"armelfb_fbsd armelf\"\n+\t\t\t;;\n armeb-*-netbsdelf*)\ttarg_emul=armelfb_nbsd;\n-\t\t\ttarg_extra_emuls=\"armelf_nbsd armelf\" ;;\n+\t\t\ttarg_extra_emuls=\"armelf_nbsd armelf\"\n+\t\t\t;;\n arm-*-netbsdelf*)\ttarg_emul=armelf_nbsd;\n-\t\t\ttarg_extra_emuls=\"armelfb_nbsd armelf\" ;;\n-arm-*-nto*)\t\ttarg_emul=armnto ;;\n-arm-*-phoenix*)\t\ttarg_emul=armelf ;;\n+\t\t\ttarg_extra_emuls=\"armelfb_nbsd armelf\"\n+\t\t\t;;\n+arm-*-nto*)\t\ttarg_emul=armnto\n+\t\t\t;;\n+arm-*-phoenix*)\t\ttarg_emul=armelf\n+\t\t\t;;\n armeb-*-elf | armeb-*-eabi*)\n-\t\t\ttarg_emul=armelfb ;;\n+\t\t\ttarg_emul=armelfb\n+\t\t\t;;\n arm-*-elf | arm*-*-eabi* | arm-*-rtems*)\n-\t\t\ttarg_emul=armelf ;;\n+\t\t\ttarg_emul=armelf\n+\t\t\t;;\n arm*-*-symbianelf*)\ttarg_emul=armsymbian;;\n-arm-*-kaos*)\t\ttarg_emul=armelf ;;\n-arm9e-*-elf)\t\ttarg_emul=armelf ;;\n+arm-*-kaos*)\t\ttarg_emul=armelf\n+\t\t\t;;\n+arm9e-*-elf)\t\ttarg_emul=armelf\n+\t\t\t;;\n arm*b-*-linux-*eabi*)\ttarg_emul=armelfb_linux_eabi\n \t\t\ttarg_extra_emuls=armelf_linux_eabi\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n@@ -161,8 +197,10 @@ arm*-*-uclinux*)\ttarg_emul=armelf_linux\n \t\t\ttarg_extra_emuls=\"armelf armelfb armelfb_linux\"\n \t\t\ttarg_extra_libpath=\"armelfb_linux\"\n \t\t\t;;\n-arm-*-vxworks)\t\ttarg_emul=armelf_vxworks ;;\n-arm*-*-conix*)\t\ttarg_emul=armelf ;;\n+arm-*-vxworks)\t\ttarg_emul=armelf_vxworks\n+\t\t\t;;\n+arm*-*-conix*)\t\ttarg_emul=armelf\n+\t\t\t;;\n arm*-*-fuchsia*)\ttarg_emul=armelf_fuchsia\n \t\t\ttarg_extra_emuls=\"armelfb_fuchsia armelf armelfb\"\n \t\t\t;;\n@@ -182,91 +220,143 @@ bfin-*-linux-uclibc*)\ttarg_emul=elf32bfinfd;\n \t\t\ttarg_extra_emuls=\"elf32bfin\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n \t\t\t;;\n-bpf-*-*)\t\ttarg_emul=elf64bpf ;;\n-cr16-*-elf*)\t\ttarg_emul=elf32cr16 ;;\n+bpf-*-*)\t\ttarg_emul=elf64bpf\n+\t\t\t;;\n+cr16-*-elf*)\t\ttarg_emul=elf32cr16\n+\t\t\t;;\n cr16c-*-elf*)\t\ttarg_emul=elf32cr16c\n \t\t\t;;\n cris-*-*aout*)\t\ttarg_emul=crisaout\n \t\t\ttarg_extra_emuls=\"criself crislinux\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n cris-*-linux-* | crisv32-*-linux-*)\n-\t\t\ttarg_emul=crislinux ;;\n+\t\t\ttarg_emul=crislinux\n+\t\t\t;;\n cris-*-* | crisv32-*-*)\ttarg_emul=criself\n \t\t\ttarg_extra_emuls=\"crisaout crislinux\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n \t\t\t;;\n crx-*-elf*)\t\ttarg_emul=elf32crx\n \t\t\t;;\n \n-csky-*-elf*)\t\ttarg_emul=cskyelf ;;\n-csky-*-linux*)\t\ttarg_emul=cskyelf_linux ;;\n+csky-*-elf*)\t\ttarg_emul=cskyelf\n+\t\t\t;;\n+csky-*-linux*)\t\ttarg_emul=cskyelf_linux\n+\t\t\t;;\n \n-d10v-*-*)\t\ttarg_emul=d10velf ;;\n-d30v-*-*ext*)\t\ttarg_emul=d30v_e; targ_extra_emuls=\"d30velf d30v_o\" ;;\n-d30v-*-*onchip*)\ttarg_emul=d30v_o; targ_extra_emuls=\"d30velf d30v_e\" ;;\n-d30v-*-*)\t\ttarg_emul=d30velf; targ_extra_emuls=\"d30v_e d30v_o\"\n+d10v-*-*)\t\ttarg_emul=d10velf\n+\t\t\t;;\n+d30v-*-*ext*)\t\ttarg_emul=d30v_e\n+\t\t\ttarg_extra_emuls=\"d30velf d30v_o\"\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n+\t\t\t;;\n+d30v-*-*onchip*)\ttarg_emul=d30v_o\n+\t\t\ttarg_extra_emuls=\"d30velf d30v_e\"\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n+\t\t\t;;\n+d30v-*-*)\t\ttarg_emul=d30velf\n+\t\t\ttarg_extra_emuls=\"d30v_e d30v_o\"\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n dlx-*-elf*)\t\ttarg_emul=elf32_dlx\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n epiphany-*-*)\t\ttarg_emul=elf32epiphany\n \t\t\ttarg_extra_emuls=\"elf32epiphany_4x4\"\n \t\t\t;;\n-fido*-*-elf*)\t\ttarg_emul=m68kelf ;;\n+fido*-*-elf*)\t\ttarg_emul=m68kelf\n+\t\t\t;;\n fr30-*-*)\t\ttarg_emul=elf32fr30\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n+\t\t\t;;\n+frv-*-*linux*)\t\ttarg_emul=elf32frvfd\n \t\t\t;;\n-frv-*-*linux*)\t\ttarg_emul=elf32frvfd ;;\n-frv-*-*)\t\ttarg_emul=elf32frv ; targ_extra_emuls=\"elf32frvfd\"\n+frv-*-*)\t\ttarg_emul=elf32frv\n+\t\t\ttarg_extra_emuls=\"elf32frvfd\"\n \t\t\t;;\n moxie-*-moxiebox*)\ttarg_emul=moxiebox\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n moxie-*-*)\t\ttarg_emul=elf32moxie\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n h8300-*-elf* | h8300-*-rtems*)\n \t\t\ttarg_emul=h8300elf;\n-\t\t\ttarg_extra_emuls=\"h8300helf h8300self h8300hnelf h8300snelf h8300sxelf h8300sxnelf\" ;;\n+\t\t\ttarg_extra_emuls=\"h8300helf h8300self h8300hnelf h8300snelf h8300sxelf h8300sxnelf\"\n+\t\t\t;;\n h8300-*-linux*)\n \t\t\ttarg_emul=h8300elf_linux;\n-\t\t\ttarg_extra_emuls=\"h8300helf_linux h8300self_linux h8300sxelf_linux\" ;;\n-hppa*64*-*-linux-*)\ttarg_emul=hppa64linux ;;\n-hppa*64*-hpux*)\t\ttarg_emul=elf64hppa ;;\n-hppa*-*-linux-*)\ttarg_emul=hppalinux ;;\n-hppa*-*-*elf*)\t\ttarg_emul=hppaelf ;;\n-hppa*-*-lites*)\t\ttarg_emul=hppaelf ;;\n-hppa*-*-netbsd*)\ttarg_emul=hppanbsd ;;\n+\t\t\ttarg_extra_emuls=\"h8300helf_linux h8300self_linux h8300sxelf_linux\"\n+\t\t\t;;\n+hppa*64*-*-linux-*)\ttarg_emul=hppa64linux\n+\t\t\t;;\n+hppa*64*-hpux*)\t\ttarg_emul=elf64hppa\n+\t\t\t;;\n+hppa*-*-linux-*)\ttarg_emul=hppalinux\n+\t\t\t;;\n+hppa*-*-*elf*)\t\ttarg_emul=hppaelf\n+\t\t\t;;\n+hppa*-*-lites*)\t\ttarg_emul=hppaelf\n+\t\t\t;;\n+hppa*-*-netbsd*)\ttarg_emul=hppanbsd\n+\t\t\t;;\n hppa*-*-openbsd*)\ttarg_emul=hppaobsd\n \t\t\t;;\n-i[3-7]86-*-nto-qnx*)\ttarg_emul=i386nto ;;\n-i[3-7]86-*-go32)\ttarg_emul=i386go32 ;;\n-i[3-7]86-*-msdosdjgpp*) targ_emul=i386go32 ;;\n-i[3-7]86-*-lynxos*)\ttarg_emul=i386lynx ;;\n+i[3-7]86-*-nto-qnx*)\ttarg_emul=i386nto\n+\t\t\t;;\n+i[3-7]86-*-go32)\ttarg_emul=i386go32\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+i[3-7]86-*-msdosdjgpp*) targ_emul=i386go32\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+i[3-7]86-*-lynxos*)\ttarg_emul=i386lynx\n+\t\t\t;;\n i[3-7]86-*-aros*)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_iamcu ;;\n+\t\t\ttarg_extra_emuls=elf_iamcu\n+\t\t\t;;\n i[3-7]86-*-rdos*)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_iamcu ;;\n-x86_64-*-rdos*)\t\ttarg_emul=elf64rdos ;;\n-x86_64-*-cloudabi*)\ttarg_emul=elf_x86_64_cloudabi ;;\n-i[3-7]86-*-bsd)\t\ttarg_emul=i386bsd ;;\n-i[3-7]86-*-bsd386)\ttarg_emul=i386bsd ;;\n-i[3-7]86-*-bsdi*)\ttarg_emul=i386bsd ;;\n+\t\t\ttarg_extra_emuls=elf_iamcu\n+\t\t\t;;\n+x86_64-*-rdos*)\t\ttarg_emul=elf64rdos\n+\t\t\t;;\n+x86_64-*-cloudabi*)\ttarg_emul=elf_x86_64_cloudabi\n+\t\t\t;;\n+i[3-7]86-*-bsd)\t\ttarg_emul=i386bsd\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+i[3-7]86-*-bsd386)\ttarg_emul=i386bsd\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+i[3-7]86-*-bsdi*)\ttarg_emul=i386bsd\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n i[3-7]86-*-linux-*)\ttarg_emul=elf_i386\n \t\t\ttarg_extra_emuls=\"elf_iamcu\"\n \t\t\ttarg64_extra_emuls=\"elf_x86_64 elf32_x86_64 elf_l1om elf_k1om\"\n-\t\t\ttarg64_extra_libpath=\"elf_x86_64 elf32_x86_64\" ;;\n+\t\t\ttarg64_extra_libpath=\"elf_x86_64 elf32_x86_64\"\n+\t\t\t;;\n x86_64-*-linux-gnux32)\ttarg_emul=elf32_x86_64\n \t\t\ttarg_extra_emuls=\"elf_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om\"\n \t\t\ttarg_extra_libpath=\"elf_i386 elf_iamcu elf_x86_64 elf_l1om elf_k1om\"\n \t\t\ttdir_elf_iamcu=`echo ${targ_alias} | sed -e 's/x86_64/i386/' -e 's/-linux-gnux32/-linux-gnu/'`\n-\t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/' -e 's/-linux-gnux32/-linux-gnu/'` ;;\n+\t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/' -e 's/-linux-gnux32/-linux-gnu/'`\n+\t\t\t;;\n x86_64-*-linux-*)\ttarg_emul=elf_x86_64\n \t\t\ttarg_extra_emuls=\"elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om\"\n \t\t\ttarg_extra_libpath=\"elf_i386 elf32_x86_64 elf_l1om elf_k1om\"\n-\t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'` ;;\n+\t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'`\n+\t\t\t;;\n i[3-7]86-*-redox*)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_x86_64 ;;\n+\t\t\ttarg_extra_emuls=elf_x86_64\n+\t\t\t;;\n x86_64-*-redox*)\ttarg_emul=elf_x86_64\n-\t\t\ttarg_extra_emuls=elf_i386 ;;\n+\t\t\ttarg_extra_emuls=elf_i386\n+\t\t\t;;\n i[3-7]86-*-sysv[45]*)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_iamcu ;;\n+\t\t\ttarg_extra_emuls=elf_iamcu\n+\t\t\t;;\n i[3-7]86-*-solaris2*)\ttarg_emul=elf_i386_sol2\n \t\t\ttarg_extra_emuls=\"elf_i386_ldso elf_i386 elf_iamcu elf_x86_64_sol2 elf_x86_64 elf_l1om elf_k1om\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n@@ -275,9 +365,11 @@ x86_64-*-solaris2*)\n \t\t\ttarg_emul=elf_x86_64_sol2\n \t\t\ttarg_extra_emuls=\"elf_x86_64 elf_i386_sol2 elf_i386_ldso elf_i386 elf_iamcu elf_l1om elf_k1om\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n-\t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'` ;;\n+\t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'`\n+\t\t\t;;\n i[3-7]86-*-unixware)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_iamcu ;;\n+\t\t\ttarg_extra_emuls=elf_iamcu\n+\t\t\t;;\n i[3-7]86-*-solaris*)\ttarg_emul=elf_i386_ldso\n \t\t\ttarg_extra_emuls=\"elf_i386\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n@@ -286,9 +378,11 @@ i[3-7]86-*-netbsdelf* | \\\n i[3-7]86-*-netbsd*-gnu* | \\\n i[3-7]86-*-knetbsd*-gnu)\n \t\t\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=\"elf_iamcu\" ;;\n+\t\t\ttarg_extra_emuls=\"elf_iamcu\"\n+\t\t\t;;\n i[3-7]86-*-netbsdpe*)\ttarg_emul=i386pe\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n x86_64-*-netbsd*)\ttarg_emul=elf_x86_64\n \t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu elf_l1om elf_k1om\"\n \t\t\ttdir_elf_iamcu=`echo ${targ_alias} | \\\n@@ -304,25 +398,31 @@ x86_64-*-netbsd*)\ttarg_emul=elf_x86_64\n \t\t\t*-netbsdelf*)   ;;\n \t\t\t*)\t\ttdir_elf_i386=`echo ${tdir_elf_i386} | \\\n \t\t\t\t\tsed -e 's/netbsd/netbsdelf/'`;;\n-\t\t\tesac ;;\n+\t\t\tesac\n+\t\t\t;;\n i[3-7]86-*-elfiamcu)\ttarg_emul=elf_iamcu\n-\t\t\ttarg_extra_emuls=elf_i386 ;;\n+\t\t\ttarg_extra_emuls=elf_i386\n+\t\t\t;;\n i[3-7]86-*-elf* | i[3-7]86-*-rtems*)\n \t\t\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_iamcu ;;\n+\t\t\ttarg_extra_emuls=elf_iamcu\n+\t\t\t;;\n x86_64-*-elf* | x86_64-*-rtems* | x86_64-*-fuchsia*)\n \t\t\ttarg_emul=elf_x86_64\n \t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu elf32_x86_64 elf_l1om elf_k1om\"\n \t\t\ttarg_extra_libpath=\"elf_i386 elf_iamcu elf32_x86_64 elf_l1om elf_k1om\"\n \t\t\ttdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'`\n \t\t\t;;\n i[3-7]86-*-dragonfly*)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=\"elf_iamcu i386bsd\" ;;\n+\t\t\ttarg_extra_emuls=\"elf_iamcu i386bsd\"\n+\t\t\t;;\n x86_64-*-dragonfly*)\ttarg_emul=elf_x86_64\n-\t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu elf_l1om elf_k1om\" ;;\n+\t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu elf_l1om elf_k1om\"\n+\t\t\t;;\n i[3-7]86-*-freebsd* | i[3-7]86-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf_i386_fbsd\n-\t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu i386bsd\" ;;\n+\t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu i386bsd\"\n+\t\t\t;;\n x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf_x86_64_fbsd\n \t\t\ttarg_extra_emuls=\"elf_i386_fbsd elf_x86_64 elf_i386 elf_iamcu elf_l1om elf_l1om_fbsd elf_k1om elf_k1om_fbsd\"\n@@ -332,35 +432,55 @@ x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)\n \t\t\ttdir_elf_iamcu=`echo ${targ_alias} \\\n \t\t\t    | sed -e 's/x86_64/i386/'`\n \t\t\ttdir_elf_i386=`echo ${targ_alias} \\\n-\t\t\t    | sed -e 's/x86_64/i386/'` ;;\n+\t\t\t    | sed -e 's/x86_64/i386/'`\n+\t\t\t;;\n i[3-7]86-*-gnu*)\ttarg_emul=elf_i386\n-\t\t\ttarg_extra_emuls=elf_iamcu ;;\n-i[3-7]86-*-msdos*)\ttarg_emul=i386msdos; targ_extra_emuls=i386aout ;;\n-i[3-7]86-*-moss*)\ttarg_emul=i386moss; targ_extra_emuls=i386msdos ;;\n+\t\t\ttarg_extra_emuls=elf_iamcu\n+\t\t\t;;\n+i[3-7]86-*-msdos*)\ttarg_emul=i386msdos\n+\t\t\ttarg_extra_emuls=i386aout\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+i[3-7]86-*-moss*)\ttarg_emul=i386moss\n+\t\t\ttarg_extra_emuls=i386msdos\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n i[3-7]86-*-winnt*)\ttarg_emul=i386pe ;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n i[3-7]86-*-pe)\t\ttarg_emul=i386pe ;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n i[3-7]86-*-cygwin*)\ttarg_emul=i386pe ;\n \t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;\n-\t\t\ttest \"$targ\" != \"$host\" && LIB_PATH='${tooldir}/lib/w32api' ;;\n+\t\t\ttest \"$targ\" != \"$host\" && LIB_PATH='${tooldir}/lib/w32api'\n+\t\t\t;;\n i[3-7]86-*-mingw32*)\ttarg_emul=i386pe ;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n x86_64-*-pe | x86_64-*-pep) targ_emul=i386pep ;\n \t\t\ttarg_extra_emuls=i386pe ;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pep-dll.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pep-dll.o pe-dll.o\"\n+\t\t\t;;\n x86_64-*-cygwin)\ttarg_emul=i386pep ;\n \t\t\ttarg_extra_emuls=i386pe\n \t\t\ttarg_extra_ofiles=\"deffilep.o pep-dll.o pe-dll.o\"\n-\t\t\ttest \"$targ\" != \"$host\" && LIB_PATH='${tooldir}/lib/w32api' ;;\n+\t\t\ttest \"$targ\" != \"$host\" && LIB_PATH='${tooldir}/lib/w32api'\n+\t\t\t;;\n x86_64-*-mingw*)\ttarg_emul=i386pep ;\n \t\t\ttarg_extra_emuls=i386pe\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pep-dll.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pep-dll.o pe-dll.o\"\n+\t\t\t;;\n i[3-7]86-*-interix*)\ttarg_emul=i386pe_posix;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n-i[3-7]86-*-beospe*)\ttarg_emul=i386beos ;;\n-i[3-7]86-*-beos*)\ttarg_emul=elf_i386_be ;;\n-i[3-7]86-*-vxworks*)\ttarg_emul=elf_i386_vxworks ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n+i[3-7]86-*-beospe*)\ttarg_emul=i386beos\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+i[3-7]86-*-beos*)\ttarg_emul=elf_i386_be\n+\t\t\t;;\n+i[3-7]86-*-vxworks*)\ttarg_emul=elf_i386_vxworks\n+\t\t\t;;\n i[3-7]86-*-chaos)\ttarg_emul=elf_i386_chaos\n \t\t\t;;\n i[3-7]86-*-nacl*)\ttarg_emul=elf_i386_nacl\n@@ -374,46 +494,69 @@ x86_64-*-nacl*)\t\ttarg_emul=elf32_x86_64_nacl\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n \t\t\ttdir_elf_i386_nacl=`echo ${targ_alias} | sed -e 's/x86_64/i386/'`\n \t\t\t;;\n-ia16-*-elf*)\t\ttarg_emul=elf_i386 targ_extra_emuls=i386msdos ;;\n-ia64-*-elf*)\t\ttarg_emul=elf64_ia64 ;;\n+ia16-*-elf*)\t\ttarg_emul=elf_i386\n+\t\t\ttarg_extra_emuls=i386msdos\n+\t\t\t;;\n+ia64-*-elf*)\t\ttarg_emul=elf64_ia64\n+\t\t\t;;\n ia64-*-freebsd* | ia64-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf64_ia64_fbsd\n-\t\t\ttarg_extra_emuls=\"elf64_ia64\" ;;\n-ia64-*-netbsd*)\t\ttarg_emul=elf64_ia64 ;;\n-ia64-*-linux*)\t\ttarg_emul=elf64_ia64 ;;\n-ia64-*-*vms*)\t\ttarg_emul=elf64_ia64_vms ;;\n+\t\t\ttarg_extra_emuls=\"elf64_ia64\"\n+\t\t\t;;\n+ia64-*-netbsd*)\t\ttarg_emul=elf64_ia64\n+\t\t\t;;\n+ia64-*-linux*)\t\ttarg_emul=elf64_ia64\n+\t\t\t;;\n+ia64-*-*vms*)\t\ttarg_emul=elf64_ia64_vms\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n+\t\t\t;;\n ia64-*-aix*)\t\ttarg_emul=elf64_aix\n \t\t\t;;\n ip2k-*-elf)\t\ttarg_emul=elf32ip2k\n \t\t\t;;\n-iq2000-*-elf)\t\ttarg_emul=elf32iq2000 ; targ_extra_emuls=\"elf32iq10\"\n+iq2000-*-elf)\t\ttarg_emul=elf32iq2000\n+\t\t\ttarg_extra_emuls=\"elf32iq10\"\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n-lm32-*-*linux*)\t\ttarg_emul=elf32lm32fd ;;\n-lm32-*-*)\t\ttarg_emul=elf32lm32 ; targ_extra_emuls=\"elf32lm32fd\"\n+lm32-*-*linux*)\t\ttarg_emul=elf32lm32fd\n+\t\t\t;;\n+lm32-*-*)\t\ttarg_emul=elf32lm32\n+\t\t\ttarg_extra_emuls=\"elf32lm32fd\"\n \t\t\t;;\n m32c-*-elf | m32c-*-rtems*)\n \t\t\ttarg_emul=elf32m32c\n \t\t\t;;\n-m32r*le-*-elf*)\t\ttarg_emul=m32rlelf ;;\n+m32r*le-*-elf*)\t\ttarg_emul=m32rlelf\n+\t\t\t;;\n m32r*-*-elf* | m32r*-*-rtems*)\n-\t\t\ttarg_emul=m32relf ;;\n-m32r*le-*-linux-*)\ttarg_emul=m32rlelf_linux ;;\n+\t\t\ttarg_emul=m32relf\n+\t\t\t;;\n+m32r*le-*-linux-*)\ttarg_emul=m32rlelf_linux\n+\t\t\t;;\n m32r*-*-linux-*)\ttarg_emul=m32relf_linux\n \t\t\t;;\n m68hc11-*-*|m6811-*-*)\ttarg_emul=m68hc11elf\n-\t\t\ttarg_extra_emuls=\"m68hc11elfb m68hc12elf m68hc12elfb\" ;;\n+\t\t\ttarg_extra_emuls=\"m68hc11elfb m68hc12elf m68hc12elfb\"\n+\t\t\t;;\n m68hc12-*-*|m6812-*-*)\ttarg_emul=m68hc12elf\n-\t\t\ttarg_extra_emuls=\"m68hc12elfb m68hc11elf m68hc11elfb\" ;;\n-m68*-*-netbsdelf*)\ttarg_emul=m68kelfnbsd ;;\n-m68*-*-*)\t\ttarg_emul=m68kelf ;;\n+\t\t\ttarg_extra_emuls=\"m68hc12elfb m68hc11elf m68hc11elfb\"\n+\t\t\t;;\n+m68*-*-netbsdelf*)\ttarg_emul=m68kelfnbsd\n+\t\t\t;;\n+m68*-*-*)\t\ttarg_emul=m68kelf\n+\t\t\t;;\n s12z-*-*)\t\ttarg_emul=m9s12zelf\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n mcore-*-pe)\t\ttarg_emul=mcorepe ;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n mcore-*-elf)\t\ttarg_emul=elf32mcore\n \t\t\t;;\n-mep-*-elf)\t\ttarg_emul=elf32mep ;;\n-metag-*-*)\t\ttarg_emul=elf32metag ;;\n+mep-*-elf)\t\ttarg_emul=elf32mep\n+\t\t\t;;\n+metag-*-*)\t\ttarg_emul=elf32metag\n+\t\t\t;;\n microblazeel*-linux*)\ttarg_emul=\"elf32mbel_linux\"\n \t\t\ttarg_extra_emuls=\"elf32mb_linux\"\n \t\t\t;;\n@@ -426,10 +569,12 @@ microblazeel*)\t\ttarg_emul=elf32microblazeel\n microblaze*)\t\ttarg_emul=elf32microblaze\n \t\t\ttarg_extra_emuls=elf32microblazeel\n \t\t\t;;\n-mips*-sgi-irix5*)\ttarg_emul=elf32bsmip ;;\n+mips*-sgi-irix5*)\ttarg_emul=elf32bsmip\n+\t\t\t;;\n mips*-sgi-irix6*)\ttarg_emul=elf32bmipn32\n \t\t\ttarg_extra_emuls=\"elf32bsmip elf64bmip\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*el-*-netbsd*)\ttarg_emul=elf32ltsmip\n \t\t\ttarg_extra_emuls=\"elf32btsmip elf64ltsmip elf64btsmip\"\n \t\t\t;;\n@@ -442,101 +587,142 @@ mips64el-*-openbsd*)\ttarg_emul=elf64ltsmip\n mips64-*-openbsd*)\ttarg_emul=elf64btsmip\n \t\t\ttarg_extra_emuls=elf64ltsmip\n \t\t\t;;\n-mips*vr4300el-*-elf*)\ttarg_emul=elf32l4300 ;;\n-mips*vr4300-*-elf*)\ttarg_emul=elf32b4300 ;;\n-mips*vr4100el-*-elf*)\ttarg_emul=elf32l4300 ;;\n-mips*vr4100-*-elf*)\ttarg_emul=elf32b4300 ;;\n-mips*vr5000el-*-elf*)\ttarg_emul=elf32l4300 ;;\n-mips*vr5000-*-elf*)\ttarg_emul=elf32b4300 ;;\n+mips*vr4300el-*-elf*)\ttarg_emul=elf32l4300\n+\t\t\t;;\n+mips*vr4300-*-elf*)\ttarg_emul=elf32b4300\n+\t\t\t;;\n+mips*vr4100el-*-elf*)\ttarg_emul=elf32l4300\n+\t\t\t;;\n+mips*vr4100-*-elf*)\ttarg_emul=elf32b4300\n+\t\t\t;;\n+mips*vr5000el-*-elf*)\ttarg_emul=elf32l4300\n+\t\t\t;;\n+mips*vr5000-*-elf*)\ttarg_emul=elf32b4300\n+\t\t\t;;\n mips*el-sde-elf* | mips*el-mti-elf* | mips*el-img-elf*)\n \t\t\ttarg_emul=elf32ltsmip\n-\t\t\ttarg_extra_emuls=\"elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip\" ;;\n+\t\t\ttarg_extra_emuls=\"elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip\"\n+\t\t\t;;\n mips*-sde-elf* | mips*-mti-elf* | mips*-img-elf*)\n \t\t\ttarg_emul=elf32btsmip\n-\t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip\" ;;\n+\t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip\"\n+\t\t\t;;\n mips64*el-ps2-elf*)\ttarg_emul=elf32lr5900n32\n \t\t\ttarg_extra_emuls=\"elf32lr5900\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*el-ps2-elf*)\ttarg_emul=elf32lr5900\n \t\t\ttarg_extra_emuls=\"elf32lr5900n32\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n-mips*el-*-elf*)\t\ttarg_emul=elf32elmip ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n+mips*el-*-elf*)\t\ttarg_emul=elf32elmip\n+\t\t\t;;\n mips*-*-elf* | mips*-*-rtems*)\n-\t\t\ttarg_emul=elf32ebmip ;;\n+\t\t\ttarg_emul=elf32ebmip\n+\t\t\t;;\n mips*el-*-vxworks*)\ttarg_emul=elf32elmipvxworks\n-\t\t\ttarg_extra_emuls=\"elf32ebmipvxworks\" ;;\n+\t\t\ttarg_extra_emuls=\"elf32ebmipvxworks\"\n+\t\t\t;;\n mips*-*-vxworks*)\ttarg_emul=elf32ebmipvxworks\n-\t\t\ttarg_extra_emuls=\"elf32elmipvxworks\" ;;\n-mips*-*-windiss)\ttarg_emul=elf32mipswindiss ;;\n+\t\t\ttarg_extra_emuls=\"elf32elmipvxworks\"\n+\t\t\t;;\n+mips*-*-windiss)\ttarg_emul=elf32mipswindiss\n+\t\t\t;;\n mips64*el-*-linux-*)\ttarg_emul=elf32ltsmipn32\n \t\t\ttarg_extra_emuls=\"elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips64*-*-linux-*)\ttarg_emul=elf32btsmipn32\n \t\t\ttarg_extra_emuls=\"elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*el-*-linux-*)\ttarg_emul=elf32ltsmip\n \t\t\ttarg_extra_emuls=\"elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*-*-linux-*)\ttarg_emul=elf32btsmip\n \t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips64*el-*-freebsd* | mips64*el-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf32ltsmipn32_fbsd\n \t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmip_fbsd elf32btsmip_fbsd elf32btsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips64*-*-freebsd* | mips64*-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf32btsmipn32_fbsd\n \t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmip_fbsd elf32btsmip_fbsd elf32ltsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*el-*-freebsd* | mips*el-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf32ltsmip_fbsd\n \t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmipn32_fbsd elf32btsmip_fbsd elf32btsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*-*-freebsd* | mips*-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf32btsmip_fbsd\n \t\t\ttarg_extra_emuls=\"elf32ltsmip elf32btsmip elf32ltsmipn32 elf32btsmipn32 elf64ltsmip elf64btsmip elf32ltsmip_fbsd elf32btsmipn32_fbsd elf32ltsmipn32_fbsd elf64ltsmip_fbsd elf64btsmip_fbsd\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n mips*-*-sysv4*)\t\ttarg_emul=elf32btsmip\n \t\t\t;;\n mmix-*-*)\t\ttarg_emul=mmo\n \t\t\ttarg_extra_emuls=elf64mmix\n \t\t\t;;\n-am33_2.0-*-linux*)\ttarg_emul=elf32am33lin ;;\n-mn10200-*-*)\t\ttarg_emul=mn10200 ;;\n+am33_2.0-*-linux*)\ttarg_emul=elf32am33lin\n+\t\t\t;;\n+mn10200-*-*)\t\ttarg_emul=mn10200\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n+\t\t\t;;\n mn10300-*-*)\t\ttarg_emul=mn10300\n \t\t\t;;\n mt-*elf)\t\ttarg_emul=elf32mt\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n msp430-*-*)\t\ttarg_emul=msp430elf\n \t\t\ttarg_extra_emuls=\"msp430X\"\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n nds32*le-*-elf*)\ttarg_emul=nds32elf\n \t\t\ttarg_extra_emuls=\"nds32elf16m nds32belf nds32belf16m\"\n \t\t\t;;\n nds32*be-*-elf*)\ttarg_emul=nds32belf\n \t\t\ttarg_extra_emuls=\"nds32elf nds32elf16m nds32belf16m\"\n \t\t\t;;\n-nds32*le-*-linux-gnu*)\ttarg_emul=nds32elf_linux ;;\n-nds32*be-*-linux-gnu*)\ttarg_emul=nds32belf_linux ;;\n-nios2*-*-linux*)\ttarg_emul=nios2linux ;;\n-nios2*-*-*)\t\ttarg_emul=nios2elf ;;\n-ns32k-pc532-mach* | ns32k-pc532-ux*)  targ_emul=pc532macha ;;\n+nds32*le-*-linux-gnu*)\ttarg_emul=nds32elf_linux\n+\t\t\t;;\n+nds32*be-*-linux-gnu*)\ttarg_emul=nds32belf_linux\n+\t\t\t;;\n+nios2*-*-linux*)\ttarg_emul=nios2linux\n+\t\t\t;;\n+nios2*-*-*)\t\ttarg_emul=nios2elf\n+\t\t\t;;\n+ns32k-pc532-mach* | ns32k-pc532-ux*)  targ_emul=pc532macha\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n ns32k-*-netbsd* | ns32k-pc532-lites*) targ_emul=ns32knbsd\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n or1k-*-elf | or1knd-*-elf | or1k-*-rtems* | or1knd-*-rtems*)\n-\t\t\ttarg_emul=elf32or1k ;;\n-or1k-*-linux* | or1knd-*-linux*)\ttarg_emul=elf32or1k_linux ;;\n+\t\t\ttarg_emul=elf32or1k\n+\t\t\t;;\n+or1k-*-linux* | or1knd-*-linux*)\ttarg_emul=elf32or1k_linux\n+\t\t\t;;\n pdp11-*-*)\t\ttarg_emul=pdp11\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n pjl*-*-*)\t\ttarg_emul=pjlelf\n-\t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu\" ;;\n+\t\t\ttarg_extra_emuls=\"elf_i386 elf_iamcu\"\n+\t\t\t;;\n pj*-*-*)\t\ttarg_emul=pjelf\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n powerpc-*-freebsd* | powerpc-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf32ppc_fbsd\n \t\t\ttarg_extra_emuls=\"elf32ppc elf32ppcsim\"\n \t\t\ttarg_extra_libpath=elf32ppc;\n-\t\t\ttdir_elf32ppcsim=`echo ${targ_alias} | sed -e 's/ppc/ppcsim/'` ;;\n+\t\t\ttdir_elf32ppcsim=`echo ${targ_alias} | sed -e 's/ppc/ppcsim/'`\n+\t\t\t;;\n powerpc64-*-freebsd*)\n \t\t\ttarg_emul=elf64ppc_fbsd\n \t\t\ttarg_extra_emuls=\"elf64ppc elf32ppc_fbsd elf32ppc\"\n@@ -546,7 +732,8 @@ powerpc64-*-freebsd*)\n \t\t\t;;\n powerpc-*-vxworks*)\n \t\t\ttarg_emul=elf32ppcvxworks\n-\t\t\ttarg_extra_emuls=\"elf32ppc elf32ppclinux elf32ppcsim\" ;;\n+\t\t\ttarg_extra_emuls=\"elf32ppc elf32ppclinux elf32ppcsim\"\n+\t\t\t;;\n powerpc*-*-elf* | powerpc*-*-eabi* | powerpc*-*-sysv* \\\n   | powerpc*-*-linux* | powerpc*-*-netbsd* | powerpc*-*-openbsd* \\\n   | powerpc*-*-rtems* \\\n@@ -621,111 +808,171 @@ powerpc*-*-elf* | powerpc*-*-eabi* | powerpc*-*-sysv* \\\n \t\t\teval test -n \\\"\\$${td}sim\\\" || eval ${td}sim=\"${ta32}\"\n \t\t\teval test -n \\\"\\$${td64}\\\" || eval ${td64}=\"${ta64}\"\n \t\t\t;;\n-powerpc-*-nto*)\t\ttarg_emul=elf32ppcnto ;;\n-powerpcle-*-nto*)\ttarg_emul=elf32lppcnto ;;\n-powerpc-*-macos*)\ttarg_emul=ppcmacos ;;\n+powerpc-*-nto*)\t\ttarg_emul=elf32ppcnto\n+\t\t\t;;\n+powerpcle-*-nto*)\ttarg_emul=elf32lppcnto\n+\t\t\t;;\n+powerpc-*-macos*)\ttarg_emul=ppcmacos\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin*)\n \t\t\ttarg_emul=ppcpe\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n-powerpc-*-aix[5-9]*)\ttarg_emul=aix5ppc ;;\n-powerpc-*-aix*)\t\ttarg_emul=aixppc ;;\n-powerpc-*-beos*)\ttarg_emul=aixppc ;;\n-powerpc-*-windiss*)\ttarg_emul=elf32ppcwindiss ;;\n-powerpc-*-lynxos*)\ttarg_emul=ppclynx ;;\n-pru*-*-*)\t\ttarg_emul=pruelf ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n+powerpc-*-aix[5-9]*)\ttarg_emul=aix5ppc\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+powerpc-*-aix*)\t\ttarg_emul=aixppc\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+powerpc-*-beos*)\ttarg_emul=aixppc\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+powerpc-*-windiss*)\ttarg_emul=elf32ppcwindiss\n+\t\t\t;;\n+powerpc-*-lynxos*)\ttarg_emul=ppclynx\n+\t\t\t;;\n+pru*-*-*)\t\ttarg_emul=pruelf\n+\t\t\t;;\n riscv32*-*-linux*)\ttarg_emul=elf32lriscv\n \t\t\ttarg_extra_emuls=\"elf32lriscv_ilp32f elf32lriscv_ilp32 elf64lriscv elf64lriscv_lp64f elf64lriscv_lp64\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n riscv-*-* | riscv32*-*-*)\n \t\t\ttarg_emul=elf32lriscv\n \t\t\ttarg_extra_emuls=\"elf64lriscv\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n riscv64*-*-linux*)\ttarg_emul=elf64lriscv\n \t\t\ttarg_extra_emuls=\"elf64lriscv_lp64f elf64lriscv_lp64 elf32lriscv elf32lriscv_ilp32f elf32lriscv_ilp32\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n riscv64*-*-*)\t\ttarg_emul=elf64lriscv\n \t\t\ttarg_extra_emuls=\"elf32lriscv\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n-rs6000-*-aix[5-9]*)\ttarg_emul=aix5rs6 ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n+rs6000-*-aix[5-9]*)\ttarg_emul=aix5rs6\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n rs6000-*-aix*)\t\ttarg_emul=aixrs6\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+rl78-*-*)\t\ttarg_emul=elf32rl78\n+\t\t\t;;\n+rx-*-*)\t\t\ttarg_emul=elf32rx\n \t\t\t;;\n-rl78-*-*)\t\ttarg_emul=elf32rl78 ;;\n-rx-*-*)\t\t\ttarg_emul=elf32rx ;;\n s390x-*-linux*)\t\ttarg_emul=elf64_s390\n \t\t\ttarg_extra_emuls=elf_s390\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n-\t\t\ttdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'` ;;\n+\t\t\ttdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'`\n+\t\t\t;;\n s390x-*-tpf*)\t\ttarg_emul=elf64_s390\n-\t\t\ttdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'` ;;\n+\t\t\ttdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'`\n+\t\t\t;;\n s390-*-linux*)\t\ttarg_emul=elf_s390\n \t\t\ttarg64_extra_emuls=elf64_s390\n \t\t\ttarg64_extra_libpath=elf64_s390\n \t\t\ttdir_elf64_s390=`echo ${targ_alias} | sed -e 's/s390/s390x/'`\n \t\t\t;;\n score-*-elf)\t\ttarg_emul=score7_elf\n-\t\t\ttarg_extra_emuls=score3_elf ;;\n+\t\t\ttarg_extra_emuls=score3_elf\n+\t\t\t;;\n sh-*-linux*)\t\ttarg_emul=shlelf_linux\n \t\t\ttarg_extra_emuls=\"shelf_linux shlelf_fd shelf_fd\"\n-\t\t\ttarg_extra_libpath=shelf_linux ;;\n+\t\t\ttarg_extra_libpath=shelf_linux\n+\t\t\t;;\n sh*eb-*-linux*)\t\ttarg_emul=shelf_linux\n-\t\t\ttarg_extra_emuls=\"shelf_fd\" ;;\n+\t\t\ttarg_extra_emuls=\"shelf_fd\"\n+\t\t\t;;\n sh*-*-linux*)\t\ttarg_emul=shlelf_linux\n-\t\t\ttarg_extra_emuls=\"shlelf_fd\" ;;\n+\t\t\ttarg_extra_emuls=\"shlelf_fd\"\n+\t\t\t;;\n sh*l*-*-netbsdelf*)\ttarg_emul=shlelf_nbsd\n-\t\t\ttarg_extra_emuls=shelf_nbsd ;;\n+\t\t\ttarg_extra_emuls=shelf_nbsd\n+\t\t\t;;\n sh*-*-netbsdelf*)\ttarg_emul=shelf_nbsd\n-\t\t\ttarg_extra_emuls=shlelf_nbsd ;;\n+\t\t\ttarg_extra_emuls=shlelf_nbsd\n+\t\t\t;;\n shle*-*-elf* | sh[1234]*le*-*-elf | shle*-*-kaos*)\n \t\t\ttarg_emul=shlelf\n-\t\t\ttarg_extra_emuls=\"shelf shl sh\"\t;;\n+\t\t\ttarg_extra_emuls=\"shelf shl sh\"\n+\t\t\t;;\n sh-*-elf* | sh[1234]*-*-elf | sh-*-rtems* | sh-*-kaos*)\n \t\t\ttarg_emul=shelf\n-\t\t\ttarg_extra_emuls=\"shlelf sh shl\" ;;\n+\t\t\ttarg_extra_emuls=\"shlelf sh shl\"\n+\t\t\t;;\n sh-*-uclinux* | sh[12]-*-uclinux*)\n \t\t\ttarg_emul=shelf_uclinux\n-\t\t\ttarg_extra_emuls=\"shelf shlelf sh shl shelf_fd shlelf_fd\" ;;\n+\t\t\ttarg_extra_emuls=\"shelf shlelf sh shl shelf_fd shlelf_fd\"\n+\t\t\t;;\n sh-*-vxworks)\t\ttarg_emul=shelf_vxworks\n-\t\t\ttarg_extra_emuls=shlelf_vxworks ;;\n+\t\t\ttarg_extra_emuls=shlelf_vxworks\n+\t\t\t;;\n sh-*-nto*)\t\ttarg_emul=shelf_nto\n-\t\t\ttarg_extra_emuls=shlelf_nto ;;\n+\t\t\ttarg_extra_emuls=shlelf_nto\n+\t\t\t;;\n sh-*-pe)\t\ttarg_emul=shpe ;\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\" ;;\n-sh-*-*)\t\t\ttarg_emul=sh; targ_extra_emuls=shl ;;\n+\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n+\t\t\t;;\n+sh-*-*)\t\t\ttarg_emul=sh;\n+\t\t\ttarg_extra_emuls=shl\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n sparc64-*-freebsd* | sparcv9-*-freebsd* | sparc64-*-kfreebsd*-gnu | sparcv9-*-kfreebsd*-gnu)\n \t\t\ttarg_emul=elf64_sparc_fbsd\n \t\t\ttarg_extra_emuls=\"elf64_sparc elf32_sparc\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n-\t\t\ttdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`\t;;\n+\t\t\ttdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`\n+\t\t\t;;\n sparc64-*-linux-*)\ttarg_emul=elf64_sparc\n \t\t\ttarg_extra_emuls=\"elf32_sparc\"\n \t\t\ttarg_extra_libpath=elf32_sparc\n-\t\t\ttdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'` ;;\n+\t\t\ttdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`\n+\t\t\t;;\n sparc64-*-*bsd*)\ttarg_emul=elf64_sparc\n-\t\t\ttarg_extra_emuls=\"elf32_sparc\" ;;\n+\t\t\ttarg_extra_emuls=\"elf32_sparc\"\n+\t\t\t;;\n sparc64-*-solaris2* | sparcv9-*-solaris2*)\n \t\t\ttarg_emul=elf64_sparc_sol2\n \t\t\ttarg_extra_emuls=\"elf64_sparc elf32_sparc_sol2 elf32_sparc\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n-\t\t\ttdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'` ;;\n-sparc64-*-*)\t\ttarg_emul=elf64_sparc ;;\n+\t\t\ttdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`\n+\t\t\t;;\n+sparc64-*-*)\t\ttarg_emul=elf64_sparc\n+\t\t\t;;\n sparc*-*-linux-*)\ttarg_emul=elf32_sparc\n \t\t\ttarg_extra_emuls=\"elf64_sparc\"\n \t\t\ttarg_extra_libpath=elf64_sparc\n-\t\t\ttdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'` ;;\n+\t\t\ttdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`\n+\t\t\t;;\n sparc-*-solaris2.[0-6] | sparc-*-solaris2.[0-6].*)\n \t\t\ttarg_emul=elf32_sparc_sol2\n-\t\t\ttarg_extra_emuls=elf32_sparc ;;\n+\t\t\ttarg_extra_emuls=elf32_sparc\n+\t\t\t;;\n sparc-*-solaris2*)\ttarg_emul=elf32_sparc_sol2\n \t\t\ttarg_extra_emuls=\"elf32_sparc elf64_sparc_sol2 elf64_sparc\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n-\t\t\ttdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`\t;;\n-sparc*-*-vxworks*)\ttarg_emul=elf32_sparc_vxworks ;;\n-sparc*-*-*)\t\ttarg_emul=elf32_sparc ;;\n-spu-*-elf*)\t\ttarg_emul=elf32_spu ;;\n-tic30-*-*aout*)\t\ttarg_emul=tic30aout ;;\n-tic30-*-*coff*)\t\ttarg_emul=tic30coff ;;\n-tic4x-*-* | c4x-*-*)\ttarg_emul=tic4xcoff ; targ_extra_emuls=\"tic3xcoff tic3xcoff_onchip\" ;;\n-tic54x-*-* | c54x*-*-*)\ttarg_emul=tic54xcoff ;;\n+\t\t\ttdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`\n+\t\t\t;;\n+sparc*-*-vxworks*)\ttarg_emul=elf32_sparc_vxworks\n+\t\t\t;;\n+sparc*-*-*)\t\ttarg_emul=elf32_sparc\n+\t\t\t;;\n+spu-*-elf*)\t\ttarg_emul=elf32_spu\n+\t\t\t;;\n+tic30-*-*aout*)\t\ttarg_emul=tic30aout\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+tic30-*-*coff*)\t\ttarg_emul=tic30coff\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+tic4x-*-* | c4x-*-*)\ttarg_emul=tic4xcoff\n+\t\t\ttarg_extra_emuls=\"tic3xcoff tic3xcoff_onchip\"\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n+tic54x-*-* | c54x*-*-*)\ttarg_emul=tic54xcoff\n+\t\t\ttarg_extra_ofiles=\n+\t\t\t;;\n tic6x-*-elf)\t\ttarg_emul=elf32_tic6x_elf_le\n \t\t\ttarg_extra_emuls=\"elf32_tic6x_elf_be elf32_tic6x_le elf32_tic6x_be\"\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n@@ -735,24 +982,31 @@ tic6x-*-uclinux)\ttarg_emul=elf32_tic6x_linux_le\n \t\t\ttarg_extra_libpath=$targ_extra_emuls\n \t\t\t;;\n tic80-*-*)\t\ttarg_emul=tic80coff\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n tilegx-*-*)\t\ttarg_emul=elf64tilegx\n \t\t\ttarg_extra_emuls=\"elf64tilegx_be elf32tilegx elf32tilegx_be\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n tilegxbe-*-*)\t\ttarg_emul=elf64tilegx_be\n \t\t\ttarg_extra_emuls=\"elf64tilegx elf32tilegx elf32tilegx_be\"\n-\t\t\ttarg_extra_libpath=$targ_extra_emuls ;;\n-tilepro-*-*)\t\ttarg_emul=elf32tilepro ;;\n+\t\t\ttarg_extra_libpath=$targ_extra_emuls\n+\t\t\t;;\n+tilepro-*-*)\t\ttarg_emul=elf32tilepro\n+\t\t\t;;\n ft32-*-*)\t\ttarg_emul=elf32ft32\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n v850*-*-*)\t\ttarg_emul=v850_rh850\n \t\t\ttarg_extra_emuls=v850\n \t\t\t;;\n vax-*-netbsdelf*)\ttarg_emul=elf32vax\n-\t\t\ttarg_extra_emuls=vaxnbsd ;;\n+\t\t\ttarg_extra_emuls=vaxnbsd\n+\t\t\t;;\n vax-*-netbsdaout* | vax-*-netbsd*)\n \t\t\ttarg_emul=vaxnbsd\n-\t\t\ttarg_extra_emuls=elf32vax ;;\n+\t\t\ttarg_extra_emuls=elf32vax\n+\t\t\t;;\n vax-*-linux-*)\t\ttarg_emul=elf32vax\n \t\t\t;;\n visium-*-elf)\t\ttarg_emul=elf32visium\n@@ -765,12 +1019,17 @@ xstormy16-*-*)\t\ttarg_emul=elf32xstormy16\n xtensa*-*-*)\t\ttarg_emul=elf32xtensa\n \t\t\t;;\n xgate-*-*)\t\ttarg_emul=xgateelf\n+\t\t\ttarg_extra_ofiles=ldelfgen.o\n \t\t\t;;\n z80-*-coff)\t\ttarg_emul=z80\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n-z8k-*-coff)\t\ttarg_emul=z8002; targ_extra_emuls=z8001\n+z8k-*-coff)\t\ttarg_emul=z8002\n+\t\t\ttarg_extra_emuls=z8001\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n *-*-ieee*)\t\ttarg_emul=vanilla\n+\t\t\ttarg_extra_ofiles=\n \t\t\t;;\n *)\n   echo 2>&1 \"*** ld does not support target ${targ}\""
    },
    {
      "sha": "022de0834e3cb0c520ad441eb0f3b4a821e27631",
      "filename": "ld/emultempl/aarch64elf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 22,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/aarch64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/aarch64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/aarch64elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -206,7 +206,7 @@ gldaarch64_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n   need_laying_out = -1;\n }\n \n@@ -275,7 +275,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n \n   if (need_laying_out != -1)\n-    gld${EMULATION_NAME}_map_segments (need_laying_out);\n+    ldelf_map_segments (need_laying_out);\n }\n \n static void\n@@ -339,26 +339,6 @@ aarch64_elf_create_output_section_statements (void)\n   ldlang_add_file (stub_file);\n }\n \n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void aarch64_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-aarch64_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&aarch64_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file aarch64_lang_for_each_input_file\n-\n EOF\n \n # Define some shell vars to insert bits of code into the standard elf"
    },
    {
      "sha": "fbee01f519fae99c54e15daffc8bde5331bb4d28",
      "filename": "ld/emultempl/alphaelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/alphaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/alphaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/alphaelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -82,7 +82,7 @@ alpha_after_parse (void)\n \t\t\t\t   exp_nameop (SIZEOF_HEADERS, NULL)),\n \t\t\tNULL);\n \n-  gld${EMULATION_NAME}_after_parse ();\n+  ldelf_after_parse ();\n }\n \n static void"
    },
    {
      "sha": "29972f14fd735d537414296350cd02a0accb284c",
      "filename": "ld/emultempl/armelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 22,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/armelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/armelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/armelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -276,7 +276,7 @@ gldarm_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n   need_laying_out = -1;\n }\n \n@@ -413,7 +413,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n \n   if (need_laying_out != -1)\n-    gld${EMULATION_NAME}_map_segments (need_laying_out);\n+    ldelf_map_segments (need_laying_out);\n }\n \n static void\n@@ -553,26 +553,6 @@ arm_elf_create_output_section_statements (void)\n   bfd_elf32_arm_get_bfd_for_interworking (stub_file->the_bfd, &link_info);\n }\n \n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void arm_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-arm_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&arm_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file arm_lang_for_each_input_file\n-\n EOF\n \n # Define some shell vars to insert bits of code into the standard elf"
    },
    {
      "sha": "6f97d41b7c41c87820d59541427267d8ad22c77d",
      "filename": "ld/emultempl/cr16elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/cr16elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/cr16elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cr16elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -120,7 +120,7 @@ cr16elf_after_parse (void)\n      is true the link sometimes fails.  */\n   config.magic_demand_paged = FALSE;\n \n-  gld${EMULATION_NAME}_after_parse ();\n+  ldelf_after_parse ();\n }\n \n /* This is called after the sections have been attached to output"
    },
    {
      "sha": "22bacde2ce29a01a1f1e97c4d5f4ccc7c9f91541",
      "filename": "ld/emultempl/crxelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/crxelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/crxelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/crxelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -26,8 +26,6 @@ fragment <<EOF\n \n #include \"ldctor.h\"\n \n-static void crxelf_after_parse (void);\n-\n static void\n crxelf_after_parse (void)\n {\n@@ -42,7 +40,7 @@ crxelf_after_parse (void)\n      is true the link sometimes fails.  */\n   config.magic_demand_paged = FALSE;\n \n-  gld${EMULATION_NAME}_after_parse ();\n+  ldelf_after_parse ();\n }\n \n /* This is called after the sections have been attached to output"
    },
    {
      "sha": "aaddd9c146c76aaf60a863271b2f5b6383172a93",
      "filename": "ld/emultempl/cskyelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 22,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/cskyelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/cskyelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cskyelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -208,7 +208,7 @@ gldcsky_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n   need_laying_out = -1;\n }\n \n@@ -269,7 +269,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n \n   if (need_laying_out != -1)\n-    gld${EMULATION_NAME}_map_segments (need_laying_out);\n+    ldelf_map_segments (need_laying_out);\n }\n \n static void\n@@ -283,26 +283,6 @@ gld${EMULATION_NAME}_finish (void)\n   finish_default ();\n }\n \n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void csky_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-csky_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&csky_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file csky_lang_for_each_input_file\n-\n EOF\n \n # This code gets inserted into the generic elf32.sc linker script"
    },
    {
      "sha": "8392ceac23660ea3b75de5c7b2173623c62ba01f",
      "filename": "ld/emultempl/elf-generic.em",
      "status": "modified",
      "additions": 0,
      "deletions": 44,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/elf-generic.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/elf-generic.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/elf-generic.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -24,48 +24,4 @@\n #\n fragment <<EOF\n \n-static void\n-gld${EMULATION_NAME}_map_segments (bfd_boolean need_layout)\n-{\n-  int tries = 10;\n-\n-  do\n-    {\n-      lang_relax_sections (need_layout);\n-      need_layout = FALSE;\n-\n-      if (link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour\n-\t  && !bfd_link_relocatable (&link_info))\n-\t{\n-\t  bfd_size_type phdr_size;\n-\n-\t  phdr_size = elf_program_header_size (link_info.output_bfd);\n-\t  /* If we don't have user supplied phdrs, throw away any\n-\t     previous linker generated program headers.  */\n-\t  if (lang_phdr_list == NULL)\n-\t    elf_seg_map (link_info.output_bfd) = NULL;\n-\t  if (!_bfd_elf_map_sections_to_segments (link_info.output_bfd,\n-\t\t\t\t\t\t  &link_info))\n-\t    einfo (_(\"%F%P: map sections to segments failed: %E\\n\"));\n-\n-\t  if (phdr_size != elf_program_header_size (link_info.output_bfd))\n-\t    {\n-\t      if (tries > 6)\n-\t\t/* The first few times we allow any change to\n-\t\t   phdr_size .  */\n-\t\tneed_layout = TRUE;\n-\t      else if (phdr_size\n-\t\t       < elf_program_header_size (link_info.output_bfd))\n-\t\t/* After that we only allow the size to grow.  */\n-\t\tneed_layout = TRUE;\n-\t      else\n-\t\telf_program_header_size (link_info.output_bfd) = phdr_size;\n-\t    }\n-\t}\n-    }\n-  while (need_layout && --tries);\n-\n-  if (tries == 0)\n-    einfo (_(\"%F%P: looping in map_segments\"));\n-}\n EOF"
    },
    {
      "sha": "5a3cc2fdcaac0a56140b60336b322a16d8ebbb68",
      "filename": "ld/emultempl/elf32.em",
      "status": "modified",
      "additions": 43,
      "deletions": 2216,
      "changes": 2259,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/elf32.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/elf32.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/elf32.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -38,47 +38,26 @@ fragment <<EOF\n #include \"sysdep.h\"\n #include \"bfd.h\"\n #include \"libiberty.h\"\n-#include \"safe-ctype.h\"\n-#include \"filenames.h\"\n #include \"getopt.h\"\n-#include <fcntl.h>\n-\n #include \"bfdlink.h\"\n-\n #include \"ld.h\"\n #include \"ldmain.h\"\n #include \"ldmisc.h\"\n #include \"ldexp.h\"\n #include \"ldlang.h\"\n #include \"ldfile.h\"\n #include \"ldemul.h\"\n-#include \"ldbuildid.h\"\n #include <ldgram.h>\n-#include \"elf/common.h\"\n #include \"elf-bfd.h\"\n-#include \"filenames.h\"\n+#include \"ldelf.h\"\n+#include \"ldelfgen.h\"\n \n /* Declare functions used by various EXTRA_EM_FILEs.  */\n static void gld${EMULATION_NAME}_before_parse (void);\n-static void gld${EMULATION_NAME}_after_parse (void);\n static void gld${EMULATION_NAME}_after_open (void);\n static void gld${EMULATION_NAME}_before_allocation (void);\n static void gld${EMULATION_NAME}_after_allocation (void);\n-static lang_output_section_statement_type *gld${EMULATION_NAME}_place_orphan\n-  (asection *, const char *, int);\n-EOF\n-\n-if [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-  case ${target} in\n-    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)\n-  fragment <<EOF\n-#ifdef HAVE_GLOB\n-#include <glob.h>\n-#endif\n EOF\n-    ;;\n-  esac\n-fi\n \n # Import any needed special functions and/or overrides.\n #\n@@ -111,2215 +90,63 @@ gld${EMULATION_NAME}_before_parse (void)\n EOF\n fi\n \n-if test x\"$LDEMUL_AFTER_PARSE\" != xgld\"$EMULATION_NAME\"_after_parse; then\n-fragment <<EOF\n-\n-static void\n-gld${EMULATION_NAME}_after_parse (void)\n-{\n-  if (bfd_link_pie (&link_info))\n-    link_info.flags_1 |= (bfd_vma) DF_1_PIE;\n-\n-  if (bfd_link_executable (&link_info)\n-      && link_info.nointerp)\n-    {\n-      if (link_info.dynamic_undefined_weak > 0)\n-\teinfo (_(\"%P: warning: -z dynamic-undefined-weak ignored\\n\"));\n-      link_info.dynamic_undefined_weak = 0;\n-    }\n-  after_parse_default ();\n-}\n-\n-EOF\n-fi\n-\n-if test x\"$LDEMUL_RECOGNIZED_FILE\" != xgld\"${EMULATION_NAME}\"_load_symbols; then\n-fragment <<EOF\n-/* Handle the generation of DT_NEEDED tags.  */\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *entry)\n-{\n-  int link_class = 0;\n-\n-  /* Tell the ELF linker that we don't want the output file to have a\n-     DT_NEEDED entry for this file, unless it is used to resolve\n-     references in a regular object.  */\n-  if (entry->flags.add_DT_NEEDED_for_regular)\n-    link_class = DYN_AS_NEEDED;\n-\n-  /* Tell the ELF linker that we don't want the output file to have a\n-     DT_NEEDED entry for any dynamic library in DT_NEEDED tags from\n-     this file at all.  */\n-  if (!entry->flags.add_DT_NEEDED_for_dynamic)\n-    link_class |= DYN_NO_ADD_NEEDED;\n-\n-  if (entry->flags.just_syms\n-      && (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) != 0)\n-    einfo (_(\"%F%P: %pB: --just-symbols may not be used on DSO\\n\"),\n-\t   entry->the_bfd);\n-\n-  if (link_class == 0\n-      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)\n-    return FALSE;\n-\n-  bfd_elf_set_dyn_lib_class (entry->the_bfd,\n-\t\t\t     (enum dynamic_lib_link_class) link_class);\n-\n-  /* Continue on with normal load_symbols processing.  */\n-  return FALSE;\n-}\n-EOF\n-fi\n-\n fragment <<EOF\n \n-/* These variables are required to pass information back and forth\n-   between after_open and check_needed and stat_needed and vercheck.  */\n-\n-static struct bfd_link_needed_list *global_needed;\n-static struct stat global_stat;\n-static lang_input_statement_type *global_found;\n-static struct bfd_link_needed_list *global_vercheck_needed;\n-static bfd_boolean global_vercheck_failed;\n-\n /* These variables are used to implement target options */\n \n static char *audit; /* colon (typically) separated list of libs */\n static char *depaudit; /* colon (typically) separated list of libs */\n \n-/* Style of .note.gnu.build-id section.  */\n-static const char *emit_note_gnu_build_id;\n-\n-/* On Linux, it's possible to have different versions of the same\n-   shared library linked against different versions of libc.  The\n-   dynamic linker somehow tags which libc version to use in\n-   /etc/ld.so.cache, and, based on the libc that it sees in the\n-   executable, chooses which version of the shared library to use.\n-\n-   We try to do a similar check here by checking whether this shared\n-   library needs any other shared libraries which may conflict with\n-   libraries we have already included in the link.  If it does, we\n-   skip it, and try to find another shared library farther on down the\n-   link path.\n-\n-   This is called via lang_for_each_input_file.\n-   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object\n-   which we are checking.  This sets GLOBAL_VERCHECK_FAILED if we find\n-   a conflicting version.  */\n-\n-static void\n-gld${EMULATION_NAME}_vercheck (lang_input_statement_type *s)\n-{\n-  const char *soname;\n-  struct bfd_link_needed_list *l;\n-\n-  if (global_vercheck_failed)\n-    return;\n-  if (s->the_bfd == NULL\n-      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)\n-    return;\n-\n-  soname = bfd_elf_get_dt_soname (s->the_bfd);\n-  if (soname == NULL)\n-    soname = lbasename (bfd_get_filename (s->the_bfd));\n-\n-  for (l = global_vercheck_needed; l != NULL; l = l->next)\n-    {\n-      const char *suffix;\n-\n-      if (filename_cmp (soname, l->name) == 0)\n-\t{\n-\t  /* Probably can't happen, but it's an easy check.  */\n-\t  continue;\n-\t}\n-\n-      if (strchr (l->name, '/') != NULL)\n-\tcontinue;\n-\n-      suffix = strstr (l->name, \".so.\");\n-      if (suffix == NULL)\n-\tcontinue;\n-\n-      suffix += sizeof \".so.\" - 1;\n-\n-      if (filename_ncmp (soname, l->name, suffix - l->name) == 0)\n-\t{\n-\t  /* Here we know that S is a dynamic object FOO.SO.VER1, and\n-\t     the object we are considering needs a dynamic object\n-\t     FOO.SO.VER2, and VER1 and VER2 are different.  This\n-\t     appears to be a version mismatch, so we tell the caller\n-\t     to try a different version of this library.  */\n-\t  global_vercheck_failed = TRUE;\n-\t  return;\n-\t}\n-    }\n-}\n-\n-\n-/* See if an input file matches a DT_NEEDED entry by running stat on\n-   the file.  */\n-\n-static void\n-gld${EMULATION_NAME}_stat_needed (lang_input_statement_type *s)\n-{\n-  struct stat st;\n-  const char *suffix;\n-  const char *soname;\n-\n-  if (global_found != NULL)\n-    return;\n-  if (s->the_bfd == NULL)\n-    return;\n-\n-  /* If this input file was an as-needed entry, and wasn't found to be\n-     needed at the stage it was linked, then don't say we have loaded it.  */\n-  if ((bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)\n-    return;\n-\n-  if (bfd_stat (s->the_bfd, &st) != 0)\n-    {\n-      einfo (_(\"%P: %pB: bfd_stat failed: %E\\n\"), s->the_bfd);\n-      return;\n-    }\n-\n-  /* Some operating systems, e.g. Windows, do not provide a meaningful\n-     st_ino; they always set it to zero.  (Windows does provide a\n-     meaningful st_dev.)  Do not indicate a duplicate library in that\n-     case.  While there is no guarantee that a system that provides\n-     meaningful inode numbers will never set st_ino to zero, this is\n-     merely an optimization, so we do not need to worry about false\n-     negatives.  */\n-  if (st.st_dev == global_stat.st_dev\n-      && st.st_ino == global_stat.st_ino\n-      && st.st_ino != 0)\n-    {\n-      global_found = s;\n-      return;\n-    }\n-\n-  /* We issue a warning if it looks like we are including two\n-     different versions of the same shared library.  For example,\n-     there may be a problem if -lc picks up libc.so.6 but some other\n-     shared library has a DT_NEEDED entry of libc.so.5.  This is a\n-     heuristic test, and it will only work if the name looks like\n-     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.\n-     If we really want to issue warnings about mixing version numbers\n-     of shared libraries, we need to find a better way.  */\n-\n-  if (strchr (global_needed->name, '/') != NULL)\n-    return;\n-  suffix = strstr (global_needed->name, \".so.\");\n-  if (suffix == NULL)\n-    return;\n-  suffix += sizeof \".so.\" - 1;\n-\n-  soname = bfd_elf_get_dt_soname (s->the_bfd);\n-  if (soname == NULL)\n-    soname = lbasename (s->filename);\n-\n-  if (filename_ncmp (soname, global_needed->name, suffix - global_needed->name) == 0)\n-    einfo (_(\"%P: warning: %s, needed by %pB, may conflict with %s\\n\"),\n-\t   global_needed->name, global_needed->by, soname);\n-}\n-\n-struct dt_needed\n-{\n-  bfd *by;\n-  const char *name;\n-};\n-\n-/* This function is called for each possible name for a dynamic object\n-   named by a DT_NEEDED entry.  The FORCE parameter indicates whether\n-   to skip the check for a conflicting version.  */\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_try_needed (struct dt_needed *needed,\n-\t\t\t\t int force)\n-{\n-  bfd *abfd;\n-  const char *name = needed->name;\n-  const char *soname;\n-  int link_class;\n-\n-  abfd = bfd_openr (name, bfd_get_target (link_info.output_bfd));\n-  if (abfd == NULL)\n-    {\n-      if (verbose)\n-\tinfo_msg (_(\"attempt to open %s failed\\n\"), name);\n-      return FALSE;\n-    }\n-\n-  /* Linker needs to decompress sections.  */\n-  abfd->flags |= BFD_DECOMPRESS;\n-\n-  if (! bfd_check_format (abfd, bfd_object))\n-    {\n-      bfd_close (abfd);\n-      return FALSE;\n-    }\n-  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)\n-    {\n-      bfd_close (abfd);\n-      return FALSE;\n-    }\n-\n-  /* For DT_NEEDED, they have to match.  */\n-  if (abfd->xvec != link_info.output_bfd->xvec)\n-    {\n-      bfd_close (abfd);\n-      return FALSE;\n-    }\n-\n-  /* Check whether this object would include any conflicting library\n-     versions.  If FORCE is set, then we skip this check; we use this\n-     the second time around, if we couldn't find any compatible\n-     instance of the shared library.  */\n-\n-  if (! force)\n-    {\n-      struct bfd_link_needed_list *needs;\n-\n-      if (! bfd_elf_get_bfd_needed_list (abfd, &needs))\n-\teinfo (_(\"%F%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\\n\"), abfd);\n-\n-      if (needs != NULL)\n-\t{\n-\t  global_vercheck_needed = needs;\n-\t  global_vercheck_failed = FALSE;\n-\t  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);\n-\t  if (global_vercheck_failed)\n-\t    {\n-\t      bfd_close (abfd);\n-\t      /* Return FALSE to force the caller to move on to try\n-\t\t another file on the search path.  */\n-\t      return FALSE;\n-\t    }\n-\n-\t  /* But wait!  It gets much worse.  On Linux, if a shared\n-\t     library does not use libc at all, we are supposed to skip\n-\t     it the first time around in case we encounter a shared\n-\t     library later on with the same name which does use the\n-\t     version of libc that we want.  This is much too horrible\n-\t     to use on any system other than Linux.  */\n-\n-EOF\n-case ${target} in\n-  *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)\n-    fragment <<EOF\n-\t  {\n-\t    struct bfd_link_needed_list *l;\n-\n-\t    for (l = needs; l != NULL; l = l->next)\n-\t      if (CONST_STRNEQ (l->name, \"libc.so\"))\n-\t\tbreak;\n-\t    if (l == NULL)\n-\t      {\n-\t\tbfd_close (abfd);\n-\t\treturn FALSE;\n-\t      }\n-\t  }\n-\n-EOF\n-    ;;\n-esac\n-fragment <<EOF\n-\t}\n-    }\n-\n-  /* We've found a dynamic object matching the DT_NEEDED entry.  */\n-\n-  /* We have already checked that there is no other input file of the\n-     same name.  We must now check again that we are not including the\n-     same file twice.  We need to do this because on many systems\n-     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will\n-     reference libc.so.1.  If we have already included libc.so, we\n-     don't want to include libc.so.1 if they are the same file, and we\n-     can only check that using stat.  */\n-\n-  if (bfd_stat (abfd, &global_stat) != 0)\n-    einfo (_(\"%F%P: %pB: bfd_stat failed: %E\\n\"), abfd);\n-\n-  /* First strip off everything before the last '/'.  */\n-  soname = lbasename (abfd->filename);\n-\n-  if (verbose)\n-    info_msg (_(\"found %s at %s\\n\"), soname, name);\n-\n-  global_found = NULL;\n-  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);\n-  if (global_found != NULL)\n-    {\n-      /* Return TRUE to indicate that we found the file, even though\n-\t we aren't going to do anything with it.  */\n-      return TRUE;\n-    }\n-\n-  /* Specify the soname to use.  */\n-  bfd_elf_set_dt_needed_name (abfd, soname);\n-\n-  /* Tell the ELF linker that we don't want the output file to have a\n-     DT_NEEDED entry for this file, unless it is used to resolve\n-     references in a regular object.  */\n-  link_class = DYN_DT_NEEDED;\n-\n-  /* Tell the ELF linker that we don't want the output file to have a\n-     DT_NEEDED entry for this file at all if the entry is from a file\n-     with DYN_NO_ADD_NEEDED.  */\n-  if (needed->by != NULL\n-      && (bfd_elf_get_dyn_lib_class (needed->by) & DYN_NO_ADD_NEEDED) != 0)\n-    link_class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;\n-\n-  bfd_elf_set_dyn_lib_class (abfd, (enum dynamic_lib_link_class) link_class);\n-\n-  /* Add this file into the symbol table.  */\n-  if (! bfd_link_add_symbols (abfd, &link_info))\n-    einfo (_(\"%F%P: %pB: error adding symbols: %E\\n\"), abfd);\n-\n-  return TRUE;\n-}\n-\n-/* Search for a needed file in a path.  */\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_search_needed (const char *path,\n-\t\t\t\t    struct dt_needed *n, int force)\n-{\n-  const char *s;\n-  const char *name = n->name;\n-  size_t len;\n-  struct dt_needed needed;\n-\n-  if (name[0] == '/')\n-    return gld${EMULATION_NAME}_try_needed (n, force);\n-\n-  if (path == NULL || *path == '\\0')\n-    return FALSE;\n-\n-  needed.by = n->by;\n-  needed.name = n->name;\n-\n-  len = strlen (name);\n-  while (1)\n-    {\n-      unsigned offset = 0;\n-      char * var;\n-      char *filename, *sset;\n-\n-      s = strchr (path, config.rpath_separator);\n-      if (s == NULL)\n-\ts = path + strlen (path);\n-\n-#if HAVE_DOS_BASED_FILE_SYSTEM\n-      /* Assume a match on the second char is part of drive specifier.  */\n-      else if (config.rpath_separator == ':'\n-\t       && s == path + 1\n-\t       && ISALPHA (*path))\n-\t{\n-\t  s = strchr (s + 1, config.rpath_separator);\n-\t  if (s == NULL)\n-\t    s = path + strlen (path);\n-\t}\n-#endif\n-      filename = (char *) xmalloc (s - path + len + 2);\n-      if (s == path)\n-\tsset = filename;\n-      else\n-\t{\n-\t  memcpy (filename, path, s - path);\n-\t  filename[s - path] = '/';\n-\t  sset = filename + (s - path) + 1;\n-\t}\n-      strcpy (sset, name);\n-\n-      /* PR 20535: Support the same pseudo-environment variables that\n-\t are supported by ld.so.  Namely, $ORIGIN, $LIB and $PLATFORM.\n-\t Since there can be more than one occurrence of these tokens in\n-\t the path we loop until no more are found.  Since we might not\n-\t be able to substitute some of the tokens we maintain an offset\n-\t into the filename for where we should begin our scan.  */\n-      while ((var = strchr (filename + offset, '$')) != NULL)\n-\t{\n-\t  /* The ld.so manual page does not say, but I am going to assume that\n-\t     these tokens are terminated by a directory separator character\n-\t     (/) or the end of the string.  There is also an implication that\n-\t     $ORIGIN should only be used at the start of a path, but that is\n-\t     not enforced here.\n-\n-\t     The ld.so manual page also states that it allows ${ORIGIN},\n-\t     ${LIB} and ${PLATFORM}, so these are supported as well.\n-\n-\t     FIXME: The code could be a lot cleverer about allocating space\n-\t     for the processed string.  */\n-\t  char *    end = strchr (var, '/');\n-\t  const char *replacement = NULL;\n-\t  char *    v = var + 1;\n-\t  char *    freeme = NULL;\n-\t  unsigned  flen = strlen (filename);\n-\n-\t  if (end != NULL)\n-\t    /* Temporarily terminate the filename at the end of the token.  */\n-\t    * end = 0;\n-\n-\t  if (*v == '{')\n-\t    ++ v;\n-\t  switch (*v++)\n-\t    {\n-\t    case 'O':\n-\t      if (strcmp (v, \"RIGIN\") == 0 || strcmp (v, \"RIGIN}\") == 0)\n-\t\t{\n-\t\t  /* ORIGIN - replace with the full path to the directory\n-\t\t     containing the program or shared object.  */\n-\t\t  if (needed.by == NULL)\n-\t\t    {\n-\t\t      if (link_info.output_bfd == NULL)\n-\t\t\t{\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      else\n-\t\t\treplacement = bfd_get_filename (link_info.output_bfd);\n-\t\t    }\n-\t\t  else\n-\t\t    replacement = bfd_get_filename (needed.by);\n-\n-\t\t  if (replacement)\n-\t\t    {\n-\t\t      char * slash;\n-\n-\t\t      if (replacement[0] == '/')\n-\t\t\tfreeme = xstrdup (replacement);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  char * current_dir = getpwd ();\n-\n-\t\t\t  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);\n-\t\t\t  sprintf (freeme, \"%s/%s\", current_dir, replacement);\n-\t\t\t}\n-\n-\t\t      replacement = freeme;\n-\t\t      if ((slash = strrchr (replacement, '/')) != NULL)\n-\t\t\t* slash = 0;\n-\t\t    }\n-\t\t}\n-\t      break;\n-\n-\t    case 'L':\n-\t      if (strcmp (v, \"IB\") == 0 || strcmp (v, \"IB}\") == 0)\n-\t\t{\n-\t\t  /* LIB - replace with \"lib\" in 32-bit environments\n-\t\t     and \"lib64\" in 64-bit environments.  */\n-\n-\t\t  /* Note - we could replace this switch statement by\n-\t\t     conditional fragments of shell script, but that is messy.\n-\t\t     Any compiler worth its salt is going to optimize away\n-\t\t     all but one of these case statements anyway.  */\n-\t\t  switch ($ELFSIZE)\n-\t\t    {\n-\t\t    case 32: replacement = \"lib\"; break;\n-\t\t    case 64: replacement = \"lib64\"; break;\n-\t\t    default:\n-\t\t      /* $ELFSIZE is not 32 or 64 ...  */\n-\t\t      abort ();\n-\t\t    }\n-\t\t}\n-\t      break;\n-\n-\t    case 'P':\n-\t      /* Supporting $PLATFORM in a cross-hosted environment is not\n-\t\t possible.  Supporting it in a native environment involves\n-\t\t loading the <sys/auxv.h> header file which loads the\n-\t\t system <elf.h> header file, which conflicts with the\n-\t\t \"include/elf/mips.h\" header file.  */\n-\t      /* Fall through.  */\n-\t    default:\n-\t      break;\n-\t    }\n-\n-\t  if (replacement)\n-\t    {\n-\t      char * filename2 = xmalloc (flen + strlen (replacement));\n-\n-\t      if (end)\n-\t\t{\n-\t\t  sprintf (filename2, \"%.*s%s/%s\",\n-\t\t\t   (int)(var - filename), filename,\n-\t\t\t   replacement, end + 1);\n-\t\t  offset = (var - filename) + 1 + strlen (replacement);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  sprintf (filename2, \"%.*s%s\",\n-\t\t\t   (int)(var - filename), filename,\n-\t\t\t   replacement);\n-\t\t  offset = var - filename + strlen (replacement);\n-\t\t}\n-\n-\t      free (filename);\n-\t      filename = filename2;\n-\t      /* There is no need to restore the path separator (when\n-\t\t end != NULL) as we have replaced the entire string.  */\n-\t    }\n-\t  else\n-\t    {\n-\t      if (verbose)\n-\t\t/* We only issue an \"unrecognised\" message in verbose mode\n-\t\t   as the $<foo> token might be a legitimate component of\n-\t\t   a path name in the target's file system.  */\n-\t\tinfo_msg (_(\"unrecognised or unsupported token '%s' in search path\\n\"), var);\n-\n-\t      if (end)\n-\t\t/* Restore the path separator.  */\n-\t\t* end = '/';\n-\n-\t      /* PR 20784: Make sure that we resume the scan *after*\n-\t\t the token that we could not replace.  */\n-\t      offset = (var + 1) - filename;\n-\t    }\n-\n-\t  free (freeme);\n-\t}\n-\n-      needed.name = filename;\n-\n-      if (gld${EMULATION_NAME}_try_needed (&needed, force))\n-\treturn TRUE;\n-\n-      free (filename);\n-\n-      if (*s == '\\0')\n-\tbreak;\n-      path = s + 1;\n-    }\n-\n-  return FALSE;\n-}\n-\n EOF\n-if [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-  fragment <<EOF\n-\n-/* Prefix the sysroot to absolute paths in PATH, a string containing\n-   paths separated by config.rpath_separator.  If running on a DOS\n-   file system, paths containing a drive spec won't have the sysroot\n-   prefix added, unless the sysroot also specifies the same drive.  */\n-\n-static const char *\n-gld${EMULATION_NAME}_add_sysroot (const char *path)\n-{\n-  size_t len, extra;\n-  const char *p;\n-  char *ret, *q;\n-  int dos_drive_sysroot = HAS_DRIVE_SPEC (ld_sysroot);\n-\n-  len = strlen (ld_sysroot);\n-  for (extra = 0, p = path; ; )\n-    {\n-      int dos_drive = HAS_DRIVE_SPEC (p);\n-\n-      if (dos_drive)\n-\tp += 2;\n-      if (IS_DIR_SEPARATOR (*p)\n-\t  && (!dos_drive\n-\t      || (dos_drive_sysroot\n-\t\t  && ld_sysroot[0] == p[-2])))\n-\t{\n-\t  if (dos_drive && dos_drive_sysroot)\n-\t    extra += len - 2;\n-\t  else\n-\t    extra += len;\n-\t}\n-      p = strchr (p, config.rpath_separator);\n-      if (!p)\n-\tbreak;\n-      ++p;\n-    }\n-\n-  ret = xmalloc (strlen (path) + extra + 1);\n-\n-  for (q = ret, p = path; ; )\n-    {\n-      const char *end;\n-      int dos_drive = HAS_DRIVE_SPEC (p);\n-\n-      if (dos_drive)\n-\t{\n-\t  *q++ = *p++;\n-\t  *q++ = *p++;\n-\t}\n-      if (IS_DIR_SEPARATOR (*p)\n-\t  && (!dos_drive\n-\t      || (dos_drive_sysroot\n-\t\t  && ld_sysroot[0] == p[-2])))\n-\t{\n-\t  if (dos_drive && dos_drive_sysroot)\n-\t    {\n-\t      strcpy (q, ld_sysroot + 2);\n-\t      q += len - 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      strcpy (q, ld_sysroot);\n-\t      q += len;\n-\t    }\n-\t}\n-      end = strchr (p, config.rpath_separator);\n-      if (end)\n-\t{\n-\t  size_t n = end - p + 1;\n-\t  strncpy (q, p, n);\n-\t  q += n;\n-\t  p += n;\n-\t}\n-      else\n-\t{\n-\t  strcpy (q, p);\n-\t  break;\n-\t}\n-    }\n \n-  return ret;\n-}\n+if test x\"$LDEMUL_AFTER_OPEN\" != xgld\"$EMULATION_NAME\"_after_open; then\n \n-EOF\n+  IS_LINUX_TARGET=FALSE\n+  IS_FREEBSD_TARGET=FALSE\n   case ${target} in\n-    *-*-freebsd* | *-*-dragonfly*)\n-      fragment <<EOF\n-/* Read the system search path the FreeBSD way rather than the Linux way.  */\n-#ifdef HAVE_ELF_HINTS_H\n-#include <elf-hints.h>\n-#else\n-#include \"elf-hints-local.h\"\n-#endif\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_check_ld_elf_hints (const struct bfd_link_needed_list *l,\n-\t\t\t\t\t int force)\n-{\n-  static bfd_boolean initialized;\n-  static const char *ld_elf_hints;\n-  struct dt_needed needed;\n-\n-  if (!initialized)\n-    {\n-      FILE *f;\n-      char *tmppath;\n-\n-      tmppath = concat (ld_sysroot, _PATH_ELF_HINTS, (const char *) NULL);\n-      f = fopen (tmppath, FOPEN_RB);\n-      free (tmppath);\n-      if (f != NULL)\n-\t{\n-\t  struct elfhints_hdr hdr;\n-\n-\t  if (fread (&hdr, 1, sizeof (hdr), f) == sizeof (hdr)\n-\t      && hdr.magic == ELFHINTS_MAGIC\n-\t      && hdr.version == 1)\n-\t    {\n-\t      if (fseek (f, hdr.strtab + hdr.dirlist, SEEK_SET) != -1)\n-\t\t{\n-\t\t  char *b;\n-\n-\t\t  b = xmalloc (hdr.dirlistlen + 1);\n-\t\t  if (fread (b, 1, hdr.dirlistlen + 1, f) ==\n-\t\t      hdr.dirlistlen + 1)\n-\t\t    ld_elf_hints = gld${EMULATION_NAME}_add_sysroot (b);\n-\n-\t\t  free (b);\n-\t\t}\n-\t    }\n-\t  fclose (f);\n-\t}\n-\n-      initialized = TRUE;\n-    }\n-\n-  if (ld_elf_hints == NULL)\n-    return FALSE;\n-\n-  needed.by = l->by;\n-  needed.name = l->name;\n-  return gld${EMULATION_NAME}_search_needed (ld_elf_hints, &needed, force);\n-}\n-EOF\n-    # FreeBSD\n-    ;;\n-\n     *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)\n-      fragment <<EOF\n-/* For a native linker, check the file /etc/ld.so.conf for directories\n-   in which we may find shared libraries.  /etc/ld.so.conf is really\n-   only meaningful on Linux.  */\n+      IS_LINUX_TARGET=TRUE ;;\n+    *-*-freebsd* | *-*-dragonfly*)\n+      IS_FREEBSD_TARGET=TRUE ;;\n+  esac\n+  IS_LIBPATH=FALSE\n+  if test \"x${USE_LIBPATH}\" = xyes; then\n+    IS_LIBPATH=TRUE\n+  fi\n+  IS_NATIVE=FALSE\n+  if test \"x${NATIVE}\" = xyes; then\n+    IS_NATIVE=TRUE\n+  fi\n \n-struct gld${EMULATION_NAME}_ld_so_conf\n-{\n-  char *path;\n-  size_t len, alloc;\n-};\n+fragment <<EOF\n \n-static bfd_boolean\n-gld${EMULATION_NAME}_parse_ld_so_conf\n-     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename);\n+/* This is called after all the input files have been opened.  */\n \n static void\n-gld${EMULATION_NAME}_parse_ld_so_conf_include\n-     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename,\n-      const char *pattern)\n-{\n-  char *newp = NULL;\n-#ifdef HAVE_GLOB\n-  glob_t gl;\n-#endif\n-\n-  if (pattern[0] != '/')\n-    {\n-      char *p = strrchr (filename, '/');\n-      size_t patlen = strlen (pattern) + 1;\n-\n-      newp = xmalloc (p - filename + 1 + patlen);\n-      memcpy (newp, filename, p - filename + 1);\n-      memcpy (newp + (p - filename + 1), pattern, patlen);\n-      pattern = newp;\n-    }\n-\n-#ifdef HAVE_GLOB\n-  if (glob (pattern, 0, NULL, &gl) == 0)\n-    {\n-      size_t i;\n-\n-      for (i = 0; i < gl.gl_pathc; ++i)\n-\tgld${EMULATION_NAME}_parse_ld_so_conf (info, gl.gl_pathv[i]);\n-      globfree (&gl);\n-    }\n-#else\n-  /* If we do not have glob, treat the pattern as a literal filename.  */\n-  gld${EMULATION_NAME}_parse_ld_so_conf (info, pattern);\n-#endif\n-\n-  if (newp)\n-    free (newp);\n-}\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_parse_ld_so_conf\n-     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename)\n-{\n-  FILE *f = fopen (filename, FOPEN_RT);\n-  char *line;\n-  size_t linelen;\n-\n-  if (f == NULL)\n-    return FALSE;\n-\n-  linelen = 256;\n-  line = xmalloc (linelen);\n-  do\n-    {\n-      char *p = line, *q;\n-\n-      /* Normally this would use getline(3), but we need to be portable.  */\n-      while ((q = fgets (p, linelen - (p - line), f)) != NULL\n-\t     && strlen (q) == linelen - (p - line) - 1\n-\t     && line[linelen - 2] != '\\n')\n-\t{\n-\t  line = xrealloc (line, 2 * linelen);\n-\t  p = line + linelen - 1;\n-\t  linelen += linelen;\n-\t}\n-\n-      if (q == NULL && p == line)\n-\tbreak;\n-\n-      p = strchr (line, '\\n');\n-      if (p)\n-\t*p = '\\0';\n-\n-      /* Because the file format does not know any form of quoting we\n-\t can search forward for the next '#' character and if found\n-\t make it terminating the line.  */\n-      p = strchr (line, '#');\n-      if (p)\n-\t*p = '\\0';\n-\n-      /* Remove leading whitespace.  NUL is no whitespace character.  */\n-      p = line;\n-      while (*p == ' ' || *p == '\\f' || *p == '\\r' || *p == '\\t' || *p == '\\v')\n-\t++p;\n-\n-      /* If the line is blank it is ignored.  */\n-      if (p[0] == '\\0')\n-\tcontinue;\n-\n-      if (CONST_STRNEQ (p, \"include\") && (p[7] == ' ' || p[7] == '\\t'))\n-\t{\n-\t  char *dir, c;\n-\t  p += 8;\n-\t  do\n-\t    {\n-\t      while (*p == ' ' || *p == '\\t')\n-\t\t++p;\n-\n-\t      if (*p == '\\0')\n-\t\tbreak;\n-\n-\t      dir = p;\n-\n-\t      while (*p != ' ' && *p != '\\t' && *p)\n-\t\t++p;\n-\n-\t      c = *p;\n-\t      *p++ = '\\0';\n-\t      if (dir[0] != '\\0')\n-\t\tgld${EMULATION_NAME}_parse_ld_so_conf_include (info, filename,\n-\t\t\t\t\t\t\t       dir);\n-\t    }\n-\t  while (c != '\\0');\n-\t}\n-      else\n-\t{\n-\t  char *dir = p;\n-\t  while (*p && *p != '=' && *p != ' ' && *p != '\\t' && *p != '\\f'\n-\t\t && *p != '\\r' && *p != '\\v')\n-\t    ++p;\n-\n-\t  while (p != dir && p[-1] == '/')\n-\t    --p;\n-\t  if (info->path == NULL)\n-\t    {\n-\t      info->alloc = p - dir + 1 + 256;\n-\t      info->path = xmalloc (info->alloc);\n-\t      info->len = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (info->len + 1 + (p - dir) >= info->alloc)\n-\t\t{\n-\t\t  info->alloc += p - dir + 256;\n-\t\t  info->path = xrealloc (info->path, info->alloc);\n-\t\t}\n-\t      info->path[info->len++] = config.rpath_separator;\n-\t    }\n-\t  memcpy (info->path + info->len, dir, p - dir);\n-\t  info->len += p - dir;\n-\t  info->path[info->len] = '\\0';\n-\t}\n-    }\n-  while (! feof (f));\n-  free (line);\n-  fclose (f);\n-  return TRUE;\n-}\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_check_ld_so_conf (const struct bfd_link_needed_list *l,\n-\t\t\t\t       int force)\n+gld${EMULATION_NAME}_after_open (void)\n {\n-  static bfd_boolean initialized;\n-  static const char *ld_so_conf;\n-  struct dt_needed needed;\n-\n-  if (! initialized)\n-    {\n-      char *tmppath;\n-      struct gld${EMULATION_NAME}_ld_so_conf info;\n-\n-      info.path = NULL;\n-      info.len = info.alloc = 0;\n-      tmppath = concat (ld_sysroot, \"${prefix}/etc/ld.so.conf\",\n-\t\t\t(const char *) NULL);\n-      if (!gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath))\n-\t{\n-\t  free (tmppath);\n-\t  tmppath = concat (ld_sysroot, \"/etc/ld.so.conf\",\n-\t\t\t    (const char *) NULL);\n-\t  gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath);\n-\t}\n-      free (tmppath);\n-\n-      if (info.path)\n-\t{\n-\t  ld_so_conf = gld${EMULATION_NAME}_add_sysroot (info.path);\n-\t  free (info.path);\n-\t}\n-      initialized = TRUE;\n-    }\n-\n-  if (ld_so_conf == NULL)\n-    return FALSE;\n-\n-\n-  needed.by = l->by;\n-  needed.name = l->name;\n-  return gld${EMULATION_NAME}_search_needed (ld_so_conf, &needed, force);\n+  ldelf_after_open ($IS_LIBPATH, $IS_NATIVE,\n+\t\t    $IS_LINUX_TARGET, $IS_FREEBSD_TARGET, $ELFSIZE);\n }\n \n EOF\n-    # Linux\n-    ;;\n-  esac\n fi\n+\n+if test x\"$LDEMUL_BEFORE_ALLOCATION\" != xgld\"$EMULATION_NAME\"_before_allocation; then\n+  if test x\"${ELF_INTERPRETER_NAME}\" = x; then\n+    ELF_INTERPRETER_NAME=NULL\n+  fi\n fragment <<EOF\n \n-/* See if an input file matches a DT_NEEDED entry by name.  */\n+/* This is called after the sections have been attached to output\n+   sections, but before any sizes or addresses have been set.  */\n \n static void\n-gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)\n+gld${EMULATION_NAME}_before_allocation (void)\n {\n-  const char *soname;\n-\n-  /* Stop looking if we've found a loaded lib.  */\n-  if (global_found != NULL\n-      && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)\n-\t  & DYN_AS_NEEDED) == 0)\n-    return;\n-\n-  if (s->filename == NULL || s->the_bfd == NULL)\n-    return;\n-\n-  /* Don't look for a second non-loaded as-needed lib.  */\n-  if (global_found != NULL\n-      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)\n-    return;\n+  ldelf_before_allocation (audit, depaudit, ${ELF_INTERPRETER_NAME});\n+}\n \n-  if (filename_cmp (s->filename, global_needed->name) == 0)\n-    {\n-      global_found = s;\n-      return;\n-    }\n-\n-  if (s->flags.search_dirs)\n-    {\n-      const char *f = strrchr (s->filename, '/');\n-      if (f != NULL\n-\t  && filename_cmp (f + 1, global_needed->name) == 0)\n-\t{\n-\t  global_found = s;\n-\t  return;\n-\t}\n-    }\n-\n-  soname = bfd_elf_get_dt_soname (s->the_bfd);\n-  if (soname != NULL\n-      && filename_cmp (soname, global_needed->name) == 0)\n-    {\n-      global_found = s;\n-      return;\n-    }\n-}\n-\n-EOF\n-\n-if test x\"$LDEMUL_AFTER_OPEN\" != xgld\"$EMULATION_NAME\"_after_open; then\n-fragment <<EOF\n-\n-static bfd_size_type\n-id_note_section_size (bfd *abfd ATTRIBUTE_UNUSED)\n-{\n-  const char *style = emit_note_gnu_build_id;\n-  bfd_size_type size;\n-  bfd_size_type build_id_size;\n-\n-  size = offsetof (Elf_External_Note, name[sizeof \"GNU\"]);\n-  size = (size + 3) & -(bfd_size_type) 4;\n-\n-  build_id_size = compute_build_id_size (style);\n-  if (build_id_size)\n-    size += build_id_size;\n-  else\n-    size = 0;\n-\n-  return size;\n-}\n-\n-static bfd_boolean\n-write_build_id (bfd *abfd)\n-{\n-  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n-  struct elf_obj_tdata *t = elf_tdata (abfd);\n-  const char *style;\n-  asection *asec;\n-  Elf_Internal_Shdr *i_shdr;\n-  unsigned char *contents, *id_bits;\n-  bfd_size_type size;\n-  file_ptr position;\n-  Elf_External_Note *e_note;\n-\n-  style = t->o->build_id.style;\n-  asec = t->o->build_id.sec;\n-  if (bfd_is_abs_section (asec->output_section))\n-    {\n-      einfo (_(\"%P: warning: .note.gnu.build-id section discarded,\"\n-\t       \" --build-id ignored\\n\"));\n-      return TRUE;\n-    }\n-  i_shdr = &elf_section_data (asec->output_section)->this_hdr;\n-\n-  if (i_shdr->contents == NULL)\n-    {\n-      if (asec->contents == NULL)\n-\tasec->contents = (unsigned char *) xmalloc (asec->size);\n-      contents = asec->contents;\n-    }\n-  else\n-    contents = i_shdr->contents + asec->output_offset;\n-\n-  e_note = (Elf_External_Note *) contents;\n-  size = offsetof (Elf_External_Note, name[sizeof \"GNU\"]);\n-  size = (size + 3) & -(bfd_size_type) 4;\n-  id_bits = contents + size;\n-  size = asec->size - size;\n-\n-  bfd_h_put_32 (abfd, sizeof \"GNU\", &e_note->namesz);\n-  bfd_h_put_32 (abfd, size, &e_note->descsz);\n-  bfd_h_put_32 (abfd, NT_GNU_BUILD_ID, &e_note->type);\n-  memcpy (e_note->name, \"GNU\", sizeof \"GNU\");\n-\n-  generate_build_id (abfd, style, bed->s->checksum_contents, id_bits, size);\n-\n-  position = i_shdr->sh_offset + asec->output_offset;\n-  size = asec->size;\n-  return (bfd_seek (abfd, position, SEEK_SET) == 0\n-\t  && bfd_bwrite (contents, size, abfd) == size);\n-}\n-\n-/* Make .note.gnu.build-id section, and set up elf_tdata->build_id.  */\n-\n-static bfd_boolean\n-setup_build_id (bfd *ibfd)\n-{\n-  asection *s;\n-  bfd_size_type size;\n-  flagword flags;\n-\n-  size = id_note_section_size (ibfd);\n-  if (size == 0)\n-    {\n-      einfo (_(\"%P: warning: unrecognized --build-id style ignored\\n\"));\n-      return FALSE;\n-    }\n-\n-  flags = (SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY\n-\t   | SEC_LINKER_CREATED | SEC_READONLY | SEC_DATA);\n-  s = bfd_make_section_with_flags (ibfd, \".note.gnu.build-id\", flags);\n-  if (s != NULL && bfd_set_section_alignment (ibfd, s, 2))\n-    {\n-      struct elf_obj_tdata *t = elf_tdata (link_info.output_bfd);\n-      t->o->build_id.after_write_object_contents = &write_build_id;\n-      t->o->build_id.style = emit_note_gnu_build_id;\n-      t->o->build_id.sec = s;\n-      elf_section_type (s) = SHT_NOTE;\n-      s->size = size;\n-      return TRUE;\n-    }\n-\n-  einfo (_(\"%P: warning: cannot create .note.gnu.build-id section,\"\n-\t   \" --build-id ignored\\n\"));\n-  return FALSE;\n-}\n-\n-/* This is called after all the input files have been opened.  */\n-\n-static void\n-gld${EMULATION_NAME}_after_open (void)\n-{\n-  struct bfd_link_needed_list *needed, *l;\n-  struct elf_link_hash_table *htab;\n-  asection *s;\n-  bfd *abfd;\n-\n-  after_open_default ();\n-\n-  htab = elf_hash_table (&link_info);\n-  if (!is_elf_hash_table (htab))\n-    return;\n-\n-  if (command_line.out_implib_filename)\n-    {\n-      unlink_if_ordinary (command_line.out_implib_filename);\n-      link_info.out_implib_bfd\n-\t= bfd_openw (command_line.out_implib_filename,\n-\t\t     bfd_get_target (link_info.output_bfd));\n-\n-      if (link_info.out_implib_bfd == NULL)\n-\t{\n-\t  einfo (_(\"%F%P: %s: can't open for writing: %E\\n\"),\n-\t\t command_line.out_implib_filename);\n-\t}\n-    }\n-\n-  if (emit_note_gnu_build_id != NULL)\n-    {\n-      /* Find an ELF input.  */\n-      for (abfd = link_info.input_bfds;\n-\t   abfd != (bfd *) NULL; abfd = abfd->link.next)\n-\tif (bfd_get_flavour (abfd) == bfd_target_elf_flavour\n-\t    && bfd_count_sections (abfd) != 0\n-\t    && !((lang_input_statement_type *) abfd->usrdata)->flags.just_syms)\n-\t  break;\n-\n-      /* PR 10555: If there are no ELF input files do not try to\n-\t create a .note.gnu-build-id section.  */\n-      if (abfd == NULL\n-\t  || !setup_build_id (abfd))\n-\t{\n-\t  free ((char *) emit_note_gnu_build_id);\n-\t  emit_note_gnu_build_id = NULL;\n-\t}\n-    }\n-\n-  get_elf_backend_data (link_info.output_bfd)->setup_gnu_properties (&link_info);\n-\n-  if (bfd_link_relocatable (&link_info))\n-    {\n-      if (link_info.execstack == ! link_info.noexecstack)\n-\t/* PR ld/16744: If \"-z [no]execstack\" has been specified on the\n-\t   command line and we are perfoming a relocatable link then no\n-\t   PT_GNU_STACK segment will be created and so the\n-\t   linkinfo.[no]execstack values set in _handle_option() will have no\n-\t   effect.  Instead we create a .note.GNU-stack section in much the\n-\t   same way as the assembler does with its --[no]execstack option.  */\n-\t(void) bfd_make_section_with_flags (link_info.input_bfds,\n-\t\t\t\t\t    \".note.GNU-stack\",\n-\t\t\t\t\t    SEC_READONLY | (link_info.execstack ? SEC_CODE : 0));\n-\n-      return;\n-    }\n-\n-  if (!link_info.traditional_format)\n-    {\n-      bfd *elfbfd = NULL;\n-      bfd_boolean warn_eh_frame = FALSE;\n-      int seen_type = 0;\n-\n-      for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)\n-\t{\n-\t  int type = 0;\n-\n-\t  if (((lang_input_statement_type *) abfd->usrdata)->flags.just_syms)\n-\t    continue;\n-\n-\t  for (s = abfd->sections; s && type < COMPACT_EH_HDR; s = s->next)\n-\t    {\n-\t      const char *name = bfd_get_section_name (abfd, s);\n-\n-\t      if (bfd_is_abs_section (s->output_section))\n-\t\tcontinue;\n-\t      if (CONST_STRNEQ (name, \".eh_frame_entry\"))\n-\t\ttype = COMPACT_EH_HDR;\n-\t      else if (strcmp (name, \".eh_frame\") == 0 && s->size > 8)\n-\t\ttype = DWARF2_EH_HDR;\n-\t    }\n-\n-\t  if (type != 0)\n-\t    {\n-\t      if (seen_type == 0)\n-\t\t{\n-\t\t  seen_type = type;\n-\t\t}\n-\t      else if (seen_type != type)\n-\t\t{\n-\t\t  einfo (_(\"%F%P: compact frame descriptions incompatible with\"\n-\t\t\t   \" DWARF2 .eh_frame from %pB\\n\"),\n-\t\t\t type == DWARF2_EH_HDR ? abfd : elfbfd);\n-\t\t  break;\n-\t\t}\n-\n-\t      if (!elfbfd\n-\t\t  && (type == COMPACT_EH_HDR || link_info.eh_frame_hdr_type != 0))\n-\t\t{\n-\t\t  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n-\t\t    elfbfd = abfd;\n-\n-\t\t  warn_eh_frame = TRUE;\n-\t\t}\n-\t    }\n-\n-\t  if (seen_type == COMPACT_EH_HDR)\n-\t    link_info.eh_frame_hdr_type = COMPACT_EH_HDR;\n-\t}\n-      if (elfbfd)\n-\t{\n-\t  const struct elf_backend_data *bed;\n-\n-\t  bed = get_elf_backend_data (elfbfd);\n-\t  s = bfd_make_section_with_flags (elfbfd, \".eh_frame_hdr\",\n-\t\t\t\t\t   bed->dynamic_sec_flags\n-\t\t\t\t\t   | SEC_READONLY);\n-\t  if (s != NULL\n-\t      && bfd_set_section_alignment (elfbfd, s, 2))\n-\t    {\n-\t      htab->eh_info.hdr_sec = s;\n-\t      warn_eh_frame = FALSE;\n-\t    }\n-\t}\n-      if (warn_eh_frame)\n-\teinfo (_(\"%P: warning: cannot create .eh_frame_hdr section,\"\n-\t\t \" --eh-frame-hdr ignored\\n\"));\n-    }\n-\n-  /* Get the list of files which appear in DT_NEEDED entries in\n-     dynamic objects included in the link (often there will be none).\n-     For each such file, we want to track down the corresponding\n-     library, and include the symbol table in the link.  This is what\n-     the runtime dynamic linker will do.  Tracking the files down here\n-     permits one dynamic object to include another without requiring\n-     special action by the person doing the link.  Note that the\n-     needed list can actually grow while we are stepping through this\n-     loop.  */\n-  needed = bfd_elf_get_needed_list (link_info.output_bfd, &link_info);\n-  for (l = needed; l != NULL; l = l->next)\n-    {\n-      struct bfd_link_needed_list *ll;\n-      struct dt_needed n, nn;\n-      int force;\n-\n-      /* If the lib that needs this one was --as-needed and wasn't\n-\t found to be needed, then this lib isn't needed either.  */\n-      if (l->by != NULL\n-\t  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_AS_NEEDED) != 0)\n-\tcontinue;\n-\n-      /* Skip the lib if --no-copy-dt-needed-entries and\n-\t --allow-shlib-undefined is in effect.  */\n-      if (l->by != NULL\n-\t  && link_info.unresolved_syms_in_shared_libs == RM_IGNORE\n-\t  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_NO_ADD_NEEDED) != 0)\n-\tcontinue;\n-\n-      /* If we've already seen this file, skip it.  */\n-      for (ll = needed; ll != l; ll = ll->next)\n-\tif ((ll->by == NULL\n-\t     || (bfd_elf_get_dyn_lib_class (ll->by) & DYN_AS_NEEDED) == 0)\n-\t    && strcmp (ll->name, l->name) == 0)\n-\t  break;\n-      if (ll != l)\n-\tcontinue;\n-\n-      /* See if this file was included in the link explicitly.  */\n-      global_needed = l;\n-      global_found = NULL;\n-      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);\n-      if (global_found != NULL\n-\t  && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)\n-\t      & DYN_AS_NEEDED) == 0)\n-\tcontinue;\n-\n-      n.by = l->by;\n-      n.name = l->name;\n-      nn.by = l->by;\n-      if (verbose)\n-\tinfo_msg (_(\"%s needed by %pB\\n\"), l->name, l->by);\n-\n-      /* As-needed libs specified on the command line (or linker script)\n-\t take priority over libs found in search dirs.  */\n-      if (global_found != NULL)\n-\t{\n-\t  nn.name = global_found->filename;\n-\t  if (gld${EMULATION_NAME}_try_needed (&nn, TRUE))\n-\t    continue;\n-\t}\n-\n-      /* We need to find this file and include the symbol table.  We\n-\t want to search for the file in the same way that the dynamic\n-\t linker will search.  That means that we want to use\n-\t rpath_link, rpath, then the environment variable\n-\t LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH\n-\t entries (native only), then the linker script LIB_SEARCH_DIRS.\n-\t We do not search using the -L arguments.\n-\n-\t We search twice.  The first time, we skip objects which may\n-\t introduce version mismatches.  The second time, we force\n-\t their use.  See gld${EMULATION_NAME}_vercheck comment.  */\n-      for (force = 0; force < 2; force++)\n-\t{\n-\t  size_t len;\n-\t  search_dirs_type *search;\n-EOF\n-if [ \"x${NATIVE}\" = xyes ] || [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-fragment <<EOF\n-\t  const char *path;\n-EOF\n-fi\n-if [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-fragment <<EOF\n-\t  struct bfd_link_needed_list *rp;\n-\t  int found;\n-EOF\n-fi\n-fragment <<EOF\n-\n-\t  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,\n-\t\t\t\t\t\t  &n, force))\n-\t    break;\n-EOF\n-if [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-fragment <<EOF\n-\t  path = command_line.rpath;\n-\t  if (path)\n-\t    {\n-\t      path = gld${EMULATION_NAME}_add_sysroot (path);\n-\t      found = gld${EMULATION_NAME}_search_needed (path, &n, force);\n-\t      free ((char *) path);\n-\t      if (found)\n-\t\tbreak;\n-\t    }\n-EOF\n-fi\n-if [ \"x${NATIVE}\" = xyes ] ; then\n-fragment <<EOF\n-\t  if (command_line.rpath_link == NULL\n-\t      && command_line.rpath == NULL)\n-\t    {\n-\t      path = (const char *) getenv (\"LD_RUN_PATH\");\n-\t      if (path\n-\t\t  && gld${EMULATION_NAME}_search_needed (path, &n, force))\n-\t\tbreak;\n-\t    }\n-\t  path = (const char *) getenv (\"LD_LIBRARY_PATH\");\n-\t  if (path\n-\t      && gld${EMULATION_NAME}_search_needed (path, &n, force))\n-\t    break;\n-EOF\n-fi\n-if [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-fragment <<EOF\n-\t  found = 0;\n-\t  rp = bfd_elf_get_runpath_list (link_info.output_bfd, &link_info);\n-\t  for (; !found && rp != NULL; rp = rp->next)\n-\t    {\n-\t      path = gld${EMULATION_NAME}_add_sysroot (rp->name);\n-\t      found = (rp->by == l->by\n-\t\t       && gld${EMULATION_NAME}_search_needed (path, &n,\n-\t\t\t\t\t\t\t      force));\n-\t      free ((char *) path);\n-\t    }\n-\t  if (found)\n-\t    break;\n-\n-EOF\n-fi\n-if [ \"x${USE_LIBPATH}\" = xyes ] ; then\n-  case ${target} in\n-    *-*-freebsd* | *-*-dragonfly*)\n-      fragment <<EOF\n-\t  if (gld${EMULATION_NAME}_check_ld_elf_hints (l, force))\n-\t    break;\n-EOF\n-    # FreeBSD\n-    ;;\n-\n-    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)\n-      fragment <<EOF\n-\t  if (gld${EMULATION_NAME}_check_ld_so_conf (l, force))\n-\t    break;\n-\n-EOF\n-    # Linux\n-    ;;\n-  esac\n-fi\n-fragment <<EOF\n-\t  len = strlen (l->name);\n-\t  for (search = search_head; search != NULL; search = search->next)\n-\t    {\n-\t      char *filename;\n-\n-\t      if (search->cmdline)\n-\t\tcontinue;\n-\t      filename = (char *) xmalloc (strlen (search->name) + len + 2);\n-\t      sprintf (filename, \"%s/%s\", search->name, l->name);\n-\t      nn.name = filename;\n-\t      if (gld${EMULATION_NAME}_try_needed (&nn, force))\n-\t\tbreak;\n-\t      free (filename);\n-\t    }\n-\t  if (search != NULL)\n-\t    break;\n-EOF\n-fragment <<EOF\n-\t}\n-\n-      if (force < 2)\n-\tcontinue;\n-\n-      einfo (_(\"%P: warning: %s, needed by %pB, not found \"\n-\t       \"(try using -rpath or -rpath-link)\\n\"),\n-\t     l->name, l->by);\n-    }\n-\n-  if (link_info.eh_frame_hdr_type == COMPACT_EH_HDR)\n-    if (!bfd_elf_parse_eh_frame_entries (NULL, &link_info))\n-      einfo (_(\"%F%P: failed to parse EH frame entries\\n\"));\n-}\n-\n-EOF\n-fi\n-\n-fragment <<EOF\n-\n-/* Look through an expression for an assignment statement.  */\n-\n-static void\n-gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)\n-{\n-  bfd_boolean provide = FALSE;\n-\n-  switch (exp->type.node_class)\n-    {\n-    case etree_provide:\n-    case etree_provided:\n-      provide = TRUE;\n-      /* Fallthru */\n-    case etree_assign:\n-      /* We call record_link_assignment even if the symbol is defined.\n-\t This is because if it is defined by a dynamic object, we\n-\t actually want to use the value defined by the linker script,\n-\t not the value from the dynamic object (because we are setting\n-\t symbols like etext).  If the symbol is defined by a regular\n-\t object, then, as it happens, calling record_link_assignment\n-\t will do no harm.  */\n-      if (strcmp (exp->assign.dst, \".\") != 0)\n-\t{\n-\t  if (!bfd_elf_record_link_assignment (link_info.output_bfd,\n-\t\t\t\t\t       &link_info,\n-\t\t\t\t\t       exp->assign.dst, provide,\n-\t\t\t\t\t       exp->assign.hidden))\n-\t    einfo (_(\"%F%P: failed to record assignment to %s: %E\\n\"),\n-\t\t   exp->assign.dst);\n-\t}\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);\n-      break;\n-\n-    case etree_binary:\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);\n-      break;\n-\n-    case etree_trinary:\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);\n-      break;\n-\n-    case etree_unary:\n-      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-\n-/* This is called by the before_allocation routine via\n-   lang_for_each_statement.  It locates any assignment statements, and\n-   tells the ELF backend about them, in case they are assignments to\n-   symbols which are referred to by dynamic objects.  */\n-\n-static void\n-gld${EMULATION_NAME}_find_statement_assignment (lang_statement_union_type *s)\n-{\n-  if (s->header.type == lang_assignment_statement_enum)\n-    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);\n-}\n-\n-EOF\n-\n-if test x\"$LDEMUL_BEFORE_ALLOCATION\" != xgld\"$EMULATION_NAME\"_before_allocation; then\n-  if test x\"${ELF_INTERPRETER_NAME+set}\" = xset; then\n-    ELF_INTERPRETER_SET_DEFAULT=\"\n-  if (sinterp != NULL)\n-    {\n-      sinterp->contents = (unsigned char *) ${ELF_INTERPRETER_NAME};\n-      sinterp->size = strlen ((char *) sinterp->contents) + 1;\n-    }\n-\n-\"\n-  else\n-    ELF_INTERPRETER_SET_DEFAULT=\n-  fi\n-fragment <<EOF\n-\n-/* used by before_allocation and handle_option. */\n-static void\n-gld${EMULATION_NAME}_append_to_separated_string (char **to, char *op_arg)\n-{\n-  if (*to == NULL)\n-    *to = xstrdup (op_arg);\n-  else\n-    {\n-      size_t to_len = strlen (*to);\n-      size_t op_arg_len = strlen (op_arg);\n-      char *buf;\n-      char *cp = *to;\n-\n-      /* First see whether OPTARG is already in the path.  */\n-      do\n-\t{\n-\t  if (strncmp (op_arg, cp, op_arg_len) == 0\n-\t      && (cp[op_arg_len] == 0\n-\t\t  || cp[op_arg_len] == config.rpath_separator))\n-\t    /* We found it.  */\n-\t    break;\n-\n-\t  /* Not yet found.  */\n-\t  cp = strchr (cp, config.rpath_separator);\n-\t  if (cp != NULL)\n-\t    ++cp;\n-\t}\n-      while (cp != NULL);\n-\n-      if (cp == NULL)\n-\t{\n-\t  buf = xmalloc (to_len + op_arg_len + 2);\n-\t  sprintf (buf, \"%s%c%s\", *to,\n-\t\t   config.rpath_separator, op_arg);\n-\t  free (*to);\n-\t  *to = buf;\n-\t}\n-    }\n-}\n-\n-/* This is called after the sections have been attached to output\n-   sections, but before any sizes or addresses have been set.  */\n-\n-static void\n-gld${EMULATION_NAME}_before_allocation (void)\n-{\n-  const char *rpath;\n-  asection *sinterp;\n-  bfd *abfd;\n-  struct bfd_link_hash_entry *ehdr_start = NULL;\n-  unsigned char ehdr_start_save_type = 0;\n-  char ehdr_start_save_u[sizeof ehdr_start->u\n-\t\t\t - sizeof ehdr_start->u.def.next] = \"\";\n-\n-  if (is_elf_hash_table (link_info.hash))\n-    {\n-      _bfd_elf_tls_setup (link_info.output_bfd, &link_info);\n-\n-      /* Make __ehdr_start hidden if it has been referenced, to\n-\t prevent the symbol from being dynamic.  */\n-      if (!bfd_link_relocatable (&link_info))\n-\t{\n-\t  struct elf_link_hash_table *htab = elf_hash_table (&link_info);\n-\t  struct elf_link_hash_entry *h\n-\t    = elf_link_hash_lookup (htab, \"__ehdr_start\", FALSE, FALSE, TRUE);\n-\n-\t  /* Only adjust the export class if the symbol was referenced\n-\t     and not defined, otherwise leave it alone.  */\n-\t  if (h != NULL\n-\t      && (h->root.type == bfd_link_hash_new\n-\t\t  || h->root.type == bfd_link_hash_undefined\n-\t\t  || h->root.type == bfd_link_hash_undefweak\n-\t\t  || h->root.type == bfd_link_hash_common))\n-\t    {\n-\t      const struct elf_backend_data *bed;\n-\t      bed = get_elf_backend_data (link_info.output_bfd);\n-\t      (*bed->elf_backend_hide_symbol) (&link_info, h, TRUE);\n-\t      if (ELF_ST_VISIBILITY (h->other) != STV_INTERNAL)\n-\t\th->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;\n-\t      /* Don't leave the symbol undefined.  Undefined hidden\n-\t\t symbols typically won't have dynamic relocations, but\n-\t\t we most likely will need dynamic relocations for\n-\t\t __ehdr_start if we are building a PIE or shared\n-\t\t library.  */\n-\t      ehdr_start = &h->root;\n-\t      ehdr_start_save_type = ehdr_start->type;\n-\t      memcpy (ehdr_start_save_u,\n-\t\t      (char *) &ehdr_start->u + sizeof ehdr_start->u.def.next,\n-\t\t      sizeof ehdr_start_save_u);\n-\t      ehdr_start->type = bfd_link_hash_defined;\n-\t      ehdr_start->u.def.section = bfd_abs_section_ptr;\n-\t      ehdr_start->u.def.value = 0;\n-\t    }\n-\t}\n-\n-      /* If we are going to make any variable assignments, we need to\n-\t let the ELF backend know about them in case the variables are\n-\t referred to by dynamic objects.  */\n-      lang_for_each_statement (gld${EMULATION_NAME}_find_statement_assignment);\n-    }\n-\n-  /* Let the ELF backend work out the sizes of any sections required\n-     by dynamic linking.  */\n-  rpath = command_line.rpath;\n-  if (rpath == NULL)\n-    rpath = (const char *) getenv (\"LD_RUN_PATH\");\n-\n-  for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)\n-    if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n-      {\n-\tconst char *audit_libs = elf_dt_audit (abfd);\n-\n-\t/* If the input bfd contains an audit entry, we need to add it as\n-\t   a dep audit entry.  */\n-\tif (audit_libs && *audit_libs != '\\0')\n-\t  {\n-\t    char *cp = xstrdup (audit_libs);\n-\t    do\n-\t      {\n-\t\tint more = 0;\n-\t\tchar *cp2 = strchr (cp, config.rpath_separator);\n-\n-\t\tif (cp2)\n-\t\t  {\n-\t\t    *cp2 = '\\0';\n-\t\t    more = 1;\n-\t\t  }\n-\n-\t\tif (cp != NULL && *cp != '\\0')\n-\t\t  gld${EMULATION_NAME}_append_to_separated_string (&depaudit, cp);\n-\n-\t\tcp = more ? ++cp2 : NULL;\n-\t      }\n-\t    while (cp != NULL);\n-\t  }\n-      }\n-\n-  if (! (bfd_elf_size_dynamic_sections\n-\t (link_info.output_bfd, command_line.soname, rpath,\n-\t  command_line.filter_shlib, audit, depaudit,\n-\t  (const char * const *) command_line.auxiliary_filters,\n-\t  &link_info, &sinterp)))\n-    einfo (_(\"%F%P: failed to set dynamic section sizes: %E\\n\"));\n-\n-${ELF_INTERPRETER_SET_DEFAULT}\n-  /* Let the user override the dynamic linker we are using.  */\n-  if (command_line.interpreter != NULL\n-      && sinterp != NULL)\n-    {\n-      sinterp->contents = (bfd_byte *) command_line.interpreter;\n-      sinterp->size = strlen (command_line.interpreter) + 1;\n-    }\n-\n-  /* Look for any sections named .gnu.warning.  As a GNU extensions,\n-     we treat such sections as containing warning messages.  We print\n-     out the warning message, and then zero out the section size so\n-     that it does not get copied into the output file.  */\n-\n-  {\n-    LANG_FOR_EACH_INPUT_STATEMENT (is)\n-      {\n-\tasection *s;\n-\tbfd_size_type sz;\n-\tchar *msg;\n-\n-\tif (is->flags.just_syms)\n-\t  continue;\n-\n-\ts = bfd_get_section_by_name (is->the_bfd, \".gnu.warning\");\n-\tif (s == NULL)\n-\t  continue;\n-\n-\tsz = s->size;\n-\tmsg = (char *) xmalloc ((size_t) (sz + 1));\n-\tif (! bfd_get_section_contents (is->the_bfd, s,\tmsg,\n-\t\t\t\t\t(file_ptr) 0, sz))\n-\t  einfo (_(\"%F%P: %pB: can't read contents of section .gnu.warning: %E\\n\"),\n-\t\t is->the_bfd);\n-\tmsg[sz] = '\\0';\n-\t(*link_info.callbacks->warning) (&link_info, msg,\n-\t\t\t\t\t (const char *) NULL, is->the_bfd,\n-\t\t\t\t\t (asection *) NULL, (bfd_vma) 0);\n-\tfree (msg);\n-\n-\t/* Clobber the section size, so that we don't waste space\n-\t   copying the warning into the output file.  If we've already\n-\t   sized the output section, adjust its size.  The adjustment\n-\t   is on rawsize because targets that size sections early will\n-\t   have called lang_reset_memory_regions after sizing.  */\n-\tif (s->output_section != NULL\n-\t    && s->output_section->rawsize >= s->size)\n-\t  s->output_section->rawsize -= s->size;\n-\n-\ts->size = 0;\n-\n-\t/* Also set SEC_EXCLUDE, so that local symbols defined in the\n-\t   warning section don't get copied to the output.  */\n-\ts->flags |= SEC_EXCLUDE | SEC_KEEP;\n-      }\n-  }\n-\n-  before_allocation_default ();\n-\n-  if (!bfd_elf_size_dynsym_hash_dynstr (link_info.output_bfd, &link_info))\n-    einfo (_(\"%F%P: failed to set dynamic section sizes: %E\\n\"));\n-\n-  if (ehdr_start != NULL)\n-    {\n-      /* If we twiddled __ehdr_start to defined earlier, put it back\n-\t as it was.  */\n-      ehdr_start->type = ehdr_start_save_type;\n-      memcpy ((char *) &ehdr_start->u + sizeof ehdr_start->u.def.next,\n-\t      ehdr_start_save_u,\n-\t      sizeof ehdr_start_save_u);\n-    }\n-}\n-\n-EOF\n-fi\n-\n-if test x\"$LDEMUL_OPEN_DYNAMIC_ARCHIVE\" != xgld\"$EMULATION_NAME\"_open_dynamic_archive; then\n-fragment <<EOF\n-\n-/* Try to open a dynamic archive.  This is where we know that ELF\n-   dynamic libraries have an extension of .so (or .sl on oddball systems\n-   like hpux).  */\n-\n-static bfd_boolean\n-gld${EMULATION_NAME}_open_dynamic_archive\n-  (const char *arch, search_dirs_type *search, lang_input_statement_type *entry)\n-{\n-  const char *filename;\n-  char *string;\n-  size_t len;\n-  bfd_boolean opened = FALSE;\n-\n-  if (! entry->flags.maybe_archive)\n-    return FALSE;\n-\n-  filename = entry->filename;\n-  len = strlen (search->name) + strlen (filename);\n-  if (entry->flags.full_name_provided)\n-    {\n-      len += sizeof \"/\";\n-      string = (char *) xmalloc (len);\n-      sprintf (string, \"%s/%s\", search->name, filename);\n-    }\n-  else\n-    {\n-      size_t xlen = 0;\n-\n-      len += strlen (arch) + sizeof \"/lib.so\";\n-#ifdef EXTRA_SHLIB_EXTENSION\n-      xlen = (strlen (EXTRA_SHLIB_EXTENSION) > 3\n-\t      ? strlen (EXTRA_SHLIB_EXTENSION) - 3\n-\t      : 0);\n-#endif\n-      string = (char *) xmalloc (len + xlen);\n-      sprintf (string, \"%s/lib%s%s.so\", search->name, filename, arch);\n-#ifdef EXTRA_SHLIB_EXTENSION\n-      /* Try the .so extension first.  If that fails build a new filename\n-\t using EXTRA_SHLIB_EXTENSION.  */\n-      opened = ldfile_try_open_bfd (string, entry);\n-      if (!opened)\n-\tstrcpy (string + len - 4, EXTRA_SHLIB_EXTENSION);\n-#endif\n-    }\n-\n-  if (!opened && !ldfile_try_open_bfd (string, entry))\n-    {\n-      free (string);\n-      return FALSE;\n-    }\n-\n-  entry->filename = string;\n-\n-  /* We have found a dynamic object to include in the link.  The ELF\n-     backend linker will create a DT_NEEDED entry in the .dynamic\n-     section naming this file.  If this file includes a DT_SONAME\n-     entry, it will be used.  Otherwise, the ELF linker will just use\n-     the name of the file.  For an archive found by searching, like\n-     this one, the DT_NEEDED entry should consist of just the name of\n-     the file, without the path information used to find it.  Note\n-     that we only need to do this if we have a dynamic object; an\n-     archive will never be referenced by a DT_NEEDED entry.\n-\n-     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not\n-     very pretty.  I haven't been able to think of anything that is\n-     pretty, though.  */\n-  if (bfd_check_format (entry->the_bfd, bfd_object)\n-      && (entry->the_bfd->flags & DYNAMIC) != 0)\n-    {\n-      ASSERT (entry->flags.maybe_archive && entry->flags.search_dirs);\n-\n-      /* Rather than duplicating the logic above.  Just use the\n-\t filename we recorded earlier.  */\n-\n-      if (!entry->flags.full_name_provided)\n-\tfilename = lbasename (entry->filename);\n-      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);\n-    }\n-\n-  return TRUE;\n-}\n-\n-EOF\n-fi\n-\n-if test x\"$LDEMUL_PLACE_ORPHAN\" != xgld\"$EMULATION_NAME\"_place_orphan; then\n-fragment <<EOF\n-\n-/* A variant of lang_output_section_find used by place_orphan.  */\n-\n-static lang_output_section_statement_type *\n-output_rel_find (int isdyn, int rela)\n-{\n-  lang_output_section_statement_type *lookup;\n-  lang_output_section_statement_type *last = NULL;\n-  lang_output_section_statement_type *last_alloc = NULL;\n-  lang_output_section_statement_type *last_ro_alloc = NULL;\n-  lang_output_section_statement_type *last_rel = NULL;\n-  lang_output_section_statement_type *last_rel_alloc = NULL;\n-\n-  for (lookup = &lang_os_list.head->output_section_statement;\n-       lookup != NULL;\n-       lookup = lookup->next)\n-    {\n-      if (lookup->constraint >= 0\n-\t  && CONST_STRNEQ (lookup->name, \".rel\"))\n-\t{\n-\t  int lookrela = lookup->name[4] == 'a';\n-\n-\t  /* .rel.dyn must come before all other reloc sections, to suit\n-\t     GNU ld.so.  */\n-\t  if (isdyn)\n-\t    break;\n-\n-\t  /* Don't place after .rel.plt as doing so results in wrong\n-\t     dynamic tags.  */\n-\t  if (strcmp (\".plt\", lookup->name + 4 + lookrela) == 0)\n-\t    break;\n-\n-\t  if (rela == lookrela || last_rel == NULL)\n-\t    last_rel = lookup;\n-\t  if ((rela == lookrela || last_rel_alloc == NULL)\n-\t      && lookup->bfd_section != NULL\n-\t      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)\n-\t    last_rel_alloc = lookup;\n-\t}\n-\n-      last = lookup;\n-      if (lookup->bfd_section != NULL\n-\t  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)\n-\t{\n-\t  last_alloc = lookup;\n-\t  if ((lookup->bfd_section->flags & SEC_READONLY) != 0)\n-\t    last_ro_alloc = lookup;\n-\t}\n-    }\n-\n-  if (last_rel_alloc)\n-    return last_rel_alloc;\n-\n-  if (last_rel)\n-    return last_rel;\n-\n-  if (last_ro_alloc)\n-    return last_ro_alloc;\n-\n-  if (last_alloc)\n-    return last_alloc;\n-\n-  return last;\n-}\n-\n-/* Return whether IN is suitable to be part of OUT.  */\n-\n-static bfd_boolean\n-elf_orphan_compatible (asection *in, asection *out)\n-{\n-  /* Non-zero sh_info implies a section with SHF_INFO_LINK with\n-     unknown semantics for the generic linker, or a SHT_REL/SHT_RELA\n-     section where sh_info specifies a symbol table.  (We won't see\n-     SHT_GROUP, SHT_SYMTAB or SHT_DYNSYM sections here.)  We clearly\n-     can't merge SHT_REL/SHT_RELA using differing symbol tables, and\n-     shouldn't merge sections with differing unknown semantics.  */\n-  if (elf_section_data (out)->this_hdr.sh_info\n-      != elf_section_data (in)->this_hdr.sh_info)\n-    return FALSE;\n-  /* We can't merge with member of output section group nor merge two\n-     sections with differing SHF_EXCLUDE when doing a relocatable link.\n-   */\n-  if (bfd_link_relocatable (&link_info)\n-      && (elf_next_in_group (out) != NULL\n-\t  || ((elf_section_flags (out) ^ elf_section_flags (in))\n-\t      & SHF_EXCLUDE) != 0))\n-    return FALSE;\n-  return _bfd_elf_match_sections_by_type (link_info.output_bfd, out,\n-\t\t\t\t\t  in->owner, in);\n-}\n-\n-/* Place an orphan section.  We use this to put random SHF_ALLOC\n-   sections in the right segment.  */\n-\n-static lang_output_section_statement_type *\n-gld${EMULATION_NAME}_place_orphan (asection *s,\n-\t\t\t\t   const char *secname,\n-\t\t\t\t   int constraint)\n-{\n-  static struct orphan_save hold[] =\n-    {\n-      { \".text\",\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,\n-\t0, 0, 0, 0 },\n-      { \".rodata\",\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,\n-\t0, 0, 0, 0 },\n-      { \".tdata\",\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_THREAD_LOCAL,\n-\t0, 0, 0, 0 },\n-      { \".data\",\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,\n-\t0, 0, 0, 0 },\n-      { \".bss\",\n-\tSEC_ALLOC,\n-\t0, 0, 0, 0 },\n-      { 0,\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,\n-\t0, 0, 0, 0 },\n-      { \".interp\",\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,\n-\t0, 0, 0, 0 },\n-      { \".sdata\",\n-\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_SMALL_DATA,\n-\t0, 0, 0, 0 },\n-      { \".comment\",\n-\tSEC_HAS_CONTENTS,\n-\t0, 0, 0, 0 },\n-    };\n-  enum orphan_save_index\n-    {\n-      orphan_text = 0,\n-      orphan_rodata,\n-      orphan_tdata,\n-      orphan_data,\n-      orphan_bss,\n-      orphan_rel,\n-      orphan_interp,\n-      orphan_sdata,\n-      orphan_nonalloc\n-    };\n-  static int orphan_init_done = 0;\n-  struct orphan_save *place;\n-  lang_output_section_statement_type *after;\n-  lang_output_section_statement_type *os;\n-  lang_output_section_statement_type *match_by_name = NULL;\n-  int isdyn = 0;\n-  int elfinput = s->owner->xvec->flavour == bfd_target_elf_flavour;\n-  int elfoutput = link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour;\n-  unsigned int sh_type = elfinput ? elf_section_type (s) : SHT_NULL;\n-  flagword flags;\n-  asection *nexts;\n-\n-  if (!bfd_link_relocatable (&link_info)\n-      && link_info.combreloc\n-      && (s->flags & SEC_ALLOC))\n-    {\n-      if (elfinput)\n-\tswitch (sh_type)\n-\t  {\n-\t  case SHT_RELA:\n-\t    secname = \".rela.dyn\";\n-\t    isdyn = 1;\n-\t    break;\n-\t  case SHT_REL:\n-\t    secname = \".rel.dyn\";\n-\t    isdyn = 1;\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n-      else if (CONST_STRNEQ (secname, \".rel\"))\n-\t{\n-\t  secname = secname[4] == 'a' ? \".rela.dyn\" : \".rel.dyn\";\n-\t  isdyn = 1;\n-\t}\n-    }\n-\n-  if (!bfd_link_relocatable (&link_info)\n-      && elfinput\n-      && elfoutput\n-      && (s->flags & SEC_ALLOC) != 0\n-      && (elf_tdata (s->owner)->has_gnu_osabi & elf_gnu_osabi_mbind) != 0\n-      && (elf_section_flags (s) & SHF_GNU_MBIND) != 0)\n-    {\n-      /* Find the output mbind section with the same type, attributes\n-\t and sh_info field.  */\n-      for (os = &lang_os_list.head->output_section_statement;\n-\t   os != NULL;\n-\t   os = os->next)\n-\tif (os->bfd_section != NULL\n-\t    && !bfd_is_abs_section (os->bfd_section)\n-\t    && (elf_section_flags (os->bfd_section) & SHF_GNU_MBIND) != 0\n-\t    && ((s->flags & (SEC_ALLOC\n-\t\t\t     | SEC_LOAD\n-\t\t\t     | SEC_HAS_CONTENTS\n-\t\t\t     | SEC_READONLY\n-\t\t\t     | SEC_CODE))\n-\t\t== (os->bfd_section->flags & (SEC_ALLOC\n-\t\t\t\t\t      | SEC_LOAD\n-\t\t\t\t\t      | SEC_HAS_CONTENTS\n-\t\t\t\t\t      | SEC_READONLY\n-\t\t\t\t\t      | SEC_CODE)))\n-\t    && (elf_section_data (os->bfd_section)->this_hdr.sh_info\n-\t\t== elf_section_data (s)->this_hdr.sh_info))\n-\t    {\n-\t      lang_add_section (&os->children, s, NULL, os);\n-\t      return os;\n-\t    }\n-\n-      /* Create the output mbind section with the \".mbind.\" prefix\n-\t in section name.  */\n-      if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)\n-\tsecname = \".mbind.bss\";\n-      else if ((s->flags & SEC_READONLY) == 0)\n-\tsecname = \".mbind.data\";\n-      else if ((s->flags & SEC_CODE) == 0)\n-\tsecname = \".mbind.rodata\";\n-      else\n-\tsecname = \".mbind.text\";\n-      elf_tdata (link_info.output_bfd)->has_gnu_osabi |= elf_gnu_osabi_mbind;\n-    }\n-\n-  /* Look through the script to see where to place this section.  The\n-     script includes entries added by previous lang_insert_orphan\n-     calls, so this loop puts multiple compatible orphans of the same\n-     name into a single output section.  */\n-  if (constraint == 0)\n-    for (os = lang_output_section_find (secname);\n-\t os != NULL;\n-\t os = next_matching_output_section_statement (os, 0))\n-      {\n-\t/* If we don't match an existing output section, tell\n-\t   lang_insert_orphan to create a new output section.  */\n-\tconstraint = SPECIAL;\n-\n-\t/* Check to see if we already have an output section statement\n-\t   with this name, and its bfd section has compatible flags.\n-\t   If the section already exists but does not have any flags\n-\t   set, then it has been created by the linker, possibly as a\n-\t   result of a --section-start command line switch.  */\n-\tif (os->bfd_section != NULL\n-\t    && (os->bfd_section->flags == 0\n-\t\t|| (((s->flags ^ os->bfd_section->flags)\n-\t\t     & (SEC_LOAD | SEC_ALLOC)) == 0\n-\t\t    && (!elfinput\n-\t\t\t|| !elfoutput\n-\t\t\t|| elf_orphan_compatible (s, os->bfd_section)))))\n-\t  {\n-\t    lang_add_section (&os->children, s, NULL, os);\n-\t    return os;\n-\t  }\n-\n-\t/* Save unused output sections in case we can match them\n-\t   against orphans later.  */\n-\tif (os->bfd_section == NULL)\n-\t  match_by_name = os;\n-      }\n-\n-  /* If we didn't match an active output section, see if we matched an\n-     unused one and use that.  */\n-  if (match_by_name)\n-    {\n-      lang_add_section (&match_by_name->children, s, NULL, match_by_name);\n-      return match_by_name;\n-    }\n-\n-  if (!orphan_init_done)\n-    {\n-      struct orphan_save *ho;\n-\n-      for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)\n-\tif (ho->name != NULL)\n-\t  {\n-\t    ho->os = lang_output_section_find (ho->name);\n-\t    if (ho->os != NULL && ho->os->flags == 0)\n-\t      ho->os->flags = ho->flags;\n-\t  }\n-      orphan_init_done = 1;\n-    }\n-\n-  /* If this is a final link, then always put .gnu.warning.SYMBOL\n-     sections into the .text section to get them out of the way.  */\n-  if (bfd_link_executable (&link_info)\n-      && CONST_STRNEQ (s->name, \".gnu.warning.\")\n-      && hold[orphan_text].os != NULL)\n-    {\n-      os = hold[orphan_text].os;\n-      lang_add_section (&os->children, s, NULL, os);\n-      return os;\n-    }\n-\n-  flags = s->flags;\n-  if (!bfd_link_relocatable (&link_info))\n-    {\n-      nexts = s;\n-      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts))\n-\t     != NULL)\n-\tif (nexts->output_section == NULL\n-\t    && (nexts->flags & SEC_EXCLUDE) == 0\n-\t    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0\n-\t    && (nexts->owner->flags & DYNAMIC) == 0\n-\t    && nexts->owner->usrdata != NULL\n-\t    && !(((lang_input_statement_type *) nexts->owner->usrdata)\n-\t\t ->flags.just_syms)\n-\t    && _bfd_elf_match_sections_by_type (nexts->owner, nexts,\n-\t\t\t\t\t\ts->owner, s))\n-\t  flags = (((flags ^ SEC_READONLY)\n-\t\t    | (nexts->flags ^ SEC_READONLY))\n-\t\t   ^ SEC_READONLY);\n-    }\n-\n-  /* Decide which segment the section should go in based on the\n-     section name and section flags.  We put loadable .note sections\n-     right after the .interp section, so that the PT_NOTE segment is\n-     stored right after the program headers where the OS can read it\n-     in the first page.  */\n-\n-  place = NULL;\n-  if ((flags & (SEC_ALLOC | SEC_DEBUGGING)) == 0)\n-    place = &hold[orphan_nonalloc];\n-  else if ((flags & SEC_ALLOC) == 0)\n-    ;\n-  else if ((flags & SEC_LOAD) != 0\n-\t   && (elfinput\n-\t       ? sh_type == SHT_NOTE\n-\t       : CONST_STRNEQ (secname, \".note\")))\n-    place = &hold[orphan_interp];\n-  else if ((flags & (SEC_LOAD | SEC_HAS_CONTENTS | SEC_THREAD_LOCAL)) == 0)\n-    place = &hold[orphan_bss];\n-  else if ((flags & SEC_SMALL_DATA) != 0)\n-    place = &hold[orphan_sdata];\n-  else if ((flags & SEC_THREAD_LOCAL) != 0)\n-    place = &hold[orphan_tdata];\n-  else if ((flags & SEC_READONLY) == 0)\n-    place = &hold[orphan_data];\n-  else if ((flags & SEC_LOAD) != 0\n-\t   && (elfinput\n-\t       ? sh_type == SHT_RELA || sh_type == SHT_REL\n-\t       : CONST_STRNEQ (secname, \".rel\")))\n-    place = &hold[orphan_rel];\n-  else if ((flags & SEC_CODE) == 0)\n-    place = &hold[orphan_rodata];\n-  else\n-    place = &hold[orphan_text];\n-\n-  after = NULL;\n-  if (place != NULL)\n-    {\n-      if (place->os == NULL)\n-\t{\n-\t  if (place->name != NULL)\n-\t    place->os = lang_output_section_find (place->name);\n-\t  else\n-\t    {\n-\t      int rela = elfinput ? sh_type == SHT_RELA : secname[4] == 'a';\n-\t      place->os = output_rel_find (isdyn, rela);\n-\t    }\n-\t}\n-      after = place->os;\n-      if (after == NULL)\n-\tafter\n-\t  = lang_output_section_find_by_flags (s, flags, &place->os,\n-\t\t\t\t\t       _bfd_elf_match_sections_by_type);\n-      if (after == NULL)\n-\t/* *ABS* is always the first output section statement.  */\n-\tafter = &lang_os_list.head->output_section_statement;\n-    }\n-\n-  return lang_insert_orphan (s, secname, constraint, after, place, NULL, NULL);\n-}\n EOF\n fi\n \n@@ -2334,7 +161,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n   if (need_layout < 0)\n     einfo (_(\"%X%P: .eh_frame/.stab edit: %E\\n\"));\n   else\n-    gld${EMULATION_NAME}_map_segments (need_layout);\n+    ldelf_map_segments (need_layout);\n }\n EOF\n fi\n@@ -2794,15 +621,15 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       return FALSE;\n \n     case OPTION_BUILD_ID:\n-      if (emit_note_gnu_build_id != NULL)\n+      if (ldelf_emit_note_gnu_build_id != NULL)\n \t{\n-\t  free ((char *) emit_note_gnu_build_id);\n-\t  emit_note_gnu_build_id = NULL;\n+\t  free ((char *) ldelf_emit_note_gnu_build_id);\n+\t  ldelf_emit_note_gnu_build_id = NULL;\n \t}\n       if (optarg == NULL)\n \toptarg = DEFAULT_BUILD_ID_STYLE;\n       if (strcmp (optarg, \"none\"))\n-\temit_note_gnu_build_id = xstrdup (optarg);\n+\tldelf_emit_note_gnu_build_id = xstrdup (optarg);\n       break;\n \n     case OPTION_COMPRESS_DEBUG:\n@@ -2823,11 +650,11 @@ EOF\n if test x\"$GENERATE_SHLIB_SCRIPT\" = xyes; then\n fragment <<EOF\n     case OPTION_AUDIT:\n-\tgld${EMULATION_NAME}_append_to_separated_string (&audit, optarg);\n+\tldelf_append_to_separated_string (&audit, optarg);\n \tbreak;\n \n     case 'P':\n-\tgld${EMULATION_NAME}_append_to_separated_string (&depaudit, optarg);\n+\tldelf_append_to_separated_string (&depaudit, optarg);\n \tbreak;\n \n     case OPTION_DISABLE_NEW_DTAGS:\n@@ -3051,7 +878,7 @@ struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =\n   ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},\n   ${LDEMUL_SYSLIB-syslib_default},\n   ${LDEMUL_HLL-hll_default},\n-  ${LDEMUL_AFTER_PARSE-gld${EMULATION_NAME}_after_parse},\n+  ${LDEMUL_AFTER_PARSE-ldelf_after_parse},\n   ${LDEMUL_AFTER_OPEN-gld${EMULATION_NAME}_after_open},\n   ${LDEMUL_AFTER_CHECK_RELOCS-after_check_relocs_default},\n   ${LDEMUL_AFTER_ALLOCATION-gld${EMULATION_NAME}_after_allocation},\n@@ -3063,15 +890,15 @@ struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =\n   \"${OUTPUT_FORMAT}\",\n   ${LDEMUL_FINISH-finish_default},\n   ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},\n-  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-gld${EMULATION_NAME}_open_dynamic_archive},\n-  ${LDEMUL_PLACE_ORPHAN-gld${EMULATION_NAME}_place_orphan},\n+  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-ldelf_open_dynamic_archive},\n+  ${LDEMUL_PLACE_ORPHAN-ldelf_place_orphan},\n   ${LDEMUL_SET_SYMBOLS-NULL},\n   ${LDEMUL_PARSE_ARGS-NULL},\n   gld${EMULATION_NAME}_add_options,\n   gld${EMULATION_NAME}_handle_option,\n   ${LDEMUL_UNRECOGNIZED_FILE-NULL},\n   ${LDEMUL_LIST_OPTIONS-${gld_list_options}},\n-  ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},\n+  ${LDEMUL_RECOGNIZED_FILE-ldelf_load_symbols},\n   ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},\n   ${LDEMUL_NEW_VERS_PATTERN-NULL},\n   ${LDEMUL_EXTRA_MAP_FILE_TEXT-NULL}"
    },
    {
      "sha": "9c5898d31fcd2596db5f8f439c0d6febf06cdfc2",
      "filename": "ld/emultempl/genelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/genelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/genelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/genelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -23,6 +23,7 @@\n #\n fragment <<EOF\n #include \"elf-bfd.h\"\n+#include \"ldelfgen.h\"\n \n EOF\n source_em ${srcdir}/emultempl/elf-generic.em\n@@ -63,7 +64,7 @@ gld${EMULATION_NAME}_before_allocation (void)\n static void\n gld${EMULATION_NAME}_after_allocation (void)\n {\n-  gld${EMULATION_NAME}_map_segments (FALSE);\n+  ldelf_map_segments (FALSE);\n }\n EOF\n # Put these extra routines in ld_${EMULATION_NAME}_emulation"
    },
    {
      "sha": "547ab9b39835e4322931a4a08d1f6e5601214630",
      "filename": "ld/emultempl/hppaelf.em",
      "status": "modified",
      "additions": 3,
      "deletions": 24,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/hppaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/hppaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/hppaelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -59,7 +59,7 @@ hppaelf_after_parse (void)\n \t\t\t  NULL);\n   */\n \n-  gld${EMULATION_NAME}_after_parse ();\n+  ldelf_after_parse ();\n }\n \n /* This is called before the input files are opened.  We create a new\n@@ -215,7 +215,7 @@ hppaelf_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n   need_laying_out = -1;\n }\n \n@@ -289,7 +289,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n \n   if (need_laying_out != -1)\n-    gld${EMULATION_NAME}_map_segments (need_laying_out);\n+    ldelf_map_segments (need_laying_out);\n \n   if (!bfd_link_relocatable (&link_info))\n     {\n@@ -309,27 +309,6 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n }\n \n-\n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void hppa_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-hppa_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&hppa_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file hppa_lang_for_each_input_file\n-\n EOF\n \n # Define some shell vars to insert bits of code into the standard elf"
    },
    {
      "sha": "e67a04ca105904fb115403ee7ee525cefee16849",
      "filename": "ld/emultempl/ia64elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/ia64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/ia64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ia64elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -36,7 +36,7 @@ ia64elf_after_parse (void)\n   link_info.relax_pass = 2;\n   bfd_elf${ELFSIZE}_ia64_after_parse (itanium);\n \n-  gld${EMULATION_NAME}_after_parse ();\n+  ldelf_after_parse ();\n }\n \n EOF"
    },
    {
      "sha": "3fa325a4498aa8dbee8c3d27aec3e3a66cb857d4",
      "filename": "ld/emultempl/m68hc1xelf.em",
      "status": "modified",
      "additions": 0,
      "deletions": 21,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/m68hc1xelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/m68hc1xelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/m68hc1xelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -319,27 +319,6 @@ m68hc11elf_after_allocation (void)\n   gld${EMULATION_NAME}_after_allocation ();\n }\n \n-\n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void m68hc11_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-m68hc11_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&m68hc11_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file m68hc11_lang_for_each_input_file\n-\n EOF\n \n # Define some shell vars to insert bits of code into the standard elf"
    },
    {
      "sha": "966d19c16650e5d3f3b58bc4d58cee282c03d01e",
      "filename": "ld/emultempl/metagelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 23,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/metagelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/metagelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/metagelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -191,7 +191,7 @@ metagelf_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n   need_laying_out = -1;\n }\n \n@@ -264,7 +264,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n \n   if (need_laying_out != -1)\n-    gld${EMULATION_NAME}_map_segments (need_laying_out);\n+    ldelf_map_segments (need_laying_out);\n \n   if (!bfd_link_relocatable (&link_info))\n     {\n@@ -277,27 +277,6 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n }\n \n-\n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void metag_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-metag_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&metag_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file metag_lang_for_each_input_file\n-\n EOF\n \n # Define some shell vars to insert bits of code into the standard elf"
    },
    {
      "sha": "108d33faf3382cef617a0e627da101e7adcb3c22",
      "filename": "ld/emultempl/mipself.em",
      "status": "modified",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/mipself.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/mipself.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mipself.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -227,26 +227,6 @@ mips_before_allocation (void)\n   gld${EMULATION_NAME}_before_allocation ();\n }\n \n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void mips_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-mips_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&mips_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file mips_lang_for_each_input_file\n-\n EOF\n \n # Define some shell vars to insert bits of code into the standard elf"
    },
    {
      "sha": "b4b4f1e725c1206c079f41afc08ea0324aaf7050",
      "filename": "ld/emultempl/mmo.em",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/mmo.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/mmo.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmo.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -29,11 +29,10 @@ fragment <<EOF\n #define gldmmo_before_allocation before_allocation_default\n \n /* We include this header *not* because we expect to handle ELF here\n-   but because we re-use the map_segments function in elf-generic.em,\n-   a file which is rightly somewhat ELF-centric.  But this is only to\n+   but because we use the map_segments function.  But this is only to\n    get a weird testcase right; ld-mmix/bpo-22, forcing ELF to be\n    output from the mmo emulation: -m mmo --oformat elf64-mmix!  */\n-#include \"elf-bfd.h\"\n+#include \"ldelfgen.h\"\n \n static void gld${EMULATION_NAME}_after_allocation (void);\n EOF\n@@ -205,7 +204,7 @@ static void\n gld${EMULATION_NAME}_after_allocation (void)\n {\n   bfd_map_over_sections (link_info.output_bfd, mmo_wipe_sec_reloc_flag, NULL);\n-  gld${EMULATION_NAME}_map_segments (FALSE);\n+  ldelf_map_segments (FALSE);\n }\n \f\n /* To get on-demand global register allocation right, we need to parse the"
    },
    {
      "sha": "00e997590b0e51a8b5dd81771e197b2d8271e12a",
      "filename": "ld/emultempl/nds32elf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/nds32elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/nds32elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/nds32elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -68,7 +68,7 @@ nds32_elf_after_parse (void)\n   if (!RELAXATION_ENABLED)\n     relax_fp_as_gp = 0;\n \n-  gld${EMULATION_NAME}_after_parse ();\n+  ldelf_after_parse ();\n }\n \n static void\n@@ -123,7 +123,7 @@ nds32_elf_after_allocation (void)\n {\n   /* Call default after allocation callback.\n      1. This is where relaxation is done.\n-     2. It calls gld${EMULATION_NAME}_map_segments to build ELF segment table.\n+     2. It calls ldelf_map_segments to build ELF segment table.\n      3. Any relaxation requires relax being done must be called after it.  */\n   gld${EMULATION_NAME}_after_allocation ();\n }"
    },
    {
      "sha": "676c1fbbf7df8efbd8ecb4f3d9893300e3a0f8b6",
      "filename": "ld/emultempl/nios2elf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 23,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/nios2elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/nios2elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/nios2elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -208,7 +208,7 @@ nios2elf_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n   need_laying_out = -1;\n }\n \n@@ -282,7 +282,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n \n   if (need_laying_out != -1)\n-    gld${EMULATION_NAME}_map_segments (need_laying_out);\n+    ldelf_map_segments (need_laying_out);\n \n   if (!bfd_link_relocatable (&link_info) && RELAXATION_ENABLED)\n     {\n@@ -295,27 +295,6 @@ gld${EMULATION_NAME}_after_allocation (void)\n     }\n }\n \n-\n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void nios2_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-nios2_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&nios2_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file nios2_lang_for_each_input_file\n-\n EOF\n \n "
    },
    {
      "sha": "eb75373224b9ec9c9ead2516197630f15593ef4c",
      "filename": "ld/emultempl/ppc32elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/ppc32elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/ppc32elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ppc32elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -247,15 +247,14 @@ if grep -q 'ld_elf32_spu_emulation' ldemul-list.h; then\n   fragment <<EOF\n /* Special handling for embedded SPU executables.  */\n extern bfd_boolean embedded_spu_file (lang_input_statement_type *, const char *);\n-static bfd_boolean gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *);\n \n static bfd_boolean\n ppc_recognized_file (lang_input_statement_type *entry)\n {\n   if (embedded_spu_file (entry, \"-m32\"))\n     return TRUE;\n \n-  return gld${EMULATION_NAME}_load_symbols (entry);\n+  return ldelf_load_symbols (entry);\n }\n \n EOF"
    },
    {
      "sha": "ef1fd0e7bcaa90faf10b234e400adc947e05ecd3",
      "filename": "ld/emultempl/ppc64elf.em",
      "status": "modified",
      "additions": 3,
      "deletions": 25,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/ppc64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/ppc64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ppc64elf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -456,7 +456,7 @@ ppc_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  gld${EMULATION_NAME}_map_segments (TRUE);\n+  ldelf_map_segments (TRUE);\n \n   if (!bfd_link_relocatable (&link_info))\n     ppc64_elf_set_toc (&link_info, link_info.output_bfd);\n@@ -565,7 +565,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n      unneeded, after ppc_layout_sections_again.  Another call removes\n      these sections from the segment map.  Their presence is\n      innocuous except for confusing ELF_SECTION_IN_SEGMENT.  */\n-  gld${EMULATION_NAME}_map_segments (need_laying_out > 0);\n+  ldelf_map_segments (need_laying_out > 0);\n \n   if (need_laying_out != -1 && !bfd_link_relocatable (&link_info))\n     ppc64_elf_set_toc (&link_info, link_info.output_bfd);\n@@ -652,42 +652,20 @@ gld${EMULATION_NAME}_new_vers_pattern (struct bfd_elf_version_expr *entry)\n   return dot_entry;\n }\n \n-\n-/* Avoid processing the fake stub_file in vercheck, stat_needed and\n-   check_needed routines.  */\n-\n-static void (*real_func) (lang_input_statement_type *);\n-\n-static void ppc_for_each_input_file_wrapper (lang_input_statement_type *l)\n-{\n-  if (l != stub_file)\n-    (*real_func) (l);\n-}\n-\n-static void\n-ppc_lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n-{\n-  real_func = func;\n-  lang_for_each_input_file (&ppc_for_each_input_file_wrapper);\n-}\n-\n-#define lang_for_each_input_file ppc_lang_for_each_input_file\n-\n EOF\n \n if grep -q 'ld_elf32_spu_emulation' ldemul-list.h; then\n   fragment <<EOF\n /* Special handling for embedded SPU executables.  */\n extern bfd_boolean embedded_spu_file (lang_input_statement_type *, const char *);\n-static bfd_boolean gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *);\n \n static bfd_boolean\n ppc64_recognized_file (lang_input_statement_type *entry)\n {\n   if (embedded_spu_file (entry, \"-m64\"))\n     return TRUE;\n \n-  return gld${EMULATION_NAME}_load_symbols (entry);\n+  return ldelf_load_symbols (entry);\n }\n EOF\n LDEMUL_RECOGNIZED_FILE=ppc64_recognized_file"
    },
    {
      "sha": "ebc07df95cfa9e69d680f1c8d223c94508de5b28",
      "filename": "ld/emultempl/riscvelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/riscvelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/riscvelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/riscvelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -62,7 +62,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n \t}\n     }\n \n-  gld${EMULATION_NAME}_map_segments (need_layout);\n+  ldelf_map_segments (need_layout);\n }\n \n /* This is a convenient point to tell BFD about target specific flags."
    },
    {
      "sha": "54f9f8fcab68943c7d6f304c61c77792b7902aea",
      "filename": "ld/emultempl/spuelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/spuelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/spuelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/spuelf.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -142,7 +142,7 @@ spu_place_special_section (asection *s, asection *o, const char *output_name)\n     os = lang_output_section_find (output_name);\n   if (os == NULL)\n     {\n-      os = gld${EMULATION_NAME}_place_orphan (s, output_name, 0);\n+      os = ldelf_place_orphan (s, output_name, 0);\n       os->addr_tree = NULL;\n     }\n   else if (params.ovly_flavour != ovly_soft_icache"
    },
    {
      "sha": "a6e2792e689efdfc704f1f9b543fa35390e1fd29",
      "filename": "ld/emultempl/tic6xdsbt.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/tic6xdsbt.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/tic6xdsbt.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/tic6xdsbt.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -159,7 +159,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n   else if (ret > 0)\n     layout_changed = 1;\n \n-  gld${EMULATION_NAME}_map_segments (layout_changed);\n+  ldelf_map_segments (layout_changed);\n }\n EOF\n "
    },
    {
      "sha": "c7e0b784b38ef63aeadee7981d99b9bac30fe186",
      "filename": "ld/emultempl/vms.em",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/vms.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/emultempl/vms.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/vms.em?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -174,6 +174,7 @@ if test \"$OUTPUT_FORMAT\" = \"elf64-ia64-vms\"; then\n \n fragment <<EOF\n #include \"elf-bfd.h\"\n+#include \"ldelfgen.h\"\n EOF\n \n source_em ${srcdir}/emultempl/elf-generic.em\n@@ -212,7 +213,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n   if (need_layout < 0)\n     einfo (_(\"%X%P: .eh_frame/.stab edit: %E\\n\"));\n   else\n-    gld${EMULATION_NAME}_map_segments (need_layout);\n+    ldelf_map_segments (need_layout);\n }\n \n static void"
    },
    {
      "sha": "c88712fbe5d4ae110a3c093050600f8f59149549",
      "filename": "ld/ldelf.c",
      "status": "added",
      "additions": 2135,
      "deletions": 0,
      "changes": 2135,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.c?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -0,0 +1,2135 @@\n+/* ELF emulation code for targets using elf32.em.\n+   Copyright (C) 1991-2019 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Binutils.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"sysdep.h\"\n+#include \"bfd.h\"\n+#include \"libiberty.h\"\n+#include \"filenames.h\"\n+#include \"ld.h\"\n+#include \"ldmain.h\"\n+#include \"ldmisc.h\"\n+#include \"ldexp.h\"\n+#include \"ldlang.h\"\n+#include \"ldfile.h\"\n+#include \"ldemul.h\"\n+#include \"ldbuildid.h\"\n+#include <ldgram.h>\n+#include \"elf-bfd.h\"\n+#ifdef HAVE_GLOB\n+#include <glob.h>\n+#endif\n+#include \"ldelf.h\"\n+\n+struct dt_needed\n+{\n+  bfd *by;\n+  const char *name;\n+};\n+\n+/* Style of .note.gnu.build-id section.  */\n+const char *ldelf_emit_note_gnu_build_id;\n+\n+/* These variables are required to pass information back and forth\n+   between after_open and check_needed and stat_needed and vercheck.  */\n+\n+static struct bfd_link_needed_list *global_needed;\n+static lang_input_statement_type *global_found;\n+static struct stat global_stat;\n+static struct bfd_link_needed_list *global_vercheck_needed;\n+static bfd_boolean global_vercheck_failed;\n+\n+void\n+ldelf_after_parse (void)\n+{\n+  if (bfd_link_pie (&link_info))\n+    link_info.flags_1 |= (bfd_vma) DF_1_PIE;\n+\n+  if (bfd_link_executable (&link_info)\n+      && link_info.nointerp)\n+    {\n+      if (link_info.dynamic_undefined_weak > 0)\n+\teinfo (_(\"%P: warning: -z dynamic-undefined-weak ignored\\n\"));\n+      link_info.dynamic_undefined_weak = 0;\n+    }\n+  after_parse_default ();\n+}\n+\n+/* Handle the generation of DT_NEEDED tags.  */\n+\n+bfd_boolean\n+ldelf_load_symbols (lang_input_statement_type *entry)\n+{\n+  int link_class = 0;\n+\n+  /* Tell the ELF linker that we don't want the output file to have a\n+     DT_NEEDED entry for this file, unless it is used to resolve\n+     references in a regular object.  */\n+  if (entry->flags.add_DT_NEEDED_for_regular)\n+    link_class = DYN_AS_NEEDED;\n+\n+  /* Tell the ELF linker that we don't want the output file to have a\n+     DT_NEEDED entry for any dynamic library in DT_NEEDED tags from\n+     this file at all.  */\n+  if (!entry->flags.add_DT_NEEDED_for_dynamic)\n+    link_class |= DYN_NO_ADD_NEEDED;\n+\n+  if (entry->flags.just_syms\n+      && (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) != 0)\n+    einfo (_(\"%F%P: %pB: --just-symbols may not be used on DSO\\n\"),\n+\t   entry->the_bfd);\n+\n+  if (link_class == 0\n+      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)\n+    return FALSE;\n+\n+  bfd_elf_set_dyn_lib_class (entry->the_bfd,\n+\t\t\t     (enum dynamic_lib_link_class) link_class);\n+\n+  /* Continue on with normal load_symbols processing.  */\n+  return FALSE;\n+}\n+\n+/* On Linux, it's possible to have different versions of the same\n+   shared library linked against different versions of libc.  The\n+   dynamic linker somehow tags which libc version to use in\n+   /etc/ld.so.cache, and, based on the libc that it sees in the\n+   executable, chooses which version of the shared library to use.\n+\n+   We try to do a similar check here by checking whether this shared\n+   library needs any other shared libraries which may conflict with\n+   libraries we have already included in the link.  If it does, we\n+   skip it, and try to find another shared library farther on down the\n+   link path.\n+\n+   This is called via lang_for_each_input_file.\n+   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object\n+   which we are checking.  This sets GLOBAL_VERCHECK_FAILED if we find\n+   a conflicting version.  */\n+\n+static void\n+ldelf_vercheck (lang_input_statement_type *s)\n+{\n+  const char *soname;\n+  struct bfd_link_needed_list *l;\n+\n+  if (global_vercheck_failed)\n+    return;\n+  if (s->the_bfd == NULL\n+      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)\n+    return;\n+\n+  soname = bfd_elf_get_dt_soname (s->the_bfd);\n+  if (soname == NULL)\n+    soname = lbasename (bfd_get_filename (s->the_bfd));\n+\n+  for (l = global_vercheck_needed; l != NULL; l = l->next)\n+    {\n+      const char *suffix;\n+\n+      if (filename_cmp (soname, l->name) == 0)\n+\t{\n+\t  /* Probably can't happen, but it's an easy check.  */\n+\t  continue;\n+\t}\n+\n+      if (strchr (l->name, '/') != NULL)\n+\tcontinue;\n+\n+      suffix = strstr (l->name, \".so.\");\n+      if (suffix == NULL)\n+\tcontinue;\n+\n+      suffix += sizeof \".so.\" - 1;\n+\n+      if (filename_ncmp (soname, l->name, suffix - l->name) == 0)\n+\t{\n+\t  /* Here we know that S is a dynamic object FOO.SO.VER1, and\n+\t     the object we are considering needs a dynamic object\n+\t     FOO.SO.VER2, and VER1 and VER2 are different.  This\n+\t     appears to be a version mismatch, so we tell the caller\n+\t     to try a different version of this library.  */\n+\t  global_vercheck_failed = TRUE;\n+\t  return;\n+\t}\n+    }\n+}\n+\n+\n+/* See if an input file matches a DT_NEEDED entry by running stat on\n+   the file.  */\n+\n+static void\n+ldelf_stat_needed (lang_input_statement_type *s)\n+{\n+  struct stat st;\n+  const char *suffix;\n+  const char *soname;\n+\n+  if (global_found != NULL)\n+    return;\n+  if (s->the_bfd == NULL)\n+    return;\n+\n+  /* If this input file was an as-needed entry, and wasn't found to be\n+     needed at the stage it was linked, then don't say we have loaded it.  */\n+  if ((bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)\n+    return;\n+\n+  if (bfd_stat (s->the_bfd, &st) != 0)\n+    {\n+      einfo (_(\"%P: %pB: bfd_stat failed: %E\\n\"), s->the_bfd);\n+      return;\n+    }\n+\n+  /* Some operating systems, e.g. Windows, do not provide a meaningful\n+     st_ino; they always set it to zero.  (Windows does provide a\n+     meaningful st_dev.)  Do not indicate a duplicate library in that\n+     case.  While there is no guarantee that a system that provides\n+     meaningful inode numbers will never set st_ino to zero, this is\n+     merely an optimization, so we do not need to worry about false\n+     negatives.  */\n+  if (st.st_dev == global_stat.st_dev\n+      && st.st_ino == global_stat.st_ino\n+      && st.st_ino != 0)\n+    {\n+      global_found = s;\n+      return;\n+    }\n+\n+  /* We issue a warning if it looks like we are including two\n+     different versions of the same shared library.  For example,\n+     there may be a problem if -lc picks up libc.so.6 but some other\n+     shared library has a DT_NEEDED entry of libc.so.5.  This is a\n+     heuristic test, and it will only work if the name looks like\n+     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.\n+     If we really want to issue warnings about mixing version numbers\n+     of shared libraries, we need to find a better way.  */\n+\n+  if (strchr (global_needed->name, '/') != NULL)\n+    return;\n+  suffix = strstr (global_needed->name, \".so.\");\n+  if (suffix == NULL)\n+    return;\n+  suffix += sizeof \".so.\" - 1;\n+\n+  soname = bfd_elf_get_dt_soname (s->the_bfd);\n+  if (soname == NULL)\n+    soname = lbasename (s->filename);\n+\n+  if (filename_ncmp (soname, global_needed->name,\n+\t\t     suffix - global_needed->name) == 0)\n+    einfo (_(\"%P: warning: %s, needed by %pB, may conflict with %s\\n\"),\n+\t   global_needed->name, global_needed->by, soname);\n+}\n+\n+/* This function is called for each possible name for a dynamic object\n+   named by a DT_NEEDED entry.  The FORCE parameter indicates whether\n+   to skip the check for a conflicting version.  */\n+\n+static bfd_boolean\n+ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n+{\n+  bfd *abfd;\n+  const char *name = needed->name;\n+  const char *soname;\n+  int link_class;\n+\n+  abfd = bfd_openr (name, bfd_get_target (link_info.output_bfd));\n+  if (abfd == NULL)\n+    {\n+      if (verbose)\n+\tinfo_msg (_(\"attempt to open %s failed\\n\"), name);\n+      return FALSE;\n+    }\n+\n+  /* Linker needs to decompress sections.  */\n+  abfd->flags |= BFD_DECOMPRESS;\n+\n+  if (! bfd_check_format (abfd, bfd_object))\n+    {\n+      bfd_close (abfd);\n+      return FALSE;\n+    }\n+  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)\n+    {\n+      bfd_close (abfd);\n+      return FALSE;\n+    }\n+\n+  /* For DT_NEEDED, they have to match.  */\n+  if (abfd->xvec != link_info.output_bfd->xvec)\n+    {\n+      bfd_close (abfd);\n+      return FALSE;\n+    }\n+\n+  /* Check whether this object would include any conflicting library\n+     versions.  If FORCE is set, then we skip this check; we use this\n+     the second time around, if we couldn't find any compatible\n+     instance of the shared library.  */\n+\n+  if (!force)\n+    {\n+      struct bfd_link_needed_list *needs;\n+\n+      if (! bfd_elf_get_bfd_needed_list (abfd, &needs))\n+\teinfo (_(\"%F%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\\n\"), abfd);\n+\n+      if (needs != NULL)\n+\t{\n+\t  global_vercheck_needed = needs;\n+\t  global_vercheck_failed = FALSE;\n+\t  lang_for_each_input_file (ldelf_vercheck);\n+\t  if (global_vercheck_failed)\n+\t    {\n+\t      bfd_close (abfd);\n+\t      /* Return FALSE to force the caller to move on to try\n+\t\t another file on the search path.  */\n+\t      return FALSE;\n+\t    }\n+\n+\t  /* But wait!  It gets much worse.  On Linux, if a shared\n+\t     library does not use libc at all, we are supposed to skip\n+\t     it the first time around in case we encounter a shared\n+\t     library later on with the same name which does use the\n+\t     version of libc that we want.  This is much too horrible\n+\t     to use on any system other than Linux.  */\n+\t  if (is_linux)\n+\t    {\n+\t      struct bfd_link_needed_list *l;\n+\n+\t      for (l = needs; l != NULL; l = l->next)\n+\t\tif (CONST_STRNEQ (l->name, \"libc.so\"))\n+\t\t  break;\n+\t      if (l == NULL)\n+\t\t{\n+\t\t  bfd_close (abfd);\n+\t\t  return FALSE;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* We've found a dynamic object matching the DT_NEEDED entry.  */\n+\n+  /* We have already checked that there is no other input file of the\n+     same name.  We must now check again that we are not including the\n+     same file twice.  We need to do this because on many systems\n+     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will\n+     reference libc.so.1.  If we have already included libc.so, we\n+     don't want to include libc.so.1 if they are the same file, and we\n+     can only check that using stat.  */\n+\n+  if (bfd_stat (abfd, &global_stat) != 0)\n+    einfo (_(\"%F%P: %pB: bfd_stat failed: %E\\n\"), abfd);\n+\n+  /* First strip off everything before the last '/'.  */\n+  soname = lbasename (bfd_get_filename (abfd));\n+\n+  if (verbose)\n+    info_msg (_(\"found %s at %s\\n\"), soname, name);\n+\n+  global_found = NULL;\n+  lang_for_each_input_file (ldelf_stat_needed);\n+  if (global_found != NULL)\n+    {\n+      /* Return TRUE to indicate that we found the file, even though\n+\t we aren't going to do anything with it.  */\n+      return TRUE;\n+    }\n+\n+  /* Specify the soname to use.  */\n+  bfd_elf_set_dt_needed_name (abfd, soname);\n+\n+  /* Tell the ELF linker that we don't want the output file to have a\n+     DT_NEEDED entry for this file, unless it is used to resolve\n+     references in a regular object.  */\n+  link_class = DYN_DT_NEEDED;\n+\n+  /* Tell the ELF linker that we don't want the output file to have a\n+     DT_NEEDED entry for this file at all if the entry is from a file\n+     with DYN_NO_ADD_NEEDED.  */\n+  if (needed->by != NULL\n+      && (bfd_elf_get_dyn_lib_class (needed->by) & DYN_NO_ADD_NEEDED) != 0)\n+    link_class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;\n+\n+  bfd_elf_set_dyn_lib_class (abfd, (enum dynamic_lib_link_class) link_class);\n+\n+  /* Add this file into the symbol table.  */\n+  if (! bfd_link_add_symbols (abfd, &link_info))\n+    einfo (_(\"%F%P: %pB: error adding symbols: %E\\n\"), abfd);\n+\n+  return TRUE;\n+}\n+\n+/* Search for a needed file in a path.  */\n+\n+static bfd_boolean\n+ldelf_search_needed (const char *path, struct dt_needed *n, int force,\n+\t\t     int is_linux, int elfsize)\n+{\n+  const char *s;\n+  const char *name = n->name;\n+  size_t len;\n+  struct dt_needed needed;\n+\n+  if (name[0] == '/')\n+    return ldelf_try_needed (n, force, is_linux);\n+\n+  if (path == NULL || *path == '\\0')\n+    return FALSE;\n+\n+  needed.by = n->by;\n+  needed.name = n->name;\n+\n+  len = strlen (name);\n+  while (1)\n+    {\n+      unsigned offset = 0;\n+      char * var;\n+      char *filename, *sset;\n+\n+      s = strchr (path, config.rpath_separator);\n+      if (s == NULL)\n+\ts = path + strlen (path);\n+\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+      /* Assume a match on the second char is part of drive specifier.  */\n+      else if (config.rpath_separator == ':'\n+\t       && s == path + 1\n+\t       && ISALPHA (*path))\n+\t{\n+\t  s = strchr (s + 1, config.rpath_separator);\n+\t  if (s == NULL)\n+\t    s = path + strlen (path);\n+\t}\n+#endif\n+      filename = (char *) xmalloc (s - path + len + 2);\n+      if (s == path)\n+\tsset = filename;\n+      else\n+\t{\n+\t  memcpy (filename, path, s - path);\n+\t  filename[s - path] = '/';\n+\t  sset = filename + (s - path) + 1;\n+\t}\n+      strcpy (sset, name);\n+\n+      /* PR 20535: Support the same pseudo-environment variables that\n+\t are supported by ld.so.  Namely, $ORIGIN, $LIB and $PLATFORM.\n+\t Since there can be more than one occurrence of these tokens in\n+\t the path we loop until no more are found.  Since we might not\n+\t be able to substitute some of the tokens we maintain an offset\n+\t into the filename for where we should begin our scan.  */\n+      while ((var = strchr (filename + offset, '$')) != NULL)\n+\t{\n+\t  /* The ld.so manual page does not say, but I am going to assume that\n+\t     these tokens are terminated by a directory separator character\n+\t     (/) or the end of the string.  There is also an implication that\n+\t     $ORIGIN should only be used at the start of a path, but that is\n+\t     not enforced here.\n+\n+\t     The ld.so manual page also states that it allows ${ORIGIN},\n+\t     ${LIB} and ${PLATFORM}, so these are supported as well.\n+\n+\t     FIXME: The code could be a lot cleverer about allocating space\n+\t     for the processed string.  */\n+\t  char *    end = strchr (var, '/');\n+\t  const char *replacement = NULL;\n+\t  char *    v = var + 1;\n+\t  char *    freeme = NULL;\n+\t  unsigned  flen = strlen (filename);\n+\n+\t  if (end != NULL)\n+\t    /* Temporarily terminate the filename at the end of the token.  */\n+\t    * end = 0;\n+\n+\t  if (*v == '{')\n+\t    ++ v;\n+\t  switch (*v++)\n+\t    {\n+\t    case 'O':\n+\t      if (strcmp (v, \"RIGIN\") == 0 || strcmp (v, \"RIGIN}\") == 0)\n+\t\t{\n+\t\t  /* ORIGIN - replace with the full path to the directory\n+\t\t     containing the program or shared object.  */\n+\t\t  if (needed.by == NULL)\n+\t\t    {\n+\t\t      if (link_info.output_bfd == NULL)\n+\t\t\t{\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else\n+\t\t\treplacement = bfd_get_filename (link_info.output_bfd);\n+\t\t    }\n+\t\t  else\n+\t\t    replacement = bfd_get_filename (needed.by);\n+\n+\t\t  if (replacement)\n+\t\t    {\n+\t\t      char * slash;\n+\n+\t\t      if (replacement[0] == '/')\n+\t\t\tfreeme = xstrdup (replacement);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  char * current_dir = getpwd ();\n+\n+\t\t\t  freeme = xmalloc (strlen (replacement)\n+\t\t\t\t\t    + strlen (current_dir) + 2);\n+\t\t\t  sprintf (freeme, \"%s/%s\", current_dir, replacement);\n+\t\t\t}\n+\n+\t\t      replacement = freeme;\n+\t\t      if ((slash = strrchr (replacement, '/')) != NULL)\n+\t\t\t* slash = 0;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\n+\t    case 'L':\n+\t      if (strcmp (v, \"IB\") == 0 || strcmp (v, \"IB}\") == 0)\n+\t\t{\n+\t\t  /* LIB - replace with \"lib\" in 32-bit environments\n+\t\t     and \"lib64\" in 64-bit environments.  */\n+\n+\t\t  switch (elfsize)\n+\t\t    {\n+\t\t    case 32: replacement = \"lib\"; break;\n+\t\t    case 64: replacement = \"lib64\"; break;\n+\t\t    default:\n+\t\t      abort ();\n+\t\t    }\n+\t\t}\n+\t      break;\n+\n+\t    case 'P':\n+\t      /* Supporting $PLATFORM in a cross-hosted environment is not\n+\t\t possible.  Supporting it in a native environment involves\n+\t\t loading the <sys/auxv.h> header file which loads the\n+\t\t system <elf.h> header file, which conflicts with the\n+\t\t \"include/elf/mips.h\" header file.  */\n+\t      /* Fall through.  */\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  if (replacement)\n+\t    {\n+\t      char * filename2 = xmalloc (flen + strlen (replacement));\n+\n+\t      if (end)\n+\t\t{\n+\t\t  sprintf (filename2, \"%.*s%s/%s\",\n+\t\t\t   (int)(var - filename), filename,\n+\t\t\t   replacement, end + 1);\n+\t\t  offset = (var - filename) + 1 + strlen (replacement);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sprintf (filename2, \"%.*s%s\",\n+\t\t\t   (int)(var - filename), filename,\n+\t\t\t   replacement);\n+\t\t  offset = var - filename + strlen (replacement);\n+\t\t}\n+\n+\t      free (filename);\n+\t      filename = filename2;\n+\t      /* There is no need to restore the path separator (when\n+\t\t end != NULL) as we have replaced the entire string.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      if (verbose)\n+\t\t/* We only issue an \"unrecognised\" message in verbose mode\n+\t\t   as the $<foo> token might be a legitimate component of\n+\t\t   a path name in the target's file system.  */\n+\t\tinfo_msg (_(\"unrecognised or unsupported token \"\n+\t\t\t    \"'%s' in search path\\n\"), var);\n+\t      if (end)\n+\t\t/* Restore the path separator.  */\n+\t\t* end = '/';\n+\n+\t      /* PR 20784: Make sure that we resume the scan *after*\n+\t\t the token that we could not replace.  */\n+\t      offset = (var + 1) - filename;\n+\t    }\n+\n+\t  free (freeme);\n+\t}\n+\n+      needed.name = filename;\n+\n+      if (ldelf_try_needed (&needed, force, is_linux))\n+\treturn TRUE;\n+\n+      free (filename);\n+\n+      if (*s == '\\0')\n+\tbreak;\n+      path = s + 1;\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Prefix the sysroot to absolute paths in PATH, a string containing\n+   paths separated by config.rpath_separator.  If running on a DOS\n+   file system, paths containing a drive spec won't have the sysroot\n+   prefix added, unless the sysroot also specifies the same drive.  */\n+\n+static const char *\n+ldelf_add_sysroot (const char *path)\n+{\n+  size_t len, extra;\n+  const char *p;\n+  char *ret, *q;\n+  int dos_drive_sysroot = HAS_DRIVE_SPEC (ld_sysroot);\n+\n+  len = strlen (ld_sysroot);\n+  for (extra = 0, p = path; ; )\n+    {\n+      int dos_drive = HAS_DRIVE_SPEC (p);\n+\n+      if (dos_drive)\n+\tp += 2;\n+      if (IS_DIR_SEPARATOR (*p)\n+\t  && (!dos_drive\n+\t      || (dos_drive_sysroot\n+\t\t  && ld_sysroot[0] == p[-2])))\n+\t{\n+\t  if (dos_drive && dos_drive_sysroot)\n+\t    extra += len - 2;\n+\t  else\n+\t    extra += len;\n+\t}\n+      p = strchr (p, config.rpath_separator);\n+      if (!p)\n+\tbreak;\n+      ++p;\n+    }\n+\n+  ret = xmalloc (strlen (path) + extra + 1);\n+\n+  for (q = ret, p = path; ; )\n+    {\n+      const char *end;\n+      int dos_drive = HAS_DRIVE_SPEC (p);\n+\n+      if (dos_drive)\n+\t{\n+\t  *q++ = *p++;\n+\t  *q++ = *p++;\n+\t}\n+      if (IS_DIR_SEPARATOR (*p)\n+\t  && (!dos_drive\n+\t      || (dos_drive_sysroot\n+\t\t  && ld_sysroot[0] == p[-2])))\n+\t{\n+\t  if (dos_drive && dos_drive_sysroot)\n+\t    {\n+\t      strcpy (q, ld_sysroot + 2);\n+\t      q += len - 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      strcpy (q, ld_sysroot);\n+\t      q += len;\n+\t    }\n+\t}\n+      end = strchr (p, config.rpath_separator);\n+      if (end)\n+\t{\n+\t  size_t n = end - p + 1;\n+\t  strncpy (q, p, n);\n+\t  q += n;\n+\t  p += n;\n+\t}\n+      else\n+\t{\n+\t  strcpy (q, p);\n+\t  break;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Read the system search path the FreeBSD way rather than the Linux way.  */\n+#ifdef HAVE_ELF_HINTS_H\n+#include <elf-hints.h>\n+#else\n+#include \"elf-hints-local.h\"\n+#endif\n+\n+static bfd_boolean\n+ldelf_check_ld_elf_hints (const struct bfd_link_needed_list *l, int force,\n+\t\t\t  int elfsize)\n+{\n+  static bfd_boolean initialized;\n+  static const char *ld_elf_hints;\n+  struct dt_needed needed;\n+\n+  if (!initialized)\n+    {\n+      FILE *f;\n+      char *tmppath;\n+\n+      tmppath = concat (ld_sysroot, _PATH_ELF_HINTS, (const char *) NULL);\n+      f = fopen (tmppath, FOPEN_RB);\n+      free (tmppath);\n+      if (f != NULL)\n+\t{\n+\t  struct elfhints_hdr hdr;\n+\n+\t  if (fread (&hdr, 1, sizeof (hdr), f) == sizeof (hdr)\n+\t      && hdr.magic == ELFHINTS_MAGIC\n+\t      && hdr.version == 1)\n+\t    {\n+\t      if (fseek (f, hdr.strtab + hdr.dirlist, SEEK_SET) != -1)\n+\t\t{\n+\t\t  char *b;\n+\n+\t\t  b = xmalloc (hdr.dirlistlen + 1);\n+\t\t  if (fread (b, 1, hdr.dirlistlen + 1, f) ==\n+\t\t      hdr.dirlistlen + 1)\n+\t\t    ld_elf_hints = ldelf_add_sysroot (b);\n+\n+\t\t  free (b);\n+\t\t}\n+\t    }\n+\t  fclose (f);\n+\t}\n+\n+      initialized = TRUE;\n+    }\n+\n+  if (ld_elf_hints == NULL)\n+    return FALSE;\n+\n+  needed.by = l->by;\n+  needed.name = l->name;\n+  return ldelf_search_needed (ld_elf_hints, &needed, force, FALSE, elfsize);\n+}\n+\n+/* For a native linker, check the file /etc/ld.so.conf for directories\n+   in which we may find shared libraries.  /etc/ld.so.conf is really\n+   only meaningful on Linux.  */\n+\n+struct ldelf_ld_so_conf\n+{\n+  char *path;\n+  size_t len, alloc;\n+};\n+\n+static bfd_boolean\n+ldelf_parse_ld_so_conf (struct ldelf_ld_so_conf *, const char *);\n+\n+static void\n+ldelf_parse_ld_so_conf_include (struct ldelf_ld_so_conf *info,\n+\t\t\t\tconst char *filename,\n+\t\t\t\tconst char *pattern)\n+{\n+  char *newp = NULL;\n+#ifdef HAVE_GLOB\n+  glob_t gl;\n+#endif\n+\n+  if (pattern[0] != '/')\n+    {\n+      char *p = strrchr (filename, '/');\n+      size_t patlen = strlen (pattern) + 1;\n+\n+      newp = xmalloc (p - filename + 1 + patlen);\n+      memcpy (newp, filename, p - filename + 1);\n+      memcpy (newp + (p - filename + 1), pattern, patlen);\n+      pattern = newp;\n+    }\n+\n+#ifdef HAVE_GLOB\n+  if (glob (pattern, 0, NULL, &gl) == 0)\n+    {\n+      size_t i;\n+\n+      for (i = 0; i < gl.gl_pathc; ++i)\n+\tldelf_parse_ld_so_conf (info, gl.gl_pathv[i]);\n+      globfree (&gl);\n+    }\n+#else\n+  /* If we do not have glob, treat the pattern as a literal filename.  */\n+  ldelf_parse_ld_so_conf (info, pattern);\n+#endif\n+\n+  if (newp)\n+    free (newp);\n+}\n+\n+static bfd_boolean\n+ldelf_parse_ld_so_conf (struct ldelf_ld_so_conf *info, const char *filename)\n+{\n+  FILE *f = fopen (filename, FOPEN_RT);\n+  char *line;\n+  size_t linelen;\n+\n+  if (f == NULL)\n+    return FALSE;\n+\n+  linelen = 256;\n+  line = xmalloc (linelen);\n+  do\n+    {\n+      char *p = line, *q;\n+\n+      /* Normally this would use getline(3), but we need to be portable.  */\n+      while ((q = fgets (p, linelen - (p - line), f)) != NULL\n+\t     && strlen (q) == linelen - (p - line) - 1\n+\t     && line[linelen - 2] != '\\n')\n+\t{\n+\t  line = xrealloc (line, 2 * linelen);\n+\t  p = line + linelen - 1;\n+\t  linelen += linelen;\n+\t}\n+\n+      if (q == NULL && p == line)\n+\tbreak;\n+\n+      p = strchr (line, '\\n');\n+      if (p)\n+\t*p = '\\0';\n+\n+      /* Because the file format does not know any form of quoting we\n+\t can search forward for the next '#' character and if found\n+\t make it terminating the line.  */\n+      p = strchr (line, '#');\n+      if (p)\n+\t*p = '\\0';\n+\n+      /* Remove leading whitespace.  NUL is no whitespace character.  */\n+      p = line;\n+      while (*p == ' ' || *p == '\\f' || *p == '\\r' || *p == '\\t' || *p == '\\v')\n+\t++p;\n+\n+      /* If the line is blank it is ignored.  */\n+      if (p[0] == '\\0')\n+\tcontinue;\n+\n+      if (CONST_STRNEQ (p, \"include\") && (p[7] == ' ' || p[7] == '\\t'))\n+\t{\n+\t  char *dir, c;\n+\t  p += 8;\n+\t  do\n+\t    {\n+\t      while (*p == ' ' || *p == '\\t')\n+\t\t++p;\n+\n+\t      if (*p == '\\0')\n+\t\tbreak;\n+\n+\t      dir = p;\n+\n+\t      while (*p != ' ' && *p != '\\t' && *p)\n+\t\t++p;\n+\n+\t      c = *p;\n+\t      *p++ = '\\0';\n+\t      if (dir[0] != '\\0')\n+\t\tldelf_parse_ld_so_conf_include (info, filename, dir);\n+\t    }\n+\t  while (c != '\\0');\n+\t}\n+      else\n+\t{\n+\t  char *dir = p;\n+\t  while (*p && *p != '=' && *p != ' ' && *p != '\\t' && *p != '\\f'\n+\t\t && *p != '\\r' && *p != '\\v')\n+\t    ++p;\n+\n+\t  while (p != dir && p[-1] == '/')\n+\t    --p;\n+\t  if (info->path == NULL)\n+\t    {\n+\t      info->alloc = p - dir + 1 + 256;\n+\t      info->path = xmalloc (info->alloc);\n+\t      info->len = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (info->len + 1 + (p - dir) >= info->alloc)\n+\t\t{\n+\t\t  info->alloc += p - dir + 256;\n+\t\t  info->path = xrealloc (info->path, info->alloc);\n+\t\t}\n+\t      info->path[info->len++] = config.rpath_separator;\n+\t    }\n+\t  memcpy (info->path + info->len, dir, p - dir);\n+\t  info->len += p - dir;\n+\t  info->path[info->len] = '\\0';\n+\t}\n+    }\n+  while (! feof (f));\n+  free (line);\n+  fclose (f);\n+  return TRUE;\n+}\n+\n+static bfd_boolean\n+ldelf_check_ld_so_conf (const struct bfd_link_needed_list *l, int force,\n+\t\t\tint elfsize)\n+{\n+  static bfd_boolean initialized;\n+  static const char *ld_so_conf;\n+  struct dt_needed needed;\n+\n+  if (! initialized)\n+    {\n+      char *tmppath;\n+      struct ldelf_ld_so_conf info;\n+\n+      info.path = NULL;\n+      info.len = info.alloc = 0;\n+      tmppath = concat (ld_sysroot, \"${prefix}/etc/ld.so.conf\",\n+\t\t\t(const char *) NULL);\n+      if (!ldelf_parse_ld_so_conf (&info, tmppath))\n+\t{\n+\t  free (tmppath);\n+\t  tmppath = concat (ld_sysroot, \"/etc/ld.so.conf\",\n+\t\t\t    (const char *) NULL);\n+\t  ldelf_parse_ld_so_conf (&info, tmppath);\n+\t}\n+      free (tmppath);\n+\n+      if (info.path)\n+\t{\n+\t  ld_so_conf = ldelf_add_sysroot (info.path);\n+\t  free (info.path);\n+\t}\n+      initialized = TRUE;\n+    }\n+\n+  if (ld_so_conf == NULL)\n+    return FALSE;\n+\n+\n+  needed.by = l->by;\n+  needed.name = l->name;\n+  return ldelf_search_needed (ld_so_conf, &needed, force, TRUE, elfsize);\n+}\n+\n+/* See if an input file matches a DT_NEEDED entry by name.  */\n+\n+static void\n+ldelf_check_needed (lang_input_statement_type *s)\n+{\n+  const char *soname;\n+\n+  /* Stop looking if we've found a loaded lib.  */\n+  if (global_found != NULL\n+      && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)\n+\t  & DYN_AS_NEEDED) == 0)\n+    return;\n+\n+  if (s->filename == NULL || s->the_bfd == NULL)\n+    return;\n+\n+  /* Don't look for a second non-loaded as-needed lib.  */\n+  if (global_found != NULL\n+      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)\n+    return;\n+\n+  if (filename_cmp (s->filename, global_needed->name) == 0)\n+    {\n+      global_found = s;\n+      return;\n+    }\n+\n+  if (s->flags.search_dirs)\n+    {\n+      const char *f = strrchr (s->filename, '/');\n+      if (f != NULL\n+\t  && filename_cmp (f + 1, global_needed->name) == 0)\n+\t{\n+\t  global_found = s;\n+\t  return;\n+\t}\n+    }\n+\n+  soname = bfd_elf_get_dt_soname (s->the_bfd);\n+  if (soname != NULL\n+      && filename_cmp (soname, global_needed->name) == 0)\n+    {\n+      global_found = s;\n+      return;\n+    }\n+}\n+\n+/* This is called after all the input files have been opened.  */\n+\n+void\n+ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n+\t\t  int elfsize)\n+{\n+  struct bfd_link_needed_list *needed, *l;\n+  struct elf_link_hash_table *htab;\n+  asection *s;\n+  bfd *abfd;\n+\n+  after_open_default ();\n+\n+  htab = elf_hash_table (&link_info);\n+  if (!is_elf_hash_table (htab))\n+    return;\n+\n+  if (command_line.out_implib_filename)\n+    {\n+      unlink_if_ordinary (command_line.out_implib_filename);\n+      link_info.out_implib_bfd\n+\t= bfd_openw (command_line.out_implib_filename,\n+\t\t     bfd_get_target (link_info.output_bfd));\n+\n+      if (link_info.out_implib_bfd == NULL)\n+\t{\n+\t  einfo (_(\"%F%P: %s: can't open for writing: %E\\n\"),\n+\t\t command_line.out_implib_filename);\n+\t}\n+    }\n+\n+  if (ldelf_emit_note_gnu_build_id != NULL)\n+    {\n+      /* Find an ELF input.  */\n+      for (abfd = link_info.input_bfds;\n+\t   abfd != (bfd *) NULL; abfd = abfd->link.next)\n+\tif (bfd_get_flavour (abfd) == bfd_target_elf_flavour\n+\t    && bfd_count_sections (abfd) != 0\n+\t    && !((lang_input_statement_type *) abfd->usrdata)->flags.just_syms)\n+\t  break;\n+\n+      /* PR 10555: If there are no ELF input files do not try to\n+\t create a .note.gnu-build-id section.  */\n+      if (abfd == NULL\n+\t  || !ldelf_setup_build_id (abfd))\n+\t{\n+\t  free ((char *) ldelf_emit_note_gnu_build_id);\n+\t  ldelf_emit_note_gnu_build_id = NULL;\n+\t}\n+    }\n+\n+  get_elf_backend_data (link_info.output_bfd)->setup_gnu_properties (&link_info);\n+\n+  if (bfd_link_relocatable (&link_info))\n+    {\n+      if (link_info.execstack == !link_info.noexecstack)\n+\t{\n+\t  /* PR ld/16744: If \"-z [no]execstack\" has been specified on the\n+\t     command line and we are perfoming a relocatable link then no\n+\t     PT_GNU_STACK segment will be created and so the\n+\t     linkinfo.[no]execstack values set in _handle_option() will have no\n+\t     effect.  Instead we create a .note.GNU-stack section in much the\n+\t     same way as the assembler does with its --[no]execstack option.  */\n+\t  flagword flags = SEC_READONLY | (link_info.execstack ? SEC_CODE : 0);\n+\t  (void) bfd_make_section_with_flags (link_info.input_bfds,\n+\t\t\t\t\t      \".note.GNU-stack\", flags);\n+\t}\n+      return;\n+    }\n+\n+  if (!link_info.traditional_format)\n+    {\n+      bfd *elfbfd = NULL;\n+      bfd_boolean warn_eh_frame = FALSE;\n+      int seen_type = 0;\n+\n+      for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)\n+\t{\n+\t  int type = 0;\n+\n+\t  if (((lang_input_statement_type *) abfd->usrdata)->flags.just_syms)\n+\t    continue;\n+\n+\t  for (s = abfd->sections; s && type < COMPACT_EH_HDR; s = s->next)\n+\t    {\n+\t      const char *name = bfd_get_section_name (abfd, s);\n+\n+\t      if (bfd_is_abs_section (s->output_section))\n+\t\tcontinue;\n+\t      if (CONST_STRNEQ (name, \".eh_frame_entry\"))\n+\t\ttype = COMPACT_EH_HDR;\n+\t      else if (strcmp (name, \".eh_frame\") == 0 && s->size > 8)\n+\t\ttype = DWARF2_EH_HDR;\n+\t    }\n+\n+\t  if (type != 0)\n+\t    {\n+\t      if (seen_type == 0)\n+\t\t{\n+\t\t  seen_type = type;\n+\t\t}\n+\t      else if (seen_type != type)\n+\t\t{\n+\t\t  einfo (_(\"%F%P: compact frame descriptions incompatible with\"\n+\t\t\t   \" DWARF2 .eh_frame from %pB\\n\"),\n+\t\t\t type == DWARF2_EH_HDR ? abfd : elfbfd);\n+\t\t  break;\n+\t\t}\n+\n+\t      if (!elfbfd\n+\t\t  && (type == COMPACT_EH_HDR\n+\t\t      || link_info.eh_frame_hdr_type != 0))\n+\t\t{\n+\t\t  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n+\t\t    elfbfd = abfd;\n+\n+\t\t  warn_eh_frame = TRUE;\n+\t\t}\n+\t    }\n+\n+\t  if (seen_type == COMPACT_EH_HDR)\n+\t    link_info.eh_frame_hdr_type = COMPACT_EH_HDR;\n+\t}\n+      if (elfbfd)\n+\t{\n+\t  const struct elf_backend_data *bed;\n+\n+\t  bed = get_elf_backend_data (elfbfd);\n+\t  s = bfd_make_section_with_flags (elfbfd, \".eh_frame_hdr\",\n+\t\t\t\t\t   bed->dynamic_sec_flags\n+\t\t\t\t\t   | SEC_READONLY);\n+\t  if (s != NULL\n+\t      && bfd_set_section_alignment (elfbfd, s, 2))\n+\t    {\n+\t      htab->eh_info.hdr_sec = s;\n+\t      warn_eh_frame = FALSE;\n+\t    }\n+\t}\n+      if (warn_eh_frame)\n+\teinfo (_(\"%P: warning: cannot create .eh_frame_hdr section,\"\n+\t\t \" --eh-frame-hdr ignored\\n\"));\n+    }\n+\n+  /* Get the list of files which appear in DT_NEEDED entries in\n+     dynamic objects included in the link (often there will be none).\n+     For each such file, we want to track down the corresponding\n+     library, and include the symbol table in the link.  This is what\n+     the runtime dynamic linker will do.  Tracking the files down here\n+     permits one dynamic object to include another without requiring\n+     special action by the person doing the link.  Note that the\n+     needed list can actually grow while we are stepping through this\n+     loop.  */\n+  needed = bfd_elf_get_needed_list (link_info.output_bfd, &link_info);\n+  for (l = needed; l != NULL; l = l->next)\n+    {\n+      struct bfd_link_needed_list *ll;\n+      struct dt_needed n, nn;\n+      int force;\n+\n+      /* If the lib that needs this one was --as-needed and wasn't\n+\t found to be needed, then this lib isn't needed either.  */\n+      if (l->by != NULL\n+\t  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_AS_NEEDED) != 0)\n+\tcontinue;\n+\n+      /* Skip the lib if --no-copy-dt-needed-entries and\n+\t --allow-shlib-undefined is in effect.  */\n+      if (l->by != NULL\n+\t  && link_info.unresolved_syms_in_shared_libs == RM_IGNORE\n+\t  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_NO_ADD_NEEDED) != 0)\n+\tcontinue;\n+\n+      /* If we've already seen this file, skip it.  */\n+      for (ll = needed; ll != l; ll = ll->next)\n+\tif ((ll->by == NULL\n+\t     || (bfd_elf_get_dyn_lib_class (ll->by) & DYN_AS_NEEDED) == 0)\n+\t    && strcmp (ll->name, l->name) == 0)\n+\t  break;\n+      if (ll != l)\n+\tcontinue;\n+\n+      /* See if this file was included in the link explicitly.  */\n+      global_needed = l;\n+      global_found = NULL;\n+      lang_for_each_input_file (ldelf_check_needed);\n+      if (global_found != NULL\n+\t  && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)\n+\t      & DYN_AS_NEEDED) == 0)\n+\tcontinue;\n+\n+      n.by = l->by;\n+      n.name = l->name;\n+      nn.by = l->by;\n+      if (verbose)\n+\tinfo_msg (_(\"%s needed by %pB\\n\"), l->name, l->by);\n+\n+      /* As-needed libs specified on the command line (or linker script)\n+\t take priority over libs found in search dirs.  */\n+      if (global_found != NULL)\n+\t{\n+\t  nn.name = global_found->filename;\n+\t  if (ldelf_try_needed (&nn, TRUE, is_linux))\n+\t    continue;\n+\t}\n+\n+      /* We need to find this file and include the symbol table.  We\n+\t want to search for the file in the same way that the dynamic\n+\t linker will search.  That means that we want to use\n+\t rpath_link, rpath, then the environment variable\n+\t LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH\n+\t entries (native only), then the linker script LIB_SEARCH_DIRS.\n+\t We do not search using the -L arguments.\n+\n+\t We search twice.  The first time, we skip objects which may\n+\t introduce version mismatches.  The second time, we force\n+\t their use.  See ldelf_vercheck comment.  */\n+      for (force = 0; force < 2; force++)\n+\t{\n+\t  size_t len;\n+\t  search_dirs_type *search;\n+\t  const char *path;\n+\t  struct bfd_link_needed_list *rp;\n+\t  int found;\n+\n+\t  if (ldelf_search_needed (command_line.rpath_link, &n, force,\n+\t\t\t\t   is_linux, elfsize))\n+\t    break;\n+\n+\t  if (use_libpath)\n+\t    {\n+\t      path = command_line.rpath;\n+\t      if (path)\n+\t\t{\n+\t\t  path = ldelf_add_sysroot (path);\n+\t\t  found = ldelf_search_needed (path, &n, force,\n+\t\t\t\t\t       is_linux, elfsize);\n+\t\t  free ((char *) path);\n+\t\t  if (found)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (native)\n+\t    {\n+\t      if (command_line.rpath_link == NULL\n+\t\t  && command_line.rpath == NULL)\n+\t\t{\n+\t\t  path = (const char *) getenv (\"LD_RUN_PATH\");\n+\t\t  if (path\n+\t\t      && ldelf_search_needed (path, &n, force,\n+\t\t\t\t\t      is_linux, elfsize))\n+\t\t    break;\n+\t\t}\n+\t      path = (const char *) getenv (\"LD_LIBRARY_PATH\");\n+\t      if (path\n+\t\t  && ldelf_search_needed (path, &n, force,\n+\t\t\t\t\t  is_linux, elfsize))\n+\t\tbreak;\n+\t    }\n+\t  if (use_libpath)\n+\t    {\n+\t      found = 0;\n+\t      rp = bfd_elf_get_runpath_list (link_info.output_bfd, &link_info);\n+\t      for (; !found && rp != NULL; rp = rp->next)\n+\t\t{\n+\t\t  path = ldelf_add_sysroot (rp->name);\n+\t\t  found = (rp->by == l->by\n+\t\t\t   && ldelf_search_needed (path, &n, force,\n+\t\t\t\t\t\t   is_linux, elfsize));\n+\t\t  free ((char *) path);\n+\t\t}\n+\t      if (found)\n+\t\tbreak;\n+\n+\t      if (is_freebsd\n+\t\t  && ldelf_check_ld_elf_hints (l, force, elfsize))\n+\t\tbreak;\n+\n+\t      if (is_linux\n+\t\t  && ldelf_check_ld_so_conf (l, force, elfsize))\n+\t\tbreak;\n+\t    }\n+\n+\t  len = strlen (l->name);\n+\t  for (search = search_head; search != NULL; search = search->next)\n+\t    {\n+\t      char *filename;\n+\n+\t      if (search->cmdline)\n+\t\tcontinue;\n+\t      filename = (char *) xmalloc (strlen (search->name) + len + 2);\n+\t      sprintf (filename, \"%s/%s\", search->name, l->name);\n+\t      nn.name = filename;\n+\t      if (ldelf_try_needed (&nn, force, is_linux))\n+\t\tbreak;\n+\t      free (filename);\n+\t    }\n+\t  if (search != NULL)\n+\t    break;\n+\t}\n+\n+      if (force < 2)\n+\tcontinue;\n+\n+      einfo (_(\"%P: warning: %s, needed by %pB, not found \"\n+\t       \"(try using -rpath or -rpath-link)\\n\"),\n+\t     l->name, l->by);\n+    }\n+\n+  if (link_info.eh_frame_hdr_type == COMPACT_EH_HDR)\n+    if (!bfd_elf_parse_eh_frame_entries (NULL, &link_info))\n+      einfo (_(\"%F%P: failed to parse EH frame entries\\n\"));\n+}\n+\n+static bfd_size_type\n+id_note_section_size (bfd *abfd ATTRIBUTE_UNUSED)\n+{\n+  const char *style = ldelf_emit_note_gnu_build_id;\n+  bfd_size_type size;\n+  bfd_size_type build_id_size;\n+\n+  size = offsetof (Elf_External_Note, name[sizeof \"GNU\"]);\n+  size = (size + 3) & -(bfd_size_type) 4;\n+\n+  build_id_size = compute_build_id_size (style);\n+  if (build_id_size)\n+    size += build_id_size;\n+  else\n+    size = 0;\n+\n+  return size;\n+}\n+\n+static bfd_boolean\n+write_build_id (bfd *abfd)\n+{\n+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n+  struct elf_obj_tdata *t = elf_tdata (abfd);\n+  const char *style;\n+  asection *asec;\n+  Elf_Internal_Shdr *i_shdr;\n+  unsigned char *contents, *id_bits;\n+  bfd_size_type size;\n+  file_ptr position;\n+  Elf_External_Note *e_note;\n+\n+  style = t->o->build_id.style;\n+  asec = t->o->build_id.sec;\n+  if (bfd_is_abs_section (asec->output_section))\n+    {\n+      einfo (_(\"%P: warning: .note.gnu.build-id section discarded,\"\n+\t       \" --build-id ignored\\n\"));\n+      return TRUE;\n+    }\n+  i_shdr = &elf_section_data (asec->output_section)->this_hdr;\n+\n+  if (i_shdr->contents == NULL)\n+    {\n+      if (asec->contents == NULL)\n+\tasec->contents = (unsigned char *) xmalloc (asec->size);\n+      contents = asec->contents;\n+    }\n+  else\n+    contents = i_shdr->contents + asec->output_offset;\n+\n+  e_note = (Elf_External_Note *) contents;\n+  size = offsetof (Elf_External_Note, name[sizeof \"GNU\"]);\n+  size = (size + 3) & -(bfd_size_type) 4;\n+  id_bits = contents + size;\n+  size = asec->size - size;\n+\n+  bfd_h_put_32 (abfd, sizeof \"GNU\", &e_note->namesz);\n+  bfd_h_put_32 (abfd, size, &e_note->descsz);\n+  bfd_h_put_32 (abfd, NT_GNU_BUILD_ID, &e_note->type);\n+  memcpy (e_note->name, \"GNU\", sizeof \"GNU\");\n+\n+  generate_build_id (abfd, style, bed->s->checksum_contents, id_bits, size);\n+\n+  position = i_shdr->sh_offset + asec->output_offset;\n+  size = asec->size;\n+  return (bfd_seek (abfd, position, SEEK_SET) == 0\n+\t  && bfd_bwrite (contents, size, abfd) == size);\n+}\n+\n+/* Make .note.gnu.build-id section, and set up elf_tdata->build_id.  */\n+\n+bfd_boolean\n+ldelf_setup_build_id (bfd *ibfd)\n+{\n+  asection *s;\n+  bfd_size_type size;\n+  flagword flags;\n+\n+  size = id_note_section_size (ibfd);\n+  if (size == 0)\n+    {\n+      einfo (_(\"%P: warning: unrecognized --build-id style ignored\\n\"));\n+      return FALSE;\n+    }\n+\n+  flags = (SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY\n+\t   | SEC_LINKER_CREATED | SEC_READONLY | SEC_DATA);\n+  s = bfd_make_section_with_flags (ibfd, \".note.gnu.build-id\", flags);\n+  if (s != NULL && bfd_set_section_alignment (ibfd, s, 2))\n+    {\n+      struct elf_obj_tdata *t = elf_tdata (link_info.output_bfd);\n+      t->o->build_id.after_write_object_contents = &write_build_id;\n+      t->o->build_id.style = ldelf_emit_note_gnu_build_id;\n+      t->o->build_id.sec = s;\n+      elf_section_type (s) = SHT_NOTE;\n+      s->size = size;\n+      return TRUE;\n+    }\n+\n+  einfo (_(\"%P: warning: cannot create .note.gnu.build-id section,\"\n+\t   \" --build-id ignored\\n\"));\n+  return FALSE;\n+}\n+\n+/* Look through an expression for an assignment statement.  */\n+\n+static void\n+ldelf_find_exp_assignment (etree_type *exp)\n+{\n+  bfd_boolean provide = FALSE;\n+\n+  switch (exp->type.node_class)\n+    {\n+    case etree_provide:\n+    case etree_provided:\n+      provide = TRUE;\n+      /* Fallthru */\n+    case etree_assign:\n+      /* We call record_link_assignment even if the symbol is defined.\n+\t This is because if it is defined by a dynamic object, we\n+\t actually want to use the value defined by the linker script,\n+\t not the value from the dynamic object (because we are setting\n+\t symbols like etext).  If the symbol is defined by a regular\n+\t object, then, as it happens, calling record_link_assignment\n+\t will do no harm.  */\n+      if (strcmp (exp->assign.dst, \".\") != 0)\n+\t{\n+\t  if (!bfd_elf_record_link_assignment (link_info.output_bfd,\n+\t\t\t\t\t       &link_info,\n+\t\t\t\t\t       exp->assign.dst, provide,\n+\t\t\t\t\t       exp->assign.hidden))\n+\t    einfo (_(\"%F%P: failed to record assignment to %s: %E\\n\"),\n+\t\t   exp->assign.dst);\n+\t}\n+      ldelf_find_exp_assignment (exp->assign.src);\n+      break;\n+\n+    case etree_binary:\n+      ldelf_find_exp_assignment (exp->binary.lhs);\n+      ldelf_find_exp_assignment (exp->binary.rhs);\n+      break;\n+\n+    case etree_trinary:\n+      ldelf_find_exp_assignment (exp->trinary.cond);\n+      ldelf_find_exp_assignment (exp->trinary.lhs);\n+      ldelf_find_exp_assignment (exp->trinary.rhs);\n+      break;\n+\n+    case etree_unary:\n+      ldelf_find_exp_assignment (exp->unary.child);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* This is called by the before_allocation routine via\n+   lang_for_each_statement.  It locates any assignment statements, and\n+   tells the ELF backend about them, in case they are assignments to\n+   symbols which are referred to by dynamic objects.  */\n+\n+static void\n+ldelf_find_statement_assignment (lang_statement_union_type *s)\n+{\n+  if (s->header.type == lang_assignment_statement_enum)\n+    ldelf_find_exp_assignment (s->assignment_statement.exp);\n+}\n+\n+/* Used by before_allocation and handle_option. */\n+\n+void\n+ldelf_append_to_separated_string (char **to, char *op_arg)\n+{\n+  if (*to == NULL)\n+    *to = xstrdup (op_arg);\n+  else\n+    {\n+      size_t to_len = strlen (*to);\n+      size_t op_arg_len = strlen (op_arg);\n+      char *buf;\n+      char *cp = *to;\n+\n+      /* First see whether OPTARG is already in the path.  */\n+      do\n+\t{\n+\t  if (strncmp (op_arg, cp, op_arg_len) == 0\n+\t      && (cp[op_arg_len] == 0\n+\t\t  || cp[op_arg_len] == config.rpath_separator))\n+\t    /* We found it.  */\n+\t    break;\n+\n+\t  /* Not yet found.  */\n+\t  cp = strchr (cp, config.rpath_separator);\n+\t  if (cp != NULL)\n+\t    ++cp;\n+\t}\n+      while (cp != NULL);\n+\n+      if (cp == NULL)\n+\t{\n+\t  buf = xmalloc (to_len + op_arg_len + 2);\n+\t  sprintf (buf, \"%s%c%s\", *to,\n+\t\t   config.rpath_separator, op_arg);\n+\t  free (*to);\n+\t  *to = buf;\n+\t}\n+    }\n+}\n+\n+/* This is called after the sections have been attached to output\n+   sections, but before any sizes or addresses have been set.  */\n+\n+void\n+ldelf_before_allocation (char *audit, char *depaudit,\n+\t\t\t const char *default_interpreter_name)\n+{\n+  const char *rpath;\n+  asection *sinterp;\n+  bfd *abfd;\n+  struct bfd_link_hash_entry *ehdr_start = NULL;\n+  unsigned char ehdr_start_save_type = 0;\n+  char ehdr_start_save_u[sizeof ehdr_start->u\n+\t\t\t - sizeof ehdr_start->u.def.next] = \"\";\n+\n+  if (is_elf_hash_table (link_info.hash))\n+    {\n+      _bfd_elf_tls_setup (link_info.output_bfd, &link_info);\n+\n+      /* Make __ehdr_start hidden if it has been referenced, to\n+\t prevent the symbol from being dynamic.  */\n+      if (!bfd_link_relocatable (&link_info))\n+\t{\n+\t  struct elf_link_hash_table *htab = elf_hash_table (&link_info);\n+\t  struct elf_link_hash_entry *h\n+\t    = elf_link_hash_lookup (htab, \"__ehdr_start\", FALSE, FALSE, TRUE);\n+\n+\t  /* Only adjust the export class if the symbol was referenced\n+\t     and not defined, otherwise leave it alone.  */\n+\t  if (h != NULL\n+\t      && (h->root.type == bfd_link_hash_new\n+\t\t  || h->root.type == bfd_link_hash_undefined\n+\t\t  || h->root.type == bfd_link_hash_undefweak\n+\t\t  || h->root.type == bfd_link_hash_common))\n+\t    {\n+\t      const struct elf_backend_data *bed;\n+\t      bed = get_elf_backend_data (link_info.output_bfd);\n+\t      (*bed->elf_backend_hide_symbol) (&link_info, h, TRUE);\n+\t      if (ELF_ST_VISIBILITY (h->other) != STV_INTERNAL)\n+\t\th->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;\n+\t      /* Don't leave the symbol undefined.  Undefined hidden\n+\t\t symbols typically won't have dynamic relocations, but\n+\t\t we most likely will need dynamic relocations for\n+\t\t __ehdr_start if we are building a PIE or shared\n+\t\t library.  */\n+\t      ehdr_start = &h->root;\n+\t      ehdr_start_save_type = ehdr_start->type;\n+\t      memcpy (ehdr_start_save_u,\n+\t\t      (char *) &ehdr_start->u + sizeof ehdr_start->u.def.next,\n+\t\t      sizeof ehdr_start_save_u);\n+\t      ehdr_start->type = bfd_link_hash_defined;\n+\t      ehdr_start->u.def.section = bfd_abs_section_ptr;\n+\t      ehdr_start->u.def.value = 0;\n+\t    }\n+\t}\n+\n+      /* If we are going to make any variable assignments, we need to\n+\t let the ELF backend know about them in case the variables are\n+\t referred to by dynamic objects.  */\n+      lang_for_each_statement (ldelf_find_statement_assignment);\n+    }\n+\n+  /* Let the ELF backend work out the sizes of any sections required\n+     by dynamic linking.  */\n+  rpath = command_line.rpath;\n+  if (rpath == NULL)\n+    rpath = (const char *) getenv (\"LD_RUN_PATH\");\n+\n+  for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)\n+    if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n+      {\n+\tconst char *audit_libs = elf_dt_audit (abfd);\n+\n+\t/* If the input bfd contains an audit entry, we need to add it as\n+\t   a dep audit entry.  */\n+\tif (audit_libs && *audit_libs != '\\0')\n+\t  {\n+\t    char *cp = xstrdup (audit_libs);\n+\t    do\n+\t      {\n+\t\tint more = 0;\n+\t\tchar *cp2 = strchr (cp, config.rpath_separator);\n+\n+\t\tif (cp2)\n+\t\t  {\n+\t\t    *cp2 = '\\0';\n+\t\t    more = 1;\n+\t\t  }\n+\n+\t\tif (cp != NULL && *cp != '\\0')\n+\t\t  ldelf_append_to_separated_string (&depaudit, cp);\n+\n+\t\tcp = more ? ++cp2 : NULL;\n+\t      }\n+\t    while (cp != NULL);\n+\t  }\n+      }\n+\n+  if (! (bfd_elf_size_dynamic_sections\n+\t (link_info.output_bfd, command_line.soname, rpath,\n+\t  command_line.filter_shlib, audit, depaudit,\n+\t  (const char * const *) command_line.auxiliary_filters,\n+\t  &link_info, &sinterp)))\n+    einfo (_(\"%F%P: failed to set dynamic section sizes: %E\\n\"));\n+\n+  if (sinterp != NULL)\n+    {\n+      /* Let the user override the dynamic linker we are using.  */\n+      if (command_line.interpreter != NULL)\n+\tdefault_interpreter_name = command_line.interpreter;\n+      if (default_interpreter_name != NULL)\n+\t{\n+\t  sinterp->contents = (bfd_byte *) default_interpreter_name;\n+\t  sinterp->size = strlen ((char *) sinterp->contents) + 1;\n+\t}\n+    }\n+\n+  /* Look for any sections named .gnu.warning.  As a GNU extensions,\n+     we treat such sections as containing warning messages.  We print\n+     out the warning message, and then zero out the section size so\n+     that it does not get copied into the output file.  */\n+\n+  {\n+    LANG_FOR_EACH_INPUT_STATEMENT (is)\n+      {\n+\tasection *s;\n+\tbfd_size_type sz;\n+\tchar *msg;\n+\n+\tif (is->flags.just_syms)\n+\t  continue;\n+\n+\ts = bfd_get_section_by_name (is->the_bfd, \".gnu.warning\");\n+\tif (s == NULL)\n+\t  continue;\n+\n+\tsz = s->size;\n+\tmsg = (char *) xmalloc ((size_t) (sz + 1));\n+\tif (! bfd_get_section_contents (is->the_bfd, s,\tmsg,\n+\t\t\t\t\t(file_ptr) 0, sz))\n+\t  einfo (_(\"%F%P: %pB: can't read contents of section .gnu.warning: %E\\n\"),\n+\t\t is->the_bfd);\n+\tmsg[sz] = '\\0';\n+\t(*link_info.callbacks->warning) (&link_info, msg,\n+\t\t\t\t\t (const char *) NULL, is->the_bfd,\n+\t\t\t\t\t (asection *) NULL, (bfd_vma) 0);\n+\tfree (msg);\n+\n+\t/* Clobber the section size, so that we don't waste space\n+\t   copying the warning into the output file.  If we've already\n+\t   sized the output section, adjust its size.  The adjustment\n+\t   is on rawsize because targets that size sections early will\n+\t   have called lang_reset_memory_regions after sizing.  */\n+\tif (s->output_section != NULL\n+\t    && s->output_section->rawsize >= s->size)\n+\t  s->output_section->rawsize -= s->size;\n+\n+\ts->size = 0;\n+\n+\t/* Also set SEC_EXCLUDE, so that local symbols defined in the\n+\t   warning section don't get copied to the output.  */\n+\ts->flags |= SEC_EXCLUDE | SEC_KEEP;\n+      }\n+  }\n+\n+  before_allocation_default ();\n+\n+  if (!bfd_elf_size_dynsym_hash_dynstr (link_info.output_bfd, &link_info))\n+    einfo (_(\"%F%P: failed to set dynamic section sizes: %E\\n\"));\n+\n+  if (ehdr_start != NULL)\n+    {\n+      /* If we twiddled __ehdr_start to defined earlier, put it back\n+\t as it was.  */\n+      ehdr_start->type = ehdr_start_save_type;\n+      memcpy ((char *) &ehdr_start->u + sizeof ehdr_start->u.def.next,\n+\t      ehdr_start_save_u,\n+\t      sizeof ehdr_start_save_u);\n+    }\n+}\n+/* Try to open a dynamic archive.  This is where we know that ELF\n+   dynamic libraries have an extension of .so (or .sl on oddball systems\n+   like hpux).  */\n+\n+bfd_boolean\n+ldelf_open_dynamic_archive (const char *arch, search_dirs_type *search,\n+\t\t\t    lang_input_statement_type *entry)\n+{\n+  const char *filename;\n+  char *string;\n+  size_t len;\n+  bfd_boolean opened = FALSE;\n+\n+  if (! entry->flags.maybe_archive)\n+    return FALSE;\n+\n+  filename = entry->filename;\n+  len = strlen (search->name) + strlen (filename);\n+  if (entry->flags.full_name_provided)\n+    {\n+      len += sizeof \"/\";\n+      string = (char *) xmalloc (len);\n+      sprintf (string, \"%s/%s\", search->name, filename);\n+    }\n+  else\n+    {\n+      size_t xlen = 0;\n+\n+      len += strlen (arch) + sizeof \"/lib.so\";\n+#ifdef EXTRA_SHLIB_EXTENSION\n+      xlen = (strlen (EXTRA_SHLIB_EXTENSION) > 3\n+\t      ? strlen (EXTRA_SHLIB_EXTENSION) - 3\n+\t      : 0);\n+#endif\n+      string = (char *) xmalloc (len + xlen);\n+      sprintf (string, \"%s/lib%s%s.so\", search->name, filename, arch);\n+#ifdef EXTRA_SHLIB_EXTENSION\n+      /* Try the .so extension first.  If that fails build a new filename\n+\t using EXTRA_SHLIB_EXTENSION.  */\n+      opened = ldfile_try_open_bfd (string, entry);\n+      if (!opened)\n+\tstrcpy (string + len - 4, EXTRA_SHLIB_EXTENSION);\n+#endif\n+    }\n+\n+  if (!opened && !ldfile_try_open_bfd (string, entry))\n+    {\n+      free (string);\n+      return FALSE;\n+    }\n+\n+  entry->filename = string;\n+\n+  /* We have found a dynamic object to include in the link.  The ELF\n+     backend linker will create a DT_NEEDED entry in the .dynamic\n+     section naming this file.  If this file includes a DT_SONAME\n+     entry, it will be used.  Otherwise, the ELF linker will just use\n+     the name of the file.  For an archive found by searching, like\n+     this one, the DT_NEEDED entry should consist of just the name of\n+     the file, without the path information used to find it.  Note\n+     that we only need to do this if we have a dynamic object; an\n+     archive will never be referenced by a DT_NEEDED entry.\n+\n+     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not\n+     very pretty.  I haven't been able to think of anything that is\n+     pretty, though.  */\n+  if (bfd_check_format (entry->the_bfd, bfd_object)\n+      && (entry->the_bfd->flags & DYNAMIC) != 0)\n+    {\n+      ASSERT (entry->flags.maybe_archive && entry->flags.search_dirs);\n+\n+      /* Rather than duplicating the logic above.  Just use the\n+\t filename we recorded earlier.  */\n+\n+      if (!entry->flags.full_name_provided)\n+\tfilename = lbasename (entry->filename);\n+      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);\n+    }\n+\n+  return TRUE;\n+}\n+\n+/* A variant of lang_output_section_find used by place_orphan.  */\n+\n+static lang_output_section_statement_type *\n+output_rel_find (int isdyn, int rela)\n+{\n+  lang_output_section_statement_type *lookup;\n+  lang_output_section_statement_type *last = NULL;\n+  lang_output_section_statement_type *last_alloc = NULL;\n+  lang_output_section_statement_type *last_ro_alloc = NULL;\n+  lang_output_section_statement_type *last_rel = NULL;\n+  lang_output_section_statement_type *last_rel_alloc = NULL;\n+\n+  for (lookup = &lang_os_list.head->output_section_statement;\n+       lookup != NULL;\n+       lookup = lookup->next)\n+    {\n+      if (lookup->constraint >= 0\n+\t  && CONST_STRNEQ (lookup->name, \".rel\"))\n+\t{\n+\t  int lookrela = lookup->name[4] == 'a';\n+\n+\t  /* .rel.dyn must come before all other reloc sections, to suit\n+\t     GNU ld.so.  */\n+\t  if (isdyn)\n+\t    break;\n+\n+\t  /* Don't place after .rel.plt as doing so results in wrong\n+\t     dynamic tags.  */\n+\t  if (strcmp (\".plt\", lookup->name + 4 + lookrela) == 0)\n+\t    break;\n+\n+\t  if (rela == lookrela || last_rel == NULL)\n+\t    last_rel = lookup;\n+\t  if ((rela == lookrela || last_rel_alloc == NULL)\n+\t      && lookup->bfd_section != NULL\n+\t      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)\n+\t    last_rel_alloc = lookup;\n+\t}\n+\n+      last = lookup;\n+      if (lookup->bfd_section != NULL\n+\t  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)\n+\t{\n+\t  last_alloc = lookup;\n+\t  if ((lookup->bfd_section->flags & SEC_READONLY) != 0)\n+\t    last_ro_alloc = lookup;\n+\t}\n+    }\n+\n+  if (last_rel_alloc)\n+    return last_rel_alloc;\n+\n+  if (last_rel)\n+    return last_rel;\n+\n+  if (last_ro_alloc)\n+    return last_ro_alloc;\n+\n+  if (last_alloc)\n+    return last_alloc;\n+\n+  return last;\n+}\n+\n+/* Return whether IN is suitable to be part of OUT.  */\n+\n+static bfd_boolean\n+elf_orphan_compatible (asection *in, asection *out)\n+{\n+  /* Non-zero sh_info implies a section with SHF_INFO_LINK with\n+     unknown semantics for the generic linker, or a SHT_REL/SHT_RELA\n+     section where sh_info specifies a symbol table.  (We won't see\n+     SHT_GROUP, SHT_SYMTAB or SHT_DYNSYM sections here.)  We clearly\n+     can't merge SHT_REL/SHT_RELA using differing symbol tables, and\n+     shouldn't merge sections with differing unknown semantics.  */\n+  if (elf_section_data (out)->this_hdr.sh_info\n+      != elf_section_data (in)->this_hdr.sh_info)\n+    return FALSE;\n+  /* We can't merge with member of output section group nor merge two\n+     sections with differing SHF_EXCLUDE when doing a relocatable link.\n+   */\n+  if (bfd_link_relocatable (&link_info)\n+      && (elf_next_in_group (out) != NULL\n+\t  || ((elf_section_flags (out) ^ elf_section_flags (in))\n+\t      & SHF_EXCLUDE) != 0))\n+    return FALSE;\n+  return _bfd_elf_match_sections_by_type (link_info.output_bfd, out,\n+\t\t\t\t\t  in->owner, in);\n+}\n+\n+/* Place an orphan section.  We use this to put random SHF_ALLOC\n+   sections in the right segment.  */\n+\n+lang_output_section_statement_type *\n+ldelf_place_orphan (asection *s, const char *secname, int constraint)\n+{\n+  static struct orphan_save hold[] =\n+    {\n+      { \".text\",\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,\n+\t0, 0, 0, 0 },\n+      { \".rodata\",\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,\n+\t0, 0, 0, 0 },\n+      { \".tdata\",\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_THREAD_LOCAL,\n+\t0, 0, 0, 0 },\n+      { \".data\",\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,\n+\t0, 0, 0, 0 },\n+      { \".bss\",\n+\tSEC_ALLOC,\n+\t0, 0, 0, 0 },\n+      { 0,\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,\n+\t0, 0, 0, 0 },\n+      { \".interp\",\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,\n+\t0, 0, 0, 0 },\n+      { \".sdata\",\n+\tSEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_SMALL_DATA,\n+\t0, 0, 0, 0 },\n+      { \".comment\",\n+\tSEC_HAS_CONTENTS,\n+\t0, 0, 0, 0 },\n+    };\n+  enum orphan_save_index\n+    {\n+      orphan_text = 0,\n+      orphan_rodata,\n+      orphan_tdata,\n+      orphan_data,\n+      orphan_bss,\n+      orphan_rel,\n+      orphan_interp,\n+      orphan_sdata,\n+      orphan_nonalloc\n+    };\n+  static int orphan_init_done = 0;\n+  struct orphan_save *place;\n+  lang_output_section_statement_type *after;\n+  lang_output_section_statement_type *os;\n+  lang_output_section_statement_type *match_by_name = NULL;\n+  int isdyn = 0;\n+  int elfinput = s->owner->xvec->flavour == bfd_target_elf_flavour;\n+  int elfoutput = link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour;\n+  unsigned int sh_type = elfinput ? elf_section_type (s) : SHT_NULL;\n+  flagword flags;\n+  asection *nexts;\n+\n+  if (!bfd_link_relocatable (&link_info)\n+      && link_info.combreloc\n+      && (s->flags & SEC_ALLOC))\n+    {\n+      if (elfinput)\n+\tswitch (sh_type)\n+\t  {\n+\t  case SHT_RELA:\n+\t    secname = \".rela.dyn\";\n+\t    isdyn = 1;\n+\t    break;\n+\t  case SHT_REL:\n+\t    secname = \".rel.dyn\";\n+\t    isdyn = 1;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+      else if (CONST_STRNEQ (secname, \".rel\"))\n+\t{\n+\t  secname = secname[4] == 'a' ? \".rela.dyn\" : \".rel.dyn\";\n+\t  isdyn = 1;\n+\t}\n+    }\n+\n+  if (!bfd_link_relocatable (&link_info)\n+      && elfinput\n+      && elfoutput\n+      && (s->flags & SEC_ALLOC) != 0\n+      && (elf_tdata (s->owner)->has_gnu_osabi & elf_gnu_osabi_mbind) != 0\n+      && (elf_section_flags (s) & SHF_GNU_MBIND) != 0)\n+    {\n+      /* Find the output mbind section with the same type, attributes\n+\t and sh_info field.  */\n+      for (os = &lang_os_list.head->output_section_statement;\n+\t   os != NULL;\n+\t   os = os->next)\n+\tif (os->bfd_section != NULL\n+\t    && !bfd_is_abs_section (os->bfd_section)\n+\t    && (elf_section_flags (os->bfd_section) & SHF_GNU_MBIND) != 0\n+\t    && ((s->flags & (SEC_ALLOC\n+\t\t\t     | SEC_LOAD\n+\t\t\t     | SEC_HAS_CONTENTS\n+\t\t\t     | SEC_READONLY\n+\t\t\t     | SEC_CODE))\n+\t\t== (os->bfd_section->flags & (SEC_ALLOC\n+\t\t\t\t\t      | SEC_LOAD\n+\t\t\t\t\t      | SEC_HAS_CONTENTS\n+\t\t\t\t\t      | SEC_READONLY\n+\t\t\t\t\t      | SEC_CODE)))\n+\t    && (elf_section_data (os->bfd_section)->this_hdr.sh_info\n+\t\t== elf_section_data (s)->this_hdr.sh_info))\n+\t    {\n+\t      lang_add_section (&os->children, s, NULL, os);\n+\t      return os;\n+\t    }\n+\n+      /* Create the output mbind section with the \".mbind.\" prefix\n+\t in section name.  */\n+      if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)\n+\tsecname = \".mbind.bss\";\n+      else if ((s->flags & SEC_READONLY) == 0)\n+\tsecname = \".mbind.data\";\n+      else if ((s->flags & SEC_CODE) == 0)\n+\tsecname = \".mbind.rodata\";\n+      else\n+\tsecname = \".mbind.text\";\n+      elf_tdata (link_info.output_bfd)->has_gnu_osabi |= elf_gnu_osabi_mbind;\n+    }\n+\n+  /* Look through the script to see where to place this section.  The\n+     script includes entries added by previous lang_insert_orphan\n+     calls, so this loop puts multiple compatible orphans of the same\n+     name into a single output section.  */\n+  if (constraint == 0)\n+    for (os = lang_output_section_find (secname);\n+\t os != NULL;\n+\t os = next_matching_output_section_statement (os, 0))\n+      {\n+\t/* If we don't match an existing output section, tell\n+\t   lang_insert_orphan to create a new output section.  */\n+\tconstraint = SPECIAL;\n+\n+\t/* Check to see if we already have an output section statement\n+\t   with this name, and its bfd section has compatible flags.\n+\t   If the section already exists but does not have any flags\n+\t   set, then it has been created by the linker, possibly as a\n+\t   result of a --section-start command line switch.  */\n+\tif (os->bfd_section != NULL\n+\t    && (os->bfd_section->flags == 0\n+\t\t|| (((s->flags ^ os->bfd_section->flags)\n+\t\t     & (SEC_LOAD | SEC_ALLOC)) == 0\n+\t\t    && (!elfinput\n+\t\t\t|| !elfoutput\n+\t\t\t|| elf_orphan_compatible (s, os->bfd_section)))))\n+\t  {\n+\t    lang_add_section (&os->children, s, NULL, os);\n+\t    return os;\n+\t  }\n+\n+\t/* Save unused output sections in case we can match them\n+\t   against orphans later.  */\n+\tif (os->bfd_section == NULL)\n+\t  match_by_name = os;\n+      }\n+\n+  /* If we didn't match an active output section, see if we matched an\n+     unused one and use that.  */\n+  if (match_by_name)\n+    {\n+      lang_add_section (&match_by_name->children, s, NULL, match_by_name);\n+      return match_by_name;\n+    }\n+\n+  if (!orphan_init_done)\n+    {\n+      struct orphan_save *ho;\n+\n+      for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)\n+\tif (ho->name != NULL)\n+\t  {\n+\t    ho->os = lang_output_section_find (ho->name);\n+\t    if (ho->os != NULL && ho->os->flags == 0)\n+\t      ho->os->flags = ho->flags;\n+\t  }\n+      orphan_init_done = 1;\n+    }\n+\n+  /* If this is a final link, then always put .gnu.warning.SYMBOL\n+     sections into the .text section to get them out of the way.  */\n+  if (bfd_link_executable (&link_info)\n+      && CONST_STRNEQ (s->name, \".gnu.warning.\")\n+      && hold[orphan_text].os != NULL)\n+    {\n+      os = hold[orphan_text].os;\n+      lang_add_section (&os->children, s, NULL, os);\n+      return os;\n+    }\n+\n+  flags = s->flags;\n+  if (!bfd_link_relocatable (&link_info))\n+    {\n+      nexts = s;\n+      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts))\n+\t     != NULL)\n+\tif (nexts->output_section == NULL\n+\t    && (nexts->flags & SEC_EXCLUDE) == 0\n+\t    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0\n+\t    && (nexts->owner->flags & DYNAMIC) == 0\n+\t    && nexts->owner->usrdata != NULL\n+\t    && !(((lang_input_statement_type *) nexts->owner->usrdata)\n+\t\t ->flags.just_syms)\n+\t    && _bfd_elf_match_sections_by_type (nexts->owner, nexts,\n+\t\t\t\t\t\ts->owner, s))\n+\t  flags = (((flags ^ SEC_READONLY)\n+\t\t    | (nexts->flags ^ SEC_READONLY))\n+\t\t   ^ SEC_READONLY);\n+    }\n+\n+  /* Decide which segment the section should go in based on the\n+     section name and section flags.  We put loadable .note sections\n+     right after the .interp section, so that the PT_NOTE segment is\n+     stored right after the program headers where the OS can read it\n+     in the first page.  */\n+\n+  place = NULL;\n+  if ((flags & (SEC_ALLOC | SEC_DEBUGGING)) == 0)\n+    place = &hold[orphan_nonalloc];\n+  else if ((flags & SEC_ALLOC) == 0)\n+    ;\n+  else if ((flags & SEC_LOAD) != 0\n+\t   && (elfinput\n+\t       ? sh_type == SHT_NOTE\n+\t       : CONST_STRNEQ (secname, \".note\")))\n+    place = &hold[orphan_interp];\n+  else if ((flags & (SEC_LOAD | SEC_HAS_CONTENTS | SEC_THREAD_LOCAL)) == 0)\n+    place = &hold[orphan_bss];\n+  else if ((flags & SEC_SMALL_DATA) != 0)\n+    place = &hold[orphan_sdata];\n+  else if ((flags & SEC_THREAD_LOCAL) != 0)\n+    place = &hold[orphan_tdata];\n+  else if ((flags & SEC_READONLY) == 0)\n+    place = &hold[orphan_data];\n+  else if ((flags & SEC_LOAD) != 0\n+\t   && (elfinput\n+\t       ? sh_type == SHT_RELA || sh_type == SHT_REL\n+\t       : CONST_STRNEQ (secname, \".rel\")))\n+    place = &hold[orphan_rel];\n+  else if ((flags & SEC_CODE) == 0)\n+    place = &hold[orphan_rodata];\n+  else\n+    place = &hold[orphan_text];\n+\n+  after = NULL;\n+  if (place != NULL)\n+    {\n+      if (place->os == NULL)\n+\t{\n+\t  if (place->name != NULL)\n+\t    place->os = lang_output_section_find (place->name);\n+\t  else\n+\t    {\n+\t      int rela = elfinput ? sh_type == SHT_RELA : secname[4] == 'a';\n+\t      place->os = output_rel_find (isdyn, rela);\n+\t    }\n+\t}\n+      after = place->os;\n+      if (after == NULL)\n+\tafter\n+\t  = lang_output_section_find_by_flags (s, flags, &place->os,\n+\t\t\t\t\t       _bfd_elf_match_sections_by_type);\n+      if (after == NULL)\n+\t/* *ABS* is always the first output section statement.  */\n+\tafter = &lang_os_list.head->output_section_statement;\n+    }\n+\n+  return lang_insert_orphan (s, secname, constraint, after, place, NULL, NULL);\n+}"
    },
    {
      "sha": "0116629dba36fe0e7664d24199baca47847be813",
      "filename": "ld/ldelf.h",
      "status": "added",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.h?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -0,0 +1,32 @@\n+/* ELF emulation code for targets using elf32.em.\n+   Copyright (C) 1991-2019 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Binutils.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+extern const char *ldelf_emit_note_gnu_build_id;\n+\n+extern void ldelf_after_parse (void);\n+extern bfd_boolean ldelf_load_symbols (lang_input_statement_type *);\n+extern void ldelf_after_open (int, int, int, int, int);\n+extern bfd_boolean ldelf_setup_build_id (bfd *);\n+extern void ldelf_append_to_separated_string (char **, char *);\n+extern void ldelf_before_allocation (char *, char *, const char *);\n+extern bfd_boolean ldelf_open_dynamic_archive\n+  (const char *, search_dirs_type *, lang_input_statement_type *);\n+extern lang_output_section_statement_type *ldelf_place_orphan\n+  (asection *, const char *, int);"
    },
    {
      "sha": "98bcecd89fce8f2c0ca85422ce438df08727ddd5",
      "filename": "ld/ldelfgen.c",
      "status": "added",
      "additions": 74,
      "deletions": 0,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelfgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelfgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.c?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -0,0 +1,74 @@\n+/* Emulation code used by all ELF targets.\n+   Copyright (C) 1991-2019 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Binutils.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"sysdep.h\"\n+#include \"bfd.h\"\n+#include \"ld.h\"\n+#include \"ldmain.h\"\n+#include \"ldmisc.h\"\n+#include \"ldexp.h\"\n+#include \"ldlang.h\"\n+#include \"elf-bfd.h\"\n+#include \"ldelfgen.h\"\n+\n+void\n+ldelf_map_segments (bfd_boolean need_layout)\n+{\n+  int tries = 10;\n+\n+  do\n+    {\n+      lang_relax_sections (need_layout);\n+      need_layout = FALSE;\n+\n+      if (link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour\n+\t  && !bfd_link_relocatable (&link_info))\n+\t{\n+\t  bfd_size_type phdr_size;\n+\n+\t  phdr_size = elf_program_header_size (link_info.output_bfd);\n+\t  /* If we don't have user supplied phdrs, throw away any\n+\t     previous linker generated program headers.  */\n+\t  if (lang_phdr_list == NULL)\n+\t    elf_seg_map (link_info.output_bfd) = NULL;\n+\t  if (!_bfd_elf_map_sections_to_segments (link_info.output_bfd,\n+\t\t\t\t\t\t  &link_info))\n+\t    einfo (_(\"%F%P: map sections to segments failed: %E\\n\"));\n+\n+\t  if (phdr_size != elf_program_header_size (link_info.output_bfd))\n+\t    {\n+\t      if (tries > 6)\n+\t\t/* The first few times we allow any change to\n+\t\t   phdr_size .  */\n+\t\tneed_layout = TRUE;\n+\t      else if (phdr_size\n+\t\t       < elf_program_header_size (link_info.output_bfd))\n+\t\t/* After that we only allow the size to grow.  */\n+\t\tneed_layout = TRUE;\n+\t      else\n+\t\telf_program_header_size (link_info.output_bfd) = phdr_size;\n+\t    }\n+\t}\n+    }\n+  while (need_layout && --tries);\n+\n+  if (tries == 0)\n+    einfo (_(\"%F%P: looping in map_segments\"));\n+}"
    },
    {
      "sha": "328446006c364e88a92101dfddf0bbb1c55ae386",
      "filename": "ld/ldelfgen.h",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelfgen.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldelfgen.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.h?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -0,0 +1,21 @@\n+/* Emulation code used by all ELF targets.\n+   Copyright (C) 1991-2019 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Binutils.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+extern void ldelf_map_segments (bfd_boolean);"
    },
    {
      "sha": "d5a2b497e1d6321e59ac3422f48807ab13e46080",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -6862,8 +6862,8 @@ lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)\n     }\n }\n \n-/* Call a function on each input file.  This function will be called\n-   on an archive, but not on the elements.  */\n+/* Call a function on each real input file.  This function will be\n+   called on an archive, but not on the elements.  */\n \n void\n lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n@@ -6873,19 +6873,21 @@ lang_for_each_input_file (void (*func) (lang_input_statement_type *))\n   for (f = &input_file_chain.head->input_statement;\n        f != NULL;\n        f = f->next_real_file)\n-    func (f);\n+    if (f->flags.real)\n+      func (f);\n }\n \n-/* Call a function on each file.  The function will be called on all\n-   the elements of an archive which are included in the link, but will\n-   not be called on the archive file itself.  */\n+/* Call a function on each real file.  The function will be called on\n+   all the elements of an archive which are included in the link, but\n+   will not be called on the archive file itself.  */\n \n void\n lang_for_each_file (void (*func) (lang_input_statement_type *))\n {\n   LANG_FOR_EACH_INPUT_STATEMENT (f)\n     {\n-      func (f);\n+      if (f->flags.real)\n+\tfunc (f);\n     }\n }\n "
    },
    {
      "sha": "bbadc8ebab578a61a2f130686235cbe351347957",
      "filename": "ld/po/SRC-POTFILES.in",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d871d478061f10b0879c688e2fa941407e9137aa/ld/po/SRC-POTFILES.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d871d478061f10b0879c688e2fa941407e9137aa/ld/po/SRC-POTFILES.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/po/SRC-POTFILES.in?ref=d871d478061f10b0879c688e2fa941407e9137aa",
      "patch": "@@ -6,6 +6,10 @@ ldbuildid.h\n ldcref.c\n ldctor.c\n ldctor.h\n+ldelf.c\n+ldelf.h\n+ldelfgen.c\n+ldelfgen.h\n ldemul.c\n ldemul.h\n ldexp.c"
    }
  ]
}