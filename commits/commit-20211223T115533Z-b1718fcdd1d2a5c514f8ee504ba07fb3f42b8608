{
  "sha": "b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
  "node_id": "C_kwDOANOeidoAKGIxNzE4ZmNkZDFkMmE1YzUxNGY4ZWU1MDRiYTA3ZmIzZjQyYjg2MDg",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-13T16:56:16Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-23T11:55:33Z"
    },
    "message": "gdb: on x86-64 non-trivial C++ objects are returned in memory\n\nFixes PR gdb/28681.  It was observed that after using the `finish`\ncommand an incorrect value was displayed in some cases.  Specifically,\nthis behaviour was observed on an x86-64 target.\n\nConsider this test program:\n\n  struct A\n  {\n    int i;\n\n    A ()\n    { this->i = 0; }\n    A (const A& a)\n    { this->i = a.i; }\n  };\n\n  A\n  func (int i)\n  {\n    A a;\n    a.i = i;\n    return a;\n  }\n\n  int\n  main ()\n  {\n    A a = func (3);\n    return a.i;\n  }\n\nAnd this GDB session:\n\n  $ gdb -q ex.x\n  Reading symbols from ex.x...\n  (gdb) b func\n  Breakpoint 1 at 0x401115: file ex.cc, line 14.\n  (gdb) r\n  Starting program: /home/andrew/tmp/ex.x\n\n  Breakpoint 1, func (i=3) at ex.cc:14\n  14\t  A a;\n  (gdb) finish\n  Run till exit from #0  func (i=3) at ex.cc:14\n  main () at ex.cc:23\n  23\t  return a.i;\n  Value returned is $1 = {\n    i = -19044\n  }\n  (gdb) p a\n  $2 = {\n    i = 3\n  }\n  (gdb)\n\nNotice how after the `finish` the contents of $1 are junk, but, when I\nimmediately ask for the value of `a`, I get back the correct value.\n\nThe problem here is that after the finish command GDB calls the\nfunction amd64_return_value to figure out where the return value can\nbe found (on x86-64 targets anyway).\n\nThis function makes the wrong choice for the struct A in our case, as\nsizeof(A) <= 8, then amd64_return_value decides that A will be\nreturned in a register.  GDB then reads the return value register an\ninterprets the contents as an instance of A.\n\nUnfortunately, A is not trivially copyable (due to its copy\nconstructor), and the sys-v specification for argument and return\nvalue passing, says that any non-trivial C++ object should have space\nallocated for it by the caller, and the address of this space is\npassed to the callee as a hidden first argument.  The callee should\nthen return the address of this space as the return value.\n\nAnd so, the register that GDB is treating as containing an instance of\nA, actually contains the address of an instance of A (in this case on\nthe stack), this is why GDB shows the incorrect result.\n\nThe call stack within GDB for where we actually go wrong is this:\n\n  amd64_return_value\n    amd64_classify\n      amd64_classify_aggregate\n\nAnd it is in amd64_classify_aggregate that we should be classifying\nthe type as AMD64_MEMORY, instead of as AMD64_INTEGER as we currently\ndo (via a call to amd64_classify_aggregate_field).\n\nAt the top of amd64_classify_aggregate we already have this logic:\n\n  if (TYPE_LENGTH (type) > 16 || amd64_has_unaligned_fields (type))\n    {\n      theclass[0] = theclass[1] = AMD64_MEMORY;\n      return;\n    }\n\nWhich handles some easy cases where we know a struct will be placed\ninto memory, that is (a) the struct is more than 16-bytes in size,\nor (b) the struct has any unaligned fields.\n\nAll we need then, is to add a check here to see if the struct is\ntrivially copyable.  If it is not then we know the struct will be\npassed in memory.\n\nI originally structured the code like this:\n\n  if (TYPE_LENGTH (type) > 16\n      || amd64_has_unaligned_fields (type)\n      || !language_pass_by_reference (type).trivially_copyable)\n    {\n      theclass[0] = theclass[1] = AMD64_MEMORY;\n      return;\n    }\n\nThis solved the example from the bug, and my small example above.  So\nthen I started adding some more extensive tests to the GDB testsuite,\nand I ran into a problem.  I hit this error:\n\n  gdbtypes.h:676: internal-error: loc_bitpos: Assertion `m_loc_kind == FIELD_LOC_KIND_BITPOS' failed.\n\nThis problem is triggered from:\n\n  amd64_classify_aggregate\n    amd64_has_unaligned_fields\n      field::loc_bitpos\n\nInside the unaligned field check we try to get the bit position of\neach field.  Unfortunately, in some cases the field location is not\nFIELD_LOC_KIND_BITPOS, but is FIELD_LOC_KIND_DWARF_BLOCK.\n\nAn example that shows this bug is:\n\n  struct B\n  {\n    short j;\n  };\n\n  struct A : virtual public B\n  {\n    short i;\n\n    A ()\n    { this->i = 0; }\n    A (const A& a)\n    { this->i = a.i; }\n  };\n\n  A\n  func (int i)\n  {\n    A a;\n    a.i = i;\n    return a;\n  }\n\n  int\n  main ()\n  {\n    A a = func (3);\n    return a.i;\n  }\n\nIt is the virtual base class, B, that causes the problem.  The base\nclass is represented, within GDB, as a field within A.  However, the\nlocation type for this field is a DWARF_BLOCK.\n\nI spent a little time trying to figure out how to convert the\nDWARF_BLOCK to a BITPOS, however, I realised that, in this case at\nleast, conversion is not needed.\n\nThe C++ standard says that a class is not trivially copyable if it has\nany virtual base classes.  And so, in this case, even if I could\nfigure out the BITPOS for the virtual base class fields, I know for\nsure that I would immediately fail the trivially_copyable check.  So,\nlets just reorder the checks in amd64_classify_aggregate to:\n\n  if (TYPE_LENGTH (type) > 16\n      || !language_pass_by_reference (type).trivially_copyable\n      || amd64_has_unaligned_fields (type))\n    {\n      theclass[0] = theclass[1] = AMD64_MEMORY;\n      return;\n    }\n\nNow, if we have a class with virtual bases we will fail quicker, and\navoid the unaligned fields check completely.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28681",
    "tree": {
      "sha": "c609bb907fafe163b7ce35f5ab9c20fd38820ba0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c609bb907fafe163b7ce35f5ab9c20fd38820ba0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "391c90eea53478a5e96ec88cd713e11909555911",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/391c90eea53478a5e96ec88cd713e11909555911",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/391c90eea53478a5e96ec88cd713e11909555911"
    }
  ],
  "stats": {
    "total": 61,
    "additions": 57,
    "deletions": 4
  },
  "files": [
    {
      "sha": "4956b1c60a7a1091067ec9192cef67bb9b94d31a",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 3,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
      "patch": "@@ -656,9 +656,19 @@ amd64_classify_aggregate_field (struct type *type, int i,\n static void\n amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n {\n-  /* 1. If the size of an object is larger than two eightbytes, or it has\n-\tunaligned fields, it has class memory.  */\n-  if (TYPE_LENGTH (type) > 16 || amd64_has_unaligned_fields (type))\n+  /* 1. If the size of an object is larger than two times eight bytes, or\n+\tit is a non-trivial C++ object, or it has unaligned fields, then it\n+\thas class memory.\n+\n+\tIt is important that the trivially_copyable check is before the\n+\tunaligned fields check, as C++ classes with virtual base classes\n+\twill have fields (for the virtual base classes) with non-constant\n+\tloc_bitpos attributes, which will cause an assert to trigger within\n+\tthe unaligned field check.  As classes with virtual bases are not\n+\ttrivially copyable, checking that first avoids this problem.  */\n+  if (TYPE_LENGTH (type) > 16\n+      || !language_pass_by_reference (type).trivially_copyable\n+      || amd64_has_unaligned_fields (type))\n     {\n       theclass[0] = theclass[1] = AMD64_MEMORY;\n       return;"
    },
    {
      "sha": "58b2d0a3b10c46c819dda8a1339dcae4b6c7b2dc",
      "filename": "gdb/testsuite/gdb.cp/non-trivial-retval.cc",
      "status": "modified",
      "additions": 18,
      "deletions": 1,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/gdb/testsuite/gdb.cp/non-trivial-retval.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/gdb/testsuite/gdb.cp/non-trivial-retval.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/non-trivial-retval.cc?ref=b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
      "patch": "@@ -142,11 +142,28 @@ f4 (int i1, int i2)\n   return e;\n }\n \n+/* We place a breakpoint on the call to this function.  */\n+\n+void\n+breakpt ()\n+{\n+}\n+\n int\n main (void)\n {\n   int i1 = 23;\n   int i2 = 100;\n \n-  return 0;  /* Break here  */\n+  breakpt ();\t/* Break here.  */\n+\n+  /* The copy constructor of A takes a non-const reference, so we can't\n+     pass in the temporary returned from f1.  */\n+  (void) f1 (i1, i2);\n+  B b = f2 (i1, i2);\n+  B1 b1 = f22 (i1, i2);\n+  C c = f3 (i1, i2);\n+  E e = f4 (i1, i2);\n+\n+  return 0;\n }"
    },
    {
      "sha": "8d3efc4361f4780646b6fe4ee6b0faf596a8379f",
      "filename": "gdb/testsuite/gdb.cp/non-trivial-retval.exp",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/gdb/testsuite/gdb.cp/non-trivial-retval.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608/gdb/testsuite/gdb.cp/non-trivial-retval.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/non-trivial-retval.exp?ref=b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
      "patch": "@@ -35,3 +35,29 @@ gdb_test \"p f2 (i1, i2)\" \".* = {b = 123}\"\n gdb_test \"p f22 (i1, i2)\" \".* = {b1 = 123}\"\n gdb_test \"p f3 (i1, i2)\" \".* = {.* c = 123}\"\n gdb_test \"p f4 (i1, i2)\" \".* = {.* e = 123}\"\n+\n+gdb_breakpoint \"f1\"\n+gdb_breakpoint \"f2\"\n+gdb_breakpoint \"f22\"\n+gdb_breakpoint \"f3\"\n+gdb_breakpoint \"f4\"\n+\n+gdb_continue_to_breakpoint \"Break in f1\"\n+gdb_test \"finish\" \" = {a = 123}\" \\\n+    \"finish from f1\"\n+\n+gdb_continue_to_breakpoint \"Break in f2\"\n+gdb_test \"finish\" \" = {b = 123}\" \\\n+    \"finish from f2\"\n+\n+gdb_continue_to_breakpoint \"Break in f22\"\n+gdb_test \"finish\" \" = {b1 = 123}\" \\\n+    \"finish from f22\"\n+\n+gdb_continue_to_breakpoint \"Break in f3\"\n+gdb_test \"finish\" \" = {.* c = 123}\" \\\n+    \"finish from f3\"\n+\n+gdb_continue_to_breakpoint \"Break in f4\"\n+gdb_test \"finish\" \" = {.* e = 123}\" \\\n+    \"finish from f4\""
    }
  ]
}