{
  "sha": "c50b7c1b743b241902f58d10f0c7ec9e20b55013",
  "node_id": "C_kwDOANOeidoAKGM1MGI3YzFiNzQzYjI0MTkwMmY1OGQxMGYwYzdlYzllMjBiNTUwMTM",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-06T07:15:41Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:38Z"
    },
    "message": "sim: synacor: migrate to standard uintXX_t types\n\nMove off the sim-specific unsignedXX types and to the standard uintXX_t\ntypes that C11 provides.",
    "tree": {
      "sha": "787f4a4af741be16d55325b267dc209e2f25311f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/787f4a4af741be16d55325b267dc209e2f25311f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c50b7c1b743b241902f58d10f0c7ec9e20b55013",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c50b7c1b743b241902f58d10f0c7ec9e20b55013",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c50b7c1b743b241902f58d10f0c7ec9e20b55013",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c50b7c1b743b241902f58d10f0c7ec9e20b55013/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "868b6a9d3bbfd4059b29ac58371cc92937ab1393",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/868b6a9d3bbfd4059b29ac58371cc92937ab1393",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/868b6a9d3bbfd4059b29ac58371cc92937ab1393"
    }
  ],
  "stats": {
    "total": 54,
    "additions": 27,
    "deletions": 27
  },
  "files": [
    {
      "sha": "75d5c6bc471c6865da11ba208bfae703bda3e718",
      "filename": "sim/example-synacor/sim-main.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c50b7c1b743b241902f58d10f0c7ec9e20b55013/sim/example-synacor/sim-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c50b7c1b743b241902f58d10f0c7ec9e20b55013/sim/example-synacor/sim-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/example-synacor/sim-main.c?ref=c50b7c1b743b241902f58d10f0c7ec9e20b55013",
      "patch": "@@ -28,8 +28,8 @@\n #include \"sim-signal.h\"\n \f\n /* Get the register number from the number.  */\n-static unsigned16\n-register_num (SIM_CPU *cpu, unsigned16 num)\n+static uint16_t\n+register_num (SIM_CPU *cpu, uint16_t num)\n {\n   SIM_DESC sd = CPU_STATE (cpu);\n \n@@ -40,8 +40,8 @@ register_num (SIM_CPU *cpu, unsigned16 num)\n }\n \n /* Helper to process immediates according to the ISA.  */\n-static unsigned16\n-interp_num (SIM_CPU *cpu, unsigned16 num)\n+static uint16_t\n+interp_num (SIM_CPU *cpu, uint16_t num)\n {\n   SIM_DESC sd = CPU_STATE (cpu);\n \n@@ -69,7 +69,7 @@ interp_num (SIM_CPU *cpu, unsigned16 num)\n void step_once (SIM_CPU *cpu)\n {\n   SIM_DESC sd = CPU_STATE (cpu);\n-  unsigned16 iw1, num1;\n+  uint16_t iw1, num1;\n   sim_cia pc = sim_pc_get (cpu);\n \n   iw1 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc);\n@@ -86,7 +86,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 1)\n     {\n       /* set: 1 a b: Set register <a> to the value of <b>.  */\n-      unsigned16 iw2, iw3, num2, num3;\n+      uint16_t iw2, iw3, num2, num3;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -103,7 +103,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 2)\n     {\n       /* push: 2 a: Push <a> onto the stack.  */\n-      unsigned16 iw2, num2;\n+      uint16_t iw2, num2;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -120,7 +120,7 @@ void step_once (SIM_CPU *cpu)\n     {\n       /* pop: 3 a: Remove the top element from the stack and write it into <a>.\n \t Empty stack = error.  */\n-      unsigned16 iw2, num2, result;\n+      uint16_t iw2, num2, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -139,7 +139,7 @@ void step_once (SIM_CPU *cpu)\n     {\n       /* eq: 4 a b c: Set <a> to 1 if <b> is equal to <c>; set it to 0\n \t otherwise.  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -161,7 +161,7 @@ void step_once (SIM_CPU *cpu)\n     {\n       /* gt: 5 a b c: Set <a> to 1 if <b> is greater than <c>; set it to 0\n \t otherwise.  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -182,7 +182,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 6)\n     {\n       /* jmp: 6 a: Jump to <a>.  */\n-      unsigned16 iw2, num2;\n+      uint16_t iw2, num2;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -197,7 +197,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 7)\n     {\n       /* jt: 7 a b: If <a> is nonzero, jump to <b>.  */\n-      unsigned16 iw2, iw3, num2, num3;\n+      uint16_t iw2, iw3, num2, num3;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -220,7 +220,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 8)\n     {\n       /* jf: 8 a b: If <a> is zero, jump to <b>.  */\n-      unsigned16 iw2, iw3, num2, num3;\n+      uint16_t iw2, iw3, num2, num3;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -243,7 +243,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 9)\n     {\n       /* add: 9 a b c: Assign <a> the sum of <b> and <c> (modulo 32768).  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -266,7 +266,7 @@ void step_once (SIM_CPU *cpu)\n     {\n       /* mult: 10 a b c: Store into <a> the product of <b> and <c> (modulo\n \t 32768).  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -288,7 +288,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 11)\n     {\n       /* mod: 11 a b c: Store into <a> the remainder of <b> divided by <c>.  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -309,7 +309,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 12)\n     {\n       /* and: 12 a b c: Stores into <a> the bitwise and of <b> and <c>.  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -330,7 +330,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 13)\n     {\n       /* or: 13 a b c: Stores into <a> the bitwise or of <b> and <c>.  */\n-      unsigned16 iw2, iw3, iw4, num2, num3, num4, result;\n+      uint16_t iw2, iw3, iw4, num2, num3, num4, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -351,7 +351,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 14)\n     {\n       /* not: 14 a b: Stores 15-bit bitwise inverse of <b> in <a>.  */\n-      unsigned16 iw2, iw3, num2, num3, result;\n+      uint16_t iw2, iw3, num2, num3, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -370,7 +370,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 15)\n     {\n       /* rmem: 15 a b: Read memory at address <b> and write it to <a>.  */\n-      unsigned16 iw2, iw3, num2, num3, result;\n+      uint16_t iw2, iw3, num2, num3, result;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = register_num (cpu, iw2);\n@@ -392,7 +392,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 16)\n     {\n       /* wmem: 16 a b: Write the value from <b> into memory at address <a>.  */\n-      unsigned16 iw2, iw3, num2, num3;\n+      uint16_t iw2, iw3, num2, num3;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -412,7 +412,7 @@ void step_once (SIM_CPU *cpu)\n     {\n       /* call: 17 a: Write the address of the next instruction to the stack and\n \t jump to <a>.  */\n-      unsigned16 iw2, num2;\n+      uint16_t iw2, num2;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -433,7 +433,7 @@ void step_once (SIM_CPU *cpu)\n     {\n       /* ret: 18: Remove the top element from the stack and jump to it; empty\n \t stack = halt.  */\n-      unsigned16 result;\n+      uint16_t result;\n \n       TRACE_INSN (cpu, \"RET\");\n       cpu->sp += 2;\n@@ -447,7 +447,7 @@ void step_once (SIM_CPU *cpu)\n   else if (num1 == 19)\n     {\n       /* out: 19 a: Write the character <a> to the terminal.  */\n-      unsigned16 iw2, num2;\n+      uint16_t iw2, num2;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);\n       num2 = interp_num (cpu, iw2);\n@@ -465,7 +465,7 @@ void step_once (SIM_CPU *cpu)\n \t to <a>.  It can be assumed that once input starts, it will continue\n \t until a newline is encountered.  This means that you can safely read\n \t lines from the keyboard and trust that they will be fully read.  */\n-      unsigned16 iw2, num2;\n+      uint16_t iw2, num2;\n       char c;\n \n       iw2 = sim_core_read_aligned_2 (cpu, pc, exec_map, pc + 2);"
    },
    {
      "sha": "e7e3ddc6d44d14f5d3ff41f12fee4f4a32e017b2",
      "filename": "sim/example-synacor/sim-main.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c50b7c1b743b241902f58d10f0c7ec9e20b55013/sim/example-synacor/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c50b7c1b743b241902f58d10f0c7ec9e20b55013/sim/example-synacor/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/example-synacor/sim-main.h?ref=c50b7c1b743b241902f58d10f0c7ec9e20b55013",
      "patch": "@@ -26,12 +26,12 @@\n \n struct _sim_cpu {\n   /* ... simulator specific members ... */\n-  unsigned16 regs[8];\n+  uint16_t regs[8];\n   sim_cia pc;\n \n   /* This isn't a real register, and the stack is not directly addressable,\n      so use memory outside of the 16-bit address space.  */\n-  unsigned32 sp;\n+  uint32_t sp;\n \n   sim_cpu_base base;\n };"
    }
  ]
}