{
  "sha": "1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWU1OGE0YTRkYjk5N2NmMDkzMTVjMjJmM2RhNzI1ZDFkYTdmOWVlNw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-24T17:20:05Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-05T01:55:10Z"
    },
    "message": "Move expression_context_* globals to parser_state\n\nThis moves the expression_context_block and expression_context_pc\nglobals to be members of parser_state and updates the parsers.\n\ngdb/ChangeLog\n2019-04-04  Tom Tromey  <tom@tromey.com>\n\n\t* rust-exp.y (rust_parser::crate_name, rust_parser::super_name)\n\t(rust_parser::convert_ast_to_type)\n\t(rust_parser::convert_ast_to_expression, rust_lex_tests): Update.\n\t* parser-defs.h (struct parser_state) <parser_state>: Add\n\tparameters.  Initialize new members.\n\t<expression_context_block, expression_context_pc>: New members.\n\t* parse.c (expression_context_block, expression_context_pc):\n\tRemove globals.\n\t(parse_exp_in_context): Update.\n\t* p-exp.y: Update all rules.\n\t(yylex): Update.\n\t* m2-exp.y: Update all rules.\n\t(yylex): Update.\n\t* go-exp.y (yylex): Update.\n\t* f-exp.y (yylex): Update.\n\t* d-exp.y: Update all rules.\n\t(yylex): Update.\n\t* c-exp.y: Update all rules.\n\t(lex_one_token, classify_name, yylex, c_parse): Update.\n\t* ada-exp.y (write_var_or_type, write_name_assoc): Update.",
    "tree": {
      "sha": "5166626dc2cad5a02581b158edaa245045922ab9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5166626dc2cad5a02581b158edaa245045922ab9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "37eedb39824dc26c82a92b5515a352d7de0c9b5b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/37eedb39824dc26c82a92b5515a352d7de0c9b5b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/37eedb39824dc26c82a92b5515a352d7de0c9b5b"
    }
  ],
  "stats": {
    "total": 217,
    "additions": 136,
    "deletions": 81
  },
  "files": [
    {
      "sha": "fec79ebb493a232ef9bb7b25501ed45fb8f90789",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -1,3 +1,26 @@\n+2019-04-04  Tom Tromey  <tom@tromey.com>\n+\n+\t* rust-exp.y (rust_parser::crate_name, rust_parser::super_name)\n+\t(rust_parser::convert_ast_to_type)\n+\t(rust_parser::convert_ast_to_expression, rust_lex_tests): Update.\n+\t* parser-defs.h (struct parser_state) <parser_state>: Add\n+\tparameters.  Initialize new members.\n+\t<expression_context_block, expression_context_pc>: New members.\n+\t* parse.c (expression_context_block, expression_context_pc):\n+\tRemove globals.\n+\t(parse_exp_in_context): Update.\n+\t* p-exp.y: Update all rules.\n+\t(yylex): Update.\n+\t* m2-exp.y: Update all rules.\n+\t(yylex): Update.\n+\t* go-exp.y (yylex): Update.\n+\t* f-exp.y (yylex): Update.\n+\t* d-exp.y: Update all rules.\n+\t(yylex): Update.\n+\t* c-exp.y: Update all rules.\n+\t(lex_one_token, classify_name, yylex, c_parse): Update.\n+\t* ada-exp.y (write_var_or_type, write_name_assoc): Update.\n+\n 2019-04-04  Tom Tromey  <tom@tromey.com>\n \n \t* gdbarch.h, gdbarch.c: Rebuild."
    },
    {
      "sha": "0cf85c52dd00b82836c5e5cfbecbad7c2d7427b9",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -1203,7 +1203,7 @@ write_var_or_type (struct parser_state *par_state,\n   int name_len;\n \n   if (block == NULL)\n-    block = expression_context_block;\n+    block = par_state->expression_context_block;\n \n   encoded_name = ada_encode (name0.ptr);\n   name_len = strlen (encoded_name);\n@@ -1343,7 +1343,7 @@ write_var_or_type (struct parser_state *par_state,\n \n       if (!have_full_symbols () && !have_partial_symbols () && block == NULL)\n \terror (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n-      if (block == expression_context_block)\n+      if (block == par_state->expression_context_block)\n \terror (_(\"No definition of \\\"%s\\\" in current context.\"), name0.ptr);\n       else\n \terror (_(\"No definition of \\\"%s\\\" in specified context.\"), name0.ptr);\n@@ -1376,7 +1376,8 @@ write_name_assoc (struct parser_state *par_state, struct stoken name)\n   if (strchr (name.ptr, '.') == NULL)\n     {\n       std::vector<struct block_symbol> syms;\n-      int nsyms = ada_lookup_symbol_list (name.ptr, expression_context_block,\n+      int nsyms = ada_lookup_symbol_list (name.ptr,\n+\t\t\t\t\t  par_state->expression_context_block,\n \t\t\t\t\t  VAR_DOMAIN, &syms);\n \n       if (nsyms != 1 || SYMBOL_CLASS (syms[0].symbol) == LOC_TYPEDEF)"
    },
    {
      "sha": "e6d6c208f159beb87b9c336a57d52913299603b5",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 32,
      "deletions": 21,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -559,8 +559,8 @@ exp\t:\tUNKNOWN_CPP_NAME '('\n \t\t\t  /* This could potentially be a an argument defined\n \t\t\t     lookup function (Koenig).  */\n \t\t\t  write_exp_elt_opcode (pstate, OP_ADL_FUNC);\n-\t\t\t  write_exp_elt_block (pstate,\n-\t\t\t\t\t       expression_context_block);\n+\t\t\t  write_exp_elt_block\n+\t\t\t    (pstate, pstate->expression_context_block);\n \t\t\t  write_exp_elt_sym (pstate,\n \t\t\t\t\t     NULL); /* Placeholder.  */\n \t\t\t  write_exp_string (pstate, $1.stoken);\n@@ -1400,8 +1400,10 @@ typebase\n \t\t\t\t\t\tNULL,\n \t\t\t\t\t\t0); }\n \t|\tSTRUCT name\n-\t\t\t{ $$ = lookup_struct (copy_name ($2),\n-\t\t\t\t\t      expression_context_block); }\n+\t\t\t{ $$\n+\t\t\t    = lookup_struct (copy_name ($2),\n+\t\t\t\t\t     pstate->expression_context_block);\n+\t\t\t}\n \t|\tSTRUCT COMPLETE\n \t\t\t{\n \t\t\t  mark_completion_tag (TYPE_CODE_STRUCT, \"\", 0);\n@@ -1414,8 +1416,9 @@ typebase\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tCLASS name\n-\t\t\t{ $$ = lookup_struct (copy_name ($2),\n-\t\t\t\t\t      expression_context_block); }\n+\t\t\t{ $$ = lookup_struct\n+\t\t\t    (copy_name ($2), pstate->expression_context_block);\n+\t\t\t}\n \t|\tCLASS COMPLETE\n \t\t\t{\n \t\t\t  mark_completion_tag (TYPE_CODE_STRUCT, \"\", 0);\n@@ -1428,8 +1431,10 @@ typebase\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tUNION name\n-\t\t\t{ $$ = lookup_union (copy_name ($2),\n-\t\t\t\t\t     expression_context_block); }\n+\t\t\t{ $$\n+\t\t\t    = lookup_union (copy_name ($2),\n+\t\t\t\t\t    pstate->expression_context_block);\n+\t\t\t}\n \t|\tUNION COMPLETE\n \t\t\t{\n \t\t\t  mark_completion_tag (TYPE_CODE_UNION, \"\", 0);\n@@ -1443,7 +1448,8 @@ typebase\n \t\t\t}\n \t|\tENUM name\n \t\t\t{ $$ = lookup_enum (copy_name ($2),\n-\t\t\t\t\t    expression_context_block); }\n+\t\t\t\t\t    pstate->expression_context_block);\n+\t\t\t}\n \t|\tENUM COMPLETE\n \t\t\t{\n \t\t\t  mark_completion_tag (TYPE_CODE_ENUM, \"\", 0);\n@@ -1475,8 +1481,9 @@ typebase\n                    reduced; template recognition happens by lookahead\n                    in the token processing code in yylex. */\n \t|\tTEMPLATE name '<' type '>'\n-\t\t\t{ $$ = lookup_template_type(copy_name($2), $4,\n-\t\t\t\t\t\t    expression_context_block);\n+\t\t\t{ $$ = lookup_template_type\n+\t\t\t    (copy_name($2), $4,\n+\t\t\t     pstate->expression_context_block);\n \t\t\t}\n \t| const_or_volatile_or_space_identifier_noopt typebase\n \t\t\t{ $$ = follow_types ($2); }\n@@ -1733,10 +1740,11 @@ name_not_typename :\tNAME\n \t\t\t  struct field_of_this_result is_a_field_of_this;\n \n \t\t\t  $$.stoken = $1;\n-\t\t\t  $$.sym = lookup_symbol ($1.ptr,\n-\t\t\t\t\t\t  expression_context_block,\n-\t\t\t\t\t\t  VAR_DOMAIN,\n-\t\t\t\t\t\t  &is_a_field_of_this);\n+\t\t\t  $$.sym\n+\t\t\t    = lookup_symbol ($1.ptr,\n+\t\t\t\t\t     pstate->expression_context_block,\n+\t\t\t\t\t     VAR_DOMAIN,\n+\t\t\t\t\t     &is_a_field_of_this);\n \t\t\t  $$.is_a_field_of_this\n \t\t\t    = is_a_field_of_this.type != NULL;\n \t\t\t}\n@@ -2869,7 +2877,8 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t  {\n \t    struct field_of_this_result is_a_field_of_this;\n \n-\t    if (lookup_symbol (copy, expression_context_block,\n+\t    if (lookup_symbol (copy,\n+\t\t\t       pstate->expression_context_block,\n \t\t\t       VAR_DOMAIN,\n \t\t\t       (par_state->language ()->la_language\n \t\t\t        == language_cplus ? &is_a_field_of_this\n@@ -3007,7 +3016,8 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t  struct symbol *sym;\n \n \t  yylval.theclass.theclass = Class;\n-\t  sym = lookup_struct_typedef (copy, expression_context_block, 1);\n+\t  sym = lookup_struct_typedef (copy,\n+\t\t\t\t       par_state->expression_context_block, 1);\n \t  if (sym)\n \t    yylval.theclass.type = SYMBOL_TYPE (sym);\n \t  return CLASSNAME;\n@@ -3145,7 +3155,7 @@ yylex (void)\n      name-like token.  */\n   current.token = lex_one_token (pstate, &is_quoted_name);\n   if (current.token == NAME)\n-    current.token = classify_name (pstate, expression_context_block,\n+    current.token = classify_name (pstate, pstate->expression_context_block,\n \t\t\t\t   is_quoted_name, last_lex_was_structop);\n   if (pstate->language ()->la_language != language_cplus\n       || (current.token != TYPENAME && current.token != COLONCOLON\n@@ -3191,7 +3201,7 @@ yylex (void)\n   else\n     {\n       gdb_assert (current.token == TYPENAME);\n-      search_block = expression_context_block;\n+      search_block = pstate->expression_context_block;\n       obstack_grow (&name_obstack, current.value.sval.ptr,\n \t\t    current.value.sval.length);\n       context_type = current.value.tsym.type;\n@@ -3288,8 +3298,9 @@ c_parse (struct parser_state *par_state)\n \n   gdb::unique_xmalloc_ptr<struct macro_scope> macro_scope;\n \n-  if (expression_context_block)\n-    macro_scope = sal_macro_scope (find_pc_line (expression_context_pc, 0));\n+  if (par_state->expression_context_block)\n+    macro_scope\n+      = sal_macro_scope (find_pc_line (par_state->expression_context_pc, 0));\n   else\n     macro_scope = default_macro_scope ();\n   if (! macro_scope)"
    },
    {
      "sha": "a701c2541d3fdfe75e7b25e7433a00e50946290b",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -416,8 +416,8 @@ PrimaryExpression:\n \t\t  struct block_symbol sym;\n \n \t\t  /* Handle VAR, which could be local or global.  */\n-\t\t  sym = lookup_symbol (copy, expression_context_block, VAR_DOMAIN,\n-\t\t\t\t       &is_a_field_of_this);\n+\t\t  sym = lookup_symbol (copy, pstate->expression_context_block,\n+\t\t\t\t       VAR_DOMAIN, &is_a_field_of_this);\n \t\t  if (sym.symbol && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n \t\t    {\n \t\t      if (symbol_read_needs_frame (sym.symbol))\n@@ -1458,7 +1458,7 @@ yylex (void)\n   if (current.token == IDENTIFIER)\n     {\n       yylval = current.value;\n-      current.token = classify_name (pstate, expression_context_block);\n+      current.token = classify_name (pstate, pstate->expression_context_block);\n       current.value = yylval;\n     }\n \n@@ -1489,7 +1489,8 @@ yylex (void)\n \t      yylval.sval.ptr = (char *) obstack_base (&name_obstack);\n \t      yylval.sval.length = obstack_object_size (&name_obstack);\n \n-\t      current.token = classify_name (pstate, expression_context_block);\n+\t      current.token = classify_name (pstate,\n+\t\t\t\t\t     pstate->expression_context_block);\n \t      current.value = yylval;\n \n \t      /* We keep going until we find a TYPENAME.  */\n@@ -1526,7 +1527,7 @@ yylex (void)\n   else\n     {\n       gdb_assert (current.token == TYPENAME);\n-      search_block = expression_context_block;\n+      search_block = pstate->expression_context_block;\n       obstack_grow (&name_obstack, current.value.sval.ptr,\n \t\t    current.value.sval.length);\n       context_type = current.value.tsym.type;"
    },
    {
      "sha": "5670136b2a6714a7dea700db4ab6719ed1f5036e",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -1274,7 +1274,7 @@ yylex (void)\n \t   way we can refer to it unconditionally below.  */\n \tmemset (&is_a_field_of_this, 0, sizeof (is_a_field_of_this));\n \n-\tresult = lookup_symbol (tmp, expression_context_block,\n+\tresult = lookup_symbol (tmp, pstate->expression_context_block,\n \t\t\t\tlookup_domains[i],\n \t\t\t\tpstate->language ()->la_language\n \t\t\t\t== language_cplus"
    },
    {
      "sha": "d112a73f21a7957128897ef3fe66f84f27f6f1e6",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -1528,14 +1528,14 @@ yylex (void)\n \t      return classify_unsafe_function (name2.value.sval);\n \t    }\n \n-\t  if (package_name_p (copy, expression_context_block))\n+\t  if (package_name_p (copy, pstate->expression_context_block))\n \t    {\n \t      popping = 1;\n \t      yylval.sval = build_packaged_name (current.value.sval.ptr,\n \t\t\t\t\t\t current.value.sval.length,\n \t\t\t\t\t\t name2.value.sval.ptr,\n \t\t\t\t\t\t name2.value.sval.length);\n-\t      return classify_packaged_name (expression_context_block);\n+\t      return classify_packaged_name (pstate->expression_context_block);\n \t    }\n \t}\n \n@@ -1549,7 +1549,7 @@ yylex (void)\n \n   popping = 1;\n   yylval = current.value;\n-  return classify_name (pstate, expression_context_block);\n+  return classify_name (pstate, pstate->expression_context_block);\n }\n \n int"
    },
    {
      "sha": "c1418c751f1486081b31ba0f429bca68bab9a950",
      "filename": "gdb/m2-exp.y",
      "status": "modified",
      "additions": 16,
      "deletions": 11,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/m2-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/m2-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -508,7 +508,7 @@ block\t:\tfblock\n fblock\t:\tBLOCKNAME\n \t\t\t{ struct symbol *sym\n \t\t\t    = lookup_symbol (copy_name ($1),\n-\t\t\t\t\t     expression_context_block,\n+\t\t\t\t\t     pstate->expression_context_block,\n \t\t\t\t\t     VAR_DOMAIN, 0).symbol;\n \t\t\t  $$ = sym;}\n \t;\n@@ -561,10 +561,11 @@ variable:\tNAME\n \t\t\t{ struct block_symbol sym;\n \t\t\t  struct field_of_this_result is_a_field_of_this;\n \n-\t\t\t  sym = lookup_symbol (copy_name ($1),\n-\t\t\t\t\t       expression_context_block,\n-\t\t\t\t\t       VAR_DOMAIN,\n-\t\t\t\t\t       &is_a_field_of_this);\n+\t\t\t  sym\n+\t\t\t    = lookup_symbol (copy_name ($1),\n+\t\t\t\t\t     pstate->expression_context_block,\n+\t\t\t\t\t     VAR_DOMAIN,\n+\t\t\t\t\t     &is_a_field_of_this);\n \n \t\t\t  if (sym.symbol)\n \t\t\t    {\n@@ -596,10 +597,13 @@ variable:\tNAME\n \n type\n \t:\tTYPENAME\n-\t\t\t{ $$ = lookup_typename (pstate->language (),\n-\t\t\t\t\t\tpstate->gdbarch (),\n-\t\t\t\t\t\tcopy_name ($1),\n-\t\t\t\t\t\texpression_context_block, 0); }\n+\t\t\t{ $$\n+\t\t\t    = lookup_typename (pstate->language (),\n+\t\t\t\t\t       pstate->gdbarch (),\n+\t\t\t\t\t       copy_name ($1),\n+\t\t\t\t\t       pstate->expression_context_block,\n+\t\t\t\t\t       0);\n+\t\t\t}\n \n \t;\n \n@@ -965,12 +969,13 @@ yylex (void)\n \n     if (lookup_symtab (tmp))\n       return BLOCKNAME;\n-    sym = lookup_symbol (tmp, expression_context_block, VAR_DOMAIN, 0).symbol;\n+    sym = lookup_symbol (tmp, pstate->expression_context_block,\n+\t\t\t VAR_DOMAIN, 0).symbol;\n     if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)\n       return BLOCKNAME;\n     if (lookup_typename (pstate->language (), pstate->gdbarch (),\n \t\t\t copy_name (yylval.sval),\n-\t\t\t expression_context_block, 1))\n+\t\t\t pstate->expression_context_block, 1))\n       return TYPENAME;\n \n     if(sym)"
    },
    {
      "sha": "dbccf358d5c58564efc4025d73cdf095a364e96a",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 16,
      "deletions": 10,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -784,11 +784,15 @@ typebase  /* Implements (approximately): (type-qualifier)* type-specifier */\n \t|\tTYPENAME\n \t\t\t{ $$ = $1.type; }\n \t|\tSTRUCT name\n-\t\t\t{ $$ = lookup_struct (copy_name ($2),\n-\t\t\t\t\t      expression_context_block); }\n+\t\t\t{ $$\n+\t\t\t    = lookup_struct (copy_name ($2),\n+\t\t\t\t\t     pstate->expression_context_block);\n+\t\t\t}\n \t|\tCLASS name\n-\t\t\t{ $$ = lookup_struct (copy_name ($2),\n-\t\t\t\t\t      expression_context_block); }\n+\t\t\t{ $$\n+\t\t\t    = lookup_struct (copy_name ($2),\n+\t\t\t\t\t     pstate->expression_context_block);\n+\t\t\t}\n \t/* \"const\" and \"volatile\" are curently ignored.  A type qualifier\n \t   after the type is handled in the ptype rule.  I think these could\n \t   be too.  */\n@@ -1463,7 +1467,7 @@ yylex (void)\n              inserted in FPC stabs debug info.  */\n \t  static const char this_name[] = \"this\";\n \n-\t  if (lookup_symbol (this_name, expression_context_block,\n+\t  if (lookup_symbol (this_name, pstate->expression_context_block,\n \t\t\t     VAR_DOMAIN, NULL).symbol)\n \t    {\n \t      free (uptokstart);\n@@ -1513,7 +1517,7 @@ yylex (void)\n     if (is_a_field)\n       sym = NULL;\n     else\n-      sym = lookup_symbol (tmp, expression_context_block,\n+      sym = lookup_symbol (tmp, pstate->expression_context_block,\n \t\t\t   VAR_DOMAIN, &is_a_field_of_this).symbol;\n     /* second chance uppercased (as Free Pascal does).  */\n     if (!sym && is_a_field_of_this.type == NULL && !is_a_field)\n@@ -1528,7 +1532,7 @@ yylex (void)\n        if (is_a_field)\n \t sym = NULL;\n        else\n-\t sym = lookup_symbol (tmp, expression_context_block,\n+\t sym = lookup_symbol (tmp, pstate->expression_context_block,\n \t\t\t      VAR_DOMAIN, &is_a_field_of_this).symbol;\n       }\n     /* Third chance Capitalized (as GPC does).  */\n@@ -1550,7 +1554,7 @@ yylex (void)\n        if (is_a_field)\n \t sym = NULL;\n        else\n-\t sym = lookup_symbol (tmp, expression_context_block,\n+\t sym = lookup_symbol (tmp, pstate->expression_context_block,\n \t\t\t      VAR_DOMAIN, &is_a_field_of_this).symbol;\n       }\n \n@@ -1645,8 +1649,10 @@ yylex (void)\n \t\t      tmp1 += 2;\n \t\t      memcpy (tmp1, namestart, p - namestart);\n \t\t      tmp1[p - namestart] = '\\0';\n-\t\t      cur_sym = lookup_symbol (ncopy, expression_context_block,\n-\t\t\t\t\t       VAR_DOMAIN, NULL).symbol;\n+\t\t      cur_sym\n+\t\t\t= lookup_symbol (ncopy,\n+\t\t\t\t\t pstate->expression_context_block,\n+\t\t\t\t\t VAR_DOMAIN, NULL).symbol;\n \t\t      if (cur_sym)\n \t\t\t{\n \t\t\t  if (SYMBOL_CLASS (cur_sym) == LOC_TYPEDEF)"
    },
    {
      "sha": "d76aeb1d853f7611c90e58382dee16ed1189c4fa",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -66,8 +66,6 @@ const struct exp_descriptor exp_descriptor_standard =\n   };\n \f\n /* Global variables declared in parser-defs.h (and commented there).  */\n-const struct block *expression_context_block;\n-CORE_ADDR expression_context_pc;\n innermost_block_tracker innermost_block;\n int arglist_len;\n static struct type_stack type_stack;\n@@ -593,7 +591,7 @@ mark_completion_tag (enum type_code tag, const char *ptr, int length)\n    value in the value history, I.e. $$1  */\n \n void\n-write_dollar_variable (struct expr_builder *ps, struct stoken str)\n+write_dollar_variable (struct parser_state *ps, struct stoken str)\n {\n   struct block_symbol sym;\n   struct bound_minimal_symbol msym;\n@@ -683,7 +681,7 @@ write_dollar_variable (struct expr_builder *ps, struct stoken str)\n   str.ptr++;\n   write_exp_string (ps, str);\n   write_exp_elt_opcode (ps, OP_REGISTER);\n-  innermost_block.update (expression_context_block,\n+  innermost_block.update (ps->expression_context_block,\n \t\t\t  INNERMOST_BLOCK_FOR_REGISTERS);\n   return;\n }\n@@ -1135,7 +1133,8 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n   scoped_restore save_funcall_chain = make_scoped_restore (&funcall_chain,\n \t\t\t\t\t\t\t   &funcalls);\n \n-  expression_context_block = block;\n+  const struct block *expression_context_block = block;\n+  CORE_ADDR expression_context_pc = 0;\n \n   /* If no context specified, try using the current frame, if any.  */\n   if (!expression_context_block)\n@@ -1189,7 +1188,8 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n      and others called from *.y) ensure CURRENT_LANGUAGE gets restored\n      to the value matching SELECTED_FRAME as set by get_current_arch.  */\n \n-  parser_state ps (lang, get_current_arch ());\n+  parser_state ps (lang, get_current_arch (), expression_context_block,\n+\t\t   expression_context_pc);\n \n   scoped_restore_current_language lang_saver;\n   set_language (lang->la_language);"
    },
    {
      "sha": "f895a552879837061fc6eacfa6d0a041fa746400",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 17,
      "deletions": 12,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -86,24 +86,29 @@ struct parser_state : public expr_builder\n      And GDBARCH is the gdbarch to use during parsing.  */\n \n   parser_state (const struct language_defn *lang,\n-\t\tstruct gdbarch *gdbarch)\n-    : expr_builder (lang, gdbarch)\n+\t\tstruct gdbarch *gdbarch,\n+\t\tconst struct block *context_block,\n+\t\tCORE_ADDR context_pc)\n+    : expr_builder (lang, gdbarch),\n+      expression_context_block (context_block),\n+      expression_context_pc (context_pc)\n   {\n   }\n \n   DISABLE_COPY_AND_ASSIGN (parser_state);\n-};\n \n-/* If this is nonzero, this block is used as the lexical context\n-   for symbol names.  */\n+  /* If this is nonzero, this block is used as the lexical context for\n+     symbol names.  */\n \n-extern const struct block *expression_context_block;\n+  const struct block * const expression_context_block;\n \n-/* If expression_context_block is non-zero, then this is the PC within\n-   the block that we want to evaluate expressions at.  When debugging\n-   C or C++ code, we use this to find the exact line we're at, and\n-   then look up the macro definitions active at that point.  */\n-extern CORE_ADDR expression_context_pc;\n+  /* If expression_context_block is non-zero, then this is the PC\n+     within the block that we want to evaluate expressions at.  When\n+     debugging C or C++ code, we use this to find the exact line we're\n+     at, and then look up the macro definitions active at that\n+     point.  */\n+  const CORE_ADDR expression_context_pc;\n+};\n \n /* When parsing expressions we track the innermost block that was\n    referenced.  */\n@@ -283,7 +288,7 @@ extern void write_exp_elt_objfile (struct expr_builder *,\n extern void write_exp_msymbol (struct expr_builder *,\n \t\t\t       struct bound_minimal_symbol);\n \n-extern void write_dollar_variable (struct expr_builder *, struct stoken str);\n+extern void write_dollar_variable (struct parser_state *, struct stoken str);\n \n extern void mark_struct_expression (struct expr_builder *);\n "
    },
    {
      "sha": "1b7e33e617249ef3fd5be801b69ca30fbf9e3e87",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 12,
      "deletions": 9,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e58a4a4db997cf09315c22f3da725d1da7f9ee7/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=1e58a4a4db997cf09315c22f3da725d1da7f9ee7",
      "patch": "@@ -1033,7 +1033,7 @@ rust_parser::concat3 (const char *s1, const char *s2, const char *s3)\n const struct rust_op *\n rust_parser::crate_name (const struct rust_op *name)\n {\n-  std::string crate = rust_crate_for_block (expression_context_block);\n+  std::string crate = rust_crate_for_block (pstate->expression_context_block);\n   struct stoken result;\n \n   gdb_assert (name->opcode == OP_VAR_VALUE);\n@@ -1053,7 +1053,7 @@ rust_parser::crate_name (const struct rust_op *name)\n const struct rust_op *\n rust_parser::super_name (const struct rust_op *ident, unsigned int n_supers)\n {\n-  const char *scope = block_scope (expression_context_block);\n+  const char *scope = block_scope (pstate->expression_context_block);\n   int offset;\n \n   gdb_assert (ident->opcode == OP_VAR_VALUE);\n@@ -2045,7 +2045,7 @@ rust_parser::convert_ast_to_type (const struct rust_op *operation)\n     {\n       const char *varname = convert_name (operation);\n \n-      result = rust_lookup_type (varname, expression_context_block);\n+      result = rust_lookup_type (varname, pstate->expression_context_block);\n       if (result == NULL)\n \terror (_(\"No typed name '%s' in current context\"), varname);\n       return result;\n@@ -2118,7 +2118,7 @@ rust_parser::convert_ast_to_type (const struct rust_op *operation)\n \n \t/* We don't allow creating new tuple types (yet), but we do\n \t   allow looking up existing tuple types.  */\n-\tresult = rust_lookup_type (name, expression_context_block);\n+\tresult = rust_lookup_type (name, pstate->expression_context_block);\n \tif (result == NULL)\n \t  error (_(\"could not find tuple type '%s'\"), name);\n       }\n@@ -2311,7 +2311,8 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t    struct type *type;\n \t    const char *varname = convert_name (operation->left.op);\n \n-\t    type = rust_lookup_type (varname, expression_context_block);\n+\t    type = rust_lookup_type (varname,\n+\t\t\t\t     pstate->expression_context_block);\n \t    if (type != NULL)\n \t      {\n \t\t/* This is actually a tuple struct expression, not a\n@@ -2372,7 +2373,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t  }\n \n \tvarname = convert_name (operation);\n-\tsym = rust_lookup_symbol (varname, expression_context_block,\n+\tsym = rust_lookup_symbol (varname, pstate->expression_context_block,\n \t\t\t\t  VAR_DOMAIN);\n \tif (sym.symbol != NULL && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n \t  {\n@@ -2391,7 +2392,8 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t\ttype = SYMBOL_TYPE (sym.symbol);\n \t      }\n \t    if (type == NULL)\n-\t      type = rust_lookup_type (varname, expression_context_block);\n+\t      type = rust_lookup_type (varname,\n+\t\t\t\t       pstate->expression_context_block);\n \t    if (type == NULL)\n \t      error (_(\"No symbol '%s' in current context\"), varname);\n \n@@ -2449,7 +2451,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \t  }\n \n \tname = convert_name (operation->left.op);\n-\ttype = rust_lookup_type (name, expression_context_block);\n+\ttype = rust_lookup_type (name, pstate->expression_context_block);\n \tif (type == NULL)\n \t  error (_(\"Could not find type '%s'\"), operation->left.sval.ptr);\n \n@@ -2707,7 +2709,8 @@ rust_lex_tests (void)\n   int i;\n \n   // Set up dummy \"parser\", so that rust_type works.\n-  struct parser_state ps (&rust_language_defn, target_gdbarch ());\n+  struct parser_state ps (&rust_language_defn, target_gdbarch (),\n+\t\t\t  nullptr, 0);\n   rust_parser parser (&ps);\n \n   rust_lex_test_one (&parser, \"\", 0);"
    }
  ]
}