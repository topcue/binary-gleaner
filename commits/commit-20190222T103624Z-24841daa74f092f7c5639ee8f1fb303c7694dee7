{
  "sha": "24841daa74f092f7c5639ee8f1fb303c7694dee7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjQ4NDFkYWE3NGYwOTJmN2M1NjM5ZWU4ZjFmYjMwM2M3Njk0ZGVlNw==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2019-02-22T10:36:24Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2019-02-22T10:36:24Z"
    },
    "message": "Extend readelf and objdump so that they will display and follow multiple links to separate debug information files.\n\n\tPR 23843\n\t* dwarf.h (struct separate_info): New structure for containing\n\tinformation on separate debug info files.\n\t* dwarf.c (struct dwo_info): New structure for containing dwo\n\tlinks.\n\t(first_dwo_info): Chain of dwo_info structures.\n\t(first_separate_file): Chain of separate_info structures.\n\t(separate_debug_file, separate_debug_filename): Delete.\n\t(fetch_alt_indirect_string): Scan all separate debug info files\n\tfor the requested string.\n\t(add_dwo_info): New function.\n\t(add_dwo_name): New function.\n\t(add_dwo_dir): New function.\n\t(add_dwo_id: New function.\n\t(free_dwo_info): New function.\n\t(read_and_display_attr_value): Store DWO data using the new\n\tfunctions.\n\t(load_debug_section_with_follow): If necessary, scan the list of\n\tseparate debug info files for the requested section.\n\t(add_separate_debug_file): New function.\n\t(load_separate_debug_info): Call add_separate_debug_file to store\n\tthe information on the newly loaded file.\n\t(load_dwo_file): Likewise.\n\t(load_separate_debif_file): Rename to load_separate_debug_files.\n\tChange return type to boolean.  If following links then attempt to\n\tload all separate debug info files, not just the first one.\n\t(free_debug_memory): Release memory in dwo_info and separate_info\n\tchains.\n\t* objdump.c (dump_dwarf): Iterate over all loaded debg info files.\n\t* readelf.c (process_object): Likewise.\n\t* doc/debug.options.texi: Update descriptions of links and\n\tfollow-links options.\n\t* testsuite/binutils-all/objdump.WK2: Update expected output.\n\t* testsuite/binutils-all/readelf.k2: Likewise.\n\t* NEWS: Announce the new feature.",
    "tree": {
      "sha": "e1bc310ca5ad66731c0b21496c4c3a093c7b89b8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e1bc310ca5ad66731c0b21496c4c3a093c7b89b8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/24841daa74f092f7c5639ee8f1fb303c7694dee7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24841daa74f092f7c5639ee8f1fb303c7694dee7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/24841daa74f092f7c5639ee8f1fb303c7694dee7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24841daa74f092f7c5639ee8f1fb303c7694dee7/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "83f43c8344d752fb8266b4c4e2f42cf4e5a2f86e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/83f43c8344d752fb8266b4c4e2f42cf4e5a2f86e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/83f43c8344d752fb8266b4c4e2f42cf4e5a2f86e"
    }
  ],
  "stats": {
    "total": 560,
    "additions": 377,
    "deletions": 183
  },
  "files": [
    {
      "sha": "65316ee9dedcc8bd65ccaa38bf9334870faf12b9",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -1,3 +1,41 @@\n+2019-02-22  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 23843\n+\t* dwarf.h (struct separate_info): New structure for containing\n+\tinformation on separate debug info files.\n+\t* dwarf.c (struct dwo_info): New structure for containing dwo\n+\tlinks.\n+\t(first_dwo_info): Chain of dwo_info structures.\n+\t(first_separate_file): Chain of separate_info structures.\n+\t(separate_debug_file, separate_debug_filename): Delete.\n+\t(fetch_alt_indirect_string): Scan all separate debug info files\n+\tfor the requested string.\n+\t(add_dwo_info): New function.\n+\t(add_dwo_name): New function.\n+\t(add_dwo_dir): New function.\n+\t(add_dwo_id: New function.\n+\t(free_dwo_info): New function.\n+\t(read_and_display_attr_value): Store DWO data using the new\n+\tfunctions.\n+\t(load_debug_section_with_follow): If necessary, scan the list of\n+\tseparate debug info files for the requested section.\n+\t(add_separate_debug_file): New function.\n+\t(load_separate_debug_info): Call add_separate_debug_file to store\n+\tthe information on the newly loaded file.\n+\t(load_dwo_file): Likewise.\n+\t(load_separate_debif_file): Rename to load_separate_debug_files.\n+\tChange return type to boolean.  If following links then attempt to\n+\tload all separate debug info files, not just the first one.\n+\t(free_debug_memory): Release memory in dwo_info and separate_info\n+\tchains.\n+\t* objdump.c (dump_dwarf): Iterate over all loaded debg info files.\n+\t* readelf.c (process_object): Likewise.\n+\t* doc/debug.options.texi: Update descriptions of links and\n+\tfollow-links options.\n+\t* testsuite/binutils-all/objdump.WK2: Update expected output.\n+\t* testsuite/binutils-all/readelf.k2: Likewise.\n+\t* NEWS: Announce the new feature.\n+\n 2019-02-21  Nick Clifton  <nickc@redhat.com>\n \n \tPR 24247"
    },
    {
      "sha": "5413321b4baf0d433b69752223d0c8e6a0d060fd",
      "filename": "binutils/NEWS",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/NEWS?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -1,5 +1,11 @@\n -*- text -*-\n \n+* The separate debug info file options of readelf (--debug-dump=links\n+  and --debug-dump=follow) and objdump (--dwarf=links and\n+  --dwarf=follow-links) will now display and/or follow multiple links if\n+  more than one are present in a file.  (This usually happens when gcc's\n+  -gsplit-dwarf option is used).\n+\n Changes in 2.32:\n \n * The addr2line, c++filt, nm and objdump tools now have a limit on the"
    },
    {
      "sha": "7f07388b5672088f6f4c4db39c54062404dab4c9",
      "filename": "binutils/doc/debug.options.texi",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/doc/debug.options.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/doc/debug.options.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/doc/debug.options.texi?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -45,18 +45,17 @@ output from this option can also be restricted by the use of the\n @item k\n @itemx =links\n Displays the contents of the @samp{.gnu_debuglink} and/or\n-@samp{.gnu_debugaltlink} sections.  Also displays the link to a\n-separate dwarf object file (dwo), if one is specified by the \n+@samp{.gnu_debugaltlink} sections.  Also displays any links to\n+separate dwarf object files (dwo), if they are specified by the \n DW_AT_GNU_dwo_name or DW_AT_dwo_name attributes in the\n @samp{.debug_info} section.\n \n @item K\n @itemx =follow-links\n Display the contents of any selected debug sections that are found in\n-a linked, separate debug info file.  This can result in multiple\n-versions of the same debug section being displayed if both the main\n-file and the separate debug info file contain sections with the same\n-name.\n+linked, separate debug info file(s).  This can result in multiple\n+versions of the same debug section being displayed if it exists in\n+more than one file.\n \n In addition, when displaying DWARF attributes, if a form is found that\n references the separate debug info file, then the referenced contents"
    },
    {
      "sha": "07142af747e282cc00715e080fd837928c7f06d3",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 285,
      "deletions": 162,
      "changes": 447,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -48,11 +48,26 @@ static debug_info *debug_information = NULL;\n    that the .debug_info section could not be loaded/parsed.  */\n #define DEBUG_INFO_UNAVAILABLE  (unsigned int) -1\n \n-static const char *           dwo_name;\n-static const char *           dwo_dir;\n-static const unsigned char *  dwo_id;\n-static bfd_size_type          dwo_id_len;\n-static bfd_boolean            need_dwo_info;\n+/* A .debug_info section can contain multiple links to separate\n+   DWO object files.  We use these structures to record these links.  */\n+typedef enum dwo_type\n+{\n+ DWO_NAME,\n+ DWO_DIR,\n+ DWO_ID\n+} dwo_type;\n+\n+typedef struct dwo_info\n+{\n+  dwo_type          type;\n+  const char *      value;\n+  struct dwo_info * next;\n+} dwo_info;\n+\n+static dwo_info *   first_dwo_info = NULL;\n+static bfd_boolean  need_dwo_info;\n+\n+separate_info * first_separate_info = NULL;\n \n unsigned int eh_addr_size;\n \n@@ -96,10 +111,6 @@ static unsigned int *shndx_pool = NULL;\n static unsigned int shndx_pool_size = 0;\n static unsigned int shndx_pool_used = 0;\n \n-/* Pointer to a separate file containing extra debug information.  */\n-static void * separate_debug_file = NULL;\n-static const char * separate_debug_filename = NULL;\n-\n /* For version 2 package files, each set contains an array of section offsets\n    and an array of section sizes, giving the offset and size of the\n    contribution from a CU or TU within one of the debug sections.\n@@ -1711,37 +1722,44 @@ add64 (dwarf_vma * high_bits, dwarf_vma * low_bits, dwarf_vma inc)\n static const char *\n fetch_alt_indirect_string (dwarf_vma offset)\n {\n-  struct dwarf_section * section;\n-  const char *           ret;\n+  separate_info * i;\n \n   if (! do_follow_links)\n     return \"\";\n \n-  if (separate_debug_file == NULL)\n-    return _(\"<following link not possible>\");\n+  if (first_separate_info == NULL)\n+    return _(\"<no links available>\");\n \n-  if (! load_debug_section (separate_debug_str, separate_debug_file))\n-    return _(\"<could not load separate string section>\");\n+  for (i = first_separate_info; i != NULL; i = i->next)\n+    {\n+      struct dwarf_section * section;\n+      const char *           ret;\n \n-  section = &debug_displays [separate_debug_str].section;\n-  if (section->start == NULL)\n-    return  _(\"<no .debug_str section>\");\n+      if (! load_debug_section (separate_debug_str, i->handle))\n+\tcontinue;\n \n-  if (offset >= section->size)\n-    {\n-      warn (_(\"DW_FORM_GNU_strp_alt offset too big: %s\\n\"), dwarf_vmatoa (\"x\", offset));\n-      return _(\"<offset is too big>\");\n-    }\n+      section = &debug_displays [separate_debug_str].section;\n \n-  ret = (const char *) (section->start + offset);\n-  /* Unfortunately we cannot rely upon the .debug_str section ending with a\n-     NUL byte.  Since our caller is expecting to receive a well formed C\n-     string we test for the lack of a terminating byte here.  */\n-  if (strnlen ((const char *) ret, section->size - offset)\n-      == section->size - offset)\n-    return _(\"<no NUL byte at end of .debug_str section>\");\n+      if (section->start == NULL)\n+\tcontinue;\n \n-  return ret;\n+      if (offset >= section->size)\n+\tcontinue;\n+\n+      ret = (const char *) (section->start + offset);\n+      /* Unfortunately we cannot rely upon the .debug_str section ending with a\n+\t NUL byte.  Since our caller is expecting to receive a well formed C\n+\t string we test for the lack of a terminating byte here.  */\n+      if (strnlen ((const char *) ret, section->size - offset)\n+\t  == section->size - offset)\n+\treturn _(\"<no NUL byte at end of alt .debug_str section>\");\n+\n+      return ret;\n+    }\n+  \n+  warn (_(\"DW_FORM_GNU_strp_alt offset (%s) too big or no string sections available\\n\"),\n+\tdwarf_vmatoa (\"x\", offset));\n+  return _(\"<offset is too big>\");\n }\n \t\n static const char *\n@@ -1770,6 +1788,49 @@ get_AT_name (unsigned long attribute)\n   return name;\n }\n \n+static void\n+add_dwo_info (const char * field, dwo_type type)\n+{\n+  dwo_info * dwinfo = xmalloc (sizeof * dwinfo);\n+\n+  dwinfo->type = type;\n+  dwinfo->value = field;\n+  dwinfo->next = first_dwo_info;\n+  first_dwo_info = dwinfo;\n+}\n+\n+static void\n+add_dwo_name (const char * name)\n+{\n+  add_dwo_info (name, DWO_NAME);\n+}\n+\n+static void\n+add_dwo_dir (const char * dir)\n+{\n+  add_dwo_info (dir, DWO_DIR);\n+}\n+\n+static void\n+add_dwo_id (const char * id)\n+{\n+  add_dwo_info (id, DWO_ID);\n+}\n+\n+static void\n+free_dwo_info (void)\n+{\n+  dwo_info * dwinfo;\n+  dwo_info * next;\n+\n+  for (dwinfo = first_dwo_info; dwinfo != NULL; dwinfo = next)\n+    {\n+      next = dwinfo->next;\n+      free (dwinfo);\n+    }\n+  first_dwo_info = NULL;\n+}\n+\n static unsigned char *\n read_and_display_attr_value (unsigned long           attribute,\n \t\t\t     unsigned long           form,\n@@ -2260,18 +2321,17 @@ read_and_display_attr_value (unsigned long           attribute,\n \t    switch (form)\n \t      {\n \t      case DW_FORM_strp:\n-\t\tdwo_name = (const char *) fetch_indirect_string (uvalue);\n+\t\tadd_dwo_name ((const char *) fetch_indirect_string (uvalue));\n \t\tbreak;\n \t      case DW_FORM_GNU_str_index:\n-\t\tdwo_name = fetch_indexed_string (uvalue, this_set, offset_size, FALSE);\n+\t\tadd_dwo_name (fetch_indexed_string (uvalue, this_set, offset_size, FALSE));\n \t\tbreak;\n \t      case DW_FORM_string:\n-\t\tdwo_name = (const char *) orig_data;\n+\t\tadd_dwo_name ((const char *) orig_data);\n \t\tbreak;\n \t      default:\n \t\twarn (_(\"Unsupported form (%s) for attribute %s\\n\"),\n \t\t      get_FORM_name (form), get_AT_name (attribute));\n-\t\tdwo_name = _(\"<unknown>\");\n \t\tbreak;\n \t      }\n \t  break;\n@@ -2282,21 +2342,20 @@ read_and_display_attr_value (unsigned long           attribute,\n \t    switch (form)\n \t      {\n \t      case DW_FORM_strp:\n-\t\tdwo_dir = (const char *) fetch_indirect_string (uvalue);\n+\t\tadd_dwo_dir ((const char *) fetch_indirect_string (uvalue));\n \t\tbreak;\n \t      case DW_FORM_line_strp:\n-\t\tdwo_dir = (const char *) fetch_indirect_line_string (uvalue);\n+\t\tadd_dwo_dir ((const char *) fetch_indirect_line_string (uvalue));\n \t\tbreak;\n \t      case DW_FORM_GNU_str_index:\n-\t\tdwo_dir = fetch_indexed_string (uvalue, this_set, offset_size, FALSE);\n+\t\tadd_dwo_dir (fetch_indexed_string (uvalue, this_set, offset_size, FALSE));\n \t\tbreak;\n \t      case DW_FORM_string:\n-\t\tdwo_dir = (const char *) orig_data;\n+\t\tadd_dwo_dir ((const char *) orig_data);\n \t\tbreak;\n \t      default:\n \t\twarn (_(\"Unsupported form (%s) for attribute %s\\n\"),\n \t\t      get_FORM_name (form), get_AT_name (attribute));\n-\t\tdwo_dir = _(\"<unknown>\");\n \t\tbreak;\n \t      }\n \t  break;\n@@ -2306,13 +2365,12 @@ read_and_display_attr_value (unsigned long           attribute,\n \t    switch (form)\n \t      {\n \t      case DW_FORM_data8:\n-\t\tdwo_id = data - 8;\n-\t\tdwo_id_len = 8;\n+\t\t/* FIXME: Record the length of the ID as well ?  */\n+\t\tadd_dwo_id ((const char *) (data - 8));\n \t\tbreak;\n \t      default:\n \t\twarn (_(\"Unsupported form (%s) for attribute %s\\n\"),\n \t\t      get_FORM_name (form), get_AT_name (attribute));\n-\t\tdwo_id = NULL;\n \t\tbreak;\n \t      }\n \t  break;\n@@ -2722,30 +2780,47 @@ read_and_display_attr (unsigned long           attribute,\n }\n \n /* Like load_debug_section, but if the ordinary call fails, and we are\n-   following debug links, and we have been able to load a separate debug\n-   info file, then attempt to load the requested section from the separate\n-   file.  */\n+   following debug links, then attempt to load the requested section\n+   from one of the separate debug info files.  */\n \n static bfd_boolean\n load_debug_section_with_follow (enum dwarf_section_display_enum sec_enum,\n-\t\t\t\tvoid * data)\n+\t\t\t\tvoid * handle)\n {\n-  if (load_debug_section (sec_enum, data))\n+  if (load_debug_section (sec_enum, handle))\n     {\n-      if (data == separate_debug_file)\n-\tdebug_displays[sec_enum].section.filename = separate_debug_filename;\n-\t\n-      /* FIXME: We should check to see if there is a separate debug info file\n-\t that also contains this section, and if so, issue a warning.  */\n+      if (debug_displays[sec_enum].section.filename == NULL)\n+\t{\n+\t  /* See if we can associate a filename with this section.  */\n+\t  separate_info * i;\n+\n+\t  for (i = first_separate_info; i != NULL; i = i->next)\n+\t    if (i->handle == handle)\n+\t      {\n+\t\tdebug_displays[sec_enum].section.filename = i->filename;\n+\t\tbreak;\n+\t      }\n+\t}\n+\n       return TRUE;\n     }\n \n-  if (do_follow_links && separate_debug_file != NULL)\n-    if (load_debug_section (sec_enum, separate_debug_file))\n-      {\n-\tdebug_displays[sec_enum].section.filename = separate_debug_filename;\n-\treturn TRUE;\n-      }\n+  if (do_follow_links)\n+    {\n+      separate_info * i;\n+\n+      for (i = first_separate_info; i != NULL; i = i->next)\n+\t{\n+\t  if (load_debug_section (sec_enum, i->handle))\n+\t    {\n+\t      debug_displays[sec_enum].section.filename = i->filename;\n+\n+\t      /* FIXME: We should check to see if any of the remaining debug info\n+\t\t files also contain this section, and, umm, do something about it.  */\n+\t      return TRUE;\n+\t    }\n+\t}\n+    }\n \n   return FALSE;\n }\n@@ -6003,12 +6078,12 @@ display_debug_loc (struct dwarf_section *section, void *file)\n   unsigned char *next = start, *vnext = vstart;\n   unsigned int *array = NULL;\n   const char *suffix = strrchr (section->name, '.');\n-  int is_dwo = 0;\n+  bfd_boolean is_dwo = FALSE;\n   int is_loclists = strstr (section->name, \"debug_loclists\") != NULL;\n   dwarf_vma expected_start = 0;\n \n   if (suffix && strcmp (suffix, \".dwo\") == 0)\n-    is_dwo = 1;\n+    is_dwo = TRUE;\n \n   bytes = section->size;\n \n@@ -6554,6 +6629,7 @@ display_debug_addr (struct dwarf_section *section,\n }\n \n /* Display the .debug_str_offsets and .debug_str_offsets.dwo sections.  */\n+\n static int\n display_debug_str_offsets (struct dwarf_section *section,\n \t\t\t   void *file ATTRIBUTE_UNUSED)\n@@ -9811,6 +9887,17 @@ parse_gnu_debugaltlink (struct dwarf_section * section, void * data)\n   return name;\n }\n \n+static void\n+add_separate_debug_file (const char * filename, void * handle)\n+{\n+  separate_info * i = xmalloc (sizeof * i);\n+\n+  i->filename = filename;\n+  i->handle   = handle;\n+  i->next     = first_separate_info;\n+  first_separate_info = i;\n+}\n+\n static void *\n load_separate_debug_info (const char *            main_filename,\n \t\t\t  struct dwarf_section *  xlink,\n@@ -9819,7 +9906,7 @@ load_separate_debug_info (const char *            main_filename,\n \t\t\t  void *                  func_data)\n {\n   const char *   separate_filename;\n-  char *         debugfile;\n+  char *         debug_filename;\n   char *         canon_dir;\n   size_t         canon_dirlen;\n   size_t         dirlen;\n@@ -9851,198 +9938,226 @@ load_separate_debug_info (const char *            main_filename,\n #define EXTRA_DEBUG_ROOT2 \"/usr/lib/debug/usr\"\n #endif\n \n-  debugfile = (char *) malloc (strlen (DEBUGDIR) + 1\n-\t\t\t       + canon_dirlen\n-\t\t\t       + strlen (\".debug/\")\n+  debug_filename = (char *) malloc (strlen (DEBUGDIR) + 1\n+\t\t\t\t    + canon_dirlen\n+\t\t\t\t    + strlen (\".debug/\")\n #ifdef EXTRA_DEBUG_ROOT1\n-\t\t\t       + strlen (EXTRA_DEBUG_ROOT1)\n+\t\t\t\t    + strlen (EXTRA_DEBUG_ROOT1)\n #endif\n #ifdef EXTRA_DEBUG_ROOT2\n-\t\t\t       + strlen (EXTRA_DEBUG_ROOT2)\n+\t\t\t\t    + strlen (EXTRA_DEBUG_ROOT2)\n #endif\n-\t\t\t       + strlen (separate_filename)\n-\t\t\t       + 1);\n-  if (debugfile == NULL)\n+\t\t\t\t    + strlen (separate_filename)\n+\t\t\t\t    + 1);\n+  if (debug_filename == NULL)\n     {\n       warn (_(\"Out of memory\"));\n       free (canon_dir);\n       return NULL;\n     }\n \n   /* First try in the current directory.  */\n-  sprintf (debugfile, \"%s\", separate_filename);\n-  if (check_func (debugfile, func_data))\n+  sprintf (debug_filename, \"%s\", separate_filename);\n+  if (check_func (debug_filename, func_data))\n     goto found;\n \n   /* Then try in a subdirectory called .debug.  */\n-  sprintf (debugfile, \".debug/%s\", separate_filename);\n-  if (check_func (debugfile, func_data))\n+  sprintf (debug_filename, \".debug/%s\", separate_filename);\n+  if (check_func (debug_filename, func_data))\n     goto found;\n \n   /* Then try in the same directory as the original file.  */\n-  sprintf (debugfile, \"%s%s\", canon_dir, separate_filename);\n-  if (check_func (debugfile, func_data))\n+  sprintf (debug_filename, \"%s%s\", canon_dir, separate_filename);\n+  if (check_func (debug_filename, func_data))\n     goto found;\n \n   /* And the .debug subdirectory of that directory.  */\n-  sprintf (debugfile, \"%s.debug/%s\", canon_dir, separate_filename);\n-  if (check_func (debugfile, func_data))\n+  sprintf (debug_filename, \"%s.debug/%s\", canon_dir, separate_filename);\n+  if (check_func (debug_filename, func_data))\n     goto found;\n \n #ifdef EXTRA_DEBUG_ROOT1\n   /* Try the first extra debug file root.  */\n-  sprintf (debugfile, \"%s/%s\", EXTRA_DEBUG_ROOT1, separate_filename);\n-  if (check_func (debugfile, func_data))\n+  sprintf (debug_filename, \"%s/%s\", EXTRA_DEBUG_ROOT1, separate_filename);\n+  if (check_func (debug_filename, func_data))\n     goto found;\n #endif\n \n #ifdef EXTRA_DEBUG_ROOT2\n   /* Try the second extra debug file root.  */\n-  sprintf (debugfile, \"%s/%s\", EXTRA_DEBUG_ROOT2, separate_filename);\n-  if (check_func (debugfile, func_data))\n+  sprintf (debug_filename, \"%s/%s\", EXTRA_DEBUG_ROOT2, separate_filename);\n+  if (check_func (debug_filename, func_data))\n     goto found;\n #endif\n \n-  /* Then try in the global debugfile directory.  */\n-  strcpy (debugfile, DEBUGDIR);\n+  /* Then try in the global debug_filename directory.  */\n+  strcpy (debug_filename, DEBUGDIR);\n   dirlen = strlen (DEBUGDIR) - 1;\n   if (dirlen > 0 && DEBUGDIR[dirlen] != '/')\n-    strcat (debugfile, \"/\");\n-  strcat (debugfile, (const char *) separate_filename);\n+    strcat (debug_filename, \"/\");\n+  strcat (debug_filename, (const char *) separate_filename);\n \n-  if (check_func (debugfile, func_data))\n+  if (check_func (debug_filename, func_data))\n     goto found;\n \n   /* Failed to find the file.  */\n   warn (_(\"could not find separate debug file '%s'\\n\"), separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n \n #ifdef EXTRA_DEBUG_ROOT2\n-  sprintf (debugfile, \"%s/%s\", EXTRA_DEBUG_ROOT2, separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  sprintf (debug_filename, \"%s/%s\", EXTRA_DEBUG_ROOT2, separate_filename);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n #endif\n \n #ifdef EXTRA_DEBUG_ROOT1\n-  sprintf (debugfile, \"%s/%s\", EXTRA_DEBUG_ROOT1, separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  sprintf (debug_filename, \"%s/%s\", EXTRA_DEBUG_ROOT1, separate_filename);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n #endif\n \n-  sprintf (debugfile, \"%s.debug/%s\", canon_dir, separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  sprintf (debug_filename, \"%s.debug/%s\", canon_dir, separate_filename);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n \n-  sprintf (debugfile, \"%s%s\", canon_dir, separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  sprintf (debug_filename, \"%s%s\", canon_dir, separate_filename);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n \n-  sprintf (debugfile, \".debug/%s\", separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  sprintf (debug_filename, \".debug/%s\", separate_filename);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n \n-  sprintf (debugfile, \"%s\", separate_filename);\n-  warn (_(\"tried: %s\\n\"), debugfile);\n+  sprintf (debug_filename, \"%s\", separate_filename);\n+  warn (_(\"tried: %s\\n\"), debug_filename);\n \n   free (canon_dir);\n-  free (debugfile);\n+  free (debug_filename);\n   return NULL;\n \n  found:\n   free (canon_dir);\n \n+  void * debug_handle;\n+\n   /* Now open the file.... */\n-  if ((separate_debug_file = open_debug_file (debugfile)) == NULL)\n+  if ((debug_handle = open_debug_file (debug_filename)) == NULL)\n     {\n-      warn (_(\"failed to open separate debug file: %s\\n\"), debugfile);\n-      free (debugfile);\n+      warn (_(\"failed to open separate debug file: %s\\n\"), debug_filename);\n+      free (debug_filename);\n       return FALSE;\n     }\n \n   /* FIXME: We do not check to see if there are any other separate debug info\n      files that would also match.  */\n \n-  printf (_(\"%s: Found separate debug info file: %s\\n\\n\"), main_filename, debugfile);\n-  separate_debug_filename = debugfile;\n+  printf (_(\"%s: Found separate debug info file: %s\\n\\n\"), main_filename, debug_filename);\n+  add_separate_debug_file (debug_filename, debug_handle);\n \n-  /* Do not free debugfile - it might be referenced inside\n+  /* Do not free debug_filename - it might be referenced inside\n      the structure returned by open_debug_file().  */\n-  return separate_debug_file;\n+  return debug_handle;\n }\n \n /* Attempt to load a separate dwarf object file.  */\n \n static void *\n-load_dwo_file (const char * main_filename)\n+load_dwo_file (const char * main_filename, const char * name, const char * dir, const char * id ATTRIBUTE_UNUSED)\n {\n-  char * filename;\n+  char * separate_filename;\n+  void * separate_handle;\n \n   /* FIXME: Skip adding / if dwo_dir ends in /.  */\n-  filename = concat (dwo_dir, \"/\", dwo_name, NULL);\n-  if (filename == NULL)\n+  separate_filename = concat (dir, \"/\", name, NULL);\n+  if (separate_filename == NULL)\n     {\n       warn (_(\"Out of memory allocating dwo filename\\n\"));\n       return NULL;\n     }\n \n-  if ((separate_debug_file = open_debug_file (filename)) == NULL)\n+  if ((separate_handle = open_debug_file (separate_filename)) == NULL)\n     {\n-      warn (_(\"Unable to load dwo file: %s\\n\"), filename);\n-      free (filename);\n+      warn (_(\"Unable to load dwo file: %s\\n\"), separate_filename);\n+      free (separate_filename);\n       return NULL;\n     }\n \n   /* FIXME: We should check the dwo_id.  */\n \n-  printf (_(\"%s: Found separate debug object file: %s\\n\\n\"), main_filename, filename);\n-  separate_debug_filename = filename;\n-  return separate_debug_file;\n+  printf (_(\"%s: Found separate debug object file: %s\\n\\n\"), main_filename, separate_filename);\n+  add_separate_debug_file (separate_filename, separate_handle);\n+  /* Note - separate_filename will be freed in free_debug_memory().  */\n+  return separate_handle;\n }\n \n-/* Load a separate debug info file, if it exists.\n-   Returns the data pointer that is the result of calling open_debug_file\n-   on the separate debug info file, or NULL if there were problems or there\n-   is no such file.  */\n+/* Load the separate debug info file(s) attached to FILE, if any exist.\n+   Returns TRUE if any were found, FALSE otherwise.\n+   If TRUE is returned then the linked list starting at first_separate_info\n+   will be populated with open file handles.  */\n \n-void *\n-load_separate_debug_file (void * file, const char * filename)\n+bfd_boolean\n+load_separate_debug_files (void * file, const char * filename)\n {\n   /* Skip this operation if we are not interested in debug links.  */\n   if (! do_follow_links && ! do_debug_links)\n-    return NULL;\n+    return FALSE;\n \n-  /* See if there is a dwo link.  */\n+  /* See if there are any dwo links.  */\n   if (load_debug_section (str, file)\n       && load_debug_section (abbrev, file)\n       && load_debug_section (info, file))\n     {\n-      dwo_name = dwo_dir = NULL;\n-      dwo_id = NULL;\n-      dwo_id_len = 0;\n+      free_dwo_info ();\n \n       if (process_debug_info (& debug_displays[info].section, file, abbrev, TRUE, FALSE))\n \t{\n-\t  if (dwo_name != NULL)\n+\t  bfd_boolean introduced = FALSE;\n+\t  dwo_info *   dwinfo;\n+\t  const char * dir = NULL;\n+\t  const char * id = NULL;\n+\n+\t  for (dwinfo = first_dwo_info; dwinfo != NULL; dwinfo = dwinfo->next)\n \t    {\n-\t      if (do_debug_links)\n+\t      switch (dwinfo->type)\n \t\t{\n-\t\t  printf (_(\"The %s section contains a link to a dwo file:\\n\"),\n-\t\t\t  debug_displays [info].section.uncompressed_name);\n-\t\t  printf (_(\"  Name:      %s\\n\"), dwo_name);\n-\t\t  printf (_(\"  Directory: %s\\n\"), dwo_dir ? dwo_dir : _(\"<not-found>\"));\n-\t\t  if (dwo_id != NULL)\n-\t\t    display_data (printf (_(\"  ID:       \")), dwo_id, dwo_id_len);\n-\t\t  else\n-\t\t    printf (_(\"  ID: <unknown>\\n\"));\n-\t\t  printf (\"\\n\\n\");\n-\t\t}\n+\t\tcase DWO_NAME:\n+\t\t  if (do_debug_links)\n+\t\t    {\n+\t\t      if (! introduced)\n+\t\t\t{\n+\t\t\t  printf (_(\"The %s section contains link(s) to dwo file(s):\\n\\n\"),\n+\t\t\t\t  debug_displays [info].section.uncompressed_name);\n+\t\t\t  introduced = TRUE;\n+\t\t\t}\n \n-\t      /* FIXME: We do not check to see if there are any more dwo links in the file...  */\n-\t      if (do_follow_links)\n-\t\treturn load_dwo_file (filename);\n+\t\t      printf (_(\"  Name:      %s\\n\"), dwinfo->value);\n+\t\t      printf (_(\"  Directory: %s\\n\"), dir ? dir : _(\"<not-found>\"));\n+\t\t      if (id != NULL)\n+\t\t\tdisplay_data (printf (_(\"  ID:       \")), (unsigned char *) id, 8);\n+\t\t      else\n+\t\t\tprintf (_(\"  ID: <unknown>\\n\"));\n+\t\t      printf (\"\\n\\n\");\n+\t\t    }\n+\n+\t\t  if (do_follow_links)\n+\t\t    load_dwo_file (filename, dwinfo->value, dir, id);\n+\t\t  break;\n+\n+\t\tcase DWO_DIR:\n+\t\t  dir = dwinfo->value;\n+\t\t  break;\n+\n+\t\tcase DWO_ID:\n+\t\t  id = dwinfo->value;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  error (_(\"Unexpected DWO INFO type\"));\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n     }\n \n   if (! do_follow_links)\n     /* The other debug links will be displayed by display_debug_links()\n        so we do not need to do any further processing here.  */\n-    return NULL;\n+    return FALSE;\n \n   /* FIXME: We do not check for the presence of both link sections in the same file.  */\n   /* FIXME: We do not check the separate debug info file to see if it too contains debuglinks.  */\n@@ -10053,26 +10168,29 @@ load_separate_debug_file (void * file, const char * filename)\n     {\n       Build_id_data * build_id_data;\n \n-      return load_separate_debug_info (filename,\n-\t\t\t\t       & debug_displays[gnu_debugaltlink].section,\n-\t\t\t\t       parse_gnu_debugaltlink,\n-\t\t\t\t       check_gnu_debugaltlink,\n-\t\t\t\t       & build_id_data);\n+      load_separate_debug_info (filename,\n+\t\t\t\t& debug_displays[gnu_debugaltlink].section,\n+\t\t\t\tparse_gnu_debugaltlink,\n+\t\t\t\tcheck_gnu_debugaltlink,\n+\t\t\t\t& build_id_data);\n     }\n \n   if (load_debug_section (gnu_debuglink, file))\n     {\n       unsigned long crc32;\n \n-      return load_separate_debug_info (filename,\n-\t\t\t\t       & debug_displays[gnu_debuglink].section,\n-\t\t\t\t       parse_gnu_debuglink,\n-\t\t\t\t       check_gnu_debuglink,\n-\t\t\t\t       & crc32);\n+      load_separate_debug_info (filename,\n+\t\t\t\t& debug_displays[gnu_debuglink].section,\n+\t\t\t\tparse_gnu_debuglink,\n+\t\t\t\tcheck_gnu_debuglink,\n+\t\t\t\t& crc32);\n     }\n \n+  if (first_separate_info != NULL)\n+    return TRUE;\n+\n   do_follow_links = 0;\n-  return NULL;\n+  return FALSE;\n }  \n \n void\n@@ -10105,14 +10223,19 @@ free_debug_memory (void)\n       alloc_num_debug_info_entries = num_debug_info_entries = 0;\n     }\n \n-  if (separate_debug_file != NULL)\n-    {\n-      close_debug_file (separate_debug_file);\n-      separate_debug_file = NULL;\n+  separate_info * d;\n+  separate_info * next;\n \n-      free ((void *) separate_debug_filename);\n-      separate_debug_filename = NULL;\n+  for (d = first_separate_info; d != NULL; d = next)\n+    {\n+      close_debug_file (d->handle);\n+      free ((void *) d->filename);\n+      next = d->next;\n+      free ((void *) d);\n     }\n+  first_separate_info = NULL;\n+  \n+  free_dwo_info ();\n }\n \n void"
    },
    {
      "sha": "a0287fc0bc54846f295243bc5aeacfeba693e842",
      "filename": "binutils/dwarf.h",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/dwarf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/dwarf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.h?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -187,6 +187,15 @@ typedef struct\n }\n debug_info;\n \n+typedef struct separate_info\n+{\n+  void *                  handle;    /* The pointer returned by open_debug_file().  */\n+  const char *            filename;\n+  struct separate_info *  next;\n+} separate_info;\n+\n+extern separate_info * first_separate_info;\n+\n extern unsigned int eh_addr_size;\n \n extern int do_debug_info;\n@@ -225,7 +234,7 @@ extern void init_dwarf_regnames_riscv (void);\n \n extern bfd_boolean  load_debug_section (enum dwarf_section_display_enum, void *);\n extern void         free_debug_section (enum dwarf_section_display_enum);\n-extern void *       load_separate_debug_file (void *, const char *);\n+extern bfd_boolean  load_separate_debug_files (void *, const char *);\n extern void         close_debug_file (void *);\n extern void *       open_debug_file (const char *);\n "
    },
    {
      "sha": "19365b67a0157af776d379f75df8ecf60b958d7a",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 11,
      "deletions": 4,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -2882,7 +2882,7 @@ dump_dwarf_section (bfd *abfd, asection *section,\n static void\n dump_dwarf (bfd *abfd)\n {\n-  bfd * separates;\n+  bfd_boolean have_separates;\n \n   is_relocatable = (abfd->flags & (EXEC_P | DYNAMIC)) == 0;\n \n@@ -2946,12 +2946,19 @@ dump_dwarf (bfd *abfd)\n       break;\n     }\n \n-  separates = load_separate_debug_file (abfd, bfd_get_filename (abfd));\n+  have_separates = load_separate_debug_files (abfd, bfd_get_filename (abfd));\n \n   bfd_map_over_sections (abfd, dump_dwarf_section, NULL);\n \n-  if (separates)\n-    bfd_map_over_sections (separates, dump_dwarf_section, NULL);\n+  if (have_separates)\n+    {\n+      separate_info * i;\n+\n+      for (i = first_separate_info; i != NULL; i = i->next)\n+\tbfd_map_over_sections (i->handle, dump_dwarf_section, NULL);\n+\n+      /* The file handles are closed by the call to free_debug_memory() below.  */\n+    }\n \n   free_debug_memory ();\n }"
    },
    {
      "sha": "38e9f1b3455c0f92ff53b76630a1bb80ee08c8e2",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 15,
      "deletions": 8,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -19302,7 +19302,7 @@ open_debug_file (const char * pathname)\n static bfd_boolean\n process_object (Filedata * filedata)\n {\n-  Filedata * separates;\n+  bfd_boolean  have_separate_files;\n   unsigned int i;\n   bfd_boolean res = TRUE;\n \n@@ -19379,19 +19379,26 @@ process_object (Filedata * filedata)\n     res = FALSE;\n \n   if (filedata->file_header.e_shstrndx != SHN_UNDEF)\n-    separates = load_separate_debug_file (filedata, filedata->file_name);\n+    have_separate_files = load_separate_debug_files (filedata, filedata->file_name);\n   else\n-    separates = NULL;\n+    have_separate_files = FALSE;\n \n   if (! process_section_contents (filedata))\n     res = FALSE;\n \n-  if (separates)\n+  if (have_separate_files)\n     {\n-      if (! process_section_headers (separates))\n-\tres = FALSE;\n-      else if (! process_section_contents (separates))\n-\tres = FALSE;\n+      separate_info * d;\n+\n+      for (d = first_separate_info; d != NULL; d = d->next)\n+\t{\n+\t  if (! process_section_headers (d->handle))\n+\t    res = FALSE;\n+\t  else if (! process_section_contents (d->handle))\n+\t    res = FALSE;\n+\t}\n+\n+      /* The file handles are closed by the call to free_debug_memory() below.  */\n     }\n \n   if (! process_notes (filedata))"
    },
    {
      "sha": "c98fdc15b58db2da00c59177bc3b947f7bb422f4",
      "filename": "binutils/testsuite/binutils-all/objdump.WK2",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/testsuite/binutils-all/objdump.WK2",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/testsuite/binutils-all/objdump.WK2",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/binutils-all/objdump.WK2?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -1,6 +1,6 @@\n #...\n .*debuglink.o: Found separate debug info file:.*linkdebug.debug\n-\n+#...\n Contents of the .debug_str section \\(loaded from .*debuglink.o\\):\n \n   0x00000000 73747269 6e672d31 00737472 696e672d string-1.string-"
    },
    {
      "sha": "e2ea0ad2808c5fd525f512bb2603f42c674d23bf",
      "filename": "binutils/testsuite/binutils-all/readelf.k2",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/testsuite/binutils-all/readelf.k2",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24841daa74f092f7c5639ee8f1fb303c7694dee7/binutils/testsuite/binutils-all/readelf.k2",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/binutils-all/readelf.k2?ref=24841daa74f092f7c5639ee8f1fb303c7694dee7",
      "patch": "@@ -1,4 +1,9 @@\n-The \\.debug_info section contains a link to a dwo file:\n+The \\.debug_info section contains link\\(s\\) to dwo file\\(s\\):\n+\n   Name:      file\\.dwo\n   Directory: /another/path/\n   ID:        (12|dd) (34|cc) (56|bb) (78|aa) (78|aa) (56|bb) (34|cc) (12|dd)\n+\n+  Name:      debugfile\\.dwo\n+  Directory: /path/to/dwo/files\n+  ID:        (12|dd) (34|cc) (56|bb) (78|aa) (78|aa) (56|bb) (34|cc) (12|dd)"
    }
  ]
}