{
  "sha": "4db10d8f4911298d06d2bb25927946f66f0f33e3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGRiMTBkOGY0OTExMjk4ZDA2ZDJiYjI1OTI3OTQ2ZjY2ZjBmMzNlMw==",
  "commit": {
    "author": {
      "name": "Pedro Franco de Carvalho",
      "email": "pedromfc@linux.ibm.com",
      "date": "2020-03-30T15:04:25Z"
    },
    "committer": {
      "name": "Pedro Franco de Carvalho",
      "email": "pedromfc@linux.ibm.com",
      "date": "2020-03-30T15:08:24Z"
    },
    "message": "[PowerPC] Move up some register access routines\n\nKeep the routines related to register access grouped together.\n\ngdb/ChangeLog:\n2020-03-30  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n\n\t* ppc-linux-nat.c (ppc_linux_nat_target::store_registers)\n\t(ppc_linux_nat_target::auxv_parse)\n\t(ppc_linux_nat_target::read_description)\n\t(supply_gregset, fill_gregset, supply_fpregset, fill_fpregset):\n\tMove up.",
    "tree": {
      "sha": "01e2dd2e3ac2cfe49327ecb1c1bacdd571f998df",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/01e2dd2e3ac2cfe49327ecb1c1bacdd571f998df"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4db10d8f4911298d06d2bb25927946f66f0f33e3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4db10d8f4911298d06d2bb25927946f66f0f33e3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4db10d8f4911298d06d2bb25927946f66f0f33e3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4db10d8f4911298d06d2bb25927946f66f0f33e3/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "1310c1b066d4a7b0ce48ad55103a8d559a37ace1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1310c1b066d4a7b0ce48ad55103a8d559a37ace1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1310c1b066d4a7b0ce48ad55103a8d559a37ace1"
    }
  ],
  "stats": {
    "total": 336,
    "additions": 172,
    "deletions": 164
  },
  "files": [
    {
      "sha": "f0e0bc7e5defcce0d363975ad678fb2eafa27f5f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4db10d8f4911298d06d2bb25927946f66f0f33e3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4db10d8f4911298d06d2bb25927946f66f0f33e3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4db10d8f4911298d06d2bb25927946f66f0f33e3",
      "patch": "@@ -1,3 +1,11 @@\n+2020-03-30  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n+\n+\t* ppc-linux-nat.c (ppc_linux_nat_target::store_registers)\n+\t(ppc_linux_nat_target::auxv_parse)\n+\t(ppc_linux_nat_target::read_description)\n+\t(supply_gregset, fill_gregset, supply_fpregset, fill_fpregset):\n+\tMove up.\n+\n 2020-03-30  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n \n \t* linux-nat.h (low_new_clone): New method."
    },
    {
      "sha": "229540623418ed61ab6bcc7ace58a1bbaddab627",
      "filename": "gdb/ppc-linux-nat.c",
      "status": "modified",
      "additions": 164,
      "deletions": 164,
      "changes": 328,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4db10d8f4911298d06d2bb25927946f66f0f33e3/gdb/ppc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4db10d8f4911298d06d2bb25927946f66f0f33e3/gdb/ppc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-nat.c?ref=4db10d8f4911298d06d2bb25927946f66f0f33e3",
      "patch": "@@ -1555,6 +1555,170 @@ store_ppc_registers (const struct regcache *regcache, int tid)\n      function to fail most of the time, so we ignore them.  */\n }\n \n+void\n+ppc_linux_nat_target::store_registers (struct regcache *regcache, int regno)\n+{\n+  pid_t tid = get_ptrace_pid (regcache->ptid ());\n+\n+  if (regno >= 0)\n+    store_register (regcache, tid, regno);\n+  else\n+    store_ppc_registers (regcache, tid);\n+}\n+\n+/* Functions for transferring registers between a gregset_t or fpregset_t\n+   (see sys/ucontext.h) and gdb's regcache.  The word size is that used\n+   by the ptrace interface, not the current program's ABI.  Eg. if a\n+   powerpc64-linux gdb is being used to debug a powerpc32-linux app, we\n+   read or write 64-bit gregsets.  This is to suit the host libthread_db.  */\n+\n+void\n+supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)\n+{\n+  const struct regset *regset = ppc_linux_gregset (sizeof (long));\n+\n+  ppc_supply_gregset (regset, regcache, -1, gregsetp, sizeof (*gregsetp));\n+}\n+\n+void\n+fill_gregset (const struct regcache *regcache,\n+\t      gdb_gregset_t *gregsetp, int regno)\n+{\n+  const struct regset *regset = ppc_linux_gregset (sizeof (long));\n+\n+  if (regno == -1)\n+    memset (gregsetp, 0, sizeof (*gregsetp));\n+  ppc_collect_gregset (regset, regcache, regno, gregsetp, sizeof (*gregsetp));\n+}\n+\n+void\n+supply_fpregset (struct regcache *regcache, const gdb_fpregset_t * fpregsetp)\n+{\n+  const struct regset *regset = ppc_linux_fpregset ();\n+\n+  ppc_supply_fpregset (regset, regcache, -1,\n+\t\t       fpregsetp, sizeof (*fpregsetp));\n+}\n+\n+void\n+fill_fpregset (const struct regcache *regcache,\n+\t       gdb_fpregset_t *fpregsetp, int regno)\n+{\n+  const struct regset *regset = ppc_linux_fpregset ();\n+\n+  ppc_collect_fpregset (regset, regcache, regno,\n+\t\t\tfpregsetp, sizeof (*fpregsetp));\n+}\n+\n+int\n+ppc_linux_nat_target::auxv_parse (gdb_byte **readptr,\n+\t\t\t\t  gdb_byte *endptr, CORE_ADDR *typep,\n+\t\t\t\t  CORE_ADDR *valp)\n+{\n+  int tid = inferior_ptid.lwp ();\n+  if (tid == 0)\n+    tid = inferior_ptid.pid ();\n+\n+  int sizeof_auxv_field = ppc_linux_target_wordsize (tid);\n+\n+  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n+  gdb_byte *ptr = *readptr;\n+\n+  if (endptr == ptr)\n+    return 0;\n+\n+  if (endptr - ptr < sizeof_auxv_field * 2)\n+    return -1;\n+\n+  *typep = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);\n+  ptr += sizeof_auxv_field;\n+  *valp = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);\n+  ptr += sizeof_auxv_field;\n+\n+  *readptr = ptr;\n+  return 1;\n+}\n+\n+const struct target_desc *\n+ppc_linux_nat_target::read_description ()\n+{\n+  int tid = inferior_ptid.lwp ();\n+  if (tid == 0)\n+    tid = inferior_ptid.pid ();\n+\n+  if (have_ptrace_getsetevrregs)\n+    {\n+      struct gdb_evrregset_t evrregset;\n+\n+      if (ptrace (PTRACE_GETEVRREGS, tid, 0, &evrregset) >= 0)\n+        return tdesc_powerpc_e500l;\n+\n+      /* EIO means that the PTRACE_GETEVRREGS request isn't supported.\n+\t Anything else needs to be reported.  */\n+      else if (errno != EIO)\n+\tperror_with_name (_(\"Unable to fetch SPE registers\"));\n+    }\n+\n+  struct ppc_linux_features features = ppc_linux_no_features;\n+\n+  features.wordsize = ppc_linux_target_wordsize (tid);\n+\n+  CORE_ADDR hwcap = linux_get_hwcap (current_top_target ());\n+  CORE_ADDR hwcap2 = linux_get_hwcap2 (current_top_target ());\n+\n+  if (have_ptrace_getsetvsxregs\n+      && (hwcap & PPC_FEATURE_HAS_VSX))\n+    {\n+      gdb_vsxregset_t vsxregset;\n+\n+      if (ptrace (PTRACE_GETVSXREGS, tid, 0, &vsxregset) >= 0)\n+\tfeatures.vsx = true;\n+\n+      /* EIO means that the PTRACE_GETVSXREGS request isn't supported.\n+\t Anything else needs to be reported.  */\n+      else if (errno != EIO)\n+\tperror_with_name (_(\"Unable to fetch VSX registers\"));\n+    }\n+\n+  if (have_ptrace_getvrregs\n+      && (hwcap & PPC_FEATURE_HAS_ALTIVEC))\n+    {\n+      gdb_vrregset_t vrregset;\n+\n+      if (ptrace (PTRACE_GETVRREGS, tid, 0, &vrregset) >= 0)\n+        features.altivec = true;\n+\n+      /* EIO means that the PTRACE_GETVRREGS request isn't supported.\n+\t Anything else needs to be reported.  */\n+      else if (errno != EIO)\n+\tperror_with_name (_(\"Unable to fetch AltiVec registers\"));\n+    }\n+\n+  features.isa205 = ppc_linux_has_isa205 (hwcap);\n+\n+  if ((hwcap2 & PPC_FEATURE2_DSCR)\n+      && check_regset (tid, NT_PPC_PPR, PPC_LINUX_SIZEOF_PPRREGSET)\n+      && check_regset (tid, NT_PPC_DSCR, PPC_LINUX_SIZEOF_DSCRREGSET))\n+    {\n+      features.ppr_dscr = true;\n+      if ((hwcap2 & PPC_FEATURE2_ARCH_2_07)\n+\t  && (hwcap2 & PPC_FEATURE2_TAR)\n+\t  && (hwcap2 & PPC_FEATURE2_EBB)\n+\t  && check_regset (tid, NT_PPC_TAR, PPC_LINUX_SIZEOF_TARREGSET)\n+\t  && check_regset (tid, NT_PPC_EBB, PPC_LINUX_SIZEOF_EBBREGSET)\n+\t  && check_regset (tid, NT_PPC_PMU, PPC_LINUX_SIZEOF_PMUREGSET))\n+\t{\n+\t  features.isa207 = true;\n+\t  if ((hwcap2 & PPC_FEATURE2_HTM)\n+\t      && check_regset (tid, NT_PPC_TM_SPR,\n+\t\t\t       PPC_LINUX_SIZEOF_TM_SPRREGSET))\n+\t    features.htm = true;\n+\t}\n+    }\n+\n+  return ppc_linux_match_description (features);\n+}\n+\n /* The cached DABR value, to install in new threads.\n    This variable is used when the PowerPC HWDEBUG ptrace\n    interface is not available.  */\n@@ -2507,170 +2671,6 @@ ppc_linux_nat_target::masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask\n     return 2;\n }\n \n-void\n-ppc_linux_nat_target::store_registers (struct regcache *regcache, int regno)\n-{\n-  pid_t tid = get_ptrace_pid (regcache->ptid ());\n-\n-  if (regno >= 0)\n-    store_register (regcache, tid, regno);\n-  else\n-    store_ppc_registers (regcache, tid);\n-}\n-\n-/* Functions for transferring registers between a gregset_t or fpregset_t\n-   (see sys/ucontext.h) and gdb's regcache.  The word size is that used\n-   by the ptrace interface, not the current program's ABI.  Eg. if a\n-   powerpc64-linux gdb is being used to debug a powerpc32-linux app, we\n-   read or write 64-bit gregsets.  This is to suit the host libthread_db.  */\n-\n-void\n-supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)\n-{\n-  const struct regset *regset = ppc_linux_gregset (sizeof (long));\n-\n-  ppc_supply_gregset (regset, regcache, -1, gregsetp, sizeof (*gregsetp));\n-}\n-\n-void\n-fill_gregset (const struct regcache *regcache,\n-\t      gdb_gregset_t *gregsetp, int regno)\n-{\n-  const struct regset *regset = ppc_linux_gregset (sizeof (long));\n-\n-  if (regno == -1)\n-    memset (gregsetp, 0, sizeof (*gregsetp));\n-  ppc_collect_gregset (regset, regcache, regno, gregsetp, sizeof (*gregsetp));\n-}\n-\n-void\n-supply_fpregset (struct regcache *regcache, const gdb_fpregset_t * fpregsetp)\n-{\n-  const struct regset *regset = ppc_linux_fpregset ();\n-\n-  ppc_supply_fpregset (regset, regcache, -1,\n-\t\t       fpregsetp, sizeof (*fpregsetp));\n-}\n-\n-void\n-fill_fpregset (const struct regcache *regcache,\n-\t       gdb_fpregset_t *fpregsetp, int regno)\n-{\n-  const struct regset *regset = ppc_linux_fpregset ();\n-\n-  ppc_collect_fpregset (regset, regcache, regno,\n-\t\t\tfpregsetp, sizeof (*fpregsetp));\n-}\n-\n-int\n-ppc_linux_nat_target::auxv_parse (gdb_byte **readptr,\n-\t\t\t\t  gdb_byte *endptr, CORE_ADDR *typep,\n-\t\t\t\t  CORE_ADDR *valp)\n-{\n-  int tid = inferior_ptid.lwp ();\n-  if (tid == 0)\n-    tid = inferior_ptid.pid ();\n-\n-  int sizeof_auxv_field = ppc_linux_target_wordsize (tid);\n-\n-  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n-  gdb_byte *ptr = *readptr;\n-\n-  if (endptr == ptr)\n-    return 0;\n-\n-  if (endptr - ptr < sizeof_auxv_field * 2)\n-    return -1;\n-\n-  *typep = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);\n-  ptr += sizeof_auxv_field;\n-  *valp = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);\n-  ptr += sizeof_auxv_field;\n-\n-  *readptr = ptr;\n-  return 1;\n-}\n-\n-const struct target_desc *\n-ppc_linux_nat_target::read_description ()\n-{\n-  int tid = inferior_ptid.lwp ();\n-  if (tid == 0)\n-    tid = inferior_ptid.pid ();\n-\n-  if (have_ptrace_getsetevrregs)\n-    {\n-      struct gdb_evrregset_t evrregset;\n-\n-      if (ptrace (PTRACE_GETEVRREGS, tid, 0, &evrregset) >= 0)\n-        return tdesc_powerpc_e500l;\n-\n-      /* EIO means that the PTRACE_GETEVRREGS request isn't supported.\n-\t Anything else needs to be reported.  */\n-      else if (errno != EIO)\n-\tperror_with_name (_(\"Unable to fetch SPE registers\"));\n-    }\n-\n-  struct ppc_linux_features features = ppc_linux_no_features;\n-\n-  features.wordsize = ppc_linux_target_wordsize (tid);\n-\n-  CORE_ADDR hwcap = linux_get_hwcap (current_top_target ());\n-  CORE_ADDR hwcap2 = linux_get_hwcap2 (current_top_target ());\n-\n-  if (have_ptrace_getsetvsxregs\n-      && (hwcap & PPC_FEATURE_HAS_VSX))\n-    {\n-      gdb_vsxregset_t vsxregset;\n-\n-      if (ptrace (PTRACE_GETVSXREGS, tid, 0, &vsxregset) >= 0)\n-\tfeatures.vsx = true;\n-\n-      /* EIO means that the PTRACE_GETVSXREGS request isn't supported.\n-\t Anything else needs to be reported.  */\n-      else if (errno != EIO)\n-\tperror_with_name (_(\"Unable to fetch VSX registers\"));\n-    }\n-\n-  if (have_ptrace_getvrregs\n-      && (hwcap & PPC_FEATURE_HAS_ALTIVEC))\n-    {\n-      gdb_vrregset_t vrregset;\n-\n-      if (ptrace (PTRACE_GETVRREGS, tid, 0, &vrregset) >= 0)\n-        features.altivec = true;\n-\n-      /* EIO means that the PTRACE_GETVRREGS request isn't supported.\n-\t Anything else needs to be reported.  */\n-      else if (errno != EIO)\n-\tperror_with_name (_(\"Unable to fetch AltiVec registers\"));\n-    }\n-\n-  features.isa205 = ppc_linux_has_isa205 (hwcap);\n-\n-  if ((hwcap2 & PPC_FEATURE2_DSCR)\n-      && check_regset (tid, NT_PPC_PPR, PPC_LINUX_SIZEOF_PPRREGSET)\n-      && check_regset (tid, NT_PPC_DSCR, PPC_LINUX_SIZEOF_DSCRREGSET))\n-    {\n-      features.ppr_dscr = true;\n-      if ((hwcap2 & PPC_FEATURE2_ARCH_2_07)\n-\t  && (hwcap2 & PPC_FEATURE2_TAR)\n-\t  && (hwcap2 & PPC_FEATURE2_EBB)\n-\t  && check_regset (tid, NT_PPC_TAR, PPC_LINUX_SIZEOF_TARREGSET)\n-\t  && check_regset (tid, NT_PPC_EBB, PPC_LINUX_SIZEOF_EBBREGSET)\n-\t  && check_regset (tid, NT_PPC_PMU, PPC_LINUX_SIZEOF_PMUREGSET))\n-\t{\n-\t  features.isa207 = true;\n-\t  if ((hwcap2 & PPC_FEATURE2_HTM)\n-\t      && check_regset (tid, NT_PPC_TM_SPR,\n-\t\t\t       PPC_LINUX_SIZEOF_TM_SPRREGSET))\n-\t    features.htm = true;\n-\t}\n-    }\n-\n-  return ppc_linux_match_description (features);\n-}\n-\n void _initialize_ppc_linux_nat ();\n void\n _initialize_ppc_linux_nat ()"
    }
  ]
}