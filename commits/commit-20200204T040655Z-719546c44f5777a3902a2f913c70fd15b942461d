{
  "sha": "719546c44f5777a3902a2f913c70fd15b942461d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzE5NTQ2YzQ0ZjU3NzdhMzkwMmEyZjkxM2M3MGZkMTViOTQyNDYxZA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-02-04T04:02:28Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-02-04T04:06:55Z"
    },
    "message": "Change ints to bools around thread_info executing/resumed\n\nSwitch thread_info::resumed to bool (thread_info::executing already is a bool),\nand try to change everything more or less related to that to consistently use\ntrue/false instead of 1/0.\n\ngdb/ChangeLog:\n\n\t* fork-child.c (gdb_startup_inferior): Use bool instead of int.\n\t* gdbthread.h (class thread_info) <resumed>: Likewise.\n\t* infrun.c (resume_1): Likewise.\n\t(proceed): Likewise.\n\t(infrun_thread_stop_requested): Likewise.\n\t(stop_all_threads): Likewise.\n\t(handle_inferior_event): Likewise.\n\t(restart_threads): Likewise.\n\t(finish_step_over): Likewise.\n\t(keep_going_stepped_thread): Likewise.\n\t* linux-nat.c (attach_proc_task_lwp_callback): Likewise.\n\t(linux_handle_extended_wait): Likewise.\n\t* record-btrace.c (get_thread_current_frame_id): Likewise.\n\t* record-full.c (record_full_wait_1): Likewise.\n\t* remote.c (remote_target::process_initial_stop_replies): Likewise.\n\t* target.c (target_resume): Likewise.\n\t* thread.c (set_running_thread): Likewise.",
    "tree": {
      "sha": "6f4b7f34edaa5acdba52295cfaec610404bdc2e3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6f4b7f34edaa5acdba52295cfaec610404bdc2e3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/719546c44f5777a3902a2f913c70fd15b942461d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/719546c44f5777a3902a2f913c70fd15b942461d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/719546c44f5777a3902a2f913c70fd15b942461d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/719546c44f5777a3902a2f913c70fd15b942461d/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c5d7be0c97a75ff20b49d57bff078360464125fb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c5d7be0c97a75ff20b49d57bff078360464125fb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c5d7be0c97a75ff20b49d57bff078360464125fb"
    }
  ],
  "stats": {
    "total": 80,
    "additions": 50,
    "deletions": 30
  },
  "files": [
    {
      "sha": "504961bdc900511bee5198b1f5b03e790e60b3ff",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -1,3 +1,23 @@\n+2020-02-03  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* fork-child.c (gdb_startup_inferior): Use bool instead of int.\n+\t* gdbthread.h (class thread_info) <resumed>: Likewise.\n+\t* infrun.c (resume_1): Likewise.\n+\t(proceed): Likewise.\n+\t(infrun_thread_stop_requested): Likewise.\n+\t(stop_all_threads): Likewise.\n+\t(handle_inferior_event): Likewise.\n+\t(restart_threads): Likewise.\n+\t(finish_step_over): Likewise.\n+\t(keep_going_stepped_thread): Likewise.\n+\t* linux-nat.c (attach_proc_task_lwp_callback): Likewise.\n+\t(linux_handle_extended_wait): Likewise.\n+\t* record-btrace.c (get_thread_current_frame_id): Likewise.\n+\t* record-full.c (record_full_wait_1): Likewise.\n+\t* remote.c (remote_target::process_initial_stop_replies): Likewise.\n+\t* target.c (target_resume): Likewise.\n+\t* thread.c (set_running_thread): Likewise.\n+\n 2020-02-03  Alok Kumar Sharma  <AlokKumar.Sharma@amd.com>\n \n \t* f-valprint.c (f77_print_array_1): Changed datatype of index"
    },
    {
      "sha": "41d5e2a0a47b53baf12799e16880d146a10098f3",
      "filename": "gdb/fork-child.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/fork-child.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/fork-child.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fork-child.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -134,7 +134,7 @@ gdb_startup_inferior (pid_t pid, int num_traps)\n   ptid_t ptid = startup_inferior (proc_target, pid, num_traps, NULL, NULL);\n \n   /* Mark all threads non-executing.  */\n-  set_executing (proc_target, ptid, 0);\n+  set_executing (proc_target, ptid, false);\n \n   return ptid;\n }"
    },
    {
      "sha": "717a2ad08c2fce127731081e455b605cd7c56316",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -301,20 +301,20 @@ class thread_info : public refcounted_object\n      if the thread does not have a user-given name.  */\n   char *name = NULL;\n \n-  /* Non-zero means the thread is executing.  Note: this is different\n+  /* True means the thread is executing.  Note: this is different\n      from saying that there is an active target and we are stopped at\n      a breakpoint, for instance.  This is a real indicator whether the\n      thread is off and running.  */\n   bool executing = false;\n \n-  /* Non-zero if this thread is resumed from infrun's perspective.\n+  /* True if this thread is resumed from infrun's perspective.\n      Note that a thread can be marked both as not-executing and\n      resumed at the same time.  This happens if we try to resume a\n      thread that has a wait status pending.  We shouldn't let the\n      thread really run until that wait status has been processed, but\n      we should not process that wait status if we didn't try to let\n      the thread run.  */\n-  int resumed = 0;\n+  bool resumed = false;\n \n   /* Frontend view of the thread state.  Note that the THREAD_RUNNING/\n      THREAD_STOPPED states are different from EXECUTING.  When the"
    },
    {
      "sha": "3e846f8e6802dfc07c52643d3b10deeba59c6c17",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -2282,7 +2282,7 @@ resume_1 (enum gdb_signal sig)\n \t}\n \n       tp->inf->process_target ()->threads_executing = true;\n-      tp->resumed = 1;\n+      tp->resumed = true;\n \n       /* FIXME: What should we do if we are supposed to resume this\n \t thread with a signal?  Maybe we should maintain a queue of\n@@ -2410,7 +2410,7 @@ resume_1 (enum gdb_signal sig)\n \n \t      resume_ptid = internal_resume_ptid (user_step);\n \t      do_target_resume (resume_ptid, 0, GDB_SIGNAL_0);\n-\t      tp->resumed = 1;\n+\t      tp->resumed = true;\n \t      return;\n \t    }\n \t}\n@@ -2622,7 +2622,7 @@ resume_1 (enum gdb_signal sig)\n     }\n \n   do_target_resume (resume_ptid, step, sig);\n-  tp->resumed = 1;\n+  tp->resumed = true;\n }\n \n /* Resume the inferior.  SIG is the signal to give the inferior\n@@ -3022,7 +3022,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n      inferior function, as in that case we pretend the inferior\n      doesn't run at all.  */\n   if (!cur_thr->control.in_infcall)\n-    set_running (resume_target, resume_ptid, 1);\n+    set_running (resume_target, resume_ptid, true);\n \n   if (debug_infrun)\n     fprintf_unfiltered (gdb_stdlog,\n@@ -3306,7 +3306,7 @@ infrun_thread_stop_requested (ptid_t ptid)\n       /* Otherwise we can process the (new) pending event now.  Set\n \t it so this pending event is considered by\n \t do_target_wait.  */\n-      tp->resumed = 1;\n+      tp->resumed = true;\n     }\n }\n \n@@ -4749,7 +4749,7 @@ stop_all_threads (void)\n \n \t\t  /* The thread may be not executing, but still be\n \t\t     resumed with a pending status to process.  */\n-\t\t  t->resumed = 0;\n+\t\t  t->resumed = false;\n \t\t}\n \t    }\n \n@@ -4788,7 +4788,7 @@ stop_all_threads (void)\n \n \t      t->stop_requested = 0;\n \t      t->executing = 0;\n-\t      t->resumed = 0;\n+\t      t->resumed = false;\n \t      t->control.may_range_step = 0;\n \n \t      /* This may be the first time we see the inferior report\n@@ -5126,10 +5126,10 @@ handle_inferior_event (struct execution_control_state *ecs)\n     else\n       mark_ptid = ecs->ptid;\n \n-    set_executing (ecs->target, mark_ptid, 0);\n+    set_executing (ecs->target, mark_ptid, false);\n \n     /* Likewise the resumed flag.  */\n-    set_resumed (ecs->target, mark_ptid, 0);\n+    set_resumed (ecs->target, mark_ptid, false);\n   }\n \n   switch (ecs->ws.kind)\n@@ -5623,7 +5623,7 @@ restart_threads (struct thread_info *event_thread)\n \t\t\t\t\"infrun: restart threads: \"\n \t\t\t\t\"[%s] has pending status\\n\",\n \t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n-\t  tp->resumed = 1;\n+\t  tp->resumed = true;\n \t  continue;\n \t}\n \n@@ -5763,7 +5763,7 @@ finish_step_over (struct execution_control_state *ecs)\n \t  /* This was cleared early, by handle_inferior_event.  Set it\n \t     so this pending event is considered by\n \t     do_target_wait.  */\n-\t  tp->resumed = 1;\n+\t  tp->resumed = true;\n \n \t  gdb_assert (!tp->executing);\n \n@@ -7424,7 +7424,7 @@ keep_going_stepped_thread (struct thread_info *tp)\n \t\t\t\t     get_frame_address_space (frame),\n \t\t\t\t     tp->suspend.stop_pc);\n \n-      tp->resumed = 1;\n+      tp->resumed = true;\n       resume_ptid = internal_resume_ptid (tp->control.stepping_command);\n       do_target_resume (resume_ptid, 0, GDB_SIGNAL_0);\n     }"
    },
    {
      "sha": "230ae366b6417443e5e297313c70a82a3125f3de",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -1166,8 +1166,8 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t     matching libthread_db is not found (or the process uses\n \t     raw clone).  */\n \t  add_thread (linux_target, lp->ptid);\n-\t  set_running (linux_target, lp->ptid, 1);\n-\t  set_executing (linux_target, lp->ptid, 1);\n+\t  set_running (linux_target, lp->ptid, true);\n+\t  set_executing (linux_target, lp->ptid, true);\n \t}\n \n       return 1;\n@@ -2038,8 +2038,8 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t     internal to this module, from the perspective of infrun\n \t     and the user/frontend, this new thread is running until\n \t     it next reports a stop.  */\n-\t  set_running (linux_target, new_lp->ptid, 1);\n-\t  set_executing (linux_target, new_lp->ptid, 1);\n+\t  set_running (linux_target, new_lp->ptid, true);\n+\t  set_executing (linux_target, new_lp->ptid, true);\n \n \t  if (WSTOPSIG (status) != SIGSTOP)\n \t    {"
    },
    {
      "sha": "ef23a0b7af7621f816e794378af6a23cae738ba4",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -1958,7 +1958,7 @@ static struct frame_id\n get_thread_current_frame_id (struct thread_info *tp)\n {\n   struct frame_id id;\n-  int executing;\n+  bool executing;\n \n   /* Set current thread, which is implicitly used by\n      get_current_frame.  */"
    },
    {
      "sha": "51b7beabf6680b57e883ac4d58157e2f6ee38d68",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -1267,12 +1267,12 @@ record_full_wait_1 (struct target_ops *ops,\n \n \t\t\t  /* Try to insert the software single step breakpoint.\n \t\t\t     If insert success, set step to 0.  */\n-\t\t\t  set_executing (proc_target, inferior_ptid, 0);\n+\t\t\t  set_executing (proc_target, inferior_ptid, false);\n \t\t\t  reinit_frame_cache ();\n \n \t\t\t  step = !insert_single_step_breakpoints (gdbarch);\n \n-\t\t\t  set_executing (proc_target, inferior_ptid, 1);\n+\t\t\t  set_executing (proc_target, inferior_ptid, true);\n \t\t\t}\n \n \t\t      if (record_debug)"
    },
    {
      "sha": "dafdfa8f6c92bfe17e3505301bb8bdc58b33c961",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -4449,8 +4449,8 @@ remote_target::process_initial_stop_replies (int from_tty)\n \t  || ws.value.sig != GDB_SIGNAL_0)\n \tevthread->suspend.waitstatus_pending_p = 1;\n \n-      set_executing (this, event_ptid, 0);\n-      set_running (this, event_ptid, 0);\n+      set_executing (this, event_ptid, false);\n+      set_running (this, event_ptid, false);\n       get_remote_thread_info (evthread)->vcont_resumed = 0;\n     }\n "
    },
    {
      "sha": "470ef51d69ef5d712fc51a54f426c1cd3b79c977",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -2127,7 +2127,7 @@ target_resume (ptid_t ptid, int step, enum gdb_signal signal)\n   /* We only set the internal executing state here.  The user/frontend\n      running state is set at a higher level.  This also clears the\n      thread's stop_pc as side effect.  */\n-  set_executing (curr_target, ptid, 1);\n+  set_executing (curr_target, ptid, true);\n   clear_inline_frame_state (curr_target, ptid);\n }\n "
    },
    {
      "sha": "54b59e22448a260e4190ffe5438b8b5c799a1cd9",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/719546c44f5777a3902a2f913c70fd15b942461d/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/719546c44f5777a3902a2f913c70fd15b942461d/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=719546c44f5777a3902a2f913c70fd15b942461d",
      "patch": "@@ -823,13 +823,13 @@ set_resumed (process_stratum_target *targ, ptid_t ptid, bool resumed)\n /* Helper for set_running, that marks one thread either running or\n    stopped.  */\n \n-static int\n-set_running_thread (struct thread_info *tp, int running)\n+static bool\n+set_running_thread (struct thread_info *tp, bool running)\n {\n-  int started = 0;\n+  bool started = false;\n \n   if (running && tp->state == THREAD_STOPPED)\n-    started = 1;\n+    started = true;\n   tp->state = running ? THREAD_RUNNING : THREAD_STOPPED;\n \n   if (!running)"
    }
  ]
}