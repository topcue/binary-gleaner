{
  "sha": "1657026ccd8aa05a97cb35f1d9bff646937a244e",
  "node_id": "C_kwDOANOeidoAKDE2NTcwMjZjY2Q4YWEwNWE5N2NiMzVmMWQ5YmZmNjQ2OTM3YTI0NGU",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2022-01-06T21:19:16Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2022-01-18T00:48:45Z"
    },
    "message": "PowerPC64 DT_RELR\n\nPowerPC64 takes a more traditional approach to DT_RELR than x86.  Count\nrelative relocs in check_relocs, allocate space for them and output in\nthe usual places but not doing so when enable_dt_relr.  DT_RELR is\nsized in the existing ppc stub relaxation machinery, run via the\nlinker's ldemul_after_allocation hook.  DT_RELR is output in the same\nfunction that writes ppc stubs, run via ldemul_finish.\n\nThis support should be considered experimental.\n\nbfd/\n\t* elf64-ppc.c (struct ppc_local_dyn_relocs): Renamed from\n\tppc_dyn_relocs.  Add rel_count field.  Update uses.\n\t(struct ppc_dyn_relocs): New.  Replace all uses of elf_dyn_relocs.\n\t(struct ppc_link_hash_table): Add relr_alloc, relr_count and\n\trelr_addr.\n\t(ppc64_elf_copy_indirect_symbol): Merge rel_count.\n\t(ppc64_elf_check_relocs): Init rel_count for global and local syms.\n\t(dec_dynrel_count): Change r_info param to reloc pointer.  Update\n\tall callers.  Handle decrementing rel_count.\n\t(allocate_got): Don't allocate space for relative relocs when\n\tenable_dt_relr.\n\t(allocate_dynrelocs): Likewise.\n\t(ppc64_elf_size_dynamic_sections): Likewise.  Handle srelrdyn.\n\t(ppc_build_one_stub): Don't emit relative relocs on .branch_lt.\n\t(compare_relr_address, append_relr_off): New functions.\n\t(got_and_plt_relr_for_local_syms, got_and_plt_relr): Likewise.\n\t(ppc64_elf_size_stubs): Size .relr.syn.\n\t(ppc64_elf_build_stubs): Emit .relr.dyn.\n\t(build_global_entry_stubs_and_plt): Don't output relative relocs\n\twhen enable_dt_relr.\n\t(write_plt_relocs_for_local_syms): Likewise.\n\t(ppc64_elf_relocate_section): Likewise.\nbinutils/\n\t* testsuite/lib/binutils-common.exp (supports_dt_relr): Add\n\tpowerpc64.\nld/\n\t* emulparams/elf64ppc.sh: Source dt-relr.sh.\n\t* testsuite/ld-elf/dt-relr-2b.d: Adjust for powerpc.\n\t* testsuite/ld-elf/dt-relr-2c.d: Likewise.\n\t* testsuite/ld-elf/dt-relr-2d.d: Likewise.\n\t* testsuite/ld-elf/dt-relr-2e.d: Likewise.",
    "tree": {
      "sha": "b21238f5d3e2c272a9d6a27642d7047a99b29a92",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b21238f5d3e2c272a9d6a27642d7047a99b29a92"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1657026ccd8aa05a97cb35f1d9bff646937a244e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1657026ccd8aa05a97cb35f1d9bff646937a244e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1657026ccd8aa05a97cb35f1d9bff646937a244e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1657026ccd8aa05a97cb35f1d9bff646937a244e/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "97da0e2677c4a38df2406576428ec27d1da26e7c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/97da0e2677c4a38df2406576428ec27d1da26e7c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/97da0e2677c4a38df2406576428ec27d1da26e7c"
    }
  ],
  "stats": {
    "total": 605,
    "additions": 518,
    "deletions": 87
  },
  "files": [
    {
      "sha": "0f945797b492ddd5ee70bfc5944e40ec884296a1",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 510,
      "deletions": 82,
      "changes": 592,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -3094,7 +3094,7 @@ struct ppc_branch_hash_entry\n   unsigned int iter;\n };\n \n-/* Used to track dynamic relocations for local symbols.  */\n+/* Used to track dynamic relocations.  */\n struct ppc_dyn_relocs\n {\n   struct ppc_dyn_relocs *next;\n@@ -3103,7 +3103,27 @@ struct ppc_dyn_relocs\n   asection *sec;\n \n   /* Total number of relocs copied for the input section.  */\n-  unsigned int count : 31;\n+  unsigned int count;\n+\n+  /* Number of pc-relative relocs copied for the input section.  */\n+  unsigned int pc_count;\n+\n+  /* Number of relocs that might become R_PPC64_RELATIVE.  */\n+  unsigned int rel_count;\n+};\n+\n+struct ppc_local_dyn_relocs\n+{\n+  struct ppc_local_dyn_relocs *next;\n+\n+  /* The input section of the reloc.  */\n+  asection *sec;\n+\n+  /* Total number of relocs copied for the input section.  */\n+  unsigned int count;\n+\n+  /* Number of relocs that might become R_PPC64_RELATIVE.  */\n+  unsigned int rel_count : 31;\n \n   /* Whether this entry is for STT_GNU_IFUNC symbols.  */\n   unsigned int ifunc : 1;\n@@ -3250,6 +3270,11 @@ struct ppc_link_hash_table\n   /* The size of reliplt used by got entry relocs.  */\n   bfd_size_type got_reli_size;\n \n+  /* DT_RELR array of r_offset.  */\n+  size_t relr_alloc;\n+  size_t relr_count;\n+  bfd_vma *relr_addr;\n+\n   /* Statistics.  */\n   unsigned long stub_count[ppc_stub_save_res];\n \n@@ -4068,27 +4093,32 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,\n     {\n       if (dir->dyn_relocs != NULL)\n \t{\n-\t  struct elf_dyn_relocs **pp;\n-\t  struct elf_dyn_relocs *p;\n+\t  struct ppc_dyn_relocs **pp;\n+\t  struct ppc_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = (struct ppc_dyn_relocs **) &ind->dyn_relocs;\n+\t       (p = *pp) != NULL;\n+\t       )\n \t    {\n-\t      struct elf_dyn_relocs *q;\n+\t      struct ppc_dyn_relocs *q;\n \n-\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = (struct ppc_dyn_relocs *) dir->dyn_relocs;\n+\t\t   q != NULL;\n+\t\t   q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n-\t\t    q->pc_count += p->pc_count;\n \t\t    q->count += p->count;\n+\t\t    q->pc_count += p->pc_count;\n+\t\t    q->rel_count += p->rel_count;\n \t\t    *pp = p->next;\n \t\t    break;\n \t\t  }\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = dir->dyn_relocs;\n+\t  *pp = (struct ppc_dyn_relocs *) dir->dyn_relocs;\n \t}\n \n       dir->dyn_relocs = ind->dyn_relocs;\n@@ -5337,10 +5367,10 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n \t\t{\n-\t\t  struct elf_dyn_relocs *p;\n-\t\t  struct elf_dyn_relocs **head;\n+\t\t  struct ppc_dyn_relocs *p;\n+\t\t  struct ppc_dyn_relocs **head;\n \n-\t\t  head = &h->dyn_relocs;\n+\t\t  head = (struct ppc_dyn_relocs **) &h->dyn_relocs;\n \t\t  p = *head;\n \t\t  if (p == NULL || p->sec != sec)\n \t\t    {\n@@ -5352,18 +5382,25 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t      p->sec = sec;\n \t\t      p->count = 0;\n \t\t      p->pc_count = 0;\n+\t\t      p->rel_count = 0;\n \t\t    }\n \t\t  p->count += 1;\n \t\t  if (!must_be_dyn_reloc (info, r_type))\n \t\t    p->pc_count += 1;\n+\t\t  if ((r_type == R_PPC64_ADDR64 || r_type == R_PPC64_TOC)\n+\t\t      && rel->r_offset % 2 == 0\n+\t\t      && sec->alignment_power != 0\n+\t\t      && ((!NO_OPD_RELOCS && is_opd)\n+\t\t\t  || (!ifunc && SYMBOL_REFERENCES_LOCAL (info, h))))\n+\t\t    p->rel_count += 1;\n \t\t}\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.\n \t\t     We really need local syms available to do this\n \t\t     easily.  Oh well.  */\n-\t\t  struct ppc_dyn_relocs *p;\n-\t\t  struct ppc_dyn_relocs **head;\n+\t\t  struct ppc_local_dyn_relocs *p;\n+\t\t  struct ppc_local_dyn_relocs **head;\n \t\t  bool is_ifunc;\n \t\t  asection *s;\n \t\t  void *vpp;\n@@ -5379,7 +5416,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t    s = sec;\n \n \t\t  vpp = &elf_section_data (s)->local_dynrel;\n-\t\t  head = (struct ppc_dyn_relocs **) vpp;\n+\t\t  head = (struct ppc_local_dyn_relocs **) vpp;\n \t\t  is_ifunc = ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC;\n \t\t  p = *head;\n \t\t  if (p != NULL && p->sec == sec && p->ifunc != is_ifunc)\n@@ -5392,10 +5429,16 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t      p->next = *head;\n \t\t      *head = p;\n \t\t      p->sec = sec;\n-\t\t      p->ifunc = is_ifunc;\n \t\t      p->count = 0;\n+\t\t      p->rel_count = 0;\n+\t\t      p->ifunc = is_ifunc;\n \t\t    }\n \t\t  p->count += 1;\n+\t\t  if ((r_type == R_PPC64_ADDR64 || r_type == R_PPC64_TOC)\n+\t\t      && rel->r_offset % 2 == 0\n+\t\t      && sec->alignment_power != 0\n+\t\t      && ((!NO_OPD_RELOCS && is_opd) || !is_ifunc))\n+\t\t    p->rel_count += 1;\n \t\t}\n \t    }\n \t  break;\n@@ -6576,9 +6619,9 @@ alias_readonly_dynrelocs (struct elf_link_hash_entry *h)\n static bool\n pc_dynrelocs (struct ppc_link_hash_entry *eh)\n {\n-  struct elf_dyn_relocs *p;\n+  struct ppc_dyn_relocs *p;\n \n-  for (p = eh->elf.dyn_relocs; p != NULL; p = p->next)\n+  for (p = (struct ppc_dyn_relocs *) eh->elf.dyn_relocs; p != NULL; p = p->next)\n     if (p->pc_count != 0)\n       return true;\n   return false;\n@@ -7113,7 +7156,7 @@ adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)\n    have already been determined.  */\n \n static bool\n-dec_dynrel_count (bfd_vma r_info,\n+dec_dynrel_count (const Elf_Internal_Rela *rel,\n \t\t  asection *sec,\n \t\t  struct bfd_link_info *info,\n \t\t  Elf_Internal_Sym **local_syms,\n@@ -7125,7 +7168,7 @@ dec_dynrel_count (bfd_vma r_info,\n \n   /* Can this reloc be dynamic?  This switch, and later tests here\n      should be kept in sync with the code in check_relocs.  */\n-  r_type = ELF64_R_TYPE (r_info);\n+  r_type = ELF64_R_TYPE (rel->r_info);\n   switch (r_type)\n     {\n     default:\n@@ -7199,7 +7242,7 @@ dec_dynrel_count (bfd_vma r_info,\n       unsigned long r_symndx;\n       bfd *ibfd = sec->owner;\n \n-      r_symndx = ELF64_R_SYM (r_info);\n+      r_symndx = ELF64_R_SYM (rel->r_info);\n       if (!get_sym_h (&h, &sym, &sym_sec, NULL, local_syms, r_symndx, ibfd))\n \treturn false;\n     }\n@@ -7222,9 +7265,9 @@ dec_dynrel_count (bfd_vma r_info,\n \n   if (h != NULL)\n     {\n-      struct elf_dyn_relocs *p;\n-      struct elf_dyn_relocs **pp;\n-      pp = &h->dyn_relocs;\n+      struct ppc_dyn_relocs *p;\n+      struct ppc_dyn_relocs **pp;\n+      pp = (struct ppc_dyn_relocs **) &h->dyn_relocs;\n \n       /* elf_gc_sweep may have already removed all dyn relocs associated\n \t with local syms for a given section.  Also, symbol flags are\n@@ -7239,6 +7282,14 @@ dec_dynrel_count (bfd_vma r_info,\n \t    {\n \t      if (!must_be_dyn_reloc (info, r_type))\n \t\tp->pc_count -= 1;\n+\t      if ((r_type == R_PPC64_ADDR64 || r_type == R_PPC64_TOC)\n+\t\t  && rel->r_offset % 2 == 0\n+\t\t  && sec->alignment_power != 0\n+\t\t  && ((!NO_OPD_RELOCS\n+\t\t       && ppc64_elf_section_data (sec)->sec_type == sec_opd)\n+\t\t      || (h->type != STT_GNU_IFUNC\n+\t\t\t  && SYMBOL_REFERENCES_LOCAL (info, h))))\n+\t\tp->rel_count -= 1;\n \t      p->count -= 1;\n \t      if (p->count == 0)\n \t\t*pp = p->next;\n@@ -7249,8 +7300,8 @@ dec_dynrel_count (bfd_vma r_info,\n     }\n   else\n     {\n-      struct ppc_dyn_relocs *p;\n-      struct ppc_dyn_relocs **pp;\n+      struct ppc_local_dyn_relocs *p;\n+      struct ppc_local_dyn_relocs **pp;\n       void *vpp;\n       bool is_ifunc;\n \n@@ -7260,7 +7311,7 @@ dec_dynrel_count (bfd_vma r_info,\n \tsym_sec = sec;\n \n       vpp = &elf_section_data (sym_sec)->local_dynrel;\n-      pp = (struct ppc_dyn_relocs **) vpp;\n+      pp = (struct ppc_local_dyn_relocs **) vpp;\n \n       if (*pp == NULL && info->gc_sections)\n \treturn true;\n@@ -7270,6 +7321,13 @@ dec_dynrel_count (bfd_vma r_info,\n \t{\n \t  if (p->sec == sec && p->ifunc == is_ifunc)\n \t    {\n+\t      if ((r_type == R_PPC64_ADDR64 || r_type == R_PPC64_TOC)\n+\t\t  && rel->r_offset % 2 == 0\n+\t\t  && sec->alignment_power != 0\n+\t\t  && ((!NO_OPD_RELOCS\n+\t\t       && ppc64_elf_section_data (sec)->sec_type == sec_opd)\n+\t\t      || !is_ifunc))\n+\t\tp->rel_count -= 1;\n \t      p->count -= 1;\n \t      if (p->count == 0)\n \t\t*pp = p->next;\n@@ -7567,7 +7625,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info)\n \t\t  else\n \t\t    while (1)\n \t\t      {\n-\t\t\tif (!dec_dynrel_count (rel->r_info, sec, info,\n+\t\t\tif (!dec_dynrel_count (rel, sec, info,\n \t\t\t\t\t       NULL, h, sym))\n \t\t\t  goto error_ret;\n \n@@ -8587,13 +8645,13 @@ ppc64_elf_tls_optimize (struct bfd_link_info *info)\n \t\t    {\n \t\t      /* If we got rid of a DTPMOD/DTPREL reloc pair then\n \t\t\t we'll lose one or two dyn relocs.  */\n-\t\t      if (!dec_dynrel_count (rel->r_info, sec, info,\n+\t\t      if (!dec_dynrel_count (rel, sec, info,\n \t\t\t\t\t     NULL, h, sym))\n \t\t\treturn false;\n \n \t\t      if (tls_set == (TLS_EXPLICIT | TLS_GD))\n \t\t\t{\n-\t\t\t  if (!dec_dynrel_count ((rel + 1)->r_info, sec, info,\n+\t\t\t  if (!dec_dynrel_count (rel + 1, sec, info,\n \t\t\t\t\t\t NULL, h, sym))\n \t\t\t    return false;\n \t\t\t}\n@@ -9419,7 +9477,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)\n \t\t    wrel->r_addend = rel->r_addend;\n \t\t    ++wrel;\n \t\t  }\n-\t\telse if (!dec_dynrel_count (rel->r_info, toc, info,\n+\t\telse if (!dec_dynrel_count (rel, toc, info,\n \t\t\t\t\t    &local_syms, NULL, NULL))\n \t\t  goto error_ret;\n \n@@ -9720,9 +9778,10 @@ allocate_got (struct elf_link_hash_entry *h,\n       htab->got_reli_size += rentsize;\n     }\n   else if (((bfd_link_pic (info)\n-\t     && !(gent->tls_type != 0\n-\t\t  && bfd_link_executable (info)\n-\t\t  && SYMBOL_REFERENCES_LOCAL (info, h)))\n+\t     && (gent->tls_type == 0\n+\t\t ? !info->enable_dt_relr\n+\t\t : !(bfd_link_executable (info)\n+\t\t     && SYMBOL_REFERENCES_LOCAL (info, h))))\n \t    || (htab->elf.dynamic_sections_created\n \t\t&& h->dynindx != -1\n \t\t&& !SYMBOL_REFERENCES_LOCAL (info, h)))\n@@ -9884,7 +9943,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n   if (h->dyn_relocs != NULL)\n     {\n-      struct elf_dyn_relocs *p, **pp;\n+      struct ppc_dyn_relocs *p, **pp;\n \n       /* In the shared -Bsymbolic case, discard space allocated for\n \t dynamic pc-relative relocs against symbols which turn out to\n@@ -9902,7 +9961,9 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t     avoid writing weird assembly.  */\n \t  if (SYMBOL_CALLS_LOCAL (info, h))\n \t    {\n-\t      for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n+\t      for (pp = (struct ppc_dyn_relocs **) &h->dyn_relocs;\n+\t\t   (p = *pp) != NULL;\n+\t\t   )\n \t\t{\n \t\t  p->count -= p->pc_count;\n \t\t  p->pc_count = 0;\n@@ -9948,12 +10009,16 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t}\n \n       /* Finally, allocate space.  */\n-      for (p = h->dyn_relocs; p != NULL; p = p->next)\n+      for (p = (struct ppc_dyn_relocs *) h->dyn_relocs; p != NULL; p = p->next)\n \t{\n+\t  unsigned int count;\n \t  asection *sreloc = elf_section_data (p->sec)->sreloc;\n \t  if (eh->elf.type == STT_GNU_IFUNC)\n \t    sreloc = htab->elf.irelplt;\n-\t  sreloc->size += p->count * sizeof (Elf64_External_Rela);\n+\t  count = p->count;\n+\t  if (info->enable_dt_relr)\n+\t    count -= p->rel_count;\n+\t  sreloc->size += count * sizeof (Elf64_External_Rela);\n \t}\n     }\n \n@@ -9994,7 +10059,10 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t    s = htab->pltlocal;\n \t\t    pent->plt.offset = s->size;\n \t\t    s->size += LOCAL_PLT_ENTRY_SIZE (htab);\n-\t\t    s = bfd_link_pic (info) ? htab->relpltlocal : NULL;\n+\t\t    s = NULL;\n+\t\t    if (bfd_link_pic (info)\n+\t\t\t&& !(info->enable_dt_relr && !htab->opd_abi))\n+\t\t      s = htab->relpltlocal;\n \t\t  }\n \t      }\n \t    else\n@@ -10180,7 +10248,7 @@ ppc64_elf_size_dynamic_sections (bfd *output_bfd,\n \n       for (s = ibfd->sections; s != NULL; s = s->next)\n \t{\n-\t  struct ppc_dyn_relocs *p;\n+\t  struct ppc_local_dyn_relocs *p;\n \n \t  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)\n \t    {\n@@ -10194,10 +10262,16 @@ ppc64_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t}\n \t      else if (p->count != 0)\n \t\t{\n-\t\t  asection *srel = elf_section_data (p->sec)->sreloc;\n+\t\t  unsigned int count;\n+\t\t  asection *srel;\n+\n+\t\t  count = p->count;\n+\t\t  if (info->enable_dt_relr)\n+\t\t    count -= p->rel_count;\n+\t\t  srel = elf_section_data (p->sec)->sreloc;\n \t\t  if (p->ifunc)\n \t\t    srel = htab->elf.irelplt;\n-\t\t  srel->size += p->count * sizeof (Elf64_External_Rela);\n+\t\t  srel->size += count * sizeof (Elf64_External_Rela);\n \t\t  if ((p->sec->output_section->flags & SEC_READONLY) != 0)\n \t\t    info->flags |= DF_TEXTREL;\n \t\t}\n@@ -10342,7 +10416,7 @@ ppc64_elf_size_dynamic_sections (bfd *output_bfd,\n       if ((s->flags & SEC_LINKER_CREATED) == 0)\n \tcontinue;\n \n-      if (s == htab->brlt || s == htab->relbrlt)\n+      if (s == htab->brlt || s == htab->relbrlt || s == htab->elf.srelrdyn)\n \t/* These haven't been allocated yet;  don't strip.  */\n \tcontinue;\n       else if (s == htab->elf.sgot\n@@ -11693,7 +11767,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t{\n \t  br_entry->iter = 0;\n \n-\t  if (htab->relbrlt != NULL)\n+\t  if (htab->relbrlt != NULL && !info->enable_dt_relr)\n \t    {\n \t      /* Create a reloc for the branch lookup table entry.  */\n \t      Elf_Internal_Rela rela;\n@@ -12198,7 +12272,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      br_entry->offset = htab->brlt->size;\n \t      htab->brlt->size += 8;\n \n-\t      if (htab->relbrlt != NULL)\n+\t      if (htab->relbrlt != NULL && !info->enable_dt_relr)\n \t\thtab->relbrlt->size += sizeof (Elf64_External_Rela);\n \t      else if (info->emitrelocations)\n \t\t{\n@@ -13293,6 +13367,174 @@ maybe_strip_output (struct bfd_link_info *info, asection *isec)\n     }\n }\n \n+static int\n+compare_relr_address (const void *arg1, const void *arg2)\n+{\n+  bfd_vma a = *(bfd_vma *) arg1;\n+  bfd_vma b = *(bfd_vma *) arg2;\n+  return a < b ? -1 : a > b ? 1 : 0;\n+}\n+\n+static bool\n+append_relr_off (struct ppc_link_hash_table *htab, bfd_vma off)\n+{\n+  if (htab->relr_count >= htab->relr_alloc)\n+    {\n+      if (htab->relr_alloc == 0)\n+\thtab->relr_alloc = 4096;\n+      else\n+\thtab->relr_alloc *= 2;\n+      htab->relr_addr\n+\t= bfd_realloc (htab->relr_addr,\n+\t\t       htab->relr_alloc * sizeof (htab->relr_addr[0]));\n+      if (htab->relr_addr == NULL)\n+\treturn false;\n+    }\n+  htab->relr_addr[htab->relr_count++] = off;\n+  return true;\n+}\n+\n+static bool\n+got_and_plt_relr_for_local_syms (struct bfd_link_info *info)\n+{\n+  struct ppc_link_hash_table *htab = ppc_hash_table (info);\n+  bfd *ibfd;\n+\n+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)\n+    {\n+      struct got_entry **lgot_ents, **lgot, **end_lgot_ents;\n+      struct plt_entry **local_plt, **lplt, **end_local_plt;\n+      Elf_Internal_Shdr *symtab_hdr;\n+      bfd_size_type locsymcount;\n+      Elf_Internal_Sym *local_syms = NULL;\n+      struct plt_entry *pent;\n+      struct got_entry *gent;\n+\n+      if (!is_ppc64_elf (ibfd))\n+\tcontinue;\n+\n+      lgot_ents = elf_local_got_ents (ibfd);\n+      if (!lgot_ents)\n+\tcontinue;\n+\n+      symtab_hdr = &elf_symtab_hdr (ibfd);\n+      locsymcount = symtab_hdr->sh_info;\n+      end_lgot_ents = lgot_ents + locsymcount;\n+      local_plt = (struct plt_entry **) end_lgot_ents;\n+      end_local_plt = local_plt + locsymcount;\n+      for (lgot = lgot_ents; lgot < end_lgot_ents; ++lgot)\n+\tfor (gent = *lgot; gent != NULL; gent = gent->next)\n+\t  if (!gent->is_indirect\n+\t      && gent->tls_type == 0\n+\t      && gent->got.offset != (bfd_vma) -1)\n+\t    {\n+\t      asection *got = ppc64_elf_tdata (gent->owner)->got;\n+\t      bfd_vma r_offset = (got->output_section->vma\n+\t\t\t\t  + got->output_offset\n+\t\t\t\t  + gent->got.offset);\n+\t      if (!append_relr_off (htab, r_offset))\n+\t\t{\n+\t\t  htab->stub_error = true;\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\n+      if (!htab->opd_abi)\n+\tfor (lplt = local_plt; lplt < end_local_plt; ++lplt)\n+\t  for (pent = *lplt; pent != NULL; pent = pent->next)\n+\t    if (pent->plt.offset != (bfd_vma) -1)\n+\t      {\n+\t\tElf_Internal_Sym *sym;\n+\n+\t\tif (!get_sym_h (NULL, &sym, NULL, NULL, &local_syms,\n+\t\t\t\tlplt - local_plt, ibfd))\n+\t\t  {\n+\t\t  err_exit:\n+\t\t    if (symtab_hdr->contents != (unsigned char *) local_syms)\n+\t\t      free (local_syms);\n+\t\t    return false;\n+\t\t  }\n+\n+\t\tif (ELF_ST_TYPE (sym->st_info) != STT_GNU_IFUNC)\n+\t\t  {\n+\t\t    bfd_vma r_offset = (pent->plt.offset\n+\t\t\t\t\t+ htab->pltlocal->output_offset\n+\t\t\t\t\t+ htab->pltlocal->output_section->vma);\n+\t\t    if (!append_relr_off (htab, r_offset))\n+\t\t      goto err_exit;\n+\t\t  }\n+\t      }\n+\n+      if (local_syms != NULL\n+\t  && symtab_hdr->contents != (unsigned char *) local_syms)\n+\t{\n+\t  if (!info->keep_memory)\n+\t    free (local_syms);\n+\t  else\n+\t    symtab_hdr->contents = (unsigned char *) local_syms;\n+\t}\n+    }\n+  return true;\n+}\n+\n+static bool\n+got_and_plt_relr (struct elf_link_hash_entry *h, void *inf)\n+{\n+  struct bfd_link_info *info;\n+  struct ppc_link_hash_table *htab;\n+  struct plt_entry *pent;\n+  struct got_entry *gent;\n+\n+  if (h->root.type == bfd_link_hash_indirect)\n+    return true;\n+\n+  info = (struct bfd_link_info *) inf;\n+  htab = ppc_hash_table (info);\n+  if (htab == NULL)\n+    return false;\n+\n+  if (h->type != STT_GNU_IFUNC\n+      && h->def_regular\n+      && (h->root.type == bfd_link_hash_defined\n+\t  || h->root.type == bfd_link_hash_defweak))\n+    {\n+      if (!htab->elf.dynamic_sections_created\n+\t  || h->dynindx == -1\n+\t  || SYMBOL_REFERENCES_LOCAL (info, h))\n+\tfor (gent = h->got.glist; gent != NULL; gent = gent->next)\n+\t  if (!gent->is_indirect\n+\t      && gent->tls_type == 0\n+\t      && gent->got.offset != (bfd_vma) -1)\n+\t    {\n+\t      asection *got = ppc64_elf_tdata (gent->owner)->got;\n+\t      bfd_vma r_offset = (got->output_section->vma\n+\t\t\t\t  + got->output_offset\n+\t\t\t\t  + gent->got.offset);\n+\t      if (!append_relr_off (htab, r_offset))\n+\t\t{\n+\t\t  htab->stub_error = true;\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\n+      if (!htab->opd_abi\n+\t  && use_local_plt (info, h))\n+\tfor (pent = h->plt.plist; pent != NULL; pent = pent->next)\n+\t  if (pent->plt.offset != (bfd_vma) -1)\n+\t    {\n+\t      bfd_vma r_offset = (htab->pltlocal->output_section->vma\n+\t\t\t\t  + htab->pltlocal->output_offset\n+\t\t\t\t  + pent->plt.offset);\n+\t      if (!append_relr_off (htab, r_offset))\n+\t\t{\n+\t\t  htab->stub_error = true;\n+\t\t  return false;\n+\t\t}\n+\t    }\n+    }\n+  return true;\n+}\n+\n /* Determine and set the size of the stub section for a final link.\n \n    The basic idea here is to examine all the relocations looking for\n@@ -13413,6 +13655,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n       struct map_stub *group;\n \n       htab->stub_iteration += 1;\n+      htab->relr_count = 0;\n \n       for (input_bfd = info->input_bfds, bfd_indx = 0;\n \t   input_bfd != NULL;\n@@ -13436,16 +13679,20 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t       section = section->next)\n \t    {\n \t      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;\n+\t      bool is_opd;\n \n \t      /* If there aren't any relocs, then there's nothing more\n \t\t to do.  */\n \t      if ((section->flags & SEC_RELOC) == 0\n \t\t  || (section->flags & SEC_ALLOC) == 0\n \t\t  || (section->flags & SEC_LOAD) == 0\n-\t\t  || (section->flags & SEC_CODE) == 0\n \t\t  || section->reloc_count == 0)\n \t\tcontinue;\n \n+\t      if (!info->enable_dt_relr\n+\t\t  && (section->flags & SEC_CODE) == 0)\n+\t\tcontinue;\n+\n \t      /* If this section is a link-once section that will be\n \t\t discarded, then don't create any stubs.  */\n \t      if (section->output_section == NULL\n@@ -13459,6 +13706,8 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t      if (internal_relocs == NULL)\n \t\tgoto error_ret_free_local;\n \n+\t      is_opd = ppc64_elf_section_data (section)->sec_type == sec_opd;\n+\n \t      /* Now examine each relocation.  */\n \t      irela = internal_relocs;\n \t      irelaend = irela + section->reloc_count;\n@@ -13492,21 +13741,76 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t    }\n \n \t\t  /* Only look for stubs on branch instructions.  */\n-\t\t  if (r_type != R_PPC64_REL24\n-\t\t      && r_type != R_PPC64_REL24_NOTOC\n-\t\t      && r_type != R_PPC64_REL24_P9NOTOC\n-\t\t      && r_type != R_PPC64_REL14\n-\t\t      && r_type != R_PPC64_REL14_BRTAKEN\n-\t\t      && r_type != R_PPC64_REL14_BRNTAKEN)\n-\t\t    continue;\n+\t\t  switch (r_type)\n+\t\t    {\n+\t\t    default:\n+\t\t      continue;\n+\n+\t\t    case R_PPC64_REL24:\n+\t\t    case R_PPC64_REL24_NOTOC:\n+\t\t    case R_PPC64_REL24_P9NOTOC:\n+\t\t    case R_PPC64_REL14:\n+\t\t    case R_PPC64_REL14_BRTAKEN:\n+\t\t    case R_PPC64_REL14_BRNTAKEN:\n+\t\t      if ((section->flags & SEC_CODE) != 0)\n+\t\t\tbreak;\n+\t\t      continue;\n+\n+\t\t    case R_PPC64_ADDR64:\n+\t\t    case R_PPC64_TOC:\n+\t\t      if (info->enable_dt_relr\n+\t\t\t  && irela->r_offset % 2 == 0\n+\t\t\t  && section->alignment_power != 0)\n+\t\t\tbreak;\n+\t\t      continue;\n+\t\t    }\n \n \t\t  /* Now determine the call target, its name, value,\n \t\t     section.  */\n \t\t  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,\n \t\t\t\t  r_indx, input_bfd))\n \t\t    goto error_ret_free_internal;\n-\t\t  hash = ppc_elf_hash_entry (h);\n \n+\t\t  if (r_type == R_PPC64_ADDR64 || r_type == R_PPC64_TOC)\n+\t\t    {\n+\t\t      /* Only locally defined symbols can possibly use\n+\t\t\t relative relocations.  */\n+\t\t      bfd_vma r_offset;\n+\t\t      if ((sym_sec == NULL\n+\t\t\t   || sym_sec->output_section == NULL)\n+\t\t\t  /* No symbol is OK too.  */\n+\t\t\t  && !(sym != NULL && sym->st_shndx == 0)\n+\t\t\t  /* Hack for __ehdr_start, which is undefined\n+\t\t\t     at this point.  */\n+\t\t\t  && !(h != NULL && h->root.linker_def))\n+\t\t\tcontinue;\n+\t\t      if (NO_OPD_RELOCS && is_opd)\n+\t\t\tcontinue;\n+\t\t      if (!is_opd\n+\t\t\t  && r_type == R_PPC64_ADDR64)\n+\t\t\t{\n+\t\t\t  if (h != NULL\n+\t\t\t      ? h->type == STT_GNU_IFUNC\n+\t\t\t      : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)\n+\t\t\t    continue;\n+\t\t\t  if (h != NULL\n+\t\t\t      && !SYMBOL_REFERENCES_LOCAL (info, h))\n+\t\t\t    continue;\n+\t\t\t}\n+\t\t      r_offset = _bfd_elf_section_offset (info->output_bfd,\n+\t\t\t\t\t\t\t  info,\n+\t\t\t\t\t\t\t  section,\n+\t\t\t\t\t\t\t  irela->r_offset);\n+\t\t      if (r_offset >= (bfd_vma) -2)\n+\t\t\tcontinue;\n+\t\t      r_offset += (section->output_section->vma\n+\t\t\t\t   + section->output_offset);\n+\t\t      if (!append_relr_off (htab, r_offset))\n+\t\t\tgoto error_ret_free_internal;\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  hash = ppc_elf_hash_entry (h);\n \t\t  ok_dest = false;\n \t\t  fdh = NULL;\n \t\t  sym_value = 0;\n@@ -13804,6 +14108,14 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n       if (htab->relbrlt != NULL)\n \thtab->relbrlt->size = 0;\n \n+      if (htab->elf.srelrdyn != NULL)\n+\t{\n+\t  if (htab->stub_iteration <= STUB_SHRINK_ITER\n+\t      || htab->elf.srelrdyn->rawsize < htab->elf.srelrdyn->size)\n+\t    htab->elf.srelrdyn->rawsize = htab->elf.srelrdyn->size;\n+\t  htab->elf.srelrdyn->size = 0;\n+\t}\n+\n       bfd_hash_traverse (&htab->stub_hash_table, ppc_size_one_stub, info);\n \n       for (group = htab->group; group != NULL; group = group->next)\n@@ -13845,6 +14157,53 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t= (group->stub_sec->size + (1 << align) - 1) & -(1 << align);\n \t    }\n \n+      if (htab->elf.srelrdyn != NULL)\n+\t{\n+\t  bfd_vma r_offset;\n+\n+\t  for (r_offset = 0; r_offset < htab->brlt->size; r_offset += 8)\n+\t    if (!append_relr_off (htab, (r_offset\n+\t\t\t\t\t + htab->brlt->output_section->vma\n+\t\t\t\t\t + htab->brlt->output_offset)))\n+\t      return false;\n+\n+\t  if (!got_and_plt_relr_for_local_syms (info))\n+\t    return false;\n+\t  elf_link_hash_traverse (&htab->elf, got_and_plt_relr, info);\n+\t  if (htab->stub_error)\n+\t    return false;\n+\n+\t  if (htab->relr_count > 1)\n+\t    qsort (htab->relr_addr, htab->relr_count, sizeof (*htab->relr_addr),\n+\t\t   compare_relr_address);\n+\n+\t  size_t i = 0;\n+\t  while (i < htab->relr_count)\n+\t    {\n+\t      bfd_vma base = htab->relr_addr[i];\n+\t      htab->elf.srelrdyn->size += 8;\n+\t      i++;\n+\t      /* Handle possible duplicate address.  This can happen\n+\t\t as sections increase in size when adding stubs.  */\n+\t      while (i < htab->relr_count\n+\t\t     && htab->relr_addr[i] == base)\n+\t\ti++;\n+\t      base += 8;\n+\t      while (1)\n+\t\t{\n+\t\t  size_t start_i = i;\n+\t\t  while (i < htab->relr_count\n+\t\t\t && htab->relr_addr[i] - base < 63 * 8\n+\t\t\t && (htab->relr_addr[i] - base) % 8 == 0)\n+\t\t    i++;\n+\t\t  if (i == start_i)\n+\t\t    break;\n+\t\t  htab->elf.srelrdyn->size += 8;\n+\t\t  base += 63 * 8;\n+\t\t}\n+\t    }\n+\t}\n+\n       for (group = htab->group; group != NULL; group = group->next)\n \tif (group->stub_sec != NULL\n \t    && group->stub_sec->rawsize != group->stub_sec->size\n@@ -13856,6 +14215,10 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t  && (htab->brlt->rawsize == htab->brlt->size\n \t      || (htab->stub_iteration > STUB_SHRINK_ITER\n \t\t  && htab->brlt->rawsize > htab->brlt->size))\n+\t  && (htab->elf.srelrdyn == NULL\n+\t      || htab->elf.srelrdyn->rawsize == htab->elf.srelrdyn->size\n+\t      || (htab->stub_iteration > STUB_SHRINK_ITER\n+\t\t  && htab->elf.srelrdyn->rawsize > htab->elf.srelrdyn->size))\n \t  && (htab->glink_eh_frame == NULL\n \t      || htab->glink_eh_frame->rawsize == htab->glink_eh_frame->size)\n \t  && (htab->tga_group == NULL\n@@ -13959,6 +14322,8 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n     maybe_strip_output (info, htab->relbrlt);\n   if (htab->glink_eh_frame != NULL)\n     maybe_strip_output (info, htab->glink_eh_frame);\n+  if (htab->elf.srelrdyn != NULL)\n+    maybe_strip_output (info, htab->elf.srelrdyn);\n \n   return true;\n }\n@@ -14120,16 +14485,16 @@ build_global_entry_stubs_and_plt (struct elf_link_hash_entry *h, void *inf)\n \t    else\n \t      {\n \t\tplt = htab->pltlocal;\n-\t\tif (bfd_link_pic (info))\n+\t\trelplt = NULL;\n+\t\tif (bfd_link_pic (info)\n+\t\t    && !(info->enable_dt_relr && !htab->opd_abi))\n \t\t  {\n \t\t    relplt = htab->relpltlocal;\n \t\t    if (htab->opd_abi)\n \t\t      rela.r_info = ELF64_R_INFO (0, R_PPC64_JMP_SLOT);\n \t\t    else\n \t\t      rela.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);\n \t\t  }\n-\t\telse\n-\t\t  relplt = NULL;\n \t      }\n \t    rela.r_addend = defined_sym_val (h) + ent->addend;\n \n@@ -14311,7 +14676,10 @@ write_plt_relocs_for_local_syms (struct bfd_link_info *info)\n \t      else\n \t\t{\n \t\t  plt = htab->pltlocal;\n-\t\t  relplt = bfd_link_pic (info) ? htab->relpltlocal : NULL;\n+\t\t  relplt = NULL;\n+\t\t  if (bfd_link_pic (info)\n+\t\t      && !(info->enable_dt_relr && !htab->opd_abi))\n+\t\t    relplt = htab->relpltlocal;\n \t\t}\n \n \t      if (relplt == NULL)\n@@ -14749,6 +15117,55 @@ ppc64_elf_build_stubs (struct bfd_link_info *info,\n \t}\n     }\n \n+  if (htab->elf.srelrdyn != NULL && htab->elf.srelrdyn->size != 0)\n+    {\n+      htab->elf.srelrdyn->contents\n+\t= bfd_alloc (htab->elf.dynobj, htab->elf.srelrdyn->size);\n+      if (htab->elf.srelrdyn->contents == NULL)\n+\treturn false;\n+\n+      size_t i = 0;\n+      bfd_byte *loc = htab->elf.srelrdyn->contents;\n+      while (i < htab->relr_count)\n+\t{\n+\t  bfd_vma base = htab->relr_addr[i];\n+\t  BFD_ASSERT (base % 2 == 0);\n+\t  bfd_put_64 (htab->elf.dynobj, base, loc);\n+\t  loc += 8;\n+\t  i++;\n+\t  while (i < htab->relr_count\n+\t\t && htab->relr_addr[i] == base)\n+\t    {\n+\t      htab->stub_error = true;\n+\t      i++;\n+\t    }\n+\t  base += 8;\n+\t  while (1)\n+\t    {\n+\t      bfd_vma bits = 0;\n+\t      while (i < htab->relr_count\n+\t\t     && htab->relr_addr[i] - base < 63 * 8\n+\t\t     && (htab->relr_addr[i] - base) % 8 == 0)\n+\t\t{\n+\t\t  bits |= (bfd_vma) 1 << ((htab->relr_addr[i] - base) / 8);\n+\t\t  i++;\n+\t\t}\n+\t      if (bits == 0)\n+\t\tbreak;\n+\t      bfd_put_64 (htab->elf.dynobj, (bits << 1) | 1, loc);\n+\t      loc += 8;\n+\t      base += 63 * 8;\n+\t    }\n+\t}\n+      /* Pad any excess with 1's, a do-nothing encoding.  */\n+      while ((size_t) (loc - htab->elf.srelrdyn->contents)\n+\t     < htab->elf.srelrdyn->size)\n+\t{\n+\t  bfd_put_64 (htab->elf.dynobj, 1, loc);\n+\t  loc += 8;\n+\t}\n+    }\n+\n   for (group = htab->group; group != NULL; group = group->next)\n     if ((stub_sec = group->stub_sec) != NULL)\n       {\n@@ -14760,14 +15177,14 @@ ppc64_elf_build_stubs (struct bfd_link_info *info,\n       }\n \n   if (group != NULL)\n+    htab->stub_error = true;\n+\n+  if (htab->stub_error)\n     {\n-      htab->stub_error = true;\n       _bfd_error_handler (_(\"stubs don't match calculated size\"));\n+      return false;\n     }\n \n-  if (htab->stub_error)\n-    return false;\n-\n   if (stats != NULL)\n     {\n       char *groupmsg;\n@@ -16462,10 +16879,14 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t\t      outrel.r_addend -= htab->elf.tls_sec->vma;\n \t\t\t  }\n \t\t      }\n-\t\t    loc = relgot->contents;\n-\t\t    loc += (relgot->reloc_count++\n-\t\t\t    * sizeof (Elf64_External_Rela));\n-\t\t    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);\n+\t\t    if (!(info->enable_dt_relr\n+\t\t\t  && ELF64_R_TYPE (outrel.r_info) == R_PPC64_RELATIVE))\n+\t\t      {\n+\t\t\tloc = relgot->contents;\n+\t\t\tloc += (relgot->reloc_count++\n+\t\t\t\t* sizeof (Elf64_External_Rela));\n+\t\t\tbfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);\n+\t\t      }\n \t\t  }\n \n \t\t/* Init the .got section contents here if we're not\n@@ -16924,24 +17345,31 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t    }\n \t\t}\n \n-\t      sreloc = elf_section_data (input_section)->sreloc;\n-\t      if (h != NULL\n-\t\t  ? h->elf.type == STT_GNU_IFUNC\n-\t\t  : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)\n+\t      if (!(info->enable_dt_relr\n+\t\t    && ELF64_R_TYPE (outrel.r_info) == R_PPC64_RELATIVE\n+\t\t    && rel->r_offset % 2 == 0\n+\t\t    && input_section->alignment_power != 0\n+\t\t    && ELF64_R_TYPE (orig_rel.r_info) != R_PPC64_UADDR64))\n \t\t{\n-\t\t  sreloc = htab->elf.irelplt;\n-\t\t  if (indx == 0 || is_static_defined (&h->elf))\n-\t\t    htab->elf.ifunc_resolvers = true;\n+\t\t  sreloc = elf_section_data (input_section)->sreloc;\n+\t\t  if (h != NULL\n+\t\t      ? h->elf.type == STT_GNU_IFUNC\n+\t\t      : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)\n+\t\t    {\n+\t\t      sreloc = htab->elf.irelplt;\n+\t\t      if (indx == 0 || is_static_defined (&h->elf))\n+\t\t\thtab->elf.ifunc_resolvers = true;\n+\t\t    }\n+\t\t  if (sreloc == NULL)\n+\t\t    abort ();\n+\n+\t\t  if (sreloc->reloc_count * sizeof (Elf64_External_Rela)\n+\t\t      >= sreloc->size)\n+\t\t    abort ();\n+\t\t  loc = sreloc->contents;\n+\t\t  loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);\n+\t\t  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);\n \t\t}\n-\t      if (sreloc == NULL)\n-\t\tabort ();\n-\n-\t      if (sreloc->reloc_count * sizeof (Elf64_External_Rela)\n-\t\t  >= sreloc->size)\n-\t\tabort ();\n-\t      loc = sreloc->contents;\n-\t      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);\n-\t      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);\n \n \t      if (!warned_dynamic\n \t\t  && !ppc64_glibc_dynamic_reloc (ELF64_R_TYPE (outrel.r_info)))"
    },
    {
      "sha": "2a2aaf4a17d175b684daccf3eef56d8635cfc04b",
      "filename": "binutils/testsuite/lib/binutils-common.exp",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/binutils/testsuite/lib/binutils-common.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/binutils/testsuite/lib/binutils-common.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/lib/binutils-common.exp?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -429,7 +429,9 @@ proc supports_persistent_section {} {\n \n # Whether a target support DT_RELR sections.\n proc supports_dt_relr {} {\n-    if { ([istarget x86_64-*-*] || [istarget i?86-*-*])\n+    if { ([istarget x86_64-*-*]\n+\t  || [istarget i?86-*-*]\n+\t  || [istarget powerpc64*-*-*])\n \t && ([istarget *-*-linux*]\n \t     || [istarget *-*-gnu*]) } {\n \treturn 1"
    },
    {
      "sha": "a18393b7202f441bc87c5828ffb232db826812f6",
      "filename": "ld/emulparams/elf64ppc.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/emulparams/elf64ppc.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/emulparams/elf64ppc.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf64ppc.sh?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -1,5 +1,6 @@\n source_sh ${srcdir}/emulparams/elf32ppccommon.sh\n source_sh ${srcdir}/emulparams/plt_unwind.sh\n+source_sh ${srcdir}/emulparams/dt-relr.sh\n EXTRA_EM_FILE=ppc64elf\n ELFSIZE=64\n OUTPUT_FORMAT=\"elf64-powerpc\""
    },
    {
      "sha": "b1391566a13fa08aca38247defcc6eef56326443",
      "filename": "ld/testsuite/ld-elf/dt-relr-2b.d",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2b.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2b.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/dt-relr-2b.d?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -10,7 +10,7 @@\n #...\n Relocation section '\\.rel(a|)\\.dyn' at offset 0x[0-9a-f]+ contains 1 entry:\n #...\n-[0-9a-f]+ +[0-9a-f]+ +R_.*_RELATIVE .*\n+[0-9a-f]+ +[0-9a-f]+ +R_.*_(RELATIVE|UADDR.*) .*\n #...\n Relocation section '\\.relr\\.dyn' at offset 0x[0-9a-f]+ contains 2 entries:\n   4 offsets"
    },
    {
      "sha": "c285e8707d79446c4a1385cc204994582fd395d1",
      "filename": "ld/testsuite/ld-elf/dt-relr-2c.d",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2c.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2c.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/dt-relr-2c.d?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -10,7 +10,7 @@\n #...\n Relocation section '\\.rel(a|)\\.dyn' at offset 0x[0-9a-f]+ contains 2 entries:\n #...\n-[0-9a-f]+ +[0-9a-f]+ +R_.*_RELATIVE .*\n+[0-9a-f]+ +[0-9a-f]+ +R_.*_(RELATIVE|UADDR.*) .*\n #...\n Relocation section '\\.relr\\.dyn' at offset 0x[0-9a-f]+ contains 2 entries:\n   3 offsets"
    },
    {
      "sha": "7fd3046a1cf0720d8985fe764b6f2596135175cc",
      "filename": "ld/testsuite/ld-elf/dt-relr-2d.d",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2d.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2d.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/dt-relr-2d.d?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -10,7 +10,7 @@\n #...\n Relocation section '\\.rel(a|)\\.dyn' at offset 0x[0-9a-f]+ contains 1 entry:\n #...\n-[0-9a-f]+ +[0-9a-f]+ +R_.*_RELATIVE .*\n+[0-9a-f]+ +[0-9a-f]+ +R_.*_(RELATIVE|UADDR.*) .*\n #...\n Relocation section '\\.relr\\.dyn' at offset 0x[0-9a-f]+ contains 2 entries:\n   4 offsets"
    },
    {
      "sha": "cdff8465a57d9597ec85604d7e41cc94748527ac",
      "filename": "ld/testsuite/ld-elf/dt-relr-2e.d",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2e.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1657026ccd8aa05a97cb35f1d9bff646937a244e/ld/testsuite/ld-elf/dt-relr-2e.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/dt-relr-2e.d?ref=1657026ccd8aa05a97cb35f1d9bff646937a244e",
      "patch": "@@ -10,7 +10,7 @@\n #...\n Relocation section '\\.rel(a|)\\.data' at offset 0x[0-9a-f]+ contains 1 entry:\n #...\n-[0-9a-f]+ +[0-9a-f]+ +R_.*_RELATIVE .*\n+[0-9a-f]+ +[0-9a-f]+ +R_.*_(RELATIVE|UADDR.*) .*\n #...\n Relocation section '\\.relr\\.dyn' at offset 0x[0-9a-f]+ contains 2 entries:\n   4 offsets"
    }
  ]
}