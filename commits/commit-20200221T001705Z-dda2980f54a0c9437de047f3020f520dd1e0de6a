{
  "sha": "dda2980f54a0c9437de047f3020f520dd1e0de6a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGRhMjk4MGY1NGEwYzk0MzdkZTA0N2YzMDIwZjUyMGRkMWUwZGU2YQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-20T11:23:44Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-21T00:17:05Z"
    },
    "message": "PR25569, PDP11 ld -s clobbers last data byte\n\nThis patch fixes an ancient wart in aout support, in that text and\ndata section sizes are rounded up for alignment rather that just the\ncorresponding header sizes.  Changing section sizes could conceivably\nresult in buffer overflows if section contents were held in memory.\nAlso, keeping the original section sizes allows this PR to be fixed\nnicely.\n\nbfd/\n\tPR 25569\n\t* aoutx.h (adjust_o_magic, adjust_z_magic, adjust_n_magic): Use\n\t\"text\", \"data\" and \"bss\" section pointer vars.  Don't update\n\tsection size, just exec header sizes.\n\t(adjust_sizes_and_vmas): Don't update text section size.  Set\n\tinitial exec header a_text.  Print exec headers sizes.\n\t* pdp11.c (adjust_o_magic, adjust_z_magic, adjust_n_magic),\n\t(adjust_sizes_and_vmas): Similarly.  Formatting.\n\t(final_link): Correct final file extension.\ngas/\n\tPR 25569\n\t* config/obj-aout.c (obj_aout_frob_file_before_fix): Don't loop\n\ton section size adjustment, instead perform another write if\n\texec header size is larger than section size.",
    "tree": {
      "sha": "0cec5fd8cca1430f9ebf92c851d58dab01c39ba0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0cec5fd8cca1430f9ebf92c851d58dab01c39ba0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dda2980f54a0c9437de047f3020f520dd1e0de6a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dda2980f54a0c9437de047f3020f520dd1e0de6a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dda2980f54a0c9437de047f3020f520dd1e0de6a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dda2980f54a0c9437de047f3020f520dd1e0de6a/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6565bf67add96edbe99c24acb312fe84079ab6a0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6565bf67add96edbe99c24acb312fe84079ab6a0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6565bf67add96edbe99c24acb312fe84079ab6a0"
    }
  ],
  "stats": {
    "total": 506,
    "additions": 264,
    "deletions": 242
  },
  "files": [
    {
      "sha": "0f9c3e51f32344e95c8b8747f928cc9cb8dc9718",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda2980f54a0c9437de047f3020f520dd1e0de6a/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda2980f54a0c9437de047f3020f520dd1e0de6a/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=dda2980f54a0c9437de047f3020f520dd1e0de6a",
      "patch": "@@ -1,3 +1,15 @@\n+2020-02-21  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25569\n+\t* aoutx.h (adjust_o_magic, adjust_z_magic, adjust_n_magic): Use\n+\t\"text\", \"data\" and \"bss\" section pointer vars.  Don't update\n+\tsection size, just exec header sizes.\n+\t(adjust_sizes_and_vmas): Don't update text section size.  Set\n+\tinitial exec header a_text.  Print exec headers sizes.\n+\t* pdp11.c (adjust_o_magic, adjust_z_magic, adjust_n_magic),\n+\t(adjust_sizes_and_vmas): Similarly.  Formatting.\n+\t(final_link): Correct final file extension.\n+\n 2020-02-20  Nick Clifton  <nickc@redhat.com>\n \n \t* elf-bfd.h (struct elf_backend_data): Add symbol_section_index"
    },
    {
      "sha": "fef75e54525bf617cf065dab2b7e9ec4602c7b18",
      "filename": "bfd/aoutx.h",
      "status": "modified",
      "additions": 84,
      "deletions": 95,
      "changes": 179,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda2980f54a0c9437de047f3020f520dd1e0de6a/bfd/aoutx.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda2980f54a0c9437de047f3020f520dd1e0de6a/bfd/aoutx.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aoutx.h?ref=dda2980f54a0c9437de047f3020f520dd1e0de6a",
      "patch": "@@ -891,57 +891,56 @@ adjust_o_magic (bfd *abfd, struct internal_exec *execp)\n   file_ptr pos = adata (abfd).exec_bytes_size;\n   bfd_vma vma = 0;\n   int pad = 0;\n+  asection *text = obj_textsec (abfd);\n+  asection *data = obj_datasec (abfd);\n+  asection *bss = obj_bsssec (abfd);\n \n   /* Text.  */\n-  obj_textsec (abfd)->filepos = pos;\n-  if (!obj_textsec (abfd)->user_set_vma)\n-    obj_textsec (abfd)->vma = vma;\n+  text->filepos = pos;\n+  if (!text->user_set_vma)\n+    text->vma = vma;\n   else\n-    vma = obj_textsec (abfd)->vma;\n+    vma = text->vma;\n \n-  pos += obj_textsec (abfd)->size;\n-  vma += obj_textsec (abfd)->size;\n+  pos += execp->a_text;\n+  vma += execp->a_text;\n \n   /* Data.  */\n-  if (!obj_datasec (abfd)->user_set_vma)\n+  if (!data->user_set_vma)\n     {\n-      obj_textsec (abfd)->size += pad;\n       pos += pad;\n       vma += pad;\n-      obj_datasec (abfd)->vma = vma;\n+      data->vma = vma;\n     }\n   else\n-    vma = obj_datasec (abfd)->vma;\n-  obj_datasec (abfd)->filepos = pos;\n-  pos += obj_datasec (abfd)->size;\n-  vma += obj_datasec (abfd)->size;\n+    vma = data->vma;\n+  execp->a_text += pad;\n+\n+  data->filepos = pos;\n+  pos += data->size;\n+  vma += data->size;\n \n   /* BSS.  */\n-  if (!obj_bsssec (abfd)->user_set_vma)\n+  if (!bss->user_set_vma)\n     {\n-      obj_datasec (abfd)->size += pad;\n       pos += pad;\n       vma += pad;\n-      obj_bsssec (abfd)->vma = vma;\n+      bss->vma = vma;\n     }\n   else\n     {\n       /* The VMA of the .bss section is set by the VMA of the\n \t .data section plus the size of the .data section.  We may\n \t need to add padding bytes to make this true.  */\n-      pad = obj_bsssec (abfd)->vma - vma;\n-      if (pad > 0)\n-\t{\n-\t  obj_datasec (abfd)->size += pad;\n-\t  pos += pad;\n-\t}\n+      pad = bss->vma - vma;\n+      if (pad < 0)\n+\tpad = 0;\n+      pos += pad;\n     }\n-  obj_bsssec (abfd)->filepos = pos;\n+  execp->a_data = data->size + pad;\n+  bss->filepos = pos;\n+  execp->a_bss = bss->size;\n \n-  /* Fix up the exec header.  */\n-  execp->a_text = obj_textsec (abfd)->size;\n-  execp->a_data = obj_datasec (abfd)->size;\n-  execp->a_bss = obj_bsssec (abfd)->size;\n   N_SET_MAGIC (execp, OMAGIC);\n }\n \n@@ -953,25 +952,27 @@ adjust_z_magic (bfd *abfd, struct internal_exec *execp)\n   const struct aout_backend_data *abdp;\n   /* TRUE if text includes exec header.  */\n   bfd_boolean ztih;\n+  asection *text = obj_textsec (abfd);\n+  asection *data = obj_datasec (abfd);\n+  asection *bss = obj_bsssec (abfd);\n \n   abdp = aout_backend_info (abfd);\n \n   /* Text.  */\n   ztih = (abdp != NULL\n \t  && (abdp->text_includes_header\n \t      || obj_aout_subformat (abfd) == q_magic_format));\n-  obj_textsec (abfd)->filepos = (ztih\n-\t\t\t\t ? adata (abfd).exec_bytes_size\n-\t\t\t\t : adata (abfd).zmagic_disk_block_size);\n-  if (! obj_textsec (abfd)->user_set_vma)\n+  text->filepos = (ztih\n+\t\t   ? adata (abfd).exec_bytes_size\n+\t\t   : adata (abfd).zmagic_disk_block_size);\n+  if (!text->user_set_vma)\n     {\n       /* ?? Do we really need to check for relocs here?  */\n-      obj_textsec (abfd)->vma = ((abfd->flags & HAS_RELOC)\n-\t\t\t\t ? 0\n-\t\t\t\t : (ztih\n-\t\t\t\t    ? (abdp->default_text_vma\n-\t\t\t\t       + adata (abfd).exec_bytes_size)\n-\t\t\t\t    : abdp->default_text_vma));\n+      text->vma = ((abfd->flags & HAS_RELOC)\n+\t\t   ? 0\n+\t\t   : (ztih\n+\t\t      ? abdp->default_text_vma + adata (abfd).exec_bytes_size\n+\t\t      : abdp->default_text_vma));\n       text_pad = 0;\n     }\n   else\n@@ -980,54 +981,48 @@ adjust_z_magic (bfd *abfd, struct internal_exec *execp)\n \t may need to pad it such that the .data section starts at a page\n \t boundary.  */\n       if (ztih)\n-\ttext_pad = ((obj_textsec (abfd)->filepos - obj_textsec (abfd)->vma)\n+\ttext_pad = ((text->filepos - text->vma)\n \t\t    & (adata (abfd).page_size - 1));\n       else\n-\ttext_pad = ((- obj_textsec (abfd)->vma)\n+\ttext_pad = (-text->vma\n \t\t    & (adata (abfd).page_size - 1));\n     }\n \n   /* Find start of data.  */\n   if (ztih)\n     {\n-      text_end = obj_textsec (abfd)->filepos + obj_textsec (abfd)->size;\n+      text_end = text->filepos + execp->a_text;\n       text_pad += BFD_ALIGN (text_end, adata (abfd).page_size) - text_end;\n     }\n   else\n     {\n       /* Note that if page_size == zmagic_disk_block_size, then\n \t filepos == page_size, and this case is the same as the ztih\n \t case.  */\n-      text_end = obj_textsec (abfd)->size;\n+      text_end = execp->a_text;\n       text_pad += BFD_ALIGN (text_end, adata (abfd).page_size) - text_end;\n-      text_end += obj_textsec (abfd)->filepos;\n+      text_end += text->filepos;\n     }\n-  obj_textsec (abfd)->size += text_pad;\n-  text_end += text_pad;\n+  execp->a_text += text_pad;\n \n   /* Data.  */\n-  if (!obj_datasec (abfd)->user_set_vma)\n+  if (!data->user_set_vma)\n     {\n       bfd_vma vma;\n-      vma = obj_textsec (abfd)->vma + obj_textsec (abfd)->size;\n-      obj_datasec (abfd)->vma = BFD_ALIGN (vma, adata (abfd).segment_size);\n+      vma = text->vma + execp->a_text;\n+      data->vma = BFD_ALIGN (vma, adata (abfd).segment_size);\n     }\n   if (abdp && abdp->zmagic_mapped_contiguous)\n     {\n-      asection * text = obj_textsec (abfd);\n-      asection * data = obj_datasec (abfd);\n-\n-      text_pad = data->vma - (text->vma + text->size);\n+      text_pad = data->vma - (text->vma + execp->a_text);\n       /* Only pad the text section if the data\n \t section is going to be placed after it.  */\n       if (text_pad > 0)\n-\ttext->size += text_pad;\n+\texecp->a_text += text_pad;\n     }\n-  obj_datasec (abfd)->filepos = (obj_textsec (abfd)->filepos\n-\t\t\t\t + obj_textsec (abfd)->size);\n+  data->filepos = text->filepos + execp->a_text;\n \n   /* Fix up exec header while we're at it.  */\n-  execp->a_text = obj_textsec (abfd)->size;\n   if (ztih && (!abdp || (abdp && !abdp->exec_header_not_counted)))\n     execp->a_text += adata (abfd).exec_bytes_size;\n   if (obj_aout_subformat (abfd) == q_magic_format)\n@@ -1036,30 +1031,24 @@ adjust_z_magic (bfd *abfd, struct internal_exec *execp)\n     N_SET_MAGIC (execp, ZMAGIC);\n \n   /* Spec says data section should be rounded up to page boundary.  */\n-  obj_datasec (abfd)->size\n-    = align_power (obj_datasec (abfd)->size,\n-\t\t   obj_bsssec (abfd)->alignment_power);\n-  execp->a_data = BFD_ALIGN (obj_datasec (abfd)->size,\n-\t\t\t     adata (abfd).page_size);\n-  data_pad = execp->a_data - obj_datasec (abfd)->size;\n+  execp->a_data = align_power (data->size, bss->alignment_power);\n+  execp->a_data = BFD_ALIGN (execp->a_data, adata (abfd).page_size);\n+  data_pad = execp->a_data - data->size;\n \n   /* BSS.  */\n-  if (!obj_bsssec (abfd)->user_set_vma)\n-    obj_bsssec (abfd)->vma = (obj_datasec (abfd)->vma\n-\t\t\t      + obj_datasec (abfd)->size);\n+  if (!bss->user_set_vma)\n+    bss->vma = data->vma + execp->a_data;\n   /* If the BSS immediately follows the data section and extra space\n      in the page is left after the data section, fudge data\n      in the header so that the bss section looks smaller by that\n      amount.  We'll start the bss section there, and lie to the OS.\n      (Note that a linker script, as well as the above assignment,\n      could have explicitly set the BSS vma to immediately follow\n      the data section.)  */\n-  if (align_power (obj_bsssec (abfd)->vma, obj_bsssec (abfd)->alignment_power)\n-      == obj_datasec (abfd)->vma + obj_datasec (abfd)->size)\n-    execp->a_bss = (data_pad > obj_bsssec (abfd)->size\n-\t\t    ? 0 : obj_bsssec (abfd)->size - data_pad);\n+  if (align_power (bss->vma, bss->alignment_power) == data->vma + execp->a_data)\n+    execp->a_bss = data_pad > bss->size ? 0 : bss->size - data_pad;\n   else\n-    execp->a_bss = obj_bsssec (abfd)->size;\n+    execp->a_bss = bss->size;\n }\n \n static void\n@@ -1068,38 +1057,39 @@ adjust_n_magic (bfd *abfd, struct internal_exec *execp)\n   file_ptr pos = adata (abfd).exec_bytes_size;\n   bfd_vma vma = 0;\n   int pad;\n+  asection *text = obj_textsec (abfd);\n+  asection *data = obj_datasec (abfd);\n+  asection *bss = obj_bsssec (abfd);\n \n   /* Text.  */\n-  obj_textsec (abfd)->filepos = pos;\n-  if (!obj_textsec (abfd)->user_set_vma)\n-    obj_textsec (abfd)->vma = vma;\n+  text->filepos = pos;\n+  if (!text->user_set_vma)\n+    text->vma = vma;\n   else\n-    vma = obj_textsec (abfd)->vma;\n-  pos += obj_textsec (abfd)->size;\n-  vma += obj_textsec (abfd)->size;\n+    vma = text->vma;\n+  pos += execp->a_text;\n+  vma += execp->a_text;\n \n   /* Data.  */\n-  obj_datasec (abfd)->filepos = pos;\n-  if (!obj_datasec (abfd)->user_set_vma)\n-    obj_datasec (abfd)->vma = BFD_ALIGN (vma, adata (abfd).segment_size);\n-  vma = obj_datasec (abfd)->vma;\n+  data->filepos = pos;\n+  if (!data->user_set_vma)\n+    data->vma = BFD_ALIGN (vma, adata (abfd).segment_size);\n+  vma = data->vma;\n \n   /* Since BSS follows data immediately, see if it needs alignment.  */\n-  vma += obj_datasec (abfd)->size;\n-  pad = align_power (vma, obj_bsssec (abfd)->alignment_power) - vma;\n-  obj_datasec (abfd)->size += pad;\n-  pos += obj_datasec (abfd)->size;\n+  vma += data->size;\n+  pad = align_power (vma, bss->alignment_power) - vma;\n+  execp->a_data = data->size + pad;\n+  pos += execp->a_data;\n \n   /* BSS.  */\n-  if (!obj_bsssec (abfd)->user_set_vma)\n-    obj_bsssec (abfd)->vma = vma;\n+  if (!bss->user_set_vma)\n+    bss->vma = vma;\n   else\n-    vma = obj_bsssec (abfd)->vma;\n+    vma = bss->vma;\n \n   /* Fix up exec header.  */\n-  execp->a_text = obj_textsec (abfd)->size;\n-  execp->a_data = obj_datasec (abfd)->size;\n-  execp->a_bss = obj_bsssec (abfd)->size;\n+  execp->a_bss = bss->size;\n   N_SET_MAGIC (execp, NMAGIC);\n }\n \n@@ -1114,9 +1104,8 @@ NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n   if (adata (abfd).magic != undecided_magic)\n     return TRUE;\n \n-  obj_textsec (abfd)->size =\n-    align_power (obj_textsec (abfd)->size,\n-\t\t obj_textsec (abfd)->alignment_power);\n+  execp->a_text = align_power (obj_textsec (abfd)->size,\n+\t\t\t       obj_textsec (abfd)->alignment_power);\n \n   /* Rule (heuristic) for when to pad to a new page.  Note that there\n      are (at least) two ways demand-paged (ZMAGIC) files have been\n@@ -1181,11 +1170,11 @@ NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n \n #ifdef BFD_AOUT_DEBUG\n   fprintf (stderr, \"       text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x>\\n\",\n-\t   obj_textsec (abfd)->vma, obj_textsec (abfd)->size,\n+\t   obj_textsec (abfd)->vma, execp->a_text,\n \t\tobj_textsec (abfd)->filepos,\n-\t   obj_datasec (abfd)->vma, obj_datasec (abfd)->size,\n+\t   obj_datasec (abfd)->vma, execp->a_data,\n \t\tobj_datasec (abfd)->filepos,\n-\t   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->size);\n+\t   obj_bsssec (abfd)->vma, execp->a_bss);\n #endif\n \n   return TRUE;"
    },
    {
      "sha": "50d006f0859068b33536bfcb8fb66318a86bac11",
      "filename": "bfd/pdp11.c",
      "status": "modified",
      "additions": 133,
      "deletions": 127,
      "changes": 260,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda2980f54a0c9437de047f3020f520dd1e0de6a/bfd/pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda2980f54a0c9437de047f3020f520dd1e0de6a/bfd/pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pdp11.c?ref=dda2980f54a0c9437de047f3020f520dd1e0de6a",
      "patch": "@@ -789,57 +789,56 @@ adjust_o_magic (bfd *abfd, struct internal_exec *execp)\n   file_ptr pos = adata (abfd).exec_bytes_size;\n   bfd_vma vma = 0;\n   int pad = 0;\n+  asection *text = obj_textsec (abfd);\n+  asection *data = obj_datasec (abfd);\n+  asection *bss = obj_bsssec (abfd);\n \n   /* Text.  */\n-  obj_textsec (abfd)->filepos = pos;\n-  if (! obj_textsec (abfd)->user_set_vma)\n-    obj_textsec (abfd)->vma = vma;\n+  text->filepos = pos;\n+  if (!text->user_set_vma)\n+    text->vma = vma;\n   else\n-    vma = obj_textsec (abfd)->vma;\n+    vma = text->vma;\n \n-  pos += obj_textsec (abfd)->size;\n-  vma += obj_textsec (abfd)->size;\n+  pos += execp->a_text;\n+  vma += execp->a_text;\n \n   /* Data.  */\n-  if (!obj_datasec (abfd)->user_set_vma)\n+  if (!data->user_set_vma)\n     {\n-      obj_textsec (abfd)->size += pad;\n       pos += pad;\n       vma += pad;\n-      obj_datasec (abfd)->vma = vma;\n+      data->vma = vma;\n     }\n   else\n-    vma = obj_datasec (abfd)->vma;\n-  obj_datasec (abfd)->filepos = pos;\n-  pos += obj_datasec (abfd)->size;\n-  vma += obj_datasec (abfd)->size;\n+    vma = data->vma;\n+  execp->a_text += pad;\n+\n+  data->filepos = pos;\n+  pos += data->size;\n+  vma += data->size;\n \n   /* BSS.  */\n-  if (! obj_bsssec (abfd)->user_set_vma)\n+  if (!bss->user_set_vma)\n     {\n-      obj_datasec (abfd)->size += pad;\n       pos += pad;\n       vma += pad;\n-      obj_bsssec (abfd)->vma = vma;\n+      bss->vma = vma;\n     }\n   else\n     {\n       /* The VMA of the .bss section is set by the VMA of the\n \t .data section plus the size of the .data section.  We may\n \t need to add padding bytes to make this true.  */\n-      pad = obj_bsssec (abfd)->vma - vma;\n-      if (pad > 0)\n-\t{\n-\t  obj_datasec (abfd)->size += pad;\n-\t  pos += pad;\n-\t}\n+      pad = bss->vma - vma;\n+      if (pad < 0)\n+\tpad = 0;\n+      pos += pad;\n     }\n-  obj_bsssec (abfd)->filepos = pos;\n+  execp->a_data = data->size + pad;\n+  bss->filepos = pos;\n+  execp->a_bss = bss->size;\n \n-  /* Fix up the exec header.  */\n-  execp->a_text = obj_textsec (abfd)->size;\n-  execp->a_data = obj_datasec (abfd)->size;\n-  execp->a_bss  = obj_bsssec (abfd)->size;\n   N_SET_MAGIC (execp, OMAGIC);\n }\n \n@@ -849,26 +848,29 @@ adjust_z_magic (bfd *abfd, struct internal_exec *execp)\n   bfd_size_type data_pad, text_pad;\n   file_ptr text_end;\n   const struct aout_backend_data *abdp;\n-  int ztih;\t\t\t/* Nonzero if text includes exec header.  */\n+  /* TRUE if text includes exec header.  */\n+  bfd_boolean ztih;\n+  asection *text = obj_textsec (abfd);\n+  asection *data = obj_datasec (abfd);\n+  asection *bss = obj_bsssec (abfd);\n \n   abdp = aout_backend_info (abfd);\n \n   /* Text.  */\n   ztih = (abdp != NULL\n \t  && (abdp->text_includes_header\n \t      || obj_aout_subformat (abfd) == q_magic_format));\n-  obj_textsec(abfd)->filepos = (ztih\n-\t\t\t\t? adata(abfd).exec_bytes_size\n-\t\t\t\t: adata(abfd).zmagic_disk_block_size);\n-  if (! obj_textsec(abfd)->user_set_vma)\n+  text->filepos = (ztih\n+\t\t   ? adata (abfd).exec_bytes_size\n+\t\t   : adata (abfd).zmagic_disk_block_size);\n+  if (!text->user_set_vma)\n     {\n       /* ?? Do we really need to check for relocs here?  */\n-      obj_textsec(abfd)->vma = ((abfd->flags & HAS_RELOC)\n-\t\t\t\t? 0\n-\t\t\t\t: (ztih\n-\t\t\t\t   ? (abdp->default_text_vma\n-\t\t\t\t      + adata (abfd).exec_bytes_size)\n-\t\t\t\t   : abdp->default_text_vma));\n+      text->vma = ((abfd->flags & HAS_RELOC)\n+\t\t   ? 0\n+\t\t   : (ztih\n+\t\t      ? abdp->default_text_vma + adata (abfd).exec_bytes_size\n+\t\t      : abdp->default_text_vma));\n       text_pad = 0;\n     }\n   else\n@@ -877,120 +879,112 @@ adjust_z_magic (bfd *abfd, struct internal_exec *execp)\n \t may need to pad it such that the .data section starts at a page\n \t boundary.  */\n       if (ztih)\n-\ttext_pad = ((obj_textsec (abfd)->filepos - obj_textsec (abfd)->vma)\n+\ttext_pad = ((text->filepos - text->vma)\n \t\t    & (adata (abfd).page_size - 1));\n       else\n-\ttext_pad = ((- obj_textsec (abfd)->vma)\n+\ttext_pad = (-text->vma\n \t\t    & (adata (abfd).page_size - 1));\n     }\n \n   /* Find start of data.  */\n   if (ztih)\n     {\n-      text_end = obj_textsec (abfd)->filepos + obj_textsec (abfd)->size;\n+      text_end = text->filepos + execp->a_text;\n       text_pad += BFD_ALIGN (text_end, adata (abfd).page_size) - text_end;\n     }\n   else\n     {\n       /* Note that if page_size == zmagic_disk_block_size, then\n \t filepos == page_size, and this case is the same as the ztih\n \t case.  */\n-      text_end = obj_textsec (abfd)->size;\n+      text_end = execp->a_text;\n       text_pad += BFD_ALIGN (text_end, adata (abfd).page_size) - text_end;\n-      text_end += obj_textsec (abfd)->filepos;\n+      text_end += text->filepos;\n     }\n-\n-  obj_textsec (abfd)->size += text_pad;\n-  text_end += text_pad;\n+  execp->a_text += text_pad;\n \n   /* Data.  */\n-  if (!obj_datasec(abfd)->user_set_vma)\n+  if (!data->user_set_vma)\n     {\n       bfd_vma vma;\n-      vma = obj_textsec(abfd)->vma + obj_textsec(abfd)->size;\n-      obj_datasec(abfd)->vma = BFD_ALIGN (vma, adata(abfd).segment_size);\n+      vma = text->vma + execp->a_text;\n+      data->vma = BFD_ALIGN (vma, adata (abfd).segment_size);\n     }\n   if (abdp && abdp->zmagic_mapped_contiguous)\n     {\n-      text_pad = (obj_datasec(abfd)->vma\n-\t\t  - obj_textsec(abfd)->vma\n-\t\t  - obj_textsec(abfd)->size);\n-      obj_textsec(abfd)->size += text_pad;\n+      text_pad = data->vma - (text->vma + execp->a_text);\n+      /* Only pad the text section if the data\n+\t section is going to be placed after it.  */\n+      if (text_pad > 0)\n+\texecp->a_text += text_pad;\n     }\n-  obj_datasec (abfd)->filepos = (obj_textsec (abfd)->filepos\n-\t\t\t\t+ obj_textsec (abfd)->size);\n+  data->filepos = text->filepos + execp->a_text;\n \n   /* Fix up exec header while we're at it.  */\n-  execp->a_text = obj_textsec(abfd)->size;\n   if (ztih && (!abdp || (abdp && !abdp->exec_header_not_counted)))\n-    execp->a_text += adata(abfd).exec_bytes_size;\n+    execp->a_text += adata (abfd).exec_bytes_size;\n   N_SET_MAGIC (execp, ZMAGIC);\n \n   /* Spec says data section should be rounded up to page boundary.  */\n-  obj_datasec(abfd)->size\n-    = align_power (obj_datasec(abfd)->size,\n-\t\t   obj_bsssec(abfd)->alignment_power);\n-  execp->a_data = BFD_ALIGN (obj_datasec(abfd)->size,\n-\t\t\t     adata(abfd).page_size);\n-  data_pad = execp->a_data - obj_datasec(abfd)->size;\n+  execp->a_data = align_power (data->size, bss->alignment_power);\n+  execp->a_data = BFD_ALIGN (execp->a_data, adata (abfd).page_size);\n+  data_pad = execp->a_data - data->size;\n \n   /* BSS.  */\n-  if (!obj_bsssec(abfd)->user_set_vma)\n-    obj_bsssec(abfd)->vma = (obj_datasec(abfd)->vma\n-\t\t\t     + obj_datasec(abfd)->size);\n+  if (!bss->user_set_vma)\n+    bss->vma = data->vma + execp->a_data;\n   /* If the BSS immediately follows the data section and extra space\n      in the page is left after the data section, fudge data\n      in the header so that the bss section looks smaller by that\n      amount.  We'll start the bss section there, and lie to the OS.\n      (Note that a linker script, as well as the above assignment,\n      could have explicitly set the BSS vma to immediately follow\n      the data section.)  */\n-  if (align_power (obj_bsssec(abfd)->vma, obj_bsssec(abfd)->alignment_power)\n-      == obj_datasec(abfd)->vma + obj_datasec(abfd)->size)\n-    execp->a_bss = (data_pad > obj_bsssec(abfd)->size) ? 0 :\n-      obj_bsssec(abfd)->size - data_pad;\n+  if (align_power (bss->vma, bss->alignment_power) == data->vma + execp->a_data)\n+    execp->a_bss = data_pad > bss->size ? 0 : bss->size - data_pad;\n   else\n-    execp->a_bss = obj_bsssec(abfd)->size;\n+    execp->a_bss = bss->size;\n }\n \n static void\n adjust_n_magic (bfd *abfd, struct internal_exec *execp)\n {\n-  file_ptr pos = adata(abfd).exec_bytes_size;\n+  file_ptr pos = adata (abfd).exec_bytes_size;\n   bfd_vma vma = 0;\n   int pad;\n+  asection *text = obj_textsec (abfd);\n+  asection *data = obj_datasec (abfd);\n+  asection *bss = obj_bsssec (abfd);\n \n   /* Text.  */\n-  obj_textsec(abfd)->filepos = pos;\n-  if (!obj_textsec(abfd)->user_set_vma)\n-    obj_textsec(abfd)->vma = vma;\n+  text->filepos = pos;\n+  if (!text->user_set_vma)\n+    text->vma = vma;\n   else\n-    vma = obj_textsec(abfd)->vma;\n-  pos += obj_textsec(abfd)->size;\n-  vma += obj_textsec(abfd)->size;\n+    vma = text->vma;\n+  pos += execp->a_text;\n+  vma += execp->a_text;\n \n   /* Data.  */\n-  obj_datasec(abfd)->filepos = pos;\n-  if (!obj_datasec(abfd)->user_set_vma)\n-    obj_datasec(abfd)->vma = BFD_ALIGN (vma, adata(abfd).segment_size);\n-  vma = obj_datasec(abfd)->vma;\n+  data->filepos = pos;\n+  if (!data->user_set_vma)\n+    data->vma = BFD_ALIGN (vma, adata (abfd).segment_size);\n+  vma = data->vma;\n \n   /* Since BSS follows data immediately, see if it needs alignment.  */\n-  vma += obj_datasec(abfd)->size;\n-  pad = align_power (vma, obj_bsssec(abfd)->alignment_power) - vma;\n-  obj_datasec(abfd)->size += pad;\n-  pos += obj_datasec(abfd)->size;\n+  vma += data->size;\n+  pad = align_power (vma, bss->alignment_power) - vma;\n+  execp->a_data = data->size + pad;\n+  pos += execp->a_data;\n \n   /* BSS.  */\n-  if (!obj_bsssec(abfd)->user_set_vma)\n-    obj_bsssec(abfd)->vma = vma;\n+  if (!bss->user_set_vma)\n+    bss->vma = vma;\n   else\n-    vma = obj_bsssec(abfd)->vma;\n+    vma = bss->vma;\n \n   /* Fix up exec header.  */\n-  execp->a_text = obj_textsec(abfd)->size;\n-  execp->a_data = obj_datasec(abfd)->size;\n-  execp->a_bss = obj_bsssec(abfd)->size;\n+  execp->a_bss = bss->size;\n   N_SET_MAGIC (execp, NMAGIC);\n }\n \n@@ -1002,20 +996,19 @@ NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n   if (! NAME (aout, make_sections) (abfd))\n     return FALSE;\n \n-  if (adata(abfd).magic != undecided_magic)\n+  if (adata (abfd).magic != undecided_magic)\n     return TRUE;\n \n-  obj_textsec(abfd)->size =\n-    align_power(obj_textsec(abfd)->size,\n-\t\tobj_textsec(abfd)->alignment_power);\n+  execp->a_text = align_power (obj_textsec (abfd)->size,\n+\t\t\t       obj_textsec (abfd)->alignment_power);\n \n   /* Rule (heuristic) for when to pad to a new page.  Note that there\n      are (at least) two ways demand-paged (ZMAGIC) files have been\n      handled.  Most Berkeley-based systems start the text segment at\n      (TARGET_PAGE_SIZE).  However, newer versions of SUNOS start the text\n      segment right after the exec header; the latter is counted in the\n      text segment size, and is paged in by the kernel with the rest of\n-     the text. */\n+     the text.  */\n \n   /* This perhaps isn't the right way to do this, but made it simpler for me\n      to understand enough to implement it.  Better would probably be to go\n@@ -1026,32 +1019,33 @@ NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n      minute.  */\n \n   if (abfd->flags & WP_TEXT)\n-    adata(abfd).magic = n_magic;\n+    adata (abfd).magic = n_magic;\n   else\n-    adata(abfd).magic = o_magic;\n+    adata (abfd).magic = o_magic;\n \n #ifdef BFD_AOUT_DEBUG /* requires gcc2 */\n #if __GNUC__ >= 2\n   fprintf (stderr, \"%s text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x,%x>\\n\",\n \t   ({ char *str;\n-\t      switch (adata(abfd).magic) {\n-\t      case n_magic: str = \"NMAGIC\"; break;\n-\t      case o_magic: str = \"OMAGIC\"; break;\n-\t      case z_magic: str = \"ZMAGIC\"; break;\n-\t      default: abort ();\n-\t      }\n+\t      switch (adata (abfd).magic)\n+\t\t{\n+\t\tcase n_magic: str = \"NMAGIC\"; break;\n+\t\tcase o_magic: str = \"OMAGIC\"; break;\n+\t\tcase z_magic: str = \"ZMAGIC\"; break;\n+\t\tdefault: abort ();\n+\t\t}\n \t      str;\n \t    }),\n-\t   obj_textsec(abfd)->vma, obj_textsec(abfd)->size,\n-\t\tobj_textsec(abfd)->alignment_power,\n-\t   obj_datasec(abfd)->vma, obj_datasec(abfd)->size,\n-\t\tobj_datasec(abfd)->alignment_power,\n-\t   obj_bsssec(abfd)->vma, obj_bsssec(abfd)->size,\n-\t\tobj_bsssec(abfd)->alignment_power);\n+\t   obj_textsec (abfd)->vma, obj_textsec (abfd)->size,\n+\t\tobj_textsec (abfd)->alignment_power,\n+\t   obj_datasec (abfd)->vma, obj_datasec (abfd)->size,\n+\t\tobj_datasec (abfd)->alignment_power,\n+\t   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->size,\n+\t\tobj_bsssec (abfd)->alignment_power);\n #endif\n #endif\n \n-  switch (adata(abfd).magic)\n+  switch (adata (abfd).magic)\n     {\n     case o_magic:\n       adjust_o_magic (abfd, execp);\n@@ -1068,11 +1062,11 @@ NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n \n #ifdef BFD_AOUT_DEBUG\n   fprintf (stderr, \"       text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x>\\n\",\n-\t   obj_textsec(abfd)->vma, obj_textsec(abfd)->size,\n-\t\tobj_textsec(abfd)->filepos,\n-\t   obj_datasec(abfd)->vma, obj_datasec(abfd)->size,\n-\t\tobj_datasec(abfd)->filepos,\n-\t   obj_bsssec(abfd)->vma, obj_bsssec(abfd)->size);\n+\t   obj_textsec (abfd)->vma, execp->a_text,\n+\t\tobj_textsec (abfd)->filepos,\n+\t   obj_datasec (abfd)->vma, execp->a_data,\n+\t\tobj_datasec (abfd)->filepos,\n+\t   obj_bsssec (abfd)->vma, execp->a_bss);\n #endif\n \n   return TRUE;\n@@ -3914,16 +3908,28 @@ NAME (aout, final_link) (bfd *abfd,\n   else if (obj_textsec (abfd)->reloc_count == 0\n \t   && obj_datasec (abfd)->reloc_count == 0)\n     {\n-      bfd_byte b;\n-\n-      b = 0;\n-      if (bfd_seek (abfd,\n-\t\t    (file_ptr) (obj_datasec (abfd)->filepos\n-\t\t\t\t+ exec_hdr (abfd)->a_data\n-\t\t\t\t- 1),\n-\t\t    SEEK_SET) != 0\n-\t  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)\n-\tgoto error_return;\n+      /* The layout of a typical a.out file is header, text, data,\n+\t relocs, symbols, string table.  When there are no relocs,\n+\t symbols or string table, the last thing in the file is data\n+\t and a_data may be rounded up.  However we may have a smaller\n+\t sized .data section and thus not written final padding.  The\n+\t same thing can happen with text if there is no data.  Write\n+\t final padding here to extend the file.  */\n+      file_ptr pos = 0;\n+\n+      if (exec_hdr (abfd)->a_data > obj_datasec (abfd)->size)\n+\tpos = obj_datasec (abfd)->filepos + exec_hdr (abfd)->a_data;\n+      else if (obj_datasec (abfd)->size == 0\n+\t       && exec_hdr (abfd)->a_text > obj_textsec (abfd)->size)\n+\tpos = obj_textsec (abfd)->filepos + exec_hdr (abfd)->a_text;\n+      if (pos != 0)\n+\t{\n+\t  bfd_byte b = 0;\n+\n+\t  if (bfd_seek (abfd, pos - 1, SEEK_SET) != 0\n+\t      || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)\n+\t    goto error_return;\n+\t}\n     }\n \n   return TRUE;"
    },
    {
      "sha": "4bc78e9bfc298d8eca462190706c97c766dd029b",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda2980f54a0c9437de047f3020f520dd1e0de6a/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda2980f54a0c9437de047f3020f520dd1e0de6a/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=dda2980f54a0c9437de047f3020f520dd1e0de6a",
      "patch": "@@ -1,3 +1,10 @@\n+2020-02-21  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25569\n+\t* config/obj-aout.c (obj_aout_frob_file_before_fix): Don't loop\n+\ton section size adjustment, instead perform another write if\n+\texec header size is larger than section size.\n+\n 2020-02-19  Nelson Chu  <nelson.chu@sifive.com>\n \n \t* doc/c-riscv.texi: Add the doc entries for -march-attr/"
    },
    {
      "sha": "aee7c8180a28ad4de8dc997341f953261767c166",
      "filename": "gas/config/obj-aout.c",
      "status": "modified",
      "additions": 28,
      "deletions": 20,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda2980f54a0c9437de047f3020f520dd1e0de6a/gas/config/obj-aout.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda2980f54a0c9437de047f3020f520dd1e0de6a/gas/config/obj-aout.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-aout.c?ref=dda2980f54a0c9437de047f3020f520dd1e0de6a",
      "patch": "@@ -113,31 +113,39 @@ obj_aout_frob_symbol (symbolS *sym, int *punt ATTRIBUTE_UNUSED)\n \t    S_GET_NAME (sym));\n }\n \n+/* Relocation processing may require knowing the VMAs of the sections.\n+   Writing to a section will cause the BFD back end to compute the\n+   VMAs.  This function also ensures that file size is large enough\n+   to cover a_text and a_data should text or data be the last section\n+   in the file.  */\n+\n void\n obj_aout_frob_file_before_fix (void)\n {\n-  /* Relocation processing may require knowing the VMAs of the sections.\n-     Since writing to a section will cause the BFD back end to compute the\n-     VMAs, fake it out here....\n-     Writing to the end of the section ensures the file contents\n-     extend to cover the entire aligned size.  We possibly won't know\n-     the aligned size until after VMAs and sizes are set on the first\n-     bfd_set_section_contents call, so it might be necessary to repeat.  */\n-  asection *sec = NULL;\n-  if (data_section->size != 0)\n-    sec = data_section;\n-  else if (text_section->size != 0)\n-    sec = text_section;\n-  if (sec)\n+  asection *sec;\n+  bfd_vma *sizep = NULL;\n+  if ((sec = data_section)->size != 0)\n+    sizep = &exec_hdr (stdoutput)->a_data;\n+  else if ((sec = text_section)->size != 0)\n+    sizep = &exec_hdr (stdoutput)->a_text;\n+  if (sizep)\n     {\n-      bfd_size_type size;\n-      do\n+      bfd_size_type size = sec->size;\n+      bfd_byte b = 0;\n+\n+      gas_assert (bfd_set_section_contents (stdoutput, sec, &b, size - 1, 1));\n+\n+      /* We don't know the aligned size until after VMAs and sizes are\n+\t set on the bfd_set_section_contents call.  If that size is\n+\t larger than the section then write again to ensure the file\n+\t contents extend to cover the aligned size.  */\n+      if (*sizep > size)\n \t{\n-\t  bfd_byte b = 0;\n-\t  size = sec->size;\n-\t  gas_assert (bfd_set_section_contents (stdoutput, sec, &b,\n-\t\t\t\t\t\tsize - 1, (bfd_size_type) 1));\n-\t} while (size != sec->size);\n+\t  file_ptr pos = sec->filepos + *sizep;\n+\n+\t  gas_assert (bfd_seek (stdoutput, pos - 1, SEEK_SET) == 0\n+\t\t      && bfd_bwrite (&b, 1, stdoutput) == 1);\n+\t}\n     }\n }\n "
    }
  ]
}