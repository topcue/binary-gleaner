{
  "sha": "1940319c0ef6271cc42a5d4c359be90063948710",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTk0MDMxOWMwZWY2MjcxY2M0MmE1ZDRjMzU5YmU5MDA2Mzk0ODcxMA==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-01-08T10:11:16Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-01-08T10:11:16Z"
    },
    "message": "[gdb] Fix internal-error in process_event_stop_test\n\nThe function create_exception_master_breakpoint in gdb/breakpoint.c attempts\nto set a master exception breakpoint in each objfile.  It tries this using\na libgcc/unwind probe, and if that fails then using the\n_Unwind_DebugHook symbol:\n...\n   for (objfile *objfile : current_program_space->objfiles ())\n     {\n        /* Try using probes.  */\n        if (/* successful */)\n          continue;\n\n        /* Try using _Unwind_DebugHook */\n     }\n...\n\nThe preference scheme works ok both if the objfile has debug info, and if it's\nstripped.\n\nBut it doesn't work when the objfile has a .gnu_debuglink to a .debug file\n(and the .debug file is present).  What happens is that:\n- we first encounter objfile libgcc.debug\n- we try using probes, and this fails\n- so we try _Unwind_DebugHook, which succeeds\n- next we encounter objfile libgcc\n- we try using probes, and this succeeds.\nSo, we end up with a master exception breakpoint in both libgcc (using probes)\nand libgcc.debug (using _Unwind_DebugHook).\n\nThis eventually causes:\n...\n(gdb) PASS: gdb.cp/nextoverthrow.exp: post-check - next over a throw 3\nnext^M\nsrc/gdb/infrun.c:6384: internal-error: \\\n  void process_event_stop_test(execution_control_state*): \\\n  Assertion `ecs->event_thread->control.exception_resume_breakpoint != NULL' \\\n  failed.^M\nA problem internal to GDB has been detected,^M\nfurther debugging may prove unreliable.^M\nQuit this debugging session? (y or n) FAIL: gdb.cp/nextoverthrow.exp: next\npast catch (GDB internal error)\n...\n\nTo trigger this internal-error, we need to use gcc-10 or later to compile the\ntest-case, such that it contains the fix for gcc PR97774 - \"Incorrect line\ninfo for try/catch\".\n\nFix this by only trying to install the master exception breakpoint in\nlibgcc.debug using the _Unwind_DebugHook method, if the install using probes\nin libgcc failed.\n\nTested on x86_64-linux.\n\ngdb/ChangeLog:\n\n2021-01-08  Tom de Vries  <tdevries@suse.de>\n\n\tPR gdb/26881\n\t* breakpoint.c (create_exception_master_breakpoint_probe)\n\t(create_exception_master_breakpoint_hook): Factor out\n\tof ...\n\t(create_exception_master_breakpoint): ... here.  Only try to install\n\tthe master exception breakpoint in objfile.debug using the\n\t_Unwind_DebugHook method, if the install using probes in objfile\n\tfailed.",
    "tree": {
      "sha": "318ea63963a6b6cb6b6726487e9e4fc31150c637",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/318ea63963a6b6cb6b6726487e9e4fc31150c637"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1940319c0ef6271cc42a5d4c359be90063948710",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1940319c0ef6271cc42a5d4c359be90063948710",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1940319c0ef6271cc42a5d4c359be90063948710",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1940319c0ef6271cc42a5d4c359be90063948710/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e343681375c1e5a27ea92486649f6a58163c0e61",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e343681375c1e5a27ea92486649f6a58163c0e61",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e343681375c1e5a27ea92486649f6a58163c0e61"
    }
  ],
  "stats": {
    "total": 175,
    "additions": 110,
    "deletions": 65
  },
  "files": [
    {
      "sha": "32ece3020a27507e4aac8c4712b4b62f5c7c7f46",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1940319c0ef6271cc42a5d4c359be90063948710/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1940319c0ef6271cc42a5d4c359be90063948710/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1940319c0ef6271cc42a5d4c359be90063948710",
      "patch": "@@ -1,3 +1,14 @@\n+2021-01-08  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR gdb/26881\n+\t* breakpoint.c (create_exception_master_breakpoint_probe)\n+\t(create_exception_master_breakpoint_hook): Factor out\n+\tof ...\n+\t(create_exception_master_breakpoint): ... here.  Only try to install\n+\tthe master exception breakpoint in objfile.debug using the\n+\t_Unwind_DebugHook method, if the install using probes in objfile\n+\tfailed.\n+\n 2021-01-08  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-lang.c (fortran_value_subarray): Call value_from_component."
    },
    {
      "sha": "70a4d0e1690749ab0bde071f5828285beae15be7",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 99,
      "deletions": 65,
      "changes": 164,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1940319c0ef6271cc42a5d4c359be90063948710/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1940319c0ef6271cc42a5d4c359be90063948710/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=1940319c0ef6271cc42a5d4c359be90063948710",
      "patch": "@@ -3477,92 +3477,126 @@ create_std_terminate_master_breakpoint (void)\n     }\n }\n \n-/* Install a master breakpoint on the unwinder's debug hook.  */\n+/* Install a master breakpoint on the unwinder's debug hook for OBJFILE using a\n+   probe.  Return true if a breakpoint was installed.  */\n \n-static void\n-create_exception_master_breakpoint (void)\n+static bool\n+create_exception_master_breakpoint_probe (objfile *objfile)\n {\n-  const char *const func_name = \"_Unwind_DebugHook\";\n+  struct breakpoint *b;\n+  struct gdbarch *gdbarch;\n+  struct breakpoint_objfile_data *bp_objfile_data;\n \n-  for (objfile *objfile : current_program_space->objfiles ())\n-    {\n-      struct breakpoint *b;\n-      struct gdbarch *gdbarch;\n-      struct breakpoint_objfile_data *bp_objfile_data;\n-      CORE_ADDR addr;\n-      struct explicit_location explicit_loc;\n+  bp_objfile_data = get_breakpoint_objfile_data (objfile);\n \n-      bp_objfile_data = get_breakpoint_objfile_data (objfile);\n+  /* We prefer the SystemTap probe point if it exists.  */\n+  if (!bp_objfile_data->exception_searched)\n+    {\n+      std::vector<probe *> ret\n+\t= find_probes_in_objfile (objfile, \"libgcc\", \"unwind\");\n \n-      /* We prefer the SystemTap probe point if it exists.  */\n-      if (!bp_objfile_data->exception_searched)\n+      if (!ret.empty ())\n \t{\n-\t  std::vector<probe *> ret\n-\t    = find_probes_in_objfile (objfile, \"libgcc\", \"unwind\");\n+\t  /* We are only interested in checking one element.  */\n+\t  probe *p = ret[0];\n \n-\t  if (!ret.empty ())\n+\t  if (!p->can_evaluate_arguments ())\n \t    {\n-\t      /* We are only interested in checking one element.  */\n-\t      probe *p = ret[0];\n-\n-\t      if (!p->can_evaluate_arguments ())\n-\t\t{\n-\t\t  /* We cannot use the probe interface here, because it does\n-\t\t     not know how to evaluate arguments.  */\n-\t\t  ret.clear ();\n-\t\t}\n+\t      /* We cannot use the probe interface here, because it does\n+\t\t not know how to evaluate arguments.  */\n+\t      ret.clear ();\n \t    }\n-\t  bp_objfile_data->exception_probes = ret;\n-\t  bp_objfile_data->exception_searched = 1;\n \t}\n+      bp_objfile_data->exception_probes = ret;\n+      bp_objfile_data->exception_searched = 1;\n+    }\n \n-      if (!bp_objfile_data->exception_probes.empty ())\n-\t{\n-\t  gdbarch = objfile->arch ();\n+  if (bp_objfile_data->exception_probes.empty ())\n+    return false;\n \n-\t  for (probe *p : bp_objfile_data->exception_probes)\n-\t    {\n-\t      b = create_internal_breakpoint (gdbarch,\n-\t\t\t\t\t      p->get_relocated_address (objfile),\n-\t\t\t\t\t      bp_exception_master,\n-\t\t\t\t\t      &internal_breakpoint_ops);\n-\t      b->location = new_probe_location (\"-probe-stap libgcc:unwind\");\n-\t      b->enable_state = bp_disabled;\n-\t    }\n+  gdbarch = objfile->arch ();\n \n-\t  continue;\n-\t}\n+  for (probe *p : bp_objfile_data->exception_probes)\n+    {\n+      b = create_internal_breakpoint (gdbarch,\n+\t\t\t\t      p->get_relocated_address (objfile),\n+\t\t\t\t      bp_exception_master,\n+\t\t\t\t      &internal_breakpoint_ops);\n+      b->location = new_probe_location (\"-probe-stap libgcc:unwind\");\n+      b->enable_state = bp_disabled;\n+    }\n \n-      /* Otherwise, try the hook function.  */\n+  return true;\n+}\n \n-      if (msym_not_found_p (bp_objfile_data->exception_msym.minsym))\n-\tcontinue;\n+/* Install a master breakpoint on the unwinder's debug hook for OBJFILE using\n+   _Unwind_DebugHook.  Return true if a breakpoint was installed.  */\n+\n+static bool\n+create_exception_master_breakpoint_hook (objfile *objfile)\n+{\n+  const char *const func_name = \"_Unwind_DebugHook\";\n+  struct breakpoint *b;\n+  struct gdbarch *gdbarch;\n+  struct breakpoint_objfile_data *bp_objfile_data;\n+  CORE_ADDR addr;\n+  struct explicit_location explicit_loc;\n \n-      gdbarch = objfile->arch ();\n+  bp_objfile_data = get_breakpoint_objfile_data (objfile);\n \n-      if (bp_objfile_data->exception_msym.minsym == NULL)\n-\t{\n-\t  struct bound_minimal_symbol debug_hook;\n+  if (msym_not_found_p (bp_objfile_data->exception_msym.minsym))\n+    return false;\n \n-\t  debug_hook = lookup_minimal_symbol (func_name, NULL, objfile);\n-\t  if (debug_hook.minsym == NULL)\n-\t    {\n-\t      bp_objfile_data->exception_msym.minsym = &msym_not_found;\n-\t      continue;\n-\t    }\n+  gdbarch = objfile->arch ();\n+\n+  if (bp_objfile_data->exception_msym.minsym == NULL)\n+    {\n+      struct bound_minimal_symbol debug_hook;\n \n-\t  bp_objfile_data->exception_msym = debug_hook;\n+      debug_hook = lookup_minimal_symbol (func_name, NULL, objfile);\n+      if (debug_hook.minsym == NULL)\n+\t{\n+\t  bp_objfile_data->exception_msym.minsym = &msym_not_found;\n+\t  return false;\n \t}\n \n-      addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->exception_msym);\n-      addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,\n-\t\t\t\t\t\t current_top_target ());\n-      b = create_internal_breakpoint (gdbarch, addr, bp_exception_master,\n-\t\t\t\t      &internal_breakpoint_ops);\n-      initialize_explicit_location (&explicit_loc);\n-      explicit_loc.function_name = ASTRDUP (func_name);\n-      b->location = new_explicit_location (&explicit_loc);\n-      b->enable_state = bp_disabled;\n+      bp_objfile_data->exception_msym = debug_hook;\n+    }\n+\n+  addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->exception_msym);\n+  addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,\n+\t\t\t\t\t     current_top_target ());\n+  b = create_internal_breakpoint (gdbarch, addr, bp_exception_master,\n+\t\t\t\t  &internal_breakpoint_ops);\n+  initialize_explicit_location (&explicit_loc);\n+  explicit_loc.function_name = ASTRDUP (func_name);\n+  b->location = new_explicit_location (&explicit_loc);\n+  b->enable_state = bp_disabled;\n+\n+  return true;\n+}\n+\n+/* Install a master breakpoint on the unwinder's debug hook.  */\n+\n+static void\n+create_exception_master_breakpoint (void)\n+{\n+  for (objfile *obj : current_program_space->objfiles ())\n+    {\n+      /* Skip separate debug object.  */\n+      if (obj->separate_debug_objfile_backlink)\n+\tcontinue;\n+\n+      /* Try a probe kind breakpoint.  */\n+      if (create_exception_master_breakpoint_probe (obj))\n+\tcontinue;\n+\n+      /* Iterate over separate debug objects and try an _Unwind_DebugHook\n+\t kind breakpoint.  */\n+      for (objfile *sepdebug = obj->separate_debug_objfile;\n+\t   sepdebug != nullptr; sepdebug = sepdebug->separate_debug_objfile)\n+\tif (create_exception_master_breakpoint_hook (sepdebug))\n+\t  break;\n     }\n }\n "
    }
  ]
}