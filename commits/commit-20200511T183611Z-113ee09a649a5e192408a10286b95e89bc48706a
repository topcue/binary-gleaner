{
  "sha": "113ee09a649a5e192408a10286b95e89bc48706a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTEzZWUwOWE2NDlhNWUxOTI0MDhhMTAyODZiOTVlODliYzQ4NzA2YQ==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2020-05-11T18:36:11Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2020-05-11T18:36:11Z"
    },
    "message": "[gdb/testsuite] Fix gdb.cp/cpexprs-debug-types.exp inclusion\n\nWhen running tests using RUNTESTFLAGS=\"cpexprs.exp cpexprs-debug-types.exp\",\nwe have:\n...\nRunning src/gdb/testsuite/gdb.cp/cpexprs-debug-types.exp ...\nRunning src/gdb/testsuite/gdb.cp/cpexprs.exp ...\n...\n\nIn the first test-case, we have -fdebug-types-section as expected:\n...\nRunning src/gdb/testsuite/gdb.cp/cpexprs-debug-types.exp ...\ng++ -fno-stack-protector -fdiagnostics-color=never \\\n  -fdebug-types-section \\\n  -c -g \\\n  -o outputs/gdb.cp/cpexprs-debug-types/cpexprs-debug-types0.o \\\n  src/gdb/testsuite/gdb.cp/cpexprs.cc\n...\nbut in the second test-case, we have also have -fdebug-types-section:\n...\nRunning src/gdb/testsuite/gdb.cp/cpexprs.exp ...\ng++ -fno-stack-protector -fdiagnostics-color=never \\\n  -fdebug-types-section \\\n  -c -g -g \\\n  -o outputs/gdb.cp/cpexprs/cpexprs0.o \\\n  src/gdb/testsuite/gdb.cp/cpexprs.cc\n...\n\nThis is due to using a global variable flags, which is set in\ncpexprs-debug-types.exp and tested for existence in cpexprs.exp.\n\nFix this by using a more robust inclusion mechanism, that is:\n- move the bulk of the test-case cpexprs.exp to cpexprs.exp.in,\n- include it from cpexprs.exp and cpexprs-debug-types.exp, and\n- set flags in both .exp files\n\ngdb/testsuite/ChangeLog:\n\n2020-05-11  Tom de Vries  <tdevries@suse.de>\n\n\t* gdb.cp/cpexprs.exp: Move everything except flags setting ...\n\t* gdb.cp/cpexprs.exp.in: .. here.\n\t* gdb.cp/cpexprs-debug-types.exp: Include cpexprs.exp.in instead of\n\tcpexprs.exp.",
    "tree": {
      "sha": "0fbb3dceb90203f63cf4ecdaf17f808770c29fb9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0fbb3dceb90203f63cf4ecdaf17f808770c29fb9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/113ee09a649a5e192408a10286b95e89bc48706a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/113ee09a649a5e192408a10286b95e89bc48706a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/113ee09a649a5e192408a10286b95e89bc48706a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/113ee09a649a5e192408a10286b95e89bc48706a/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ba3e70b008d63b13207339443ad3b9a61ab996bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ba3e70b008d63b13207339443ad3b9a61ab996bc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ba3e70b008d63b13207339443ad3b9a61ab996bc"
    }
  ],
  "stats": {
    "total": 1520,
    "additions": 772,
    "deletions": 748
  },
  "files": [
    {
      "sha": "2a0d84d814644be3f5641f3e0058a76b1efdd4f0",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=113ee09a649a5e192408a10286b95e89bc48706a",
      "patch": "@@ -1,3 +1,10 @@\n+2020-05-11  Tom de Vries  <tdevries@suse.de>\n+\n+\t* gdb.cp/cpexprs.exp: Move everything except flags setting ...\n+\t* gdb.cp/cpexprs.exp.in: .. here.\n+\t* gdb.cp/cpexprs-debug-types.exp: Include cpexprs.exp.in instead of\n+\tcpexprs.exp.\n+\n 2020-05-11  Keith Seitz  <keiths@redhat.com>\n \n \t* gdb.ada/arrayparam.exp: Resolve duplicate and tail parentheses"
    },
    {
      "sha": "b93f2e8c1572ff2d742ae66d6c783d182a3b682c",
      "filename": "gdb/testsuite/gdb.cp/cpexprs-debug-types.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/gdb.cp/cpexprs-debug-types.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/gdb.cp/cpexprs-debug-types.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/cpexprs-debug-types.exp?ref=113ee09a649a5e192408a10286b95e89bc48706a",
      "patch": "@@ -17,4 +17,4 @@\n \n # Run cpexprs.exp with -fdebug-types-section.\n set flags {additional_flags=-fdebug-types-section}\n-source $srcdir/$subdir/cpexprs.exp\n+source $srcdir/$subdir/cpexprs.exp.in"
    },
    {
      "sha": "b16a5ea6e38417738b9b2f3d6f0adc0616c38d84",
      "filename": "gdb/testsuite/gdb.cp/cpexprs.exp",
      "status": "modified",
      "additions": 3,
      "deletions": 747,
      "changes": 750,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/gdb.cp/cpexprs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/gdb.cp/cpexprs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/cpexprs.exp?ref=113ee09a649a5e192408a10286b95e89bc48706a",
      "patch": "@@ -19,750 +19,6 @@\n \n # This file is part of the gdb testsuite.\n \n-# A helper proc which sets a breakpoint at FUNC and attempts to\n-# run to the breakpoint.\n-proc test_breakpoint {func} {\n-    global DEC\n-\n-    # Return to the top of the test function every time.\n-    delete_breakpoints\n-    if { ! [gdb_breakpoint test_function] } {\n-\tfail \"set test_function breakpoint for $func\"\n-    } elseif { [gdb_test \"continue\" \\\n-\t\t    \"Continuing.\\r\\n\\r\\nBreakpoint $DEC+,.*test_function.*\" \\\n-\t\t    \"\"] != 0 } {\n-\tfail \"continue to test_function for $func\"\n-    } else {\n-\tgdb_breakpoint \"$func\"\n-\tset i [expr {[string last : $func] + 1}]\n-\tset efunc [string_to_regexp [string range $func $i end]]\n-\tgdb_test \"continue\" \\\n-\t    \"Continuing.\\r\\n\\r\\nBreakpoint $DEC+,.*$efunc.*\" \\\n-\t    \"continue to $func\"\n-    }\n-}\n-\n-# Add a function to the list of tested functions\n-# FUNC is the name of the function (which will be passed to gdb commands)\n-# TYPE is the type of the function, as expected from the \"print\" command\n-# PRINT is the name of the function, as expected result of the print command\n-#  *OR* \"-\", indicating that FUNC should be used (needed for virtual/inherited\n-#   funcs)\n-# LST is either the expected result of the list command (the comment from\n-#  the source code) *OR* \"-\", in which case FUNC will be used\n-#\n-# Usage:\n-# add NAME TYPE PRINT LST\n-# add NAME TYPE PRINT -\n-proc add_type_regexp {func type print lst} {\n-    global all_functions CONVAR ADDR\n-\n-    set all_functions($func,type) $type\n-    if {$print == \"-\"} {\n-\tset print $func\n-    }\n-\n-    # An exception: since gdb canonicalizes C++ output,\n-    # \"(void)\" must be mutated to \"()\".\n-    regsub {\\(void\\)} $print {()} print\n-\n-    set all_functions($func,print) \\\n-\t\"$CONVAR = {$type} $ADDR <[string_to_regexp $print].*>\"\n-    if {$lst == \"-\"} {\n-\tset lst \"$func\"\n-    }\n-    set all_functions($func,list) \".*// [string_to_regexp $lst]\"\n-}\n-\n-proc add {func type print lst} {\n-    add_type_regexp $func [string_to_regexp $type] $print $lst\n-}\n-\n-proc get {func cmd} {\n-    global all_functions\n-    return $all_functions($func,$cmd)\n-}\n-\n-# Returns a list of function names for a given command\n-proc get_functions {cmd} {\n-    global all_functions\n-    set result {}\n-    foreach i [array names all_functions *,$cmd] {\n-\tif {$all_functions($i) != \"\"} {\n-\t    set idx [string last , $i]\n-\t    if {$idx != -1} {\n-\t\tlappend result [string range $i 0 [expr {$idx - 1}]]\n-\t    }\n-\t}\n-    }\n-\n-    return [lsort $result]\n-}\n-\n-# Some convenience variables for this test\n-set DEC {[0-9]}; # a decimal number\n-set HEX {[0-9a-fA-F]}; # a hexidecimal number\n-set CONVAR \"\\\\\\$$DEC+\"; # convenience variable regexp\n-set ADDR \"0x$HEX+\"; # address\n-\n-# An array of functions/methods that we are testing...\n-# Each element consists is indexed by NAME,COMMAND, where\n-# NAME is the function name and COMMAND is the gdb command that\n-# we are testing. The value of the array for any index pair is\n-# the expected result of running COMMAND with the NAME as argument.\n-\n-# The array holding all functions/methods to test. Valid subindexes\n-# are (none need character escaping -- \"add\" will take care of that):\n-\n-# add name type print_name list\n-# NAME,type: value is type of function \n-# NAME,print: value is print name of function (careful w/inherited/virtual!)\n-# NAME,list: value is comment in source code on first line of function\n-#   (without the leading \"//\")\n-array set all_functions {}\n-\n-# \"Normal\" functions/methods\n-add {test_function} \\\n-    {int (int, char **)} \\\n-    - \\\n-    -\n-add {derived::a_function} \\\n-    {void (const derived * const)} \\\n-    - \\\n-    -\n-add {base1::a_function} \\\n-    {void (const base1 * const)} \\\n-    - \\\n-    -\n-add {base2::a_function} \\\n-    {void (const base2 * const)} \\\n-    - \\\n-    -\n-\n-# Constructors\n-\n-# On targets using the ARM EABI, the constructor is expected to return\n-# \"this\".\n-proc ctor_ret { type } {\n-    if { [istarget arm*-*eabi*] || [is_aarch32_target] } {\n-\treturn \"$type *\"\n-    } else {\n-\treturn \"void \"\n-    }\n-}\n-\n-proc ctor_prefix { type } {\n-    set ret [ctor_ret $type]\n-    return \"${ret}($type * const\"\n-}\n-\n-proc ctor { type arglist } {\n-    if { $arglist != \"\" } {\n-\tset arglist \", $arglist\"\n-    }\n-    return \"[ctor_prefix $type]$arglist)\"\n-}\n-\n-add {derived::derived} \\\n-    [ctor derived \"\"] \\\n-    - \\\n-    -\n-add_type_regexp {base1::base1(void)} \\\n-    \"[string_to_regexp [ctor_prefix base1]], (const )?void \\\\*\\\\*( const)?\\\\)\" \\\n-    - \\\n-    -\n-add {base1::base1(int)} \\\n-    [ctor base1 \"int\"] \\\n-    - \\\n-    -\n-add_type_regexp {base2::base2} \\\n-    \"[string_to_regexp [ctor_prefix base2]], (const )?void \\\\*\\\\*( const)?\\\\)\" \\\n-    - \\\n-    -\n-add {base::base(void)} \\\n-    [ctor base \"\"] \\\n-    - \\\n-    -\n-add {base::base(int)} \\\n-    [ctor base \"int\"] \\\n-    - \\\n-    -\n-\n-# Destructors\n-\n-# On targets using the ARM EABI, some destructors are expected\n-# to return \"this\".  Others are void.  For internal reasons,\n-# GCC returns void * instead of $type *; RealView appears to do\n-# the same.\n-proc dtor { type } {\n-    if { [istarget arm*-*eabi*] || [is_aarch32_target] } {\n-\tset ret \"void *\"\n-    } else {\n-\tset ret \"void \"\n-    }\n-    return \"${ret}($type * const)\"\n-}\n-\n-add {base::~base} \\\n-    [dtor base] \\\n-    - \\\n-    -\n-\n-# Overloaded methods (all are const)\n-add {base::overload(void) const} \\\n-    {int (const base * const)} \\\n-    - \\\n-    {base::overload(void) const}\n-add {base::overload(int) const} \\\n-    {int (const base * const, int)} \\\n-    - \\\n-    -\n-add {base::overload(short) const} \\\n-    {int (const base * const, short)} \\\n-    - \\\n-    -\n-add {base::overload(long) const} \\\n-    {int (const base * const, long)} \\\n-    - \\\n-    -\n-add {base::overload(char*) const} \\\n-    {int (const base * const, char *)} \\\n-    - \\\n-    -\n-add {base::overload(base&) const} \\\n-    {int (const base * const, base &)} \\\n-    - \\\n-    -\n-\n-# Operators\n-add {base::operator+} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator++} \\\n-    {base (base * const)} \\\n-    - \\\n-    -\n-add {base::operator+=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator-} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator--} \\\n-    {base (base * const)} \\\n-    - \\\n-    -\n-add {base::operator-=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator*} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator*=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator/} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator/=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator%} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator%=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator<} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator<=} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator>} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator>=} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator!=} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator==} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator!} \\\n-    {bool (const base * const)} \\\n-    - \\\n-    -\n-add {base::operator&&} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator||} \\\n-    {bool (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator<<} \\\n-    {int (const base * const, int)} \\\n-    - \\\n-    -\n-add {base::operator<<=} \\\n-    {base (base * const, int)} \\\n-    - \\\n-    -\n-add {base::operator>>} \\\n-    {int (const base * const, int)} \\\n-    - \\\n-    -\n-add {base::operator>>=} \\\n-    {base (base * const, int)} \\\n-    - \\\n-    -\n-add {base::operator~} \\\n-    {int (const base * const)} \\\n-    - \\\n-    -\n-add {base::operator&} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator&=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator|} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator|=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator^} \\\n-    {int (const base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator^=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator=} \\\n-    {base (base * const, const base &)} \\\n-    - \\\n-    -\n-add {base::operator()} \\\n-    {void (const base * const)} \\\n-    - \\\n-    -\n-add {base::operator[]} \\\n-    {int (const base * const, int)} \\\n-    - \\\n-    -\n-add {base::operator new} \\\n-    {void *(size_t)} \\\n-    - \\\n-    -\n-add {base::operator delete} \\\n-    {void (void *)} \\\n-    - \\\n-    -\n-add {base::operator new[]} \\\n-    {void *(size_t)} \\\n-    - \\\n-    -\n-add {base::operator delete[]} \\\n-    {void (void *)} \\\n-    - \\\n-    -\n-add {base::operator char*} \\\n-    {char *(const base * const)} \\\n-    - \\\n-    -\n-add {base::operator fluff*} \\\n-    {fluff *(const base * const)} \\\n-    - \\\n-    -\n-add {base::operator fluff**} \\\n-    {fluff **(const base * const)} \\\n-    - \\\n-    -\n-add {base::operator int} \\\n-    {int (const base * const)} \\\n-    - \\\n-    -\n-add {base::operator fluff const* const*} \\\n-    {const fluff * const *(const base * const)} \\\n-    - \\\n-    -\n-\n-# Templates\n-add {tclass<char>::do_something} \\\n-    {void (tclass<char> * const)} \\\n-    - \\\n-    -\n-add {tclass<int>::do_something} \\\n-    {void (tclass<int> * const)} \\\n-    - \\\n-    -\n-add {tclass<long>::do_something} \\\n-    {void (tclass<long> * const)} \\\n-    - \\\n-    -\n-add {tclass<short>::do_something} \\\n-    {void (tclass<short> * const)} \\\n-    - \\\n-    -\n-add {tclass<base>::do_something} \\\n-    {void (tclass<base> * const)} \\\n-    - \\\n-    -\n-add {flubber<int, int, int, int, int>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, int, short>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, int, long>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, int, char>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, short, int>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, short, short>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, short, long>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, short, char>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, long, int>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, long, short>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, long, long>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, long, char>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, char, int>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, char, short>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, char, long>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, int, char, char>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, short, int, int>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, short, int, short>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, short, int, long>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, short, int, char>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<int, int, short, short, int>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<short, int, short, int, short>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {flubber<long, short, long, short, long>} \\\n-    {void (void)} \\\n-    - \\\n-    flubber\n-add {tclass<base>::do_something} \\\n-    {void (tclass<base> * const)} \\\n-    - \\\n-    {tclass<T>::do_something}\n-add {policy1::policy} \\\n-    [ctor \"policy<int, operation_1<void*> >\" \"int\"] \\\n-    {policy<int, operation_1<void*> >::policy} \\\n-    {policy<T, Policy>::policy}\n-add {policy2::policy} \\\n-    [ctor \"policy<int, operation_2<void*> >\" int] \\\n-    {policy<int, operation_2<void*> >::policy} \\\n-    {policy<T, Policy>::policy}\n-add {policy3::policy} \\\n-    [ctor \"policy<int, operation_3<void*> >\" \"int\"] \\\n-    {policy<int, operation_3<void*> >::policy} \\\n-    {policy<T, Policy>::policy}\n-add {policy4::policy} \\\n-    [ctor \"policy<int, operation_4<void*> >\" \"int\"] \\\n-    {policy<int, operation_4<void*> >::policy} \\\n-    {policy<T, Policy>::policy}\n-add {policy1::function} \\\n-    {void (void)} \\\n-    {operation_1<void*>::function} \\\n-    {operation_1<T>::function}\n-add {policy2::function} \\\n-    {void (void)} \\\n-    {operation_2<void*>::function} \\\n-    {operation_2<T>::function}\n-add {policy3::function} \\\n-    {void (void)} \\\n-    {operation_3<void*>::function} \\\n-    {operation_3<T>::function}\n-add {policy4::function} \\\n-    {void (void)} \\\n-    {operation_4<void*>::function} \\\n-    {operation_4<T>::function}\n-add {policyd<int, operation_1<int> >::policyd} \\\n-    [ctor \"policyd<int, operation_1<int> >\" \"int\"] \\\n-    - \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd1::policyd} \\\n-    [ctor \"policyd<int, operation_1<int> >\" \"int\"] \\\n-    {policyd<int, operation_1<int> >::policyd} \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd<int, operation_1<int> >::~policyd} \\\n-    [dtor \"policyd<int, operation_1<int> >\"] \\\n-    - \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd1::~policyd} \\\n-    [dtor \"policyd<int, operation_1<int> >\"] \\\n-    {policyd<int, operation_1<int> >::~policyd} \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd<long, operation_1<long> >::policyd} \\\n-    [ctor \"policyd<long, operation_1<long> >\" \"long\"] \\\n-    - \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd2::policyd} \\\n-    [ctor \"policyd<long, operation_1<long> >\" \"long\"] \\\n-    {policyd<long, operation_1<long> >::policyd} \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd<long, operation_1<long> >::~policyd} \\\n-    [dtor \"policyd<long, operation_1<long> >\"] \\\n-    - \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd2::~policyd} \\\n-    [dtor \"policyd<long, operation_1<long> >\"] \\\n-    {policyd<long, operation_1<long> >::~policyd} \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd<char, operation_1<char> >::policyd} \\\n-    [ctor \"policyd<char, operation_1<char> >\" \"char\"] \\\n-    - \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd3::policyd} \\\n-    [ctor \"policyd<char, operation_1<char> >\" \"char\"] \\\n-    {policyd<char, operation_1<char> >::policyd} \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd<char, operation_1<char> >::~policyd} \\\n-    [dtor \"policyd<char, operation_1<char> >\"] \\\n-    - \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd3::~policyd} \\\n-    [dtor \"policyd<char, operation_1<char> >\"] \\\n-    {policyd<char, operation_1<char> >::~policyd} \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd<base, operation_1<base> >::policyd} \\\n-    [ctor \"policyd<base, operation_1<base> >\" \"base\"] \\\n-    - \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd4::policyd} \\\n-    [ctor \"policyd<base, operation_1<base> >\" \"base\"] \\\n-    {policyd<base, operation_1<base> >::policyd} \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd<base, operation_1<base> >::~policyd} \\\n-    [dtor \"policyd<base, operation_1<base> >\"] \\\n-    - \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd4::~policyd} \\\n-    [dtor \"policyd<base, operation_1<base> >\"] \\\n-    {policyd<base, operation_1<base> >::~policyd} \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd<tclass<int>, operation_1<tclass<int> > >::policyd} \\\n-    [ctor \"policyd<tclass<int>, operation_1<tclass<int> > >\" \"tclass<int>\"] \\\n-    - \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd5::policyd} \\\n-    [ctor \"policyd<tclass<int>, operation_1<tclass<int> > >\" \"tclass<int>\"] \\\n-    {policyd<tclass<int>, operation_1<tclass<int> > >::policyd} \\\n-    {policyd<T, Policy>::policyd}\n-add {policyd<tclass<int>, operation_1<tclass<int> > >::~policyd} \\\n-    [dtor \"policyd<tclass<int>, operation_1<tclass<int> > >\"] \\\n-    - \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd5::~policyd} \\\n-    [dtor \"policyd<tclass<int>, operation_1<tclass<int> > >\"] \\\n-    {policyd<tclass<int>, operation_1<tclass<int> > >::~policyd} \\\n-    {policyd<T, Policy>::~policyd}\n-add {policyd<int, operation_1<int> >::function} \\\n-    {void (void)} \\\n-    {operation_1<int>::function}\\\n-    {operation_1<T>::function}\n-add {policyd1::function} \\\n-    {void (void)} \\\n-    {operation_1<int>::function} \\\n-    {operation_1<T>::function}\n-add {policyd2::function} \\\n-    {void (void)} \\\n-    {operation_1<long>::function} \\\n-    {operation_1<T>::function}\n-add {policyd<char, operation_1<char> >::function} \\\n-    {void (void)} \\\n-    {operation_1<char>::function} \\\n-    {operation_1<T>::function}\n-add {policyd3::function} \\\n-    {void (void)} \\\n-    {operation_1<char>::function} \\\n-    {operation_1<T>::function}\n-add {policyd<base, operation_1<base> >::function} \\\n-    {void (void)} \\\n-    {operation_1<base>::function} \\\n-    {operation_1<T>::function}\n-add {policyd4::function} \\\n-    {void (void)} \\\n-    {operation_1<base>::function} \\\n-    {operation_1<T>::function}\n-add {policyd<tclass<int>, operation_1<tclass<int> > >::function} \\\n-    {void (void)} \\\n-    {operation_1<tclass<int> >::function} \\\n-    {operation_1<T>::function}\n-add {policyd5::function} \\\n-    {void (void)} \\\n-    {operation_1<tclass<int> >::function} \\\n-    {operation_1<T>::function}\n-\n-# Start the test\n-if {[skip_cplus_tests]} { continue }\n-\n-#\n-# test running programs\n-#\n-\n-standard_testfile cpexprs.cc\n-\n-if {[get_compiler_info \"c++\"]} {\n-    return -1\n-}\n-\n-if { [info exists flags] } {\n-    # Already set externally.\n-} else {\n-    # Initialize to empty.\n-    set flags {}\n-}\n-\n-# Include required flags.\n-set flags \"$flags debug c++\"\n-\n-if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile \"$flags\"]} {\n-    return -1\n-}\n-\n-if {![runto_main]} {\n-    perror \"couldn't run to breakpoint\"\n-    continue\n-}\n-\n-# Set the listsize to one. This will help with testing \"list\".\n-gdb_test \"set listsize 1\"\n-\n-# \"print METHOD\"\n-foreach name [get_functions print] {\n-    gdb_test \"print $name\" [get $name print]\n-}\n-\n-# \"list METHOD\"\n-foreach name [get_functions list] {\n-    gdb_test \"list $name\" [get $name list]\n-}\n-\n-# Running to breakpoint -- use any function we can \"list\"\n-foreach name [get_functions list] {\n-    # Skip \"test_function\", since test_breakpoint uses it\n-    if {[string compare $name \"test_function\"] != 0} {\n-\ttest_breakpoint $name\n-    }\n-}\n-\n-# Test c/v gets recognized even without quoting.\n-foreach cv {{} { const} { volatile} { const volatile}} {\n-  set test \"p 'CV::m(int)$cv'\"\n-  gdb_test_multiple $test $test {\n-      -re \"( = {.*} 0x\\[0-9a-f\\]+ <CV::m.*>)\\r\\n$gdb_prompt $\" {\n-\t  # = {void (CV * const, CV::t)} 0x400944 <CV::m(int)>\n-\t  set correct $expect_out(1,string)\n-\t  pass $test\n-      }\n-  }\n-  gdb_test \"p CV::m(int)$cv\" [string_to_regexp $correct]\n-}\n-\n-# Test TYPENAME:: gets recognized even in parentheses.\n-gdb_test \"p CV_f(int)\"   { = {int \\(int\\)} 0x[0-9a-f]+ <CV_f\\(int\\)>}\n-gdb_test \"p CV_f(CV::t)\" { = {int \\(int\\)} 0x[0-9a-f]+ <CV_f\\(int\\)>}\n-gdb_test \"p CV_f(CV::i)\" \" = 43\"\n-\n-gdb_test \"p CV_f('cpexprs.cc'::CV::t)\" \\\n-    { = {int \\(int\\)} 0x[0-9a-f]+ <CV_f\\(int\\)>}\n-\n-# Make sure conversion operator names are canonicalized and properly\n-# \"spelled.\"\n-gdb_test \"p base::operator const fluff * const *\" \\\n-    [get \"base::operator fluff const* const*\" print] \\\n-    \"canonicalized conversion operator name 1\"\n-gdb_test \"p base::operator const fluff* const*\" \\\n-    [get \"base::operator fluff const* const*\" print] \\\n-    \"canonicalized conversion operator name 2\"\n-gdb_test \"p base::operator derived*\" \\\n-    \"There is no field named operator derived\\\\*\" \\\n-    \"undefined conversion operator\"\n-\n-gdb_exit\n-return 0\n+# Run cpexprs.exp.\n+set flags {}\n+source $srcdir/$subdir/cpexprs.exp.in"
    },
    {
      "sha": "ef302157355c16f55eb815a9b64319cb30ba301f",
      "filename": "gdb/testsuite/gdb.cp/cpexprs.exp.in",
      "status": "added",
      "additions": 761,
      "deletions": 0,
      "changes": 761,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/gdb.cp/cpexprs.exp.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/113ee09a649a5e192408a10286b95e89bc48706a/gdb/testsuite/gdb.cp/cpexprs.exp.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/cpexprs.exp.in?ref=113ee09a649a5e192408a10286b95e89bc48706a",
      "patch": "@@ -0,0 +1,761 @@\n+# cpexprs.exp - C++ expressions tests\n+#\n+# Copyright 2008-2020 Free Software Foundation, Inc.\n+#\n+# Contributed by Red Hat, originally written by Keith Seitz.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is part of the gdb testsuite.\n+\n+# A helper proc which sets a breakpoint at FUNC and attempts to\n+# run to the breakpoint.\n+proc test_breakpoint {func} {\n+    global DEC\n+\n+    # Return to the top of the test function every time.\n+    delete_breakpoints\n+    if { ! [gdb_breakpoint test_function] } {\n+\tfail \"set test_function breakpoint for $func\"\n+    } elseif { [gdb_test \"continue\" \\\n+\t\t    \"Continuing.\\r\\n\\r\\nBreakpoint $DEC+,.*test_function.*\" \\\n+\t\t    \"\"] != 0 } {\n+\tfail \"continue to test_function for $func\"\n+    } else {\n+\tgdb_breakpoint \"$func\"\n+\tset i [expr {[string last : $func] + 1}]\n+\tset efunc [string_to_regexp [string range $func $i end]]\n+\tgdb_test \"continue\" \\\n+\t    \"Continuing.\\r\\n\\r\\nBreakpoint $DEC+,.*$efunc.*\" \\\n+\t    \"continue to $func\"\n+    }\n+}\n+\n+# Add a function to the list of tested functions\n+# FUNC is the name of the function (which will be passed to gdb commands)\n+# TYPE is the type of the function, as expected from the \"print\" command\n+# PRINT is the name of the function, as expected result of the print command\n+#  *OR* \"-\", indicating that FUNC should be used (needed for virtual/inherited\n+#   funcs)\n+# LST is either the expected result of the list command (the comment from\n+#  the source code) *OR* \"-\", in which case FUNC will be used\n+#\n+# Usage:\n+# add NAME TYPE PRINT LST\n+# add NAME TYPE PRINT -\n+proc add_type_regexp {func type print lst} {\n+    global all_functions CONVAR ADDR\n+\n+    set all_functions($func,type) $type\n+    if {$print == \"-\"} {\n+\tset print $func\n+    }\n+\n+    # An exception: since gdb canonicalizes C++ output,\n+    # \"(void)\" must be mutated to \"()\".\n+    regsub {\\(void\\)} $print {()} print\n+\n+    set all_functions($func,print) \\\n+\t\"$CONVAR = {$type} $ADDR <[string_to_regexp $print].*>\"\n+    if {$lst == \"-\"} {\n+\tset lst \"$func\"\n+    }\n+    set all_functions($func,list) \".*// [string_to_regexp $lst]\"\n+}\n+\n+proc add {func type print lst} {\n+    add_type_regexp $func [string_to_regexp $type] $print $lst\n+}\n+\n+proc get {func cmd} {\n+    global all_functions\n+    return $all_functions($func,$cmd)\n+}\n+\n+# Returns a list of function names for a given command\n+proc get_functions {cmd} {\n+    global all_functions\n+    set result {}\n+    foreach i [array names all_functions *,$cmd] {\n+\tif {$all_functions($i) != \"\"} {\n+\t    set idx [string last , $i]\n+\t    if {$idx != -1} {\n+\t\tlappend result [string range $i 0 [expr {$idx - 1}]]\n+\t    }\n+\t}\n+    }\n+\n+    return [lsort $result]\n+}\n+\n+# Some convenience variables for this test\n+set DEC {[0-9]}; # a decimal number\n+set HEX {[0-9a-fA-F]}; # a hexidecimal number\n+set CONVAR \"\\\\\\$$DEC+\"; # convenience variable regexp\n+set ADDR \"0x$HEX+\"; # address\n+\n+# An array of functions/methods that we are testing...\n+# Each element consists is indexed by NAME,COMMAND, where\n+# NAME is the function name and COMMAND is the gdb command that\n+# we are testing. The value of the array for any index pair is\n+# the expected result of running COMMAND with the NAME as argument.\n+\n+# The array holding all functions/methods to test. Valid subindexes\n+# are (none need character escaping -- \"add\" will take care of that):\n+\n+# add name type print_name list\n+# NAME,type: value is type of function \n+# NAME,print: value is print name of function (careful w/inherited/virtual!)\n+# NAME,list: value is comment in source code on first line of function\n+#   (without the leading \"//\")\n+array set all_functions {}\n+\n+# \"Normal\" functions/methods\n+add {test_function} \\\n+    {int (int, char **)} \\\n+    - \\\n+    -\n+add {derived::a_function} \\\n+    {void (const derived * const)} \\\n+    - \\\n+    -\n+add {base1::a_function} \\\n+    {void (const base1 * const)} \\\n+    - \\\n+    -\n+add {base2::a_function} \\\n+    {void (const base2 * const)} \\\n+    - \\\n+    -\n+\n+# Constructors\n+\n+# On targets using the ARM EABI, the constructor is expected to return\n+# \"this\".\n+proc ctor_ret { type } {\n+    if { [istarget arm*-*eabi*] || [is_aarch32_target] } {\n+\treturn \"$type *\"\n+    } else {\n+\treturn \"void \"\n+    }\n+}\n+\n+proc ctor_prefix { type } {\n+    set ret [ctor_ret $type]\n+    return \"${ret}($type * const\"\n+}\n+\n+proc ctor { type arglist } {\n+    if { $arglist != \"\" } {\n+\tset arglist \", $arglist\"\n+    }\n+    return \"[ctor_prefix $type]$arglist)\"\n+}\n+\n+add {derived::derived} \\\n+    [ctor derived \"\"] \\\n+    - \\\n+    -\n+add_type_regexp {base1::base1(void)} \\\n+    \"[string_to_regexp [ctor_prefix base1]], (const )?void \\\\*\\\\*( const)?\\\\)\" \\\n+    - \\\n+    -\n+add {base1::base1(int)} \\\n+    [ctor base1 \"int\"] \\\n+    - \\\n+    -\n+add_type_regexp {base2::base2} \\\n+    \"[string_to_regexp [ctor_prefix base2]], (const )?void \\\\*\\\\*( const)?\\\\)\" \\\n+    - \\\n+    -\n+add {base::base(void)} \\\n+    [ctor base \"\"] \\\n+    - \\\n+    -\n+add {base::base(int)} \\\n+    [ctor base \"int\"] \\\n+    - \\\n+    -\n+\n+# Destructors\n+\n+# On targets using the ARM EABI, some destructors are expected\n+# to return \"this\".  Others are void.  For internal reasons,\n+# GCC returns void * instead of $type *; RealView appears to do\n+# the same.\n+proc dtor { type } {\n+    if { [istarget arm*-*eabi*] || [is_aarch32_target] } {\n+\tset ret \"void *\"\n+    } else {\n+\tset ret \"void \"\n+    }\n+    return \"${ret}($type * const)\"\n+}\n+\n+add {base::~base} \\\n+    [dtor base] \\\n+    - \\\n+    -\n+\n+# Overloaded methods (all are const)\n+add {base::overload(void) const} \\\n+    {int (const base * const)} \\\n+    - \\\n+    {base::overload(void) const}\n+add {base::overload(int) const} \\\n+    {int (const base * const, int)} \\\n+    - \\\n+    -\n+add {base::overload(short) const} \\\n+    {int (const base * const, short)} \\\n+    - \\\n+    -\n+add {base::overload(long) const} \\\n+    {int (const base * const, long)} \\\n+    - \\\n+    -\n+add {base::overload(char*) const} \\\n+    {int (const base * const, char *)} \\\n+    - \\\n+    -\n+add {base::overload(base&) const} \\\n+    {int (const base * const, base &)} \\\n+    - \\\n+    -\n+\n+# Operators\n+add {base::operator+} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator++} \\\n+    {base (base * const)} \\\n+    - \\\n+    -\n+add {base::operator+=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator-} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator--} \\\n+    {base (base * const)} \\\n+    - \\\n+    -\n+add {base::operator-=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator*} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator*=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator/} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator/=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator%} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator%=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator<} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator<=} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator>} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator>=} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator!=} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator==} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator!} \\\n+    {bool (const base * const)} \\\n+    - \\\n+    -\n+add {base::operator&&} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator||} \\\n+    {bool (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator<<} \\\n+    {int (const base * const, int)} \\\n+    - \\\n+    -\n+add {base::operator<<=} \\\n+    {base (base * const, int)} \\\n+    - \\\n+    -\n+add {base::operator>>} \\\n+    {int (const base * const, int)} \\\n+    - \\\n+    -\n+add {base::operator>>=} \\\n+    {base (base * const, int)} \\\n+    - \\\n+    -\n+add {base::operator~} \\\n+    {int (const base * const)} \\\n+    - \\\n+    -\n+add {base::operator&} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator&=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator|} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator|=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator^} \\\n+    {int (const base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator^=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator=} \\\n+    {base (base * const, const base &)} \\\n+    - \\\n+    -\n+add {base::operator()} \\\n+    {void (const base * const)} \\\n+    - \\\n+    -\n+add {base::operator[]} \\\n+    {int (const base * const, int)} \\\n+    - \\\n+    -\n+add {base::operator new} \\\n+    {void *(size_t)} \\\n+    - \\\n+    -\n+add {base::operator delete} \\\n+    {void (void *)} \\\n+    - \\\n+    -\n+add {base::operator new[]} \\\n+    {void *(size_t)} \\\n+    - \\\n+    -\n+add {base::operator delete[]} \\\n+    {void (void *)} \\\n+    - \\\n+    -\n+add {base::operator char*} \\\n+    {char *(const base * const)} \\\n+    - \\\n+    -\n+add {base::operator fluff*} \\\n+    {fluff *(const base * const)} \\\n+    - \\\n+    -\n+add {base::operator fluff**} \\\n+    {fluff **(const base * const)} \\\n+    - \\\n+    -\n+add {base::operator int} \\\n+    {int (const base * const)} \\\n+    - \\\n+    -\n+add {base::operator fluff const* const*} \\\n+    {const fluff * const *(const base * const)} \\\n+    - \\\n+    -\n+\n+# Templates\n+add {tclass<char>::do_something} \\\n+    {void (tclass<char> * const)} \\\n+    - \\\n+    -\n+add {tclass<int>::do_something} \\\n+    {void (tclass<int> * const)} \\\n+    - \\\n+    -\n+add {tclass<long>::do_something} \\\n+    {void (tclass<long> * const)} \\\n+    - \\\n+    -\n+add {tclass<short>::do_something} \\\n+    {void (tclass<short> * const)} \\\n+    - \\\n+    -\n+add {tclass<base>::do_something} \\\n+    {void (tclass<base> * const)} \\\n+    - \\\n+    -\n+add {flubber<int, int, int, int, int>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, int, short>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, int, long>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, int, char>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, short, int>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, short, short>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, short, long>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, short, char>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, long, int>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, long, short>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, long, long>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, long, char>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, char, int>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, char, short>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, char, long>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, int, char, char>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, short, int, int>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, short, int, short>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, short, int, long>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, short, int, char>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<int, int, short, short, int>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<short, int, short, int, short>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {flubber<long, short, long, short, long>} \\\n+    {void (void)} \\\n+    - \\\n+    flubber\n+add {tclass<base>::do_something} \\\n+    {void (tclass<base> * const)} \\\n+    - \\\n+    {tclass<T>::do_something}\n+add {policy1::policy} \\\n+    [ctor \"policy<int, operation_1<void*> >\" \"int\"] \\\n+    {policy<int, operation_1<void*> >::policy} \\\n+    {policy<T, Policy>::policy}\n+add {policy2::policy} \\\n+    [ctor \"policy<int, operation_2<void*> >\" int] \\\n+    {policy<int, operation_2<void*> >::policy} \\\n+    {policy<T, Policy>::policy}\n+add {policy3::policy} \\\n+    [ctor \"policy<int, operation_3<void*> >\" \"int\"] \\\n+    {policy<int, operation_3<void*> >::policy} \\\n+    {policy<T, Policy>::policy}\n+add {policy4::policy} \\\n+    [ctor \"policy<int, operation_4<void*> >\" \"int\"] \\\n+    {policy<int, operation_4<void*> >::policy} \\\n+    {policy<T, Policy>::policy}\n+add {policy1::function} \\\n+    {void (void)} \\\n+    {operation_1<void*>::function} \\\n+    {operation_1<T>::function}\n+add {policy2::function} \\\n+    {void (void)} \\\n+    {operation_2<void*>::function} \\\n+    {operation_2<T>::function}\n+add {policy3::function} \\\n+    {void (void)} \\\n+    {operation_3<void*>::function} \\\n+    {operation_3<T>::function}\n+add {policy4::function} \\\n+    {void (void)} \\\n+    {operation_4<void*>::function} \\\n+    {operation_4<T>::function}\n+add {policyd<int, operation_1<int> >::policyd} \\\n+    [ctor \"policyd<int, operation_1<int> >\" \"int\"] \\\n+    - \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd1::policyd} \\\n+    [ctor \"policyd<int, operation_1<int> >\" \"int\"] \\\n+    {policyd<int, operation_1<int> >::policyd} \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd<int, operation_1<int> >::~policyd} \\\n+    [dtor \"policyd<int, operation_1<int> >\"] \\\n+    - \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd1::~policyd} \\\n+    [dtor \"policyd<int, operation_1<int> >\"] \\\n+    {policyd<int, operation_1<int> >::~policyd} \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd<long, operation_1<long> >::policyd} \\\n+    [ctor \"policyd<long, operation_1<long> >\" \"long\"] \\\n+    - \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd2::policyd} \\\n+    [ctor \"policyd<long, operation_1<long> >\" \"long\"] \\\n+    {policyd<long, operation_1<long> >::policyd} \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd<long, operation_1<long> >::~policyd} \\\n+    [dtor \"policyd<long, operation_1<long> >\"] \\\n+    - \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd2::~policyd} \\\n+    [dtor \"policyd<long, operation_1<long> >\"] \\\n+    {policyd<long, operation_1<long> >::~policyd} \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd<char, operation_1<char> >::policyd} \\\n+    [ctor \"policyd<char, operation_1<char> >\" \"char\"] \\\n+    - \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd3::policyd} \\\n+    [ctor \"policyd<char, operation_1<char> >\" \"char\"] \\\n+    {policyd<char, operation_1<char> >::policyd} \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd<char, operation_1<char> >::~policyd} \\\n+    [dtor \"policyd<char, operation_1<char> >\"] \\\n+    - \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd3::~policyd} \\\n+    [dtor \"policyd<char, operation_1<char> >\"] \\\n+    {policyd<char, operation_1<char> >::~policyd} \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd<base, operation_1<base> >::policyd} \\\n+    [ctor \"policyd<base, operation_1<base> >\" \"base\"] \\\n+    - \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd4::policyd} \\\n+    [ctor \"policyd<base, operation_1<base> >\" \"base\"] \\\n+    {policyd<base, operation_1<base> >::policyd} \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd<base, operation_1<base> >::~policyd} \\\n+    [dtor \"policyd<base, operation_1<base> >\"] \\\n+    - \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd4::~policyd} \\\n+    [dtor \"policyd<base, operation_1<base> >\"] \\\n+    {policyd<base, operation_1<base> >::~policyd} \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd<tclass<int>, operation_1<tclass<int> > >::policyd} \\\n+    [ctor \"policyd<tclass<int>, operation_1<tclass<int> > >\" \"tclass<int>\"] \\\n+    - \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd5::policyd} \\\n+    [ctor \"policyd<tclass<int>, operation_1<tclass<int> > >\" \"tclass<int>\"] \\\n+    {policyd<tclass<int>, operation_1<tclass<int> > >::policyd} \\\n+    {policyd<T, Policy>::policyd}\n+add {policyd<tclass<int>, operation_1<tclass<int> > >::~policyd} \\\n+    [dtor \"policyd<tclass<int>, operation_1<tclass<int> > >\"] \\\n+    - \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd5::~policyd} \\\n+    [dtor \"policyd<tclass<int>, operation_1<tclass<int> > >\"] \\\n+    {policyd<tclass<int>, operation_1<tclass<int> > >::~policyd} \\\n+    {policyd<T, Policy>::~policyd}\n+add {policyd<int, operation_1<int> >::function} \\\n+    {void (void)} \\\n+    {operation_1<int>::function}\\\n+    {operation_1<T>::function}\n+add {policyd1::function} \\\n+    {void (void)} \\\n+    {operation_1<int>::function} \\\n+    {operation_1<T>::function}\n+add {policyd2::function} \\\n+    {void (void)} \\\n+    {operation_1<long>::function} \\\n+    {operation_1<T>::function}\n+add {policyd<char, operation_1<char> >::function} \\\n+    {void (void)} \\\n+    {operation_1<char>::function} \\\n+    {operation_1<T>::function}\n+add {policyd3::function} \\\n+    {void (void)} \\\n+    {operation_1<char>::function} \\\n+    {operation_1<T>::function}\n+add {policyd<base, operation_1<base> >::function} \\\n+    {void (void)} \\\n+    {operation_1<base>::function} \\\n+    {operation_1<T>::function}\n+add {policyd4::function} \\\n+    {void (void)} \\\n+    {operation_1<base>::function} \\\n+    {operation_1<T>::function}\n+add {policyd<tclass<int>, operation_1<tclass<int> > >::function} \\\n+    {void (void)} \\\n+    {operation_1<tclass<int> >::function} \\\n+    {operation_1<T>::function}\n+add {policyd5::function} \\\n+    {void (void)} \\\n+    {operation_1<tclass<int> >::function} \\\n+    {operation_1<T>::function}\n+\n+# Start the test\n+if {[skip_cplus_tests]} { continue }\n+\n+#\n+# test running programs\n+#\n+\n+standard_testfile cpexprs.cc\n+\n+if {[get_compiler_info \"c++\"]} {\n+    return -1\n+}\n+\n+# Include required flags.\n+set flags \"$flags debug c++\"\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile \"$flags\"]} {\n+    return -1\n+}\n+\n+if {![runto_main]} {\n+    perror \"couldn't run to breakpoint\"\n+    continue\n+}\n+\n+# Set the listsize to one. This will help with testing \"list\".\n+gdb_test \"set listsize 1\"\n+\n+# \"print METHOD\"\n+foreach name [get_functions print] {\n+    gdb_test \"print $name\" [get $name print]\n+}\n+\n+# \"list METHOD\"\n+foreach name [get_functions list] {\n+    gdb_test \"list $name\" [get $name list]\n+}\n+\n+# Running to breakpoint -- use any function we can \"list\"\n+foreach name [get_functions list] {\n+    # Skip \"test_function\", since test_breakpoint uses it\n+    if {[string compare $name \"test_function\"] != 0} {\n+\ttest_breakpoint $name\n+    }\n+}\n+\n+# Test c/v gets recognized even without quoting.\n+foreach cv {{} { const} { volatile} { const volatile}} {\n+  set test \"p 'CV::m(int)$cv'\"\n+  gdb_test_multiple $test $test {\n+      -re \"( = {.*} 0x\\[0-9a-f\\]+ <CV::m.*>)\\r\\n$gdb_prompt $\" {\n+\t  # = {void (CV * const, CV::t)} 0x400944 <CV::m(int)>\n+\t  set correct $expect_out(1,string)\n+\t  pass $test\n+      }\n+  }\n+  gdb_test \"p CV::m(int)$cv\" [string_to_regexp $correct]\n+}\n+\n+# Test TYPENAME:: gets recognized even in parentheses.\n+gdb_test \"p CV_f(int)\"   { = {int \\(int\\)} 0x[0-9a-f]+ <CV_f\\(int\\)>}\n+gdb_test \"p CV_f(CV::t)\" { = {int \\(int\\)} 0x[0-9a-f]+ <CV_f\\(int\\)>}\n+gdb_test \"p CV_f(CV::i)\" \" = 43\"\n+\n+gdb_test \"p CV_f('cpexprs.cc'::CV::t)\" \\\n+    { = {int \\(int\\)} 0x[0-9a-f]+ <CV_f\\(int\\)>}\n+\n+# Make sure conversion operator names are canonicalized and properly\n+# \"spelled.\"\n+gdb_test \"p base::operator const fluff * const *\" \\\n+    [get \"base::operator fluff const* const*\" print] \\\n+    \"canonicalized conversion operator name 1\"\n+gdb_test \"p base::operator const fluff* const*\" \\\n+    [get \"base::operator fluff const* const*\" print] \\\n+    \"canonicalized conversion operator name 2\"\n+gdb_test \"p base::operator derived*\" \\\n+    \"There is no field named operator derived\\\\*\" \\\n+    \"undefined conversion operator\"\n+\n+gdb_exit\n+return 0"
    }
  ]
}