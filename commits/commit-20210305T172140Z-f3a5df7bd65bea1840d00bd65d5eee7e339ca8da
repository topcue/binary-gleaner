{
  "sha": "f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjNhNWRmN2JkNjViZWExODQwZDAwYmQ2NWQ1ZWVlN2UzMzljYThkYQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-01-18T16:00:38Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-03-05T17:21:40Z"
    },
    "message": "gdb: unify parts of the Linux and FreeBSD core dumping code\n\nWhile reviewing the Linux and FreeBSD core dumping code within GDB for\nanother patch series, I noticed that the code that collects the\nregisters for each thread and writes these into ELF note format is\nbasically identical between Linux and FreeBSD.\n\nThis commit merges this code and moves it into a new file gcore-elf.c.\n\nThe function find_signalled_thread is moved from linux-tdep.c to\ngcore.c despite not being shared.  A later commit will make use of\nthis function.\n\nI did merge, and then revert a previous version of this patch (commit\n82a1fd3a4935 for the original patch and 03642b7189bc for the revert).\nThe problem with the original patch is that it introduced a\nunconditional dependency between GDB and some ELF specific functions\nin the BFD library, e.g. elfcore_write_prstatus and\nelfcore_write_register_note.  It was pointed out in this mailing list\npost:\n\n  https://sourceware.org/pipermail/gdb-patches/2021-February/175750.html\n\nthat this change was breaking any build of GDB for non-ELF targets.\nTo confirm this breakage, and to test this new version of GDB I\nconfigured and built for the target x86_64-apple-darwin20.3.0.\n\nWhere the previous version of this patch placed all of the common code\ninto gcore.c, which is included in all builds of GDB, this new patch\nonly places non-ELF specific generic code (i.e. find_signalled_thread)\ninto gcore.c, the ELF specific code is put into the new gcore-elf.c\nfile, which is only included in GDB if BFD has ELF support.\n\nThe contents of gcore-elf.c are referenced unconditionally from\nlinux-tdep.c and fbsd-tdep.c, this is fine, we previously always\nassumed that these two targets required ELF support, and we continue\nto make that assumption after this patch; nothing has changed there.\n\nWith my previous version of this patch the darwin target mentioned\nabove failed to build, but with the new version, the target builds\nfine.\n\nThere are a couple of minor changes to the FreeBSD target after this\ncommit, but I believe that these are changes for the better:\n\n(1) For FreeBSD we always used to record the thread-id in the core\nfile by using ptid_t.lwp ().  In contrast the Linux code did this:\n\n    /* For remote targets the LWP may not be available, so use the TID.  */\n    long lwp = ptid.lwp ();\n    if (lwp == 0)\n      lwp = ptid.tid ();\n\nBoth target now do this:\n\n    /* The LWP is often not available for bare metal target, in which case\n       use the tid instead.  */\n    if (ptid.lwp_p ())\n      lwp = ptid.lwp ();\n    else\n      lwp = ptid.tid ();\n\nWhich is equivalent for Linux, but is a change for FreeBSD.  I think\nthat all this means is that in some cases where GDB might have\npreviously recorded a thread-id of 0 for each thread, we might now get\nsomething more useful.\n\n(2) When collecting the registers for Linux we collected into a zero\ninitialised buffer.  By contrast on FreeBSD the buffer is left\nuninitialised.  In the new code the buffer is always zero initialised.\nI suspect once the registers are copied into the buffer there's\nprobably no gaps left so this makes no difference, but if it does then\nusing zeros rather than random bits of GDB's memory is probably a good\nthing.\n\nOtherwise, there should be no other user visible changes after this\ncommit.\n\nTested this on x86-64/GNU-Linux and x86-64/FreeBSD-12.2 with no\nregressions.\n\ngdb/ChangeLog:\n\n\t* Makefile.in (SFILES): Add gcore-elf.c.\n\t(HFILES_NO_SRCDIR): Add gcore-elf.h\n\t* configure: Regenerate.\n\t* configure.ac: Add gcore-elf.o to CONFIG_OBS if we have ELF\n\tsupport.\n\t* fbsd-tdep.c: Add 'gcore-elf.h' include.\n\t(struct fbsd_collect_regset_section_cb_data): Delete.\n\t(fbsd_collect_regset_section_cb): Delete.\n\t(fbsd_collect_thread_registers): Delete.\n\t(struct fbsd_corefile_thread_data): Delete.\n\t(fbsd_corefile_thread): Delete.\n\t(fbsd_make_corefile_notes): Call\n\tgcore_elf_build_thread_register_notes instead of the now deleted\n\tFreeBSD code.\n\t* gcore-elf.c: New file, the content was moved here from\n\tlinux-tdep.c, functions were renamed and given minor cleanup.\n\t* gcore-elf.h: New file.\n\t* gcore.c (gcore_find_signalled_thread): Moved here from\n\tlinux-tdep.c and given a new name.  Minor cleanups.\n\t* gcore.h (gcore_find_signalled_thread): Declare.\n\t* linux-tdep.c: Add 'gcore.h' and 'gcore-elf.h' includes.\n\t(struct linux_collect_regset_section_cb_data): Delete.\n\t(linux_collect_regset_section_cb): Delete.\n\t(linux_collect_thread_registers): Delete.\n\t(linux_corefile_thread): Call\n\tgcore_elf_build_thread_register_notes.\n\t(find_signalled_thread): Delete.\n\t(linux_make_corefile_notes): Call gcore_find_signalled_thread.",
    "tree": {
      "sha": "54ab67d8645052ef01c0f03b4cc4105b69a9c5b5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/54ab67d8645052ef01c0f03b4cc4105b69a9c5b5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2017f38777038db926239b9bbea738d270597b0e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2017f38777038db926239b9bbea738d270597b0e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2017f38777038db926239b9bbea738d270597b0e"
    }
  ],
  "stats": {
    "total": 519,
    "additions": 255,
    "deletions": 264
  },
  "files": [
    {
      "sha": "6d2d3900c28a9dcf08a86614bd75b58b8c6fcfe4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -1,3 +1,34 @@\n+2021-03-05  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* Makefile.in (SFILES): Add gcore-elf.c.\n+\t(HFILES_NO_SRCDIR): Add gcore-elf.h\n+\t* configure: Regenerate.\n+\t* configure.ac: Add gcore-elf.o to CONFIG_OBS if we have ELF\n+\tsupport.\n+\t* fbsd-tdep.c: Add 'gcore-elf.h' include.\n+\t(struct fbsd_collect_regset_section_cb_data): Delete.\n+\t(fbsd_collect_regset_section_cb): Delete.\n+\t(fbsd_collect_thread_registers): Delete.\n+\t(struct fbsd_corefile_thread_data): Delete.\n+\t(fbsd_corefile_thread): Delete.\n+\t(fbsd_make_corefile_notes): Call\n+\tgcore_elf_build_thread_register_notes instead of the now deleted\n+\tFreeBSD code.\n+\t* gcore-elf.c: New file, the content was moved here from\n+\tlinux-tdep.c, functions were renamed and given minor cleanup.\n+\t* gcore-elf.h: New file.\n+\t* gcore.c (gcore_find_signalled_thread): Moved here from\n+\tlinux-tdep.c and given a new name.  Minor cleanups.\n+\t* gcore.h (gcore_find_signalled_thread): Declare.\n+\t* linux-tdep.c: Add 'gcore.h' and 'gcore-elf.h' includes.\n+\t(struct linux_collect_regset_section_cb_data): Delete.\n+\t(linux_collect_regset_section_cb): Delete.\n+\t(linux_collect_thread_registers): Delete.\n+\t(linux_corefile_thread): Call\n+\tgcore_elf_build_thread_register_notes.\n+\t(find_signalled_thread): Delete.\n+\t(linux_make_corefile_notes): Call gcore_find_signalled_thread.\n+\n 2021-03-04  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \tPR gdb/27147"
    },
    {
      "sha": "cf5017e7f66fd57dc35428bd3d83d6b90d4e10f4",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -1191,6 +1191,7 @@ SFILES = \\\n \tdtrace-probe.c \\\n \telfread.c \\\n \tf-exp.y \\\n+\tgcore-elf.c \\\n \tgdb.c \\\n \tgo-exp.y \\\n \tm2-exp.y \\\n@@ -1292,6 +1293,7 @@ HFILES_NO_SRCDIR = \\\n \tframe-unwind.h \\\n \tfrv-tdep.h \\\n \tft32-tdep.h \\\n+\tgcore-elf.h \\\n \tgcore.h \\\n \tgdb_bfd.h \\\n \tgdb_curses.h \\"
    },
    {
      "sha": "4707fd01174d583df46b553827ab8e08e4b69e44",
      "filename": "gdb/configure",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -17264,7 +17264,7 @@ $as_echo \"$gdb_cv_var_elf\" >&6; }\n   LDFLAGS=$OLD_LDFLAGS\n   LIBS=$OLD_LIBS\n if test \"$gdb_cv_var_elf\" = yes; then\n-  CONFIG_OBS=\"$CONFIG_OBS elfread.o stap-probe.o dtrace-probe.o\"\n+  CONFIG_OBS=\"$CONFIG_OBS elfread.o stap-probe.o dtrace-probe.o gcore-elf.o\"\n \n $as_echo \"#define HAVE_ELF 1\" >>confdefs.h\n "
    },
    {
      "sha": "db765af0577ee4169ce1e8feeec2fed077d50209",
      "filename": "gdb/configure.ac",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.ac?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -1882,7 +1882,7 @@ WIN32LIBS=\"$WIN32LIBS $WIN32APILIBS\"\n GDB_AC_CHECK_BFD([for ELF support in BFD], gdb_cv_var_elf,\n                  [bfd_get_elf_phdr_upper_bound (NULL)], elf-bfd.h)\n if test \"$gdb_cv_var_elf\" = yes; then\n-  CONFIG_OBS=\"$CONFIG_OBS elfread.o stap-probe.o dtrace-probe.o\"\n+  CONFIG_OBS=\"$CONFIG_OBS elfread.o stap-probe.o dtrace-probe.o gcore-elf.o\"\n   AC_DEFINE(HAVE_ELF, 1,\n \t    [Define if ELF support should be included.])\n   # -ldl is provided by bfd/Makfile.am (LIBDL) <PLUGINS>."
    },
    {
      "sha": "dc4278cd644fe107d84fd6735906f7eca924547e",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 128,
      "changes": 134,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -32,6 +32,7 @@\n \n #include \"elf-bfd.h\"\n #include \"fbsd-tdep.h\"\n+#include \"gcore-elf.h\"\n \n /* This enum is derived from FreeBSD's <sys/signal.h>.  */\n \n@@ -583,129 +584,6 @@ find_signalled_thread (struct thread_info *info, void *data)\n   return 0;\n }\n \n-/* Structure for passing information from\n-   fbsd_collect_thread_registers via an iterator to\n-   fbsd_collect_regset_section_cb. */\n-\n-struct fbsd_collect_regset_section_cb_data\n-{\n-  fbsd_collect_regset_section_cb_data (const struct regcache *regcache,\n-\t\t\t\t       bfd *obfd,\n-\t\t\t\t       gdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t\t       int *note_size,\n-\t\t\t\t       unsigned long lwp,\n-\t\t\t\t       gdb_signal stop_signal)\n-    : regcache (regcache),\n-      obfd (obfd),\n-      note_data (note_data),\n-      note_size (note_size),\n-      lwp (lwp),\n-      stop_signal (stop_signal)\n-  {}\n-\n-  const struct regcache *regcache;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> &note_data;\n-  int *note_size;\n-  unsigned long lwp;\n-  enum gdb_signal stop_signal;\n-  bool abort_iteration = false;\n-};\n-\n-static void\n-fbsd_collect_regset_section_cb (const char *sect_name, int supply_size,\n-\t\t\t\tint collect_size, const struct regset *regset,\n-\t\t\t\tconst char *human_name, void *cb_data)\n-{\n-  char *buf;\n-  struct fbsd_collect_regset_section_cb_data *data\n-    = (struct fbsd_collect_regset_section_cb_data *) cb_data;\n-\n-  if (data->abort_iteration)\n-    return;\n-\n-  gdb_assert (regset->collect_regset);\n-\n-  buf = (char *) xmalloc (collect_size);\n-  regset->collect_regset (regset, data->regcache, -1, buf, collect_size);\n-\n-  /* PRSTATUS still needs to be treated specially.  */\n-  if (strcmp (sect_name, \".reg\") == 0)\n-    data->note_data.reset (elfcore_write_prstatus\n-\t\t\t     (data->obfd, data->note_data.release (),\n-\t\t\t      data->note_size, data->lwp,\n-\t\t\t      gdb_signal_to_host (data->stop_signal),\n-\t\t\t      buf));\n-  else\n-    data->note_data.reset (elfcore_write_register_note\n-\t\t\t     (data->obfd, data->note_data.release (),\n-\t\t\t      data->note_size, sect_name, buf,\n-\t\t\t      collect_size));\n-  xfree (buf);\n-\n-  if (data->note_data == NULL)\n-    data->abort_iteration = true;\n-}\n-\n-/* Records the thread's register state for the corefile note\n-   section.  */\n-\n-static void\n-fbsd_collect_thread_registers (const struct regcache *regcache,\n-\t\t\t       ptid_t ptid, bfd *obfd,\n-\t\t\t       gdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t       int *note_size,\n-\t\t\t       enum gdb_signal stop_signal)\n-{\n-  fbsd_collect_regset_section_cb_data data (regcache, obfd, note_data,\n-\t\t\t\t\t    note_size, ptid.lwp (),\n-\t\t\t\t\t    stop_signal);\n-\n-  gdbarch_iterate_over_regset_sections (regcache->arch (),\n-\t\t\t\t\tfbsd_collect_regset_section_cb,\n-\t\t\t\t\t&data, regcache);\n-}\n-\n-struct fbsd_corefile_thread_data\n-{\n-  fbsd_corefile_thread_data (struct gdbarch *gdbarch,\n-\t\t\t     bfd *obfd,\n-\t\t\t     gdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t     int *note_size,\n-\t\t\t     gdb_signal stop_signal)\n-    : gdbarch (gdbarch),\n-      obfd (obfd),\n-      note_data (note_data),\n-      note_size (note_size),\n-      stop_signal (stop_signal)\n-  {}\n-\n-  struct gdbarch *gdbarch;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> &note_data;\n-  int *note_size;\n-  enum gdb_signal stop_signal;\n-};\n-\n-/* Records the thread's register state for the corefile note\n-   section.  */\n-\n-static void\n-fbsd_corefile_thread (struct thread_info *info,\n-\t\t      struct fbsd_corefile_thread_data *args)\n-{\n-  struct regcache *regcache;\n-\n-  regcache = get_thread_arch_regcache (info->inf->process_target (),\n-\t\t\t\t       info->ptid, args->gdbarch);\n-\n-  target_fetch_registers (regcache, -1);\n-\n-  fbsd_collect_thread_registers (regcache, info->ptid, args->obfd,\n-\t\t\t\t args->note_data, args->note_size,\n-\t\t\t\t args->stop_signal);\n-}\n-\n /* Return a byte_vector containing the contents of a core dump note\n    for the target object of type OBJECT.  If STRUCTSIZE is non-zero,\n    the data is prefixed with a 32-bit integer size to match the format\n@@ -782,16 +660,16 @@ fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n \tsignalled_thr = curr_thr;\n     }\n \n-  fbsd_corefile_thread_data thread_args (gdbarch, obfd, note_data, note_size,\n-\t\t\t\t\t signalled_thr->suspend.stop_signal);\n-\n-  fbsd_corefile_thread (signalled_thr, &thread_args);\n+  enum gdb_signal stop_signal = signalled_thr->suspend.stop_signal;\n+  gcore_elf_build_thread_register_notes (gdbarch, signalled_thr, stop_signal,\n+\t\t\t\t\t obfd, &note_data, note_size);\n   for (thread_info *thr : current_inferior ()->non_exited_threads ())\n     {\n       if (thr == signalled_thr)\n \tcontinue;\n \n-      fbsd_corefile_thread (thr, &thread_args);\n+      gcore_elf_build_thread_register_notes (gdbarch, thr, stop_signal,\n+\t\t\t\t\t     obfd, &note_data, note_size);\n     }\n \n   /* Auxiliary vector.  */"
    },
    {
      "sha": "b0fb808fae0276a660e9b4c61c5e835c20b323a1",
      "filename": "gdb/gcore-elf.c",
      "status": "added",
      "additions": 136,
      "deletions": 0,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore-elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore-elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore-elf.c?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -0,0 +1,136 @@\n+/* Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"gcore-elf.h\"\n+#include \"elf-bfd.h\"\n+#include \"target.h\"\n+#include \"regcache.h\"\n+#include \"gdbarch.h\"\n+#include \"gdbthread.h\"\n+#include \"inferior.h\"\n+#include \"regset.h\"\n+\n+/* Structure for passing information from GCORE_COLLECT_THREAD_REGISTERS\n+   via an iterator to GCORE_COLLECT_REGSET_SECTION_CB. */\n+\n+struct gcore_elf_collect_regset_section_cb_data\n+{\n+  gcore_elf_collect_regset_section_cb_data\n+\t(struct gdbarch *gdbarch, const struct regcache *regcache,\n+\t bfd *obfd, ptid_t ptid, gdb_signal stop_signal,\n+\t gdb::unique_xmalloc_ptr<char> *note_data, int *note_size)\n+    : gdbarch (gdbarch), regcache (regcache), obfd (obfd),\n+      note_data (note_data), note_size (note_size),\n+      stop_signal (stop_signal)\n+  {\n+    /* The LWP is often not available for bare metal target, in which case\n+       use the tid instead.  */\n+    if (ptid.lwp_p ())\n+      lwp = ptid.lwp ();\n+    else\n+      lwp = ptid.tid ();\n+  }\n+\n+  struct gdbarch *gdbarch;\n+  const struct regcache *regcache;\n+  bfd *obfd;\n+  gdb::unique_xmalloc_ptr<char> *note_data;\n+  int *note_size;\n+  unsigned long lwp;\n+  enum gdb_signal stop_signal;\n+  bool abort_iteration = false;\n+};\n+\n+/* Callback for ITERATE_OVER_REGSET_SECTIONS that records a single\n+   regset in the core file note section.  */\n+\n+static void\n+gcore_elf_collect_regset_section_cb (const char *sect_name,\n+\t\t\t\t     int supply_size, int collect_size,\n+\t\t\t\t     const struct regset *regset,\n+\t\t\t\t     const char *human_name, void *cb_data)\n+{\n+  struct gcore_elf_collect_regset_section_cb_data *data\n+    = (struct gcore_elf_collect_regset_section_cb_data *) cb_data;\n+  bool variable_size_section = (regset != nullptr\n+\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n+\n+  gdb_assert (variable_size_section || supply_size == collect_size);\n+\n+  if (data->abort_iteration)\n+    return;\n+\n+  gdb_assert (regset != nullptr && regset->collect_regset != nullptr);\n+\n+  /* This is intentionally zero-initialized by using std::vector, so\n+     that any padding bytes in the core file will show as 0.  */\n+  std::vector<gdb_byte> buf (collect_size);\n+\n+  regset->collect_regset (regset, data->regcache, -1, buf.data (),\n+\t\t\t  collect_size);\n+\n+  /* PRSTATUS still needs to be treated specially.  */\n+  if (strcmp (sect_name, \".reg\") == 0)\n+    data->note_data->reset (elfcore_write_prstatus\n+\t\t\t    (data->obfd, data->note_data->release (),\n+\t\t\t     data->note_size, data->lwp,\n+\t\t\t     gdb_signal_to_host (data->stop_signal),\n+\t\t\t     buf.data ()));\n+  else\n+    data->note_data->reset (elfcore_write_register_note\n+\t\t\t    (data->obfd, data->note_data->release (),\n+\t\t\t     data->note_size, sect_name, buf.data (),\n+\t\t\t     collect_size));\n+\n+  if (*data->note_data == nullptr)\n+    data->abort_iteration = true;\n+}\n+\n+/* Records the register state of thread PTID out of REGCACHE into the note\n+   buffer represented by *NOTE_DATA and NOTE_SIZE.  OBFD is the bfd into\n+   which the core file is being created, and STOP_SIGNAL is the signal that\n+   cause thread PTID to stop.  */\n+\n+static void\n+gcore_elf_collect_thread_registers\n+\t(const struct regcache *regcache, ptid_t ptid, bfd *obfd,\n+\t gdb::unique_xmalloc_ptr<char> *note_data, int *note_size,\n+\t enum gdb_signal stop_signal)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+  gcore_elf_collect_regset_section_cb_data data (gdbarch, regcache, obfd,\n+\t\t\t\t\t\t ptid, stop_signal,\n+\t\t\t\t\t\t note_data, note_size);\n+  gdbarch_iterate_over_regset_sections\n+    (gdbarch, gcore_elf_collect_regset_section_cb, &data, regcache);\n+}\n+\n+/* See gcore-elf.h.  */\n+\n+void\n+gcore_elf_build_thread_register_notes\n+  (struct gdbarch *gdbarch, struct thread_info *info, gdb_signal stop_signal,\n+   bfd *obfd, gdb::unique_xmalloc_ptr<char> *note_data, int *note_size)\n+{\n+  struct regcache *regcache\n+    = get_thread_arch_regcache (info->inf->process_target (),\n+\t\t\t\tinfo->ptid, gdbarch);\n+  target_fetch_registers (regcache, -1);\n+  gcore_elf_collect_thread_registers (regcache, info->ptid, obfd,\n+\t\t\t\t      note_data, note_size, stop_signal);\n+}"
    },
    {
      "sha": "d667686adc78d64ebc665b732ce35cb684b63570",
      "filename": "gdb/gcore-elf.h",
      "status": "added",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore-elf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore-elf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore-elf.h?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -0,0 +1,39 @@\n+/* Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains generic functions for writing ELF based core files.  */\n+\n+#if !defined (GCORE_ELF_H)\n+#define GCORE_ELF_H 1\n+\n+#include \"gdb_bfd.h\"\n+#include \"gdbsupport/gdb_signals.h\"\n+#include \"gcore.h\"\n+\n+struct gdbarch;\n+struct thread_info;\n+\n+/* Add content to *NOTE_DATA (and update *NOTE_SIZE) to describe the\n+   registers of thread INFO.  Report the thread as having stopped with\n+   STOP_SIGNAL.  The core file is being written to OBFD, and GDBARCH is the\n+   architecture for which the core file is being generated.  */\n+\n+extern void gcore_elf_build_thread_register_notes\n+  (struct gdbarch *gdbarch, struct thread_info *info, gdb_signal stop_signal,\n+   bfd *obfd, gdb::unique_xmalloc_ptr<char> *note_data, int *note_size);\n+\n+#endif /* GCORE_ELF_H */"
    },
    {
      "sha": "3b9025322f326edd8531981e6fee97beffe756b6",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -579,6 +579,27 @@ gcore_memory_sections (bfd *obfd)\n   return 1;\n }\n \n+/* See gcore.h.  */\n+\n+thread_info *\n+gcore_find_signalled_thread ()\n+{\n+  thread_info *curr_thr = inferior_thread ();\n+  if (curr_thr->state != THREAD_EXITED\n+      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n+    return curr_thr;\n+\n+  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n+    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n+      return thr;\n+\n+  /* Default to the current thread, unless it has exited.  */\n+  if (curr_thr->state != THREAD_EXITED)\n+    return curr_thr;\n+\n+  return nullptr;\n+}\n+\n void _initialize_gcore ();\n void\n _initialize_gcore ()"
    },
    {
      "sha": "7e8e316926b0c7a9a91176cc3ee79a261262aa54",
      "filename": "gdb/gcore.h",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/gcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.h?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -22,10 +22,19 @@\n \n #include \"gdb_bfd.h\"\n \n+struct thread_info;\n+\n extern gdb_bfd_ref_ptr create_gcore_bfd (const char *filename);\n extern void write_gcore_file (bfd *obfd);\n extern int objfile_find_memory_regions (struct target_ops *self,\n \t\t\t\t\tfind_memory_region_ftype func,\n \t\t\t\t\tvoid *obfd);\n \n+/* Find the signalled thread.  In case there's more than one signalled\n+   thread, prefer the current thread, if it is signalled.  If no thread was\n+   signalled, default to the current thread, unless it has exited, in which\n+   case return NULL.  */\n+\n+extern thread_info *gcore_find_signalled_thread ();\n+\n #endif /* GCORE_H */"
    },
    {
      "sha": "5bfd82d1673231aaeee8ce3dd418ac33b8995aa2",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 134,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3a5df7bd65bea1840d00bd65d5eee7e339ca8da/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=f3a5df7bd65bea1840d00bd65d5eee7e339ca8da",
      "patch": "@@ -39,6 +39,8 @@\n #include \"gdb_regex.h\"\n #include \"gdbsupport/enum-flags.h\"\n #include \"gdbsupport/gdb_optional.h\"\n+#include \"gcore.h\"\n+#include \"gcore-elf.h\"\n \n #include <ctype.h>\n \n@@ -1597,104 +1599,6 @@ linux_make_mappings_corefile_notes (struct gdbarch *gdbarch, bfd *obfd,\n     }\n }\n \n-/* Structure for passing information from\n-   linux_collect_thread_registers via an iterator to\n-   linux_collect_regset_section_cb. */\n-\n-struct linux_collect_regset_section_cb_data\n-{\n-  linux_collect_regset_section_cb_data (struct gdbarch *gdbarch,\n-\t\t\t\t\tconst struct regcache *regcache,\n-\t\t\t\t\tbfd *obfd,\n-\t\t\t\t\tgdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t\t\tint *note_size,\n-\t\t\t\t\tunsigned long lwp,\n-\t\t\t\t\tgdb_signal stop_signal)\n-    : gdbarch (gdbarch), regcache (regcache), obfd (obfd),\n-      note_data (note_data), note_size (note_size), lwp (lwp),\n-      stop_signal (stop_signal)\n-  {}\n-\n-  struct gdbarch *gdbarch;\n-  const struct regcache *regcache;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> &note_data;\n-  int *note_size;\n-  unsigned long lwp;\n-  enum gdb_signal stop_signal;\n-  bool abort_iteration = false;\n-};\n-\n-/* Callback for iterate_over_regset_sections that records a single\n-   regset in the corefile note section.  */\n-\n-static void\n-linux_collect_regset_section_cb (const char *sect_name, int supply_size,\n-\t\t\t\t int collect_size, const struct regset *regset,\n-\t\t\t\t const char *human_name, void *cb_data)\n-{\n-  struct linux_collect_regset_section_cb_data *data\n-    = (struct linux_collect_regset_section_cb_data *) cb_data;\n-  bool variable_size_section = (regset != NULL\n-\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n-\n-  if (!variable_size_section)\n-    gdb_assert (supply_size == collect_size);\n-\n-  if (data->abort_iteration)\n-    return;\n-\n-  gdb_assert (regset && regset->collect_regset);\n-\n-  /* This is intentionally zero-initialized by using std::vector, so\n-     that any padding bytes in the core file will show as 0.  */\n-  std::vector<gdb_byte> buf (collect_size);\n-\n-  regset->collect_regset (regset, data->regcache, -1, buf.data (),\n-\t\t\t  collect_size);\n-\n-  /* PRSTATUS still needs to be treated specially.  */\n-  if (strcmp (sect_name, \".reg\") == 0)\n-    data->note_data.reset (elfcore_write_prstatus\n-\t\t\t     (data->obfd, data->note_data.release (),\n-\t\t\t      data->note_size, data->lwp,\n-\t\t\t      gdb_signal_to_host (data->stop_signal),\n-\t\t\t      buf.data ()));\n-  else\n-    data->note_data.reset (elfcore_write_register_note\n-\t\t\t   (data->obfd, data->note_data.release (),\n-\t\t\t    data->note_size, sect_name, buf.data (),\n-\t\t\t    collect_size));\n-\n-  if (data->note_data == NULL)\n-    data->abort_iteration = true;\n-}\n-\n-/* Records the thread's register state for the corefile note\n-   section.  */\n-\n-static void\n-linux_collect_thread_registers (const struct regcache *regcache,\n-\t\t\t\tptid_t ptid, bfd *obfd,\n-\t\t\t\tgdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t\tint *note_size,\n-\t\t\t\tenum gdb_signal stop_signal)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-\n-  /* For remote targets the LWP may not be available, so use the TID.  */\n-  long lwp = ptid.lwp ();\n-  if (lwp == 0)\n-    lwp = ptid.tid ();\n-\n-  linux_collect_regset_section_cb_data data (gdbarch, regcache, obfd, note_data,\n-\t\t\t\t\t     note_size, lwp, stop_signal);\n-\n-  gdbarch_iterate_over_regset_sections (gdbarch,\n-\t\t\t\t\tlinux_collect_regset_section_cb,\n-\t\t\t\t\t&data, regcache);\n-}\n-\n /* Fetch the siginfo data for the specified thread, if it exists.  If\n    there is no data, or we could not read it, return an empty\n    buffer.  */\n@@ -1746,22 +1650,17 @@ static void\n linux_corefile_thread (struct thread_info *info,\n \t\t       struct linux_corefile_thread_data *args)\n {\n-  struct regcache *regcache;\n-\n-  regcache = get_thread_arch_regcache (info->inf->process_target (),\n-\t\t\t\t       info->ptid, args->gdbarch);\n-\n-  target_fetch_registers (regcache, -1);\n-  gdb::byte_vector siginfo_data = linux_get_siginfo_data (info, args->gdbarch);\n-\n-  linux_collect_thread_registers (regcache, info->ptid, args->obfd,\n-\t\t\t\t  args->note_data, args->note_size,\n-\t\t\t\t  args->stop_signal);\n+  gcore_elf_build_thread_register_notes (args->gdbarch, info,\n+\t\t\t\t\t args->stop_signal,\n+\t\t\t\t\t args->obfd, &args->note_data,\n+\t\t\t\t\t args->note_size);\n \n   /* Don't return anything if we got no register information above,\n      such a core file is useless.  */\n   if (args->note_data != NULL)\n     {\n+      gdb::byte_vector siginfo_data\n+\t= linux_get_siginfo_data (info, args->gdbarch);\n       if (!siginfo_data.empty ())\n \targs->note_data.reset (elfcore_write_note (args->obfd,\n \t\t\t\t\t\t   args->note_data.release (),\n@@ -1960,30 +1859,6 @@ linux_fill_prpsinfo (struct elf_internal_linux_prpsinfo *p)\n   return 1;\n }\n \n-/* Find the signalled thread.  In case there's more than one signalled\n-   thread, prefer the current thread, if it is signalled.  If no\n-   thread was signalled, default to the current thread, unless it has\n-   exited, in which case return NULL.  */\n-\n-static thread_info *\n-find_signalled_thread ()\n-{\n-  thread_info *curr_thr = inferior_thread ();\n-  if (curr_thr->state != THREAD_EXITED\n-      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n-    return curr_thr;\n-\n-  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n-    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n-      return thr;\n-\n-  /* Default to the current thread, unless it has exited.  */\n-  if (curr_thr->state != THREAD_EXITED)\n-    return curr_thr;\n-\n-  return nullptr;\n-}\n-\n /* Build the note section for a corefile, and return it in a malloc\n    buffer.  */\n \n@@ -2021,7 +1896,7 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n   /* Like the kernel, prefer dumping the signalled thread first.\n      \"First thread\" is what tools use to infer the signalled\n      thread.  */\n-  thread_info *signalled_thr = find_signalled_thread ();\n+  thread_info *signalled_thr = gcore_find_signalled_thread ();\n   gdb_signal stop_signal;\n   if (signalled_thr != nullptr)\n     stop_signal = signalled_thr->suspend.stop_signal;"
    }
  ]
}