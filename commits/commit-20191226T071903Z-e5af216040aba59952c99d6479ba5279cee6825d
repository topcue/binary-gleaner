{
  "sha": "e5af216040aba59952c99d6479ba5279cee6825d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTVhZjIxNjA0MGFiYTU5OTUyYzk5ZDY0NzliYTUyNzljZWU2ODI1ZA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-26T01:55:31Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-26T07:19:03Z"
    },
    "message": "asan: som: heap-buffer-overflow\n\nTriggered by overflow of size calulation resulting in a too small\nbuffer.  The testcase found one of the som_bfd_count_ar_symbols\nproblems.\n\n\t* som.c (setup_sections): Don't overflow space_strings_size.  Use\n\tbfd_malloc2 to catch overflow of size calculation.\n\t(som_prep_for_fixups): Use bfd_zalloc2 to catch overflow of size\n\tcalculation.\n\t(som_build_and_write_symbol_table): Similarly use bfd_zmalloc2.\n\t(som_slurp_symbol_table): Similarly use bfd_zmalloc2, bfd_malloc2,\n\tand bfd_zalloc2.\n\t(bfd_som_attach_aux_hdr): Use size_t vars for string length.\n\t(som_bfd_count_ar_symbols): Use bfd_malloc2 to catch overflow of\n\tsize calculation.  Use size_t vars for length and catch overflow.\n\t(som_slurp_armap): Use bfd_alloc2 to catch overflow of size\n\tcalculation.\n\t(som_bfd_ar_write_symbol_stuff): Similarly use bfd_zmalloc2 and\n\tbfd_malloc2.  Perform size calculations in bfd_size_type.",
    "tree": {
      "sha": "6f012dedae343b175af25c56e1759149b4a7bbb0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6f012dedae343b175af25c56e1759149b4a7bbb0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e5af216040aba59952c99d6479ba5279cee6825d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e5af216040aba59952c99d6479ba5279cee6825d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e5af216040aba59952c99d6479ba5279cee6825d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e5af216040aba59952c99d6479ba5279cee6825d/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cef2097a8731b04accf50d99c9b5a556cebd5f15",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cef2097a8731b04accf50d99c9b5a556cebd5f15",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cef2097a8731b04accf50d99c9b5a556cebd5f15"
    }
  ],
  "stats": {
    "total": 117,
    "additions": 69,
    "deletions": 48
  },
  "files": [
    {
      "sha": "838d9ee0b4c98e301d14e4cb990f67e78dec0b80",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e5af216040aba59952c99d6479ba5279cee6825d/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e5af216040aba59952c99d6479ba5279cee6825d/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=e5af216040aba59952c99d6479ba5279cee6825d",
      "patch": "@@ -1,3 +1,20 @@\n+2019-12-26  Alan Modra  <amodra@gmail.com>\n+\n+\t* som.c (setup_sections): Don't overflow space_strings_size.  Use\n+\tbfd_malloc2 to catch overflow of size calculation.\n+\t(som_prep_for_fixups): Use bfd_zalloc2 to catch overflow of size\n+\tcalculation.\n+\t(som_build_and_write_symbol_table): Similarly use bfd_zmalloc2.\n+\t(som_slurp_symbol_table): Similarly use bfd_zmalloc2, bfd_malloc2,\n+\tand bfd_zalloc2.\n+\t(bfd_som_attach_aux_hdr): Use size_t vars for string length.\n+\t(som_bfd_count_ar_symbols): Use bfd_malloc2 to catch overflow of\n+\tsize calculation.  Use size_t vars for length and catch overflow.\n+\t(som_slurp_armap): Use bfd_alloc2 to catch overflow of size\n+\tcalculation.\n+\t(som_bfd_ar_write_symbol_stuff): Similarly use bfd_zmalloc2 and\n+\tbfd_malloc2.  Perform size calculations in bfd_size_type.\n+\n 2019-12-26  Hannes Domani  <ssbssa@yahoo.de>\n \n \t* peicode.h (pe_bfd_read_buildid): Free data."
    },
    {
      "sha": "ce69eac563e8e027ba929f4ecdec3e65ad3bb587",
      "filename": "bfd/som.c",
      "status": "modified",
      "additions": 52,
      "deletions": 48,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e5af216040aba59952c99d6479ba5279cee6825d/bfd/som.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e5af216040aba59952c99d6479ba5279cee6825d/bfd/som.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/som.c?ref=e5af216040aba59952c99d6479ba5279cee6825d",
      "patch": "@@ -2074,7 +2074,7 @@ setup_sections (bfd *abfd,\n \t\tstruct som_header *file_hdr,\n \t\tunsigned long current_offset)\n {\n-  char *space_strings;\n+  char *space_strings = NULL;\n   unsigned int space_index, i;\n   unsigned int total_subspaces = 0;\n   asection **subspace_sections = NULL;\n@@ -2083,6 +2083,11 @@ setup_sections (bfd *abfd,\n \n   /* First, read in space names.  */\n   amt = file_hdr->space_strings_size;\n+  if (amt == (bfd_size_type) -1)\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      goto error_return;\n+    }\n   space_strings = bfd_malloc (amt + 1);\n   if (space_strings == NULL && amt != 0)\n     goto error_return;\n@@ -2339,9 +2344,7 @@ setup_sections (bfd *abfd,\n     }\n   /* Now that we've read in all the subspace records, we need to assign\n      a target index to each subspace.  */\n-  amt = total_subspaces;\n-  amt *= sizeof (asection *);\n-  subspace_sections = bfd_malloc (amt);\n+  subspace_sections = bfd_malloc2 (total_subspaces, sizeof (asection *));\n   if (subspace_sections == NULL)\n     goto error_return;\n \n@@ -2801,7 +2804,6 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n   unsigned long i;\n   asection *section;\n   asymbol **sorted_syms;\n-  bfd_size_type amt;\n \n   /* Most SOM relocations involving a symbol have a length which is\n      dependent on the index of the symbol.  So symbols which are\n@@ -2873,9 +2875,7 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n \n   /* Sort a copy of the symbol table, rather than the canonical\n      output symbol table.  */\n-  amt = num_syms;\n-  amt *= sizeof (asymbol *);\n-  sorted_syms = bfd_zalloc (abfd, amt);\n+  sorted_syms = bfd_zalloc2 (abfd, num_syms, sizeof (asymbol *));\n   memcpy (sorted_syms, syms, num_syms * sizeof (asymbol *));\n   qsort (sorted_syms, num_syms, sizeof (asymbol *), compare_syms);\n   obj_som_sorted_syms (abfd) = sorted_syms;\n@@ -4459,10 +4459,10 @@ som_build_and_write_symbol_table (bfd *abfd)\n \n   /* Compute total symbol table size and allocate a chunk of memory\n      to hold the symbol table as we build it.  */\n-  symtab_size = num_syms;\n-  symtab_size *= sizeof (struct som_external_symbol_dictionary_record);\n-  som_symtab = bfd_zmalloc (symtab_size);\n-  if (som_symtab == NULL && symtab_size != 0)\n+  som_symtab\n+    = bfd_zmalloc2 (num_syms,\n+\t\t    sizeof (struct som_external_symbol_dictionary_record));\n+  if (som_symtab == NULL && num_syms != 0)\n     goto error_return;\n \n   /* Walk over each symbol.  */\n@@ -4502,6 +4502,8 @@ som_build_and_write_symbol_table (bfd *abfd)\n   if (bfd_seek (abfd, symtab_location, SEEK_SET) != 0)\n     return FALSE;\n \n+  symtab_size = num_syms;\n+  symtab_size *= sizeof (struct som_external_symbol_dictionary_record);\n   if (bfd_bwrite ((void *) som_symtab, symtab_size, abfd) != symtab_size)\n     goto error_return;\n \n@@ -4652,20 +4654,18 @@ som_slurp_symbol_table (bfd *abfd)\n \n   stringtab = obj_som_stringtab (abfd);\n \n-  amt = symbol_count;\n-  amt *= sizeof (som_symbol_type);\n-  symbase = bfd_zmalloc (amt);\n+  symbase = bfd_zmalloc2 (symbol_count, sizeof (som_symbol_type));\n   if (symbase == NULL)\n     goto error_return;\n \n   /* Read in the external SOM representation.  */\n-  amt = symbol_count;\n-  amt *= symsize;\n-  buf = bfd_malloc (amt);\n-  if (buf == NULL && amt != 0)\n+  buf = bfd_malloc2 (symbol_count, symsize);\n+  if (buf == NULL)\n     goto error_return;\n   if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) != 0)\n     goto error_return;\n+  amt = symbol_count;\n+  amt *= symsize;\n   if (bfd_bread (buf, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5299,9 +5299,7 @@ som_slurp_reloc_table (bfd *abfd,\n   if (section->relocation != NULL)\n     return TRUE;\n \n-  amt = num_relocs;\n-  amt *= sizeof (arelent);\n-  internal_relocs = bfd_zalloc (abfd, (amt));\n+  internal_relocs = bfd_zalloc2 (abfd, num_relocs, sizeof (arelent));\n   if (internal_relocs == NULL)\n     return FALSE;\n \n@@ -5612,7 +5610,7 @@ bfd_som_attach_aux_hdr (bfd *abfd, int type, char *string)\n     }\n   else if (type == COPYRIGHT_AUX_ID)\n     {\n-      int len = strlen (string);\n+      size_t len = strlen (string);\n       int pad = 0;\n \n       if (len % 4)\n@@ -5887,16 +5885,16 @@ som_bfd_count_ar_symbols (bfd *abfd,\n \n   lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);\n \n-  amt = lst_header->hash_size * 4;\n-  hash_table = bfd_malloc (amt);\n-  if (hash_table == NULL && amt != 0)\n+  hash_table = bfd_malloc2 (lst_header->hash_size, 4);\n+  if (hash_table == NULL && lst_header->hash_size != 0)\n     goto error_return;\n \n   /* Don't forget to initialize the counter!  */\n   *count = 0;\n \n   /* Read in the hash table.  The has table is an array of 32bit file offsets\n      which point to the hash chains.  */\n+  amt = (bfd_size_type) lst_header->hash_size * 4;\n   if (bfd_bread ((void *) hash_table, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5969,13 +5967,13 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n   unsigned int string_loc;\n \n   lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);\n-  amt = lst_header->hash_size * 4;\n-  hash_table = bfd_malloc (amt);\n-  if (hash_table == NULL && amt != 0)\n+  hash_table = bfd_malloc2 (lst_header->hash_size, 4);\n+  if (hash_table == NULL && lst_header->hash_size != 0)\n     goto error_return;\n \n   /* Read in the hash table.  The has table is an array of 32bit file offsets\n      which point to the hash chains.  */\n+  amt = (bfd_size_type) lst_header->hash_size * 4;\n   if (bfd_bread ((void *) hash_table, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5984,11 +5982,13 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n   if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) != 0)\n     goto error_return;\n \n-  amt = lst_header->module_count * sizeof (struct som_external_som_entry);\n-  som_dict = bfd_malloc (amt);\n-  if (som_dict == NULL && amt != 0)\n+  som_dict = bfd_malloc2 (lst_header->module_count,\n+\t\t\t  sizeof (struct som_external_som_entry));\n+  if (som_dict == NULL && lst_header->module_count != 0)\n     goto error_return;\n \n+  amt = lst_header->module_count;\n+  amt *= sizeof (struct som_external_som_entry);\n   if (bfd_bread ((void *) som_dict, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5999,7 +5999,7 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n     {\n       struct som_external_lst_symbol_record lst_symbol;\n       unsigned int hash_val;\n-      unsigned int len;\n+      size_t len;\n       unsigned char ext_len[4];\n       char *name;\n \n@@ -6032,6 +6032,11 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n       len = bfd_getb32 (ext_len);\n \n       /* Allocate space for the name and null terminate it too.  */\n+      if (len == (size_t) -1)\n+\t{\n+\t  bfd_set_error (bfd_error_no_memory);\n+\t  goto error_return;\n+\t}\n       name = bfd_zalloc (abfd, (bfd_size_type) len + 1);\n       if (!name)\n \tgoto error_return;\n@@ -6076,6 +6081,11 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n \t  len = bfd_getb32 (ext_len);\n \n \t  /* Allocate space for the name and null terminate it too.  */\n+\t  if (len == (size_t) -1)\n+\t    {\n+\t      bfd_set_error (bfd_error_no_memory);\n+\t      goto error_return;\n+\t    }\n \t  name = bfd_zalloc (abfd, (bfd_size_type) len + 1);\n \t  if (!name)\n \t    goto error_return;\n@@ -6191,9 +6201,7 @@ som_slurp_armap (bfd *abfd)\n \n   /* Initialize the cache and allocate space for the library symbols.  */\n   ardata->cache = 0;\n-  amt = ardata->symdef_count;\n-  amt *= sizeof (carsym);\n-  ardata->symdefs = bfd_alloc (abfd, amt);\n+  ardata->symdefs = bfd_alloc2 (abfd, ardata->symdef_count, sizeof (carsym));\n   if (!ardata->symdefs)\n     return FALSE;\n \n@@ -6325,19 +6333,17 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,\n   unsigned int hash_size;\n \n   hash_size = bfd_getb32 (lst.hash_size);\n-  amt = hash_size * 4;\n-  hash_table = bfd_zmalloc (amt);\n+  hash_table = bfd_zmalloc2 (hash_size, 4);\n   if (hash_table == NULL && hash_size != 0)\n     goto error_return;\n \n   module_count = bfd_getb32 (lst.module_count);\n-  amt = module_count * sizeof (struct som_external_som_entry);\n-  som_dict = bfd_zmalloc (amt);\n+  som_dict = bfd_zmalloc2 (module_count, sizeof (struct som_external_som_entry));\n   if (som_dict == NULL && module_count != 0)\n     goto error_return;\n \n-  amt = hash_size * sizeof (struct som_external_lst_symbol_record *);\n-  last_hash_entry = bfd_zmalloc (amt);\n+  last_hash_entry\n+    = bfd_zmalloc2 (hash_size, sizeof (struct som_external_lst_symbol_record *));\n   if (last_hash_entry == NULL && hash_size != 0)\n     goto error_return;\n \n@@ -6365,9 +6371,7 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,\n   curr_som_offset = (curr_som_offset + 0x1) & ~0x1;\n \n   /* FIXME should be done with buffers just like everything else...  */\n-  amt = nsyms;\n-  amt *= sizeof (struct som_external_lst_symbol_record);\n-  lst_syms = bfd_malloc (amt);\n+  lst_syms = bfd_malloc2 (nsyms, sizeof (struct som_external_lst_symbol_record));\n   if (lst_syms == NULL && nsyms != 0)\n     goto error_return;\n   strings = bfd_malloc ((bfd_size_type) string_size);\n@@ -6515,17 +6519,17 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,\n     }\n \n   /* Now scribble out the hash table.  */\n-  amt = hash_size * 4;\n+  amt = (bfd_size_type) hash_size * 4;\n   if (bfd_bwrite ((void *) hash_table, amt, abfd) != amt)\n     goto error_return;\n \n   /* Then the SOM dictionary.  */\n-  amt = module_count * sizeof (struct som_external_som_entry);\n+  amt = (bfd_size_type) module_count * sizeof (struct som_external_som_entry);\n   if (bfd_bwrite ((void *) som_dict, amt, abfd) != amt)\n     goto error_return;\n \n   /* The library symbols.  */\n-  amt = nsyms * sizeof (struct som_external_lst_symbol_record);\n+  amt = (bfd_size_type) nsyms * sizeof (struct som_external_lst_symbol_record);\n   if (bfd_bwrite ((void *) lst_syms, amt, abfd) != amt)\n     goto error_return;\n "
    }
  ]
}