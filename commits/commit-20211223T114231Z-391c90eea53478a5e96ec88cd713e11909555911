{
  "sha": "391c90eea53478a5e96ec88cd713e11909555911",
  "node_id": "C_kwDOANOeidoAKDM5MWM5MGVlYTUzNDc4YTVlOTZlYzg4Y2Q3MTNlMTE5MDk1NTU5MTE",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-11T15:17:27Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-23T11:42:31Z"
    },
    "message": "gdb: make use of SCOPE_EXIT to manage thread executing state\n\nWhile working on another patch relating to how GDB manages threads\nexecuting and resumed state, I spotted the following code in\nrecord-btrace.c:\n\n  executing = tp->executing ();\n  set_executing (proc_target, inferior_ptid, false);\n\n  id = null_frame_id;\n  try\n    {\n      id = get_frame_id (get_current_frame ());\n    }\n  catch (const gdb_exception &except)\n    {\n      /* Restore the previous execution state.  */\n      set_executing (proc_target, inferior_ptid, executing);\n\n      throw;\n    }\n\n  /* Restore the previous execution state.  */\n  set_executing (proc_target, inferior_ptid, executing);\n\n  return id;\n\nI notice that we only catch the exception so we can call\nset_executing, and this is the same call to set_executing that we need\nto perform in the non-exception return path.\n\nThis would be much cleaner if we could use SCOPE_EXIT to avoid the\ntry/catch, so lets do that.\n\nWhile cleaning this up, I also applied a similar patch to\nrecord-full.c, though there's no try/catch in that case, but using\nSCOPE_EXIT makes the code safe if, in the future, we do start throwing\nexceptions.\n\nThere should be no user visible changes after this commit.",
    "tree": {
      "sha": "ac5b19be7b4485ebd87279dcdcc2ea57e4a0b72b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ac5b19be7b4485ebd87279dcdcc2ea57e4a0b72b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/391c90eea53478a5e96ec88cd713e11909555911",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/391c90eea53478a5e96ec88cd713e11909555911",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/391c90eea53478a5e96ec88cd713e11909555911",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/391c90eea53478a5e96ec88cd713e11909555911/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "7898f55ba03f2e0d9f59159c900c273da98a9c94",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7898f55ba03f2e0d9f59159c900c273da98a9c94",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7898f55ba03f2e0d9f59159c900c273da98a9c94"
    }
  ],
  "stats": {
    "total": 32,
    "additions": 9,
    "deletions": 23
  },
  "files": [
    {
      "sha": "a6ce3db64e57d8e857ad092c19b537f4dac4fa34",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 4,
      "deletions": 20,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/391c90eea53478a5e96ec88cd713e11909555911/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/391c90eea53478a5e96ec88cd713e11909555911/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=391c90eea53478a5e96ec88cd713e11909555911",
      "patch": "@@ -1980,9 +1980,6 @@ record_btrace_resume_thread (struct thread_info *tp,\n static struct frame_id\n get_thread_current_frame_id (struct thread_info *tp)\n {\n-  struct frame_id id;\n-  bool executing;\n-\n   /* Set current thread, which is implicitly used by\n      get_current_frame.  */\n   scoped_restore_current_thread restore_thread;\n@@ -1998,26 +1995,13 @@ get_thread_current_frame_id (struct thread_info *tp)\n      For the former, EXECUTING is true and we're in wait, about to\n      move the thread.  Since we need to recompute the stack, we temporarily\n      set EXECUTING to false.  */\n-  executing = tp->executing ();\n+  bool executing = tp->executing ();\n   set_executing (proc_target, inferior_ptid, false);\n-\n-  id = null_frame_id;\n-  try\n-    {\n-      id = get_frame_id (get_current_frame ());\n-    }\n-  catch (const gdb_exception &except)\n+  SCOPE_EXIT\n     {\n-      /* Restore the previous execution state.  */\n       set_executing (proc_target, inferior_ptid, executing);\n-\n-      throw;\n-    }\n-\n-  /* Restore the previous execution state.  */\n-  set_executing (proc_target, inferior_ptid, executing);\n-\n-  return id;\n+    };\n+  return get_frame_id (get_current_frame ());\n }\n \n /* Start replaying a thread.  */"
    },
    {
      "sha": "11a9457027c6a82bbb782532a90d907fcbde4513",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/391c90eea53478a5e96ec88cd713e11909555911/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/391c90eea53478a5e96ec88cd713e11909555911/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=391c90eea53478a5e96ec88cd713e11909555911",
      "patch": "@@ -1249,11 +1249,13 @@ record_full_wait_1 (struct target_ops *ops,\n \t\t\t  /* Try to insert the software single step breakpoint.\n \t\t\t     If insert success, set step to 0.  */\n \t\t\t  set_executing (proc_target, inferior_ptid, false);\n-\t\t\t  reinit_frame_cache ();\n+\t\t\t  SCOPE_EXIT\n+\t\t\t    {\n+\t\t\t      set_executing (proc_target, inferior_ptid, true);\n+\t\t\t    };\n \n+\t\t\t  reinit_frame_cache ();\n \t\t\t  step = !insert_single_step_breakpoints (gdbarch);\n-\n-\t\t\t  set_executing (proc_target, inferior_ptid, true);\n \t\t\t}\n \n \t\t      if (record_debug)"
    }
  ]
}