{
  "sha": "8d64371b6b710831ddfd6a8636097396040476ee",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGQ2NDM3MWI2YjcxMDgzMWRkZmQ2YTg2MzYwOTczOTYwNDA0NzZlZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-06T18:15:05Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-15T22:35:56Z"
    },
    "message": "Remove cleanup from remote.c\n\nThis removes the remaining cleanup from remote.c, by changing\nremote_state::buf to be a gdb::char_vector, and then fixing up all the\nfallout.  The resulting patch is somewhat ugly, but on the other hand,\nit eliminates some possibilities for mistakes.\n\nRegression tested using the\nFedora-x86_64-native-extended-gdbserver-m64 builder on the buildbot.\n\ngdb/ChangeLog\n2019-01-15  Tom Tromey  <tom@tromey.com>\n\n\t* remote.c (class remote_state) <buf>: Now a char_vector.\n\t<buf_size>: Remove.\n\t(remote_target::getpkt): Change type of buf.  Remove sizeof_buf\n\tparameter.\n\t(remote_target::getpkt_or_notif_sane_1)\n\t(remote_target::getpkt_sane)\n\t(remote_target::getpkt_or_notif_sane): Likewise.\n\t(class remote_target) <putpkt>: New overload.\n\t(remote_target::read_frame): Change type of \"buf_p\".  Remove\n\tsizeof_p parameter.\n\t(packet_ok): New overload.\n\t(packet_check_result): New overload.\n\tUpdate all uses.",
    "tree": {
      "sha": "9490af708be90394f58de0bef90d1cb9732b9098",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9490af708be90394f58de0bef90d1cb9732b9098"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8d64371b6b710831ddfd6a8636097396040476ee",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8d64371b6b710831ddfd6a8636097396040476ee",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8d64371b6b710831ddfd6a8636097396040476ee",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8d64371b6b710831ddfd6a8636097396040476ee/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bb27775165d9b992120371383012404e213b1981",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb27775165d9b992120371383012404e213b1981",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb27775165d9b992120371383012404e213b1981"
    }
  ],
  "stats": {
    "total": 858,
    "additions": 440,
    "deletions": 418
  },
  "files": [
    {
      "sha": "6b51d4476051e0b29484dae3e6999da3e7ac030d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d64371b6b710831ddfd6a8636097396040476ee/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d64371b6b710831ddfd6a8636097396040476ee/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8d64371b6b710831ddfd6a8636097396040476ee",
      "patch": "@@ -1,3 +1,19 @@\n+2019-01-15  Tom Tromey  <tom@tromey.com>\n+\n+\t* remote.c (class remote_state) <buf>: Now a char_vector.\n+\t<buf_size>: Remove.\n+\t(remote_target::getpkt): Change type of buf.  Remove sizeof_buf\n+\tparameter.\n+\t(remote_target::getpkt_or_notif_sane_1)\n+\t(remote_target::getpkt_sane)\n+\t(remote_target::getpkt_or_notif_sane): Likewise.\n+\t(class remote_target) <putpkt>: New overload.\n+\t(remote_target::read_frame): Change type of \"buf_p\".  Remove\n+\tsizeof_p parameter.\n+\t(packet_ok): New overload.\n+\t(packet_check_result): New overload.\n+\tUpdate all uses.\n+\n 2019-01-14  Tom Tromey  <tom@tromey.com>\n \n \t* remote-notif.c (handle_notification, remote_notif_ack)"
    },
    {
      "sha": "4e2c85a223a4097166621059714dfeefe2ba0fa2",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 424,
      "deletions": 418,
      "changes": 842,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d64371b6b710831ddfd6a8636097396040476ee/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d64371b6b710831ddfd6a8636097396040476ee/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=8d64371b6b710831ddfd6a8636097396040476ee",
      "patch": "@@ -246,11 +246,10 @@ class remote_state\n   /* A buffer to use for incoming packets, and its current size.  The\n      buffer is grown dynamically for larger incoming packets.\n      Outgoing packets may also be constructed in this buffer.\n-     BUF_SIZE is always at least REMOTE_PACKET_SIZE;\n+     The size of the buffer is always at least REMOTE_PACKET_SIZE;\n      REMOTE_PACKET_SIZE should be used to limit the length of outgoing\n      packets.  */\n-  char *buf;\n-  long buf_size;\n+  gdb::char_vector buf;\n \n   /* True if we're going through initial connection setup (finding out\n      about the remote side's threads, relocating symbols, etc.).  */\n@@ -893,13 +892,18 @@ class remote_target : public process_stratum_target\n   int putpkt (const char *buf);\n   int putpkt_binary (const char *buf, int cnt);\n \n+  int putpkt (const gdb::char_vector &buf)\n+  {\n+    return putpkt (buf.data ());\n+  }\n+\n   void skip_frame ();\n-  long read_frame (char **buf_p, long *sizeof_buf);\n-  void getpkt (char **buf, long *sizeof_buf, int forever);\n-  int getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf, int forever,\n+  long read_frame (gdb::char_vector *buf_p);\n+  void getpkt (gdb::char_vector *buf, int forever);\n+  int getpkt_or_notif_sane_1 (gdb::char_vector *buf, int forever,\n \t\t\t      int expecting_notif, int *is_notif);\n-  int getpkt_sane (char **buf, long *sizeof_buf, int forever);\n-  int getpkt_or_notif_sane (char **buf, long *sizeof_buf, int forever,\n+  int getpkt_sane (gdb::char_vector *buf, int forever);\n+  int getpkt_or_notif_sane (gdb::char_vector *buf, int forever,\n \t\t\t    int *is_notif);\n   int remote_vkill (int pid);\n   void remote_kill_k ();\n@@ -1086,18 +1090,14 @@ struct remote_thread_info : public private_thread_info\n };\n \n remote_state::remote_state ()\n+  : buf (400)\n {\n-  /* The default buffer size is unimportant; it will be expanded\n-     whenever a larger buffer is needed. */\n-  this->buf_size = 400;\n-  this->buf = (char *) xmalloc (this->buf_size);\n }\n \n remote_state::~remote_state ()\n {\n   xfree (this->last_pass_packet);\n   xfree (this->last_program_signals_packet);\n-  xfree (this->buf);\n   xfree (this->finished_object);\n   xfree (this->finished_annex);\n }\n@@ -1133,8 +1133,8 @@ remote_target::remote_get_noisy_reply ()\n       char *buf;\n \n       QUIT;\t\t\t/* Allow user to bail out with ^C.  */\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      buf = rs->buf;\n+      getpkt (&rs->buf, 0);\n+      buf = rs->buf.data ();\n       if (buf[0] == 'E')\n \ttrace_error (buf);\n       else if (startswith (buf, \"qRelocInsn:\"))\n@@ -1187,7 +1187,7 @@ remote_target::remote_get_noisy_reply ()\n \t    {\n \t      adjusted_size = to - org_to;\n \n-\t      xsnprintf (buf, rs->buf_size, \"qRelocInsn:%x\", adjusted_size);\n+\t      xsnprintf (buf, rs->buf.size (), \"qRelocInsn:%x\", adjusted_size);\n \t      putpkt (buf);\n \t    }\n \t}\n@@ -1214,11 +1214,8 @@ remote_state::get_remote_arch_state (struct gdbarch *gdbarch)\n \n       /* Make sure that the packet buffer is plenty big enough for\n \t this architecture.  */\n-      if (this->buf_size < rsa->remote_packet_size)\n-\t{\n-\t  this->buf_size = 2 * rsa->remote_packet_size;\n-\t  this->buf = (char *) xrealloc (this->buf, this->buf_size);\n-\t}\n+      if (this->buf.size () < rsa->remote_packet_size)\n+\tthis->buf.resize (2 * rsa->remote_packet_size);\n     }\n   else\n     rsa = &it->second;\n@@ -1623,11 +1620,8 @@ remote_target::get_memory_packet_size (struct memory_packet_config *config)\n \n   /* Make sure there is room in the global buffer for this packet\n      (including its trailing NUL byte).  */\n-  if (rs->buf_size < what_they_get + 1)\n-    {\n-      rs->buf_size = 2 * what_they_get;\n-      rs->buf = (char *) xrealloc (rs->buf, 2 * what_they_get);\n-    }\n+  if (rs->buf.size () < what_they_get + 1)\n+    rs->buf.resize (2 * what_they_get);\n \n   return what_they_get;\n }\n@@ -1907,6 +1901,12 @@ packet_check_result (const char *buf)\n     return PACKET_UNKNOWN;\n }\n \n+static enum packet_result\n+packet_check_result (const gdb::char_vector &buf)\n+{\n+  return packet_check_result (buf.data ());\n+}\n+\n static enum packet_result\n packet_ok (const char *buf, struct packet_config *config)\n {\n@@ -1960,6 +1960,12 @@ packet_ok (const char *buf, struct packet_config *config)\n   return result;\n }\n \n+static enum packet_result\n+packet_ok (const gdb::char_vector &buf, struct packet_config *config)\n+{\n+  return packet_ok (buf.data (), config);\n+}\n+\n enum {\n   PACKET_vCont = 0,\n   PACKET_X,\n@@ -2319,22 +2325,22 @@ remote_target::remote_query_attached (int pid)\n     return 0;\n \n   if (remote_multi_process_p (rs))\n-    xsnprintf (rs->buf, size, \"qAttached:%x\", pid);\n+    xsnprintf (rs->buf.data (), size, \"qAttached:%x\", pid);\n   else\n-    xsnprintf (rs->buf, size, \"qAttached\");\n+    xsnprintf (rs->buf.data (), size, \"qAttached\");\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf,\n \t\t     &remote_protocol_packets[PACKET_qAttached]))\n     {\n     case PACKET_OK:\n-      if (strcmp (rs->buf, \"1\") == 0)\n+      if (strcmp (rs->buf.data (), \"1\") == 0)\n \treturn 1;\n       break;\n     case PACKET_ERROR:\n-      warning (_(\"Remote failure reply: %s\"), rs->buf);\n+      warning (_(\"Remote failure reply: %s\"), rs->buf.data ());\n       break;\n     case PACKET_UNKNOWN:\n       break;\n@@ -2590,7 +2596,7 @@ remote_target::pass_signals (int numsigs, const unsigned char *pass_signals)\n       if (!rs->last_pass_packet || strcmp (rs->last_pass_packet, pass_packet))\n \t{\n \t  putpkt (pass_packet);\n-\t  getpkt (&rs->buf, &rs->buf_size, 0);\n+\t  getpkt (&rs->buf, 0);\n \t  packet_ok (rs->buf, &remote_protocol_packets[PACKET_QPassSignals]);\n \t  if (rs->last_pass_packet)\n \t    xfree (rs->last_pass_packet);\n@@ -2669,7 +2675,7 @@ remote_target::set_syscall_catchpoint (int pid, bool needed, int any_count,\n   struct remote_state *rs = get_remote_state ();\n \n   putpkt (catch_packet);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   result = packet_ok (rs->buf, &remote_protocol_packets[PACKET_QCatchSyscalls]);\n   if (result == PACKET_OK)\n     return 0;\n@@ -2717,7 +2723,7 @@ remote_target::program_signals (int numsigs, const unsigned char *signals)\n \t  || strcmp (rs->last_program_signals_packet, packet) != 0)\n \t{\n \t  putpkt (packet);\n-\t  getpkt (&rs->buf, &rs->buf_size, 0);\n+\t  getpkt (&rs->buf, 0);\n \t  packet_ok (rs->buf, &remote_protocol_packets[PACKET_QProgramSignals]);\n \t  xfree (rs->last_program_signals_packet);\n \t  rs->last_program_signals_packet = packet;\n@@ -2736,8 +2742,8 @@ remote_target::set_thread (ptid_t ptid, int gen)\n {\n   struct remote_state *rs = get_remote_state ();\n   ptid_t state = gen ? rs->general_thread : rs->continue_thread;\n-  char *buf = rs->buf;\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *buf = rs->buf.data ();\n+  char *endbuf = buf + get_remote_packet_size ();\n \n   if (state == ptid)\n     return;\n@@ -2753,7 +2759,7 @@ remote_target::set_thread (ptid_t ptid, int gen)\n   else\n     write_ptid (buf, endbuf, ptid);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   if (gen)\n     rs->general_thread = ptid;\n   else\n@@ -2830,14 +2836,14 @@ remote_target::thread_alive (ptid_t ptid)\n   if (remote_thread_always_alive (ptid))\n     return 1;\n \n-  p = rs->buf;\n-  endp = rs->buf + get_remote_packet_size ();\n+  p = rs->buf.data ();\n+  endp = p + get_remote_packet_size ();\n \n   *p++ = 'T';\n   write_ptid (p, endp, ptid);\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   return (rs->buf[0] == 'O' && rs->buf[1] == 'K');\n }\n \n@@ -3242,7 +3248,7 @@ remote_target::remote_unpack_thread_info_response (char *pkt,\n   int mask, length;\n   int tag;\n   threadref ref;\n-  char *limit = pkt + rs->buf_size; /* Plausible parsing limit.  */\n+  char *limit = pkt + rs->buf.size (); /* Plausible parsing limit.  */\n   int retval = 1;\n \n   /* info->threadid = 0; FIXME: implement zero_threadref.  */\n@@ -3335,14 +3341,14 @@ remote_target::remote_get_threadinfo (threadref *threadid,\n   struct remote_state *rs = get_remote_state ();\n   int result;\n \n-  pack_threadinfo_request (rs->buf, fieldset, threadid);\n+  pack_threadinfo_request (rs->buf.data (), fieldset, threadid);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   if (rs->buf[0] == '\\0')\n     return 0;\n \n-  result = remote_unpack_thread_info_response (rs->buf + 2,\n+  result = remote_unpack_thread_info_response (&rs->buf[2],\n \t\t\t\t\t       threadid, info);\n   return result;\n }\n@@ -3376,7 +3382,7 @@ remote_target::parse_threadlist_response (char *pkt, int result_limit,\n \n   resultcount = 0;\n   /* Assume the 'q' and 'M chars have been stripped.  */\n-  limit = pkt + (rs->buf_size - BUF_THREAD_ID_SIZE);\n+  limit = pkt + (rs->buf.size () - BUF_THREAD_ID_SIZE);\n   /* done parse past here */\n   pkt = unpack_byte (pkt, &count);\t/* count field */\n   pkt = unpack_nibble (pkt, &done);\n@@ -3409,17 +3415,18 @@ remote_target::remote_get_threadlist (int startflag, threadref *nextthread,\n       >= get_remote_packet_size ())\n     result_limit = (get_remote_packet_size () / BUF_THREAD_ID_SIZE) - 2;\n \n-  pack_threadlist_request (rs->buf, startflag, result_limit, nextthread);\n+  pack_threadlist_request (rs->buf.data (), startflag, result_limit,\n+\t\t\t   nextthread);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  if (*rs->buf == '\\0')\n+  getpkt (&rs->buf, 0);\n+  if (rs->buf[0] == '\\0')\n     {\n       /* Packet not supported.  */\n       return -1;\n     }\n \n   *result_count =\n-    parse_threadlist_response (rs->buf + 2, result_limit,\n+    parse_threadlist_response (&rs->buf[2], result_limit,\n \t\t\t       &rs->echo_nextthread, threadlist, done);\n \n   if (!threadmatch (&rs->echo_nextthread, nextthread))\n@@ -3598,7 +3605,7 @@ remote_target::remote_current_thread (ptid_t oldpid)\n   struct remote_state *rs = get_remote_state ();\n \n   putpkt (\"qC\");\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   if (rs->buf[0] == 'Q' && rs->buf[1] == 'C')\n     {\n       const char *obuf;\n@@ -3733,8 +3740,8 @@ remote_target::remote_get_threads_with_qthreadinfo (threads_listing_context *con\n       const char *bufp;\n \n       putpkt (\"qfThreadInfo\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      bufp = rs->buf;\n+      getpkt (&rs->buf, 0);\n+      bufp = rs->buf.data ();\n       if (bufp[0] != '\\0')\t\t/* q packet recognized */\n \t{\n \t  while (*bufp++ == 'm')\t/* reply contains one or more TID */\n@@ -3746,8 +3753,8 @@ remote_target::remote_get_threads_with_qthreadinfo (threads_listing_context *con\n \t\t}\n \t      while (*bufp++ == ',');\t/* comma-separated list */\n \t      putpkt (\"qsThreadInfo\");\n-\t      getpkt (&rs->buf, &rs->buf_size, 0);\n-\t      bufp = rs->buf;\n+\t      getpkt (&rs->buf, 0);\n+\t      bufp = rs->buf.data ();\n \t    }\n \t  return 1;\n \t}\n@@ -3883,19 +3890,19 @@ remote_target::extra_thread_info (thread_info *tp)\n \n   if (rs->use_threadextra_query)\n     {\n-      char *b = rs->buf;\n-      char *endb = rs->buf + get_remote_packet_size ();\n+      char *b = rs->buf.data ();\n+      char *endb = b + get_remote_packet_size ();\n \n       xsnprintf (b, endb - b, \"qThreadExtraInfo,\");\n       b += strlen (b);\n       write_ptid (b, endb, tp->ptid);\n \n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n       if (rs->buf[0] != 0)\n \t{\n-\t  extra.resize (strlen (rs->buf) / 2);\n-\t  hex2bin (rs->buf, (gdb_byte *) &extra[0], extra.size ());\n+\t  extra.resize (strlen (rs->buf.data ()) / 2);\n+\t  hex2bin (rs->buf.data (), (gdb_byte *) &extra[0], extra.size ());\n \t  return extra.c_str ();\n \t}\n     }\n@@ -3933,14 +3940,14 @@ remote_target::static_tracepoint_marker_at (CORE_ADDR addr,\n \t\t\t\t\t    struct static_tracepoint_marker *marker)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n \n   xsnprintf (p, get_remote_packet_size (), \"qTSTMat:\");\n   p += strlen (p);\n   p += hexnumstr (p, addr);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  p = rs->buf;\n+  getpkt (&rs->buf, 0);\n+  p = rs->buf.data ();\n \n   if (*p == 'E')\n     error (_(\"Remote failure reply: %s\"), p);\n@@ -3965,8 +3972,8 @@ remote_target::static_tracepoint_markers_by_strid (const char *strid)\n   /* Ask for a first packet of static tracepoint marker\n      definition.  */\n   putpkt (\"qTfSTM\");\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  p = rs->buf;\n+  getpkt (&rs->buf, 0);\n+  p = rs->buf.data ();\n   if (*p == 'E')\n     error (_(\"Remote failure reply: %s\"), p);\n \n@@ -3982,8 +3989,8 @@ remote_target::static_tracepoint_markers_by_strid (const char *strid)\n       while (*p++ == ',');\t/* comma-separated list */\n       /* Ask for another packet of static tracepoint definition.  */\n       putpkt (\"qTsSTM\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      p = rs->buf;\n+      getpkt (&rs->buf, 0);\n+      p = rs->buf.data ();\n     }\n \n   return markers;\n@@ -4008,7 +4015,7 @@ remote_target::extended_remote_restart ()\n \n   /* Send the restart command; for reasons I don't understand the\n      remote side really expects a number after the \"R\".  */\n-  xsnprintf (rs->buf, get_remote_packet_size (), \"R%x\", 0);\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"R%x\", 0);\n   putpkt (rs->buf);\n \n   remote_fileio_reset ();\n@@ -4072,8 +4079,8 @@ remote_target::get_offsets ()\n     return;\n \n   putpkt (\"qOffsets\");\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  buf = rs->buf;\n+  getpkt (&rs->buf, 0);\n+  buf = rs->buf.data ();\n \n   if (buf[0] == '\\000')\n     return;\t\t\t/* Return silently.  Stub doesn't support\n@@ -4563,12 +4570,12 @@ remote_target::start_remote (int from_tty, int extended_p)\n     const char v_mustreplyempty[] = \"vMustReplyEmpty\";\n \n     putpkt (v_mustreplyempty);\n-    getpkt (&rs->buf, &rs->buf_size, 0);\n-    if (strcmp (rs->buf, \"OK\") == 0)\n+    getpkt (&rs->buf, 0);\n+    if (strcmp (rs->buf.data (), \"OK\") == 0)\n       remote_protocol_packets[PACKET_vFile_setfs].support = PACKET_DISABLE;\n-    else if (strcmp (rs->buf, \"\") != 0)\n+    else if (strcmp (rs->buf.data (), \"\") != 0)\n       error (_(\"Remote replied unexpectedly to '%s': %s\"), v_mustreplyempty,\n-\t     rs->buf);\n+\t     rs->buf.data ());\n   }\n \n   /* Next, we possibly activate noack mode.\n@@ -4588,7 +4595,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n   if (packet_config_support (noack_config) != PACKET_DISABLE)\n     {\n       putpkt (\"QStartNoAckMode\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n       if (packet_ok (rs->buf, noack_config) == PACKET_OK)\n \trs->noack_mode = 1;\n     }\n@@ -4597,7 +4604,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n     {\n       /* Tell the remote that we are using the extended protocol.  */\n       putpkt (\"!\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n     }\n \n   /* Let the target know which signals it is allowed to pass down to\n@@ -4624,10 +4631,11 @@ remote_target::start_remote (int from_tty, int extended_p)\n \t\t \"does not support non-stop\"));\n \n       putpkt (\"QNonStop:1\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n-      if (strcmp (rs->buf, \"OK\") != 0)\n-\terror (_(\"Remote refused setting non-stop mode with: %s\"), rs->buf);\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n+\terror (_(\"Remote refused setting non-stop mode with: %s\"),\n+\t       rs->buf.data ());\n \n       /* Find about threads and processes the stub is already\n \t controlling.  We default to adding them in the running state.\n@@ -4640,10 +4648,11 @@ remote_target::start_remote (int from_tty, int extended_p)\n       /* Don't assume that the stub can operate in all-stop mode.\n \t Request it explicitly.  */\n       putpkt (\"QNonStop:0\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n-      if (strcmp (rs->buf, \"OK\") != 0)\n-\terror (_(\"Remote refused setting all-stop mode with: %s\"), rs->buf);\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n+\terror (_(\"Remote refused setting all-stop mode with: %s\"),\n+\t       rs->buf.data ());\n     }\n \n   /* Upload TSVs regardless of whether the target is running or not.  The\n@@ -4659,7 +4668,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n \n   /* Check whether the target is running now.  */\n   putpkt (\"?\");\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   if (!target_is_non_stop_p ())\n     {\n@@ -4676,8 +4685,8 @@ remote_target::start_remote (int from_tty, int extended_p)\n       else\n \t{\n \t  /* Save the reply for later.  */\n-\t  wait_status = (char *) alloca (strlen (rs->buf) + 1);\n-\t  strcpy (wait_status, rs->buf);\n+\t  wait_status = (char *) alloca (strlen (rs->buf.data ()) + 1);\n+\t  strcpy (wait_status, rs->buf.data ());\n \t}\n \n       /* Fetch thread list.  */\n@@ -4742,7 +4751,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n \n       /* Use the previously fetched status.  */\n       gdb_assert (wait_status != NULL);\n-      strcpy (rs->buf, wait_status);\n+      strcpy (rs->buf.data (), wait_status);\n       rs->cached_wait_status = 1;\n \n       ::start_remote (from_tty); /* Initialize gdb process mechanisms.  */\n@@ -4761,14 +4770,14 @@ remote_target::start_remote (int from_tty, int extended_p)\n \t reply.  In the latter case, there may be more than one thread\n \t stopped --- we pull them all out using the vStopped\n \t mechanism.  */\n-      if (strcmp (rs->buf, \"OK\") != 0)\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n \t{\n \t  struct notif_client *notif = &notif_client_stop;\n \n \t  /* remote_notif_get_pending_replies acks this one, and gets\n \t     the rest out.  */\n \t  rs->notif_state->pending_event[notif_client_stop.id]\n-\t    = remote_notif_parse (this, notif, rs->buf);\n+\t    = remote_notif_parse (this, notif, rs->buf.data ());\n \t  remote_notif_get_pending_events (notif);\n \t}\n \n@@ -4883,10 +4892,8 @@ init_all_packet_configs (void)\n void\n remote_target::remote_check_symbols ()\n {\n-  char *reply, *tmp;\n+  char *tmp;\n   int end;\n-  long reply_size;\n-  struct cleanup *old_chain;\n \n   /* The remote side has no concept of inferiors that aren't running\n      yet, it only knows about running processes.  If we're connected\n@@ -4906,17 +4913,15 @@ remote_target::remote_check_symbols ()\n   /* Allocate a message buffer.  We can't reuse the input buffer in RS,\n      because we need both at the same time.  */\n   gdb::char_vector msg (get_remote_packet_size ());\n-  reply = (char *) xmalloc (get_remote_packet_size ());\n-  old_chain = make_cleanup (free_current_contents, &reply);\n-  reply_size = get_remote_packet_size ();\n+  gdb::char_vector reply (get_remote_packet_size ());\n \n   /* Invite target to request symbol lookups.  */\n \n   putpkt (\"qSymbol::\");\n-  getpkt (&reply, &reply_size, 0);\n+  getpkt (&reply, 0);\n   packet_ok (reply, &remote_protocol_packets[PACKET_qSymbol]);\n \n-  while (startswith (reply, \"qSymbol:\"))\n+  while (startswith (reply.data (), \"qSymbol:\"))\n     {\n       struct bound_minimal_symbol sym;\n \n@@ -4944,10 +4949,8 @@ remote_target::remote_check_symbols ()\n \t}\n \n       putpkt (msg.data ());\n-      getpkt (&reply, &reply_size, 0);\n+      getpkt (&reply, 0);\n     }\n-\n-  do_cleanups (old_chain);\n }\n \n static struct serial *\n@@ -4984,20 +4987,21 @@ remote_target::set_permissions ()\n {\n   struct remote_state *rs = get_remote_state ();\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"QAllow:\"\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"QAllow:\"\n \t     \"WriteReg:%x;WriteMem:%x;\"\n \t     \"InsertBreak:%x;InsertTrace:%x;\"\n \t     \"InsertFastTrace:%x;Stop:%x\",\n \t     may_write_registers, may_write_memory,\n \t     may_insert_breakpoints, may_insert_tracepoints,\n \t     may_insert_fast_tracepoints, may_stop);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   /* If the target didn't like the packet, warn the user.  Do not try\n      to undo the user's settings, that would just be maddening.  */\n-  if (strcmp (rs->buf, \"OK\") != 0)\n-    warning (_(\"Remote refused setting permissions with: %s\"), rs->buf);\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n+    warning (_(\"Remote refused setting permissions with: %s\"),\n+\t     rs->buf.data ());\n }\n \n /* This type describes each known response to the qSupported\n@@ -5291,21 +5295,21 @@ remote_target::remote_query_supported ()\n       q = \"qSupported:\" + q;\n       putpkt (q.c_str ());\n \n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n       /* If an error occured, warn, but do not return - just reset the\n \t buffer to empty and go on to disable features.  */\n       if (packet_ok (rs->buf, &remote_protocol_packets[PACKET_qSupported])\n \t  == PACKET_ERROR)\n \t{\n-\t  warning (_(\"Remote failure reply: %s\"), rs->buf);\n+\t  warning (_(\"Remote failure reply: %s\"), rs->buf.data ());\n \t  rs->buf[0] = 0;\n \t}\n     }\n \n   memset (seen, 0, sizeof (seen));\n \n-  next = rs->buf;\n+  next = rs->buf.data ();\n   while (*next)\n     {\n       enum packet_support is_supported;\n@@ -5382,11 +5386,8 @@ remote_target::remote_query_supported ()\n      buffer size also.  We delay this until after parsing the entire\n      qSupported packet, because this is the same buffer we were\n      parsing.  */\n-  if (rs->buf_size < rs->explicit_packet_size)\n-    {\n-      rs->buf_size = rs->explicit_packet_size;\n-      rs->buf = (char *) xrealloc (rs->buf, rs->buf_size);\n-    }\n+  if (rs->buf.size () < rs->explicit_packet_size)\n+    rs->buf.resize (rs->explicit_packet_size);\n \n   /* Handle the defaults for unmentioned features.  */\n   for (i = 0; i < ARRAY_SIZE (remote_protocol_features); i++)\n@@ -5649,12 +5650,12 @@ remote_target::remote_detach_pid (int pid)\n   set_general_process ();\n \n   if (remote_multi_process_p (rs))\n-    xsnprintf (rs->buf, get_remote_packet_size (), \"D;%x\", pid);\n+    xsnprintf (rs->buf.data (), get_remote_packet_size (), \"D;%x\", pid);\n   else\n-    strcpy (rs->buf, \"D\");\n+    strcpy (rs->buf.data (), \"D\");\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   if (rs->buf[0] == 'O' && rs->buf[1] == 'K')\n     ;\n@@ -5832,9 +5833,9 @@ extended_remote_target::attach (const char *args, int from_tty)\n       gdb_flush (gdb_stdout);\n     }\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"vAttach;%x\", pid);\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"vAttach;%x\", pid);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf,\n \t\t     &remote_protocol_packets[PACKET_vAttach]))\n@@ -5843,13 +5844,13 @@ extended_remote_target::attach (const char *args, int from_tty)\n       if (!target_is_non_stop_p ())\n \t{\n \t  /* Save the reply for later.  */\n-\t  wait_status = (char *) alloca (strlen (rs->buf) + 1);\n-\t  strcpy (wait_status, rs->buf);\n+\t  wait_status = (char *) alloca (strlen (rs->buf.data ()) + 1);\n+\t  strcpy (wait_status, rs->buf.data ());\n \t}\n-      else if (strcmp (rs->buf, \"OK\") != 0)\n+      else if (strcmp (rs->buf.data (), \"OK\") != 0)\n \terror (_(\"Attaching to %s failed with: %s\"),\n \t       target_pid_to_str (ptid_t (pid)),\n-\t       rs->buf);\n+\t       rs->buf.data ());\n       break;\n     case PACKET_UNKNOWN:\n       error (_(\"This target does not support attaching to a process\"));\n@@ -5911,7 +5912,7 @@ extended_remote_target::attach (const char *args, int from_tty)\n       else\n \t{\n \t  gdb_assert (wait_status != NULL);\n-\t  strcpy (rs->buf, wait_status);\n+\t  strcpy (rs->buf.data (), wait_status);\n \t  rs->cached_wait_status = 1;\n \t}\n     }\n@@ -5946,10 +5947,10 @@ remote_target::remote_vcont_probe ()\n   remote_state *rs = get_remote_state ();\n   char *buf;\n \n-  strcpy (rs->buf, \"vCont?\");\n+  strcpy (rs->buf.data (), \"vCont?\");\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  buf = rs->buf;\n+  getpkt (&rs->buf, 0);\n+  buf = rs->buf.data ();\n \n   /* Make sure that the features we assume are supported.  */\n   if (startswith (buf, \"vCont\"))\n@@ -5988,7 +5989,7 @@ remote_target::remote_vcont_probe ()\n \tbuf[0] = 0;\n     }\n \n-  packet_ok (buf, &remote_protocol_packets[PACKET_vCont]);\n+  packet_ok (rs->buf, &remote_protocol_packets[PACKET_vCont]);\n }\n \n /* Helper function for building \"vCont\" resumptions.  Write a\n@@ -6128,7 +6129,7 @@ remote_target::remote_resume_with_hc (ptid_t ptid, int step,\n   for (thread_info *thread : all_non_exited_threads ())\n     resume_clear_thread_private_info (thread);\n \n-  buf = rs->buf;\n+  buf = rs->buf.data ();\n   if (::execution_direction == EXEC_REVERSE)\n     {\n       /* We don't pass signals to the target in reverse exec mode.  */\n@@ -6184,8 +6185,8 @@ remote_target::remote_resume_with_vcont (ptid_t ptid, int step,\n   if (packet_support (PACKET_vCont) == PACKET_DISABLE)\n     return 0;\n \n-  p = rs->buf;\n-  endp = rs->buf + get_remote_packet_size ();\n+  p = rs->buf.data ();\n+  endp = p + get_remote_packet_size ();\n \n   /* If we could generate a wider range of packets, we'd have to worry\n      about overflowing BUF.  Should there be a generic\n@@ -6226,17 +6227,18 @@ remote_target::remote_resume_with_vcont (ptid_t ptid, int step,\n       append_resumption (p, endp, ptid, step, siggnal);\n     }\n \n-  gdb_assert (strlen (rs->buf) < get_remote_packet_size ());\n+  gdb_assert (strlen (rs->buf.data ()) < get_remote_packet_size ());\n   putpkt (rs->buf);\n \n   if (target_is_non_stop_p ())\n     {\n       /* In non-stop, the stub replies to vCont with \"OK\".  The stop\n \t reply will be reported asynchronously by means of a `%Stop'\n \t notification.  */\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      if (strcmp (rs->buf, \"OK\") != 0)\n-\terror (_(\"Unexpected vCont reply in non-stop mode: %s\"), rs->buf);\n+      getpkt (&rs->buf, 0);\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n+\terror (_(\"Unexpected vCont reply in non-stop mode: %s\"),\n+\t       rs->buf.data ());\n     }\n \n   return 1;\n@@ -6367,8 +6369,8 @@ vcont_builder::restart ()\n {\n   struct remote_state *rs = m_remote->get_remote_state ();\n \n-  m_p = rs->buf;\n-  m_endp = rs->buf + m_remote->get_remote_packet_size ();\n+  m_p = rs->buf.data ();\n+  m_endp = m_p + m_remote->get_remote_packet_size ();\n   m_p += xsnprintf (m_p, m_endp - m_p, \"vCont\");\n   m_first_action = m_p;\n }\n@@ -6386,9 +6388,9 @@ vcont_builder::flush ()\n \n   rs = m_remote->get_remote_state ();\n   m_remote->putpkt (rs->buf);\n-  m_remote->getpkt (&rs->buf, &rs->buf_size, 0);\n-  if (strcmp (rs->buf, \"OK\") != 0)\n-    error (_(\"Unexpected vCont reply in non-stop mode: %s\"), rs->buf);\n+  m_remote->getpkt (&rs->buf, 0);\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n+    error (_(\"Unexpected vCont reply in non-stop mode: %s\"), rs->buf.data ());\n }\n \n /* The largest action is range-stepping, with its two addresses.  This\n@@ -6609,8 +6611,8 @@ void\n remote_target::remote_stop_ns (ptid_t ptid)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n-  char *endp = rs->buf + get_remote_packet_size ();\n+  char *p = rs->buf.data ();\n+  char *endp = p + get_remote_packet_size ();\n \n   if (packet_support (PACKET_vCont) == PACKET_SUPPORT_UNKNOWN)\n     remote_vcont_probe ();\n@@ -6647,9 +6649,10 @@ remote_target::remote_stop_ns (ptid_t ptid)\n   /* In non-stop, we get an immediate OK reply.  The stop reply will\n      come in asynchronously by notification.  */\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  if (strcmp (rs->buf, \"OK\") != 0)\n-    error (_(\"Stopping %s failed: %s\"), target_pid_to_str (ptid), rs->buf);\n+  getpkt (&rs->buf, 0);\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n+    error (_(\"Stopping %s failed: %s\"), target_pid_to_str (ptid),\n+\t   rs->buf.data ());\n }\n \n /* All-stop version of target_interrupt.  Sends a break or a ^C to\n@@ -6682,15 +6685,15 @@ void\n remote_target::remote_interrupt_ns ()\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n-  char *endp = rs->buf + get_remote_packet_size ();\n+  char *p = rs->buf.data ();\n+  char *endp = p + get_remote_packet_size ();\n \n   xsnprintf (p, endp - p, \"vCtrlC\");\n \n   /* In non-stop, we get an immediate OK reply.  The stop reply will\n      come in asynchronously by notification.  */\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_vCtrlC]))\n     {\n@@ -6699,7 +6702,7 @@ remote_target::remote_interrupt_ns ()\n     case PACKET_UNKNOWN:\n       error (_(\"No support for interrupting the remote target.\"));\n     case PACKET_ERROR:\n-      error (_(\"Interrupting target failed: %s\"), rs->buf);\n+      error (_(\"Interrupting target failed: %s\"), rs->buf.data ());\n     }\n }\n \n@@ -7609,16 +7612,17 @@ remote_target::remote_notif_get_pending_events (notif_client *nc)\n \t\t\t    nc->name);\n \n       /* acknowledge */\n-      nc->ack (this, nc, rs->buf, rs->notif_state->pending_event[nc->id]);\n+      nc->ack (this, nc, rs->buf.data (),\n+\t       rs->notif_state->pending_event[nc->id]);\n       rs->notif_state->pending_event[nc->id] = NULL;\n \n       while (1)\n \t{\n-\t  getpkt (&rs->buf, &rs->buf_size, 0);\n-\t  if (strcmp (rs->buf, \"OK\") == 0)\n+\t  getpkt (&rs->buf, 0);\n+\t  if (strcmp (rs->buf.data (), \"OK\") == 0)\n \t    break;\n \t  else\n-\t    remote_notif_ack (this, nc, rs->buf);\n+\t    remote_notif_ack (this, nc, rs->buf.data ());\n \t}\n     }\n   else\n@@ -7705,8 +7709,7 @@ remote_target::wait_ns (ptid_t ptid, struct target_waitstatus *status, int optio\n   /* If in non-stop mode, get out of getpkt even if a\n      notification is received.\t*/\n \n-  ret = getpkt_or_notif_sane (&rs->buf, &rs->buf_size,\n-\t\t\t      0 /* forever */, &is_notif);\n+  ret = getpkt_or_notif_sane (&rs->buf, 0 /* forever */, &is_notif);\n   while (1)\n     {\n       if (ret != -1 && !is_notif)\n@@ -7716,13 +7719,13 @@ remote_target::wait_ns (ptid_t ptid, struct target_waitstatus *status, int optio\n \t    /* We're out of sync with the target now.  Did it continue\n \t       or not?  We can't tell which thread it was in non-stop,\n \t       so just ignore this.  */\n-\t    warning (_(\"Remote failure reply: %s\"), rs->buf);\n+\t    warning (_(\"Remote failure reply: %s\"), rs->buf.data ());\n \t    break;\n \t  case 'O':\t\t/* Console output.  */\n-\t    remote_console_output (rs->buf + 1);\n+\t    remote_console_output (&rs->buf[1]);\n \t    break;\n \t  default:\n-\t    warning (_(\"Invalid remote reply: %s\"), rs->buf);\n+\t    warning (_(\"Invalid remote reply: %s\"), rs->buf.data ());\n \t    break;\n \t  }\n \n@@ -7745,8 +7748,7 @@ remote_target::wait_ns (ptid_t ptid, struct target_waitstatus *status, int optio\n \t}\n \n       /* Otherwise do a blocking wait.  */\n-      ret = getpkt_or_notif_sane (&rs->buf, &rs->buf_size,\n-\t\t\t\t  1 /* forever */, &is_notif);\n+      ret = getpkt_or_notif_sane (&rs->buf, 1 /* forever */, &is_notif);\n     }\n }\n \n@@ -7790,8 +7792,7 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status, int options)\n \t _never_ wait for ever -> test on target_is_async_p().\n \t However, before we do that we need to ensure that the caller\n \t knows how to take the target into/out of async mode.  */\n-      ret = getpkt_or_notif_sane (&rs->buf, &rs->buf_size,\n-\t\t\t\t  forever, &is_notif);\n+      ret = getpkt_or_notif_sane (&rs->buf, forever, &is_notif);\n \n       /* GDB gets a notification.  Return to core as this event is\n \t not interesting.  */\n@@ -7802,7 +7803,7 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status, int options)\n \treturn minus_one_ptid;\n     }\n \n-  buf = rs->buf;\n+  buf = rs->buf.data ();\n \n   /* Assume that the target has acknowledged Ctrl-C unless we receive\n      an 'F' or 'O' packet.  */\n@@ -7840,7 +7841,7 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status, int options)\n \tstop_reply\n \t  = (struct stop_reply *) remote_notif_parse (this,\n \t\t\t\t\t\t      &notif_client_stop,\n-\t\t\t\t\t\t      rs->buf);\n+\t\t\t\t\t\t      rs->buf.data ());\n \n \tevent_ptid = process_stop_reply (stop_reply, status);\n \tbreak;\n@@ -7940,16 +7941,16 @@ remote_target::fetch_register_using_p (struct regcache *regcache,\n   if (reg->pnum == -1)\n     return 0;\n \n-  p = rs->buf;\n+  p = rs->buf.data ();\n   *p++ = 'p';\n   p += hexnumstr (p, reg->pnum);\n   *p++ = '\\0';\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n-  buf = rs->buf;\n+  buf = rs->buf.data ();\n \n-  switch (packet_ok (buf, &remote_protocol_packets[PACKET_p]))\n+  switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_p]))\n     {\n     case PACKET_OK:\n       break;\n@@ -7992,12 +7993,12 @@ remote_target::send_g_packet ()\n   struct remote_state *rs = get_remote_state ();\n   int buf_len;\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"g\");\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"g\");\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   if (packet_check_result (rs->buf) == PACKET_ERROR)\n     error (_(\"Could not read registers; remote failure reply '%s'\"),\n-           rs->buf);\n+           rs->buf.data ());\n \n   /* We can get out of synch in various cases.  If the first character\n      in the buffer is not a hex character, assume that has happened\n@@ -8010,14 +8011,14 @@ remote_target::send_g_packet ()\n       if (remote_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"Bad register packet; fetching a new packet\\n\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n     }\n \n-  buf_len = strlen (rs->buf);\n+  buf_len = strlen (rs->buf.data ());\n \n   /* Sanity check the received packet.  */\n   if (buf_len % 2 != 0)\n-    error (_(\"Remote 'g' packet reply is of odd length: %s\"), rs->buf);\n+    error (_(\"Remote 'g' packet reply is of odd length: %s\"), rs->buf.data ());\n \n   return buf_len / 2;\n }\n@@ -8032,12 +8033,14 @@ remote_target::process_g_packet (struct regcache *regcache)\n   char *p;\n   char *regs;\n \n-  buf_len = strlen (rs->buf);\n+  buf_len = strlen (rs->buf.data ());\n \n   /* Further sanity checks, with knowledge of the architecture.  */\n   if (buf_len > 2 * rsa->sizeof_g_packet)\n     error (_(\"Remote 'g' packet reply is too long (expected %ld bytes, got %d \"\n-\t     \"bytes): %s\"), rsa->sizeof_g_packet, buf_len / 2, rs->buf);\n+\t     \"bytes): %s\"),\n+\t   rsa->sizeof_g_packet, buf_len / 2,\n+\t   rs->buf.data ());\n \n   /* Save the size of the packet sent to us by the target.  It is used\n      as a heuristic when determining the max size of packets that the\n@@ -8087,7 +8090,7 @@ remote_target::process_g_packet (struct regcache *regcache)\n      hex characters.  Suck them all up, then supply them to the\n      register cacheing/storage mechanism.  */\n \n-  p = rs->buf;\n+  p = rs->buf.data ();\n   for (i = 0; i < rsa->sizeof_g_packet; i++)\n     {\n       if (p[0] == 0 || p[1] == 0)\n@@ -8109,13 +8112,13 @@ remote_target::process_g_packet (struct regcache *regcache)\n \n       if (r->in_g_packet)\n \t{\n-\t  if ((r->offset + reg_size) * 2 > strlen (rs->buf))\n+\t  if ((r->offset + reg_size) * 2 > strlen (rs->buf.data ()))\n \t    /* This shouldn't happen - we adjusted in_g_packet above.  */\n \t    internal_error (__FILE__, __LINE__,\n \t\t\t    _(\"unexpected end of 'g' packet reply\"));\n \t  else if (rs->buf[r->offset * 2] == 'x')\n \t    {\n-\t      gdb_assert (r->offset * 2 < strlen (rs->buf));\n+\t      gdb_assert (r->offset * 2 < strlen (rs->buf.data ()));\n \t      /* The register isn't available, mark it as such (at\n \t\t the same time setting the value to zero).  */\n \t      regcache->raw_supply (r->regnum, NULL);\n@@ -8240,7 +8243,7 @@ remote_target::store_register_using_P (const struct regcache *regcache,\n   struct gdbarch *gdbarch = regcache->arch ();\n   struct remote_state *rs = get_remote_state ();\n   /* Try storing a single register.  */\n-  char *buf = rs->buf;\n+  char *buf = rs->buf.data ();\n   gdb_byte *regp = (gdb_byte *) alloca (register_size (gdbarch, reg->regnum));\n   char *p;\n \n@@ -8255,15 +8258,15 @@ remote_target::store_register_using_P (const struct regcache *regcache,\n   regcache->raw_collect (reg->regnum, regp);\n   bin2hex (regp, p, register_size (gdbarch, reg->regnum));\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_P]))\n     {\n     case PACKET_OK:\n       return 1;\n     case PACKET_ERROR:\n       error (_(\"Could not write register \\\"%s\\\"; remote failure reply '%s'\"),\n-\t     gdbarch_register_name (gdbarch, reg->regnum), rs->buf);\n+\t     gdbarch_register_name (gdbarch, reg->regnum), rs->buf.data ());\n     case PACKET_UNKNOWN:\n       return 0;\n     default:\n@@ -8300,14 +8303,14 @@ remote_target::store_registers_using_G (const struct regcache *regcache)\n \n   /* Command describes registers byte by byte,\n      each byte encoded as two hex characters.  */\n-  p = rs->buf;\n+  p = rs->buf.data ();\n   *p++ = 'G';\n   bin2hex (regs, p, rsa->sizeof_g_packet);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   if (packet_check_result (rs->buf) == PACKET_ERROR)\n     error (_(\"Could not write registers; remote failure reply '%s'\"), \n-\t   rs->buf);\n+\t   rs->buf.data ());\n }\n \n /* Store register REGNUM, or all registers if REGNUM == -1, from the contents\n@@ -8450,16 +8453,16 @@ remote_target::check_binary_download (CORE_ADDR addr)\n       {\n \tchar *p;\n \n-\tp = rs->buf;\n+\tp = rs->buf.data ();\n \t*p++ = 'X';\n \tp += hexnumstr (p, (ULONGEST) addr);\n \t*p++ = ',';\n \tp += hexnumstr (p, (ULONGEST) 0);\n \t*p++ = ':';\n \t*p = '\\0';\n \n-\tputpkt_binary (rs->buf, (int) (p - rs->buf));\n-\tgetpkt (&rs->buf, &rs->buf_size, 0);\n+\tputpkt_binary (rs->buf.data (), (int) (p - rs->buf.data ()));\n+\tgetpkt (&rs->buf, 0);\n \n \tif (rs->buf[0] == '\\0')\n \t  {\n@@ -8568,8 +8571,8 @@ remote_target::remote_write_bytes_aux (const char *header, CORE_ADDR memaddr,\n \n   /* Construct the packet excluding the data: \"<header><memaddr>,<len>:\".  */\n \n-  strcat (rs->buf, header);\n-  p = rs->buf + strlen (header);\n+  strcat (rs->buf.data (), header);\n+  p = rs->buf.data () + strlen (header);\n \n   /* Compute a best guess of the number of bytes actually transfered.  */\n   if (packet_format == 'X')\n@@ -8669,8 +8672,8 @@ remote_target::remote_write_bytes_aux (const char *header, CORE_ADDR memaddr,\n       units_written = todo_units;\n     }\n \n-  putpkt_binary (rs->buf, (int) (p - rs->buf));\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  putpkt_binary (rs->buf.data (), (int) (p - rs->buf.data ()));\n+  getpkt (&rs->buf, 0);\n \n   if (rs->buf[0] == 'E')\n     return TARGET_XFER_E_IO;\n@@ -8756,21 +8759,21 @@ remote_target::remote_read_bytes_1 (CORE_ADDR memaddr, gdb_byte *myaddr,\n \n   /* Construct \"m\"<memaddr>\",\"<len>\".  */\n   memaddr = remote_address_masked (memaddr);\n-  p = rs->buf;\n+  p = rs->buf.data ();\n   *p++ = 'm';\n   p += hexnumstr (p, (ULONGEST) memaddr);\n   *p++ = ',';\n   p += hexnumstr (p, (ULONGEST) todo_units);\n   *p = '\\0';\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   if (rs->buf[0] == 'E'\n       && isxdigit (rs->buf[1]) && isxdigit (rs->buf[2])\n       && rs->buf[3] == '\\0')\n     return TARGET_XFER_E_IO;\n   /* Reply describes memory byte by byte, each byte encoded as two hex\n      characters.  */\n-  p = rs->buf;\n+  p = rs->buf.data ();\n   decoded_bytes = hex2bin (p, myaddr, todo_units * unit_size);\n   /* Return what we have.  Let higher layers handle partial reads.  */\n   *xfered_len_units = (ULONGEST) (decoded_bytes / unit_size);\n@@ -8911,7 +8914,7 @@ remote_target::remote_send_printf (const char *format, ...)\n   va_start (ap, format);\n \n   rs->buf[0] = '\\0';\n-  int size = vsnprintf (rs->buf, max_size, format, ap);\n+  int size = vsnprintf (rs->buf.data (), max_size, format, ap);\n \n   va_end (ap);\n \n@@ -8922,7 +8925,7 @@ remote_target::remote_send_printf (const char *format, ...)\n     error (_(\"Communication problem with target.\"));\n \n   rs->buf[0] = '\\0';\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   return packet_check_result (rs->buf);\n }\n@@ -9267,18 +9270,18 @@ remote_target::putpkt_binary (const char *buf, int cnt)\n \t\t   for an ack.  */\n \t\t/* We've found the start of a notification.  Now\n \t\t   collect the data.  */\n-\t\tval = read_frame (&rs->buf, &rs->buf_size);\n+\t\tval = read_frame (&rs->buf);\n \t\tif (val >= 0)\n \t\t  {\n \t\t    if (remote_debug)\n \t\t      {\n-\t\t\tstd::string str = escape_buffer (rs->buf, val);\n+\t\t\tstd::string str = escape_buffer (rs->buf.data (), val);\n \n \t\t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\t    \"  Notification received: %s\\n\",\n \t\t\t\t\t    str.c_str ());\n \t\t      }\n-\t\t    handle_notification (rs->notif_state, rs->buf);\n+\t\t    handle_notification (rs->notif_state, rs->buf.data ());\n \t\t    /* We're in sync now, rewait for the ack.  */\n \t\t    tcount = 0;\n \t\t  }\n@@ -9292,7 +9295,7 @@ remote_target::putpkt_binary (const char *buf, int cnt)\n \t\t\t    fprintf_unfiltered (gdb_stdlog, \"putpkt: Junk: \");\n \t\t\t  }\n \t\t\tfputc_unfiltered (ch & 0177, gdb_stdlog);\n-\t\t\tfprintf_unfiltered (gdb_stdlog, \"%s\", rs->buf);\n+\t\t\tfprintf_unfiltered (gdb_stdlog, \"%s\", rs->buf.data ());\n \t\t      }\n \t\t  }\n \t\tcontinue;\n@@ -9369,19 +9372,19 @@ remote_target::skip_frame ()\n /* Come here after finding the start of the frame.  Collect the rest\n    into *BUF, verifying the checksum, length, and handling run-length\n    compression.  NUL terminate the buffer.  If there is not enough room,\n-   expand *BUF using xrealloc.\n+   expand *BUF.\n \n    Returns -1 on error, number of characters in buffer (ignoring the\n    trailing NULL) on success. (could be extended to return one of the\n    SERIAL status indications).  */\n \n long\n-remote_target::read_frame (char **buf_p, long *sizeof_buf)\n+remote_target::read_frame (gdb::char_vector *buf_p)\n {\n   unsigned char csum;\n   long bc;\n   int c;\n-  char *buf = *buf_p;\n+  char *buf = buf_p->data ();\n   struct remote_state *rs = get_remote_state ();\n \n   csum = 0;\n@@ -9464,12 +9467,11 @@ remote_target::read_frame (char **buf_p, long *sizeof_buf)\n \n \t    if (repeat > 0 && repeat <= 255 && bc > 0)\n \t      {\n-\t\tif (bc + repeat - 1 >= *sizeof_buf - 1)\n+\t\tif (bc + repeat - 1 >= buf_p->size () - 1)\n \t\t  {\n \t\t    /* Make some more room in the buffer.  */\n-\t\t    *sizeof_buf += repeat;\n-\t\t    *buf_p = (char *) xrealloc (*buf_p, *sizeof_buf);\n-\t\t    buf = *buf_p;\n+\t\t    buf_p->resize (buf_p->size () + repeat);\n+\t\t    buf = buf_p->data ();\n \t\t  }\n \n \t\tmemset (&buf[bc], buf[bc - 1], repeat);\n@@ -9482,12 +9484,11 @@ remote_target::read_frame (char **buf_p, long *sizeof_buf)\n \t    return -1;\n \t  }\n \tdefault:\n-\t  if (bc >= *sizeof_buf - 1)\n+\t  if (bc >= buf_p->size () - 1)\n \t    {\n \t      /* Make some more room in the buffer.  */\n-\t      *sizeof_buf *= 2;\n-\t      *buf_p = (char *) xrealloc (*buf_p, *sizeof_buf);\n-\t      buf = *buf_p;\n+\t      buf_p->resize (buf_p->size () * 2);\n+\t      buf = buf_p->data ();\n \t    }\n \n \t  buf[bc++] = c;\n@@ -9498,36 +9499,35 @@ remote_target::read_frame (char **buf_p, long *sizeof_buf)\n }\n \n /* Read a packet from the remote machine, with error checking, and\n-   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold\n-   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever\n-   rather than timing out; this is used (in synchronous mode) to wait\n-   for a target that is is executing user code to stop.  */\n+   store it in *BUF.  Resize *BUF if necessary to hold the result.  If\n+   FOREVER, wait forever rather than timing out; this is used (in\n+   synchronous mode) to wait for a target that is is executing user\n+   code to stop.  */\n /* FIXME: ezannoni 2000-02-01 this wrapper is necessary so that we\n    don't have to change all the calls to getpkt to deal with the\n    return value, because at the moment I don't know what the right\n    thing to do it for those.  */\n \n void\n-remote_target::getpkt (char **buf, long *sizeof_buf, int forever)\n+remote_target::getpkt (gdb::char_vector *buf, int forever)\n {\n-  getpkt_sane (buf, sizeof_buf, forever);\n+  getpkt_sane (buf, forever);\n }\n \n \n /* Read a packet from the remote machine, with error checking, and\n-   store it in *BUF.  Resize *BUF using xrealloc if necessary to hold\n-   the result, and update *SIZEOF_BUF.  If FOREVER, wait forever\n-   rather than timing out; this is used (in synchronous mode) to wait\n-   for a target that is is executing user code to stop.  If FOREVER ==\n-   0, this function is allowed to time out gracefully and return an\n-   indication of this to the caller.  Otherwise return the number of\n-   bytes read.  If EXPECTING_NOTIF, consider receiving a notification\n-   enough reason to return to the caller.  *IS_NOTIF is an output\n-   boolean that indicates whether *BUF holds a notification or not\n-   (a regular packet).  */\n+   store it in *BUF.  Resize *BUF if necessary to hold the result.  If\n+   FOREVER, wait forever rather than timing out; this is used (in\n+   synchronous mode) to wait for a target that is is executing user\n+   code to stop.  If FOREVER == 0, this function is allowed to time\n+   out gracefully and return an indication of this to the caller.\n+   Otherwise return the number of bytes read.  If EXPECTING_NOTIF,\n+   consider receiving a notification enough reason to return to the\n+   caller.  *IS_NOTIF is an output boolean that indicates whether *BUF\n+   holds a notification or not (a regular packet).  */\n \n int\n-remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n+remote_target::getpkt_or_notif_sane_1 (gdb::char_vector *buf,\n \t\t\t\t       int forever, int expecting_notif,\n \t\t\t\t       int *is_notif)\n {\n@@ -9541,7 +9541,7 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n      previously cached response.  */\n   rs->cached_wait_status = 0;\n \n-  strcpy (*buf, \"timeout\");\n+  strcpy (buf->data (), \"timeout\");\n \n   if (forever)\n     timeout = watchdog > 0 ? watchdog : -1;\n@@ -9594,7 +9594,7 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n \t    {\n \t      /* We've found the start of a packet or notification.\n \t\t Now collect the data.  */\n-\t      val = read_frame (buf, sizeof_buf);\n+\t      val = read_frame (buf);\n \t      if (val >= 0)\n \t\tbreak;\n \t    }\n@@ -9620,7 +9620,7 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n \t  if (remote_debug)\n \t    {\n \t      std::string str\n-\t\t= escape_buffer (*buf,\n+\t\t= escape_buffer (buf->data (),\n \t\t\t\t std::min (val, REMOTE_DEBUG_MAX_CHAR));\n \n \t      fprintf_unfiltered (gdb_stdlog, \"Packet received: %s\",\n@@ -9649,7 +9649,7 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n \n \t  if (remote_debug)\n \t    {\n-\t      std::string str = escape_buffer (*buf, val);\n+\t      std::string str = escape_buffer (buf->data (), val);\n \n \t      fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t  \"  Notification received: %s\\n\",\n@@ -9658,7 +9658,7 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n \t  if (is_notif != NULL)\n \t    *is_notif = 1;\n \n-\t  handle_notification (rs->notif_state, *buf);\n+\t  handle_notification (rs->notif_state, buf->data ());\n \n \t  /* Notifications require no acknowledgement.  */\n \n@@ -9669,17 +9669,16 @@ remote_target::getpkt_or_notif_sane_1 (char **buf, long *sizeof_buf,\n }\n \n int\n-remote_target::getpkt_sane (char **buf, long *sizeof_buf, int forever)\n+remote_target::getpkt_sane (gdb::char_vector *buf, int forever)\n {\n-  return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 0, NULL);\n+  return getpkt_or_notif_sane_1 (buf, forever, 0, NULL);\n }\n \n int\n-remote_target::getpkt_or_notif_sane (char **buf, long *sizeof_buf, int forever,\n+remote_target::getpkt_or_notif_sane (gdb::char_vector *buf, int forever,\n \t\t\t\t     int *is_notif)\n {\n-  return getpkt_or_notif_sane_1 (buf, sizeof_buf, forever, 1,\n-\t\t\t\t is_notif);\n+  return getpkt_or_notif_sane_1 (buf, forever, 1, is_notif);\n }\n \n /* Kill any new fork children of process PID that haven't been\n@@ -9780,9 +9779,9 @@ remote_target::remote_vkill (int pid)\n   remote_state *rs = get_remote_state ();\n \n   /* Tell the remote target to detach.  */\n-  xsnprintf (rs->buf, get_remote_packet_size (), \"vKill;%x\", pid);\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"vKill;%x\", pid);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf,\n \t\t     &remote_protocol_packets[PACKET_vKill]))\n@@ -9888,7 +9887,7 @@ remote_target::mourn_inferior ()\n \t  /* Check whether the target is running now - some remote stubs\n \t     automatically restart after kill.\t*/\n \t  putpkt (\"?\");\n-\t  getpkt (&rs->buf, &rs->buf_size, 0);\n+\t  getpkt (&rs->buf, 0);\n \n \t  if (rs->buf[0] == 'S' || rs->buf[0] == 'T')\n \t    {\n@@ -9914,8 +9913,8 @@ remote_target::extended_remote_disable_randomization (int val)\n   struct remote_state *rs = get_remote_state ();\n   char *reply;\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"QDisableRandomization:%x\",\n-\t     val);\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (),\n+\t     \"QDisableRandomization:%x\", val);\n   putpkt (rs->buf);\n   reply = remote_get_noisy_reply ();\n   if (*reply == '\\0')\n@@ -9936,12 +9935,12 @@ remote_target::extended_remote_run (const std::string &args)\n   if (packet_support (PACKET_vRun) == PACKET_DISABLE)\n     return -1;\n \n-  strcpy (rs->buf, \"vRun;\");\n-  len = strlen (rs->buf);\n+  strcpy (rs->buf.data (), \"vRun;\");\n+  len = strlen (rs->buf.data ());\n \n   if (strlen (remote_exec_file) * 2 + len >= get_remote_packet_size ())\n     error (_(\"Remote file name too long for run packet\"));\n-  len += 2 * bin2hex ((gdb_byte *) remote_exec_file, rs->buf + len,\n+  len += 2 * bin2hex ((gdb_byte *) remote_exec_file, rs->buf.data () + len,\n \t\t      strlen (remote_exec_file));\n \n   if (!args.empty ())\n@@ -9954,15 +9953,15 @@ remote_target::extended_remote_run (const std::string &args)\n \t  if (strlen (argv[i]) * 2 + 1 + len >= get_remote_packet_size ())\n \t    error (_(\"Argument list too long for run packet\"));\n \t  rs->buf[len++] = ';';\n-\t  len += 2 * bin2hex ((gdb_byte *) argv[i], rs->buf + len,\n+\t  len += 2 * bin2hex ((gdb_byte *) argv[i], rs->buf.data () + len,\n \t\t\t      strlen (argv[i]));\n \t}\n     }\n \n   rs->buf[len++] = '\\0';\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_vRun]))\n     {\n@@ -10000,12 +9999,12 @@ remote_target::send_environment_packet (const char *action,\n   std::string encoded_value = bin2hex ((const gdb_byte *) value,\n \t\t\t\t\t strlen (value));\n \n-  xsnprintf (rs->buf, get_remote_packet_size (),\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (),\n \t     \"%s:%s\", packet, encoded_value.c_str ());\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  if (strcmp (rs->buf, \"OK\") != 0)\n+  getpkt (&rs->buf, 0);\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n     warning (_(\"Unable to %s environment variable '%s' on remote.\"),\n \t     action, value);\n }\n@@ -10020,8 +10019,8 @@ remote_target::extended_remote_environment_support ()\n   if (packet_support (PACKET_QEnvironmentReset) != PACKET_DISABLE)\n     {\n       putpkt (\"QEnvironmentReset\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      if (strcmp (rs->buf, \"OK\") != 0)\n+      getpkt (&rs->buf, 0);\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n \twarning (_(\"Unable to reset environment on remote.\"));\n     }\n \n@@ -10053,26 +10052,26 @@ remote_target::extended_remote_set_inferior_cwd ()\n \t  std::string hexpath = bin2hex ((const gdb_byte *) inferior_cwd,\n \t\t\t\t\t strlen (inferior_cwd));\n \n-\t  xsnprintf (rs->buf, get_remote_packet_size (),\n+\t  xsnprintf (rs->buf.data (), get_remote_packet_size (),\n \t\t     \"QSetWorkingDir:%s\", hexpath.c_str ());\n \t}\n       else\n \t{\n \t  /* An empty inferior_cwd means that the user wants us to\n \t     reset the remote server's inferior's cwd.  */\n-\t  xsnprintf (rs->buf, get_remote_packet_size (),\n+\t  xsnprintf (rs->buf.data (), get_remote_packet_size (),\n \t\t     \"QSetWorkingDir:\");\n \t}\n \n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n       if (packet_ok (rs->buf,\n \t\t     &remote_protocol_packets[PACKET_QSetWorkingDir])\n \t  != PACKET_OK)\n \terror (_(\"\\\n Remote replied unexpectedly while setting the inferior's working\\n\\\n directory: %s\"),\n-\t       rs->buf);\n+\t       rs->buf.data ());\n \n     }\n }\n@@ -10106,14 +10105,14 @@ extended_remote_target::create_inferior (const char *exec_file,\n      remote inferior using a shell.  */\n   if (packet_support (PACKET_QStartupWithShell) != PACKET_DISABLE)\n     {\n-      xsnprintf (rs->buf, get_remote_packet_size (),\n+      xsnprintf (rs->buf.data (), get_remote_packet_size (),\n \t\t \"QStartupWithShell:%d\", startup_with_shell ? 1 : 0);\n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      if (strcmp (rs->buf, \"OK\") != 0)\n+      getpkt (&rs->buf, 0);\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n \terror (_(\"\\\n Remote replied unexpectedly while setting startup-with-shell: %s\"),\n-\t       rs->buf);\n+\t       rs->buf.data ());\n     }\n \n   extended_remote_environment_support ();\n@@ -10136,7 +10135,7 @@ Remote replied unexpectedly while setting startup-with-shell: %s\"),\n     }\n \n   /* vRun's success return is a stop reply.  */\n-  stop_reply = run_worked ? rs->buf : NULL;\n+  stop_reply = run_worked ? rs->buf.data () : NULL;\n   add_current_inferior_and_thread (stop_reply);\n \n   /* Get updated offsets, if the stub uses qOffsets.  */\n@@ -10222,8 +10221,8 @@ remote_target::insert_breakpoint (struct gdbarch *gdbarch,\n \tset_general_process ();\n \n       rs = get_remote_state ();\n-      p = rs->buf;\n-      endbuf = rs->buf + get_remote_packet_size ();\n+      p = rs->buf.data ();\n+      endbuf = p + get_remote_packet_size ();\n \n       *(p++) = 'Z';\n       *(p++) = '0';\n@@ -10239,7 +10238,7 @@ remote_target::insert_breakpoint (struct gdbarch *gdbarch,\n \tremote_add_target_side_commands (gdbarch, bp_tgt, p);\n \n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n       switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0]))\n \t{\n@@ -10271,8 +10270,8 @@ remote_target::remove_breakpoint (struct gdbarch *gdbarch,\n \n   if (packet_support (PACKET_Z0) != PACKET_DISABLE)\n     {\n-      char *p = rs->buf;\n-      char *endbuf = rs->buf + get_remote_packet_size ();\n+      char *p = rs->buf.data ();\n+      char *endbuf = p + get_remote_packet_size ();\n \n       /* Make sure the remote is pointing at the right process, if\n \t necessary.  */\n@@ -10288,7 +10287,7 @@ remote_target::remove_breakpoint (struct gdbarch *gdbarch,\n       xsnprintf (p, endbuf - p, \",%d\", bp_tgt->kind);\n \n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n       return (rs->buf[0] == 'E');\n     }\n@@ -10321,7 +10320,7 @@ remote_target::insert_watchpoint (CORE_ADDR addr, int len,\n \t\t\t\t  enum target_hw_bp_type type, struct expression *cond)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *endbuf = rs->buf.data () + get_remote_packet_size ();\n   char *p;\n   enum Z_packet_type packet = watchpoint_to_Z_packet (type);\n \n@@ -10333,14 +10332,14 @@ remote_target::insert_watchpoint (CORE_ADDR addr, int len,\n   if (!gdbarch_has_global_breakpoints (target_gdbarch ()))\n     set_general_process ();\n \n-  xsnprintf (rs->buf, endbuf - rs->buf, \"Z%x,\", packet);\n-  p = strchr (rs->buf, '\\0');\n+  xsnprintf (rs->buf.data (), endbuf - rs->buf.data (), \"Z%x,\", packet);\n+  p = strchr (rs->buf.data (), '\\0');\n   addr = remote_address_masked (addr);\n   p += hexnumstr (p, (ULONGEST) addr);\n   xsnprintf (p, endbuf - p, \",%x\", len);\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))\n     {\n@@ -10370,7 +10369,7 @@ remote_target::remove_watchpoint (CORE_ADDR addr, int len,\n \t\t\t\t  enum target_hw_bp_type type, struct expression *cond)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *endbuf = rs->buf.data () + get_remote_packet_size ();\n   char *p;\n   enum Z_packet_type packet = watchpoint_to_Z_packet (type);\n \n@@ -10382,13 +10381,13 @@ remote_target::remove_watchpoint (CORE_ADDR addr, int len,\n   if (!gdbarch_has_global_breakpoints (target_gdbarch ()))\n     set_general_process ();\n \n-  xsnprintf (rs->buf, endbuf - rs->buf, \"z%x,\", packet);\n-  p = strchr (rs->buf, '\\0');\n+  xsnprintf (rs->buf.data (), endbuf - rs->buf.data (), \"z%x,\", packet);\n+  p = strchr (rs->buf.data (), '\\0');\n   addr = remote_address_masked (addr);\n   p += hexnumstr (p, (ULONGEST) addr);\n   xsnprintf (p, endbuf - p, \",%x\", len);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z0 + packet]))\n     {\n@@ -10533,8 +10532,8 @@ remote_target::insert_hw_breakpoint (struct gdbarch *gdbarch,\n     set_general_process ();\n \n   rs = get_remote_state ();\n-  p = rs->buf;\n-  endbuf = rs->buf + get_remote_packet_size ();\n+  p = rs->buf.data ();\n+  endbuf = p + get_remote_packet_size ();\n \n   *(p++) = 'Z';\n   *(p++) = '1';\n@@ -10551,14 +10550,14 @@ remote_target::insert_hw_breakpoint (struct gdbarch *gdbarch,\n     remote_add_target_side_commands (gdbarch, bp_tgt, p);\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))\n     {\n     case PACKET_ERROR:\n       if (rs->buf[1] == '.')\n         {\n-          message = strchr (rs->buf + 2, '.');\n+          message = strchr (&rs->buf[2], '.');\n           if (message)\n             error (_(\"Remote failure reply: %s\"), message + 1);\n         }\n@@ -10579,8 +10578,8 @@ remote_target::remove_hw_breakpoint (struct gdbarch *gdbarch,\n {\n   CORE_ADDR addr;\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *p = rs->buf.data ();\n+  char *endbuf = p + get_remote_packet_size ();\n \n   if (packet_support (PACKET_Z1) == PACKET_DISABLE)\n     return -1;\n@@ -10599,7 +10598,7 @@ remote_target::remove_hw_breakpoint (struct gdbarch *gdbarch,\n   xsnprintf (p, endbuf  - p, \",%x\", bp_tgt->kind);\n \n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf, &remote_protocol_packets[PACKET_Z1]))\n     {\n@@ -10632,15 +10631,15 @@ remote_target::verify_memory (const gdb_byte *data, CORE_ADDR lma, ULONGEST size\n       set_general_process ();\n \n       /* FIXME: assumes lma can fit into long.  */\n-      xsnprintf (rs->buf, get_remote_packet_size (), \"qCRC:%lx,%lx\",\n+      xsnprintf (rs->buf.data (), get_remote_packet_size (), \"qCRC:%lx,%lx\",\n \t\t (long) lma, (long) size);\n       putpkt (rs->buf);\n \n       /* Be clever; compute the host_crc before waiting for target\n \t reply.  */\n       host_crc = xcrc32 (data, size, 0xffffffff);\n \n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n       result = packet_ok (rs->buf,\n \t\t\t  &remote_protocol_packets[PACKET_qCRC]);\n@@ -10752,22 +10751,22 @@ remote_target::remote_write_qxfer (const char *object_name,\n     return TARGET_XFER_E_IO;\n \n   /* Insert header.  */\n-  i = snprintf (rs->buf, max_size, \n+  i = snprintf (rs->buf.data (), max_size, \n \t\t\"qXfer:%s:write:%s:%s:\",\n \t\tobject_name, annex ? annex : \"\",\n \t\tphex_nz (offset, sizeof offset));\n   max_size -= (i + 1);\n \n   /* Escape as much data as fits into rs->buf.  */\n   buf_len = remote_escape_output \n-    (writebuf, len, 1, (gdb_byte *) rs->buf + i, &max_size, max_size);\n+    (writebuf, len, 1, (gdb_byte *) rs->buf.data () + i, &max_size, max_size);\n \n-  if (putpkt_binary (rs->buf, i + buf_len) < 0\n-      || getpkt_sane (&rs->buf, &rs->buf_size, 0) < 0\n+  if (putpkt_binary (rs->buf.data (), i + buf_len) < 0\n+      || getpkt_sane (&rs->buf, 0) < 0\n       || packet_ok (rs->buf, packet) != PACKET_OK)\n     return TARGET_XFER_E_IO;\n \n-  unpack_varlen_hex (rs->buf, &n);\n+  unpack_varlen_hex (rs->buf.data (), &n);\n \n   *xfered_len = n;\n   return (*xfered_len != 0) ? TARGET_XFER_OK : TARGET_XFER_EOF;\n@@ -10817,7 +10816,8 @@ remote_target::remote_read_qxfer (const char *object_name,\n      the target is free to respond with slightly less data.  We subtract\n      five to account for the response type and the protocol frame.  */\n   n = std::min<LONGEST> (get_remote_packet_size () - 5, len);\n-  snprintf (rs->buf, get_remote_packet_size () - 4, \"qXfer:%s:read:%s:%s,%s\",\n+  snprintf (rs->buf.data (), get_remote_packet_size () - 4,\n+\t    \"qXfer:%s:read:%s:%s,%s\",\n \t    object_name, annex ? annex : \"\",\n \t    phex_nz (offset, sizeof offset),\n \t    phex_nz (n, sizeof n));\n@@ -10826,12 +10826,12 @@ remote_target::remote_read_qxfer (const char *object_name,\n     return TARGET_XFER_E_IO;\n \n   rs->buf[0] = '\\0';\n-  packet_len = getpkt_sane (&rs->buf, &rs->buf_size, 0);\n+  packet_len = getpkt_sane (&rs->buf, 0);\n   if (packet_len < 0 || packet_ok (rs->buf, packet) != PACKET_OK)\n     return TARGET_XFER_E_IO;\n \n   if (rs->buf[0] != 'l' && rs->buf[0] != 'm')\n-    error (_(\"Unknown remote qXfer reply: %s\"), rs->buf);\n+    error (_(\"Unknown remote qXfer reply: %s\"), rs->buf.data ());\n \n   /* 'm' means there is (or at least might be) more data after this\n      batch.  That does not make sense unless there's at least one byte\n@@ -10840,7 +10840,7 @@ remote_target::remote_read_qxfer (const char *object_name,\n     error (_(\"Remote qXfer reply contained no data.\"));\n \n   /* Got some data.  */\n-  i = remote_unescape_input ((gdb_byte *) rs->buf + 1,\n+  i = remote_unescape_input ((gdb_byte *) rs->buf.data () + 1,\n \t\t\t     packet_len - 1, readbuf, n);\n \n   /* 'l' is an EOF marker, possibly including a final block of data,\n@@ -11044,7 +11044,7 @@ remote_target::xfer_partial (enum target_object object,\n   gdb_assert (annex != NULL);\n   gdb_assert (readbuf != NULL);\n \n-  p2 = rs->buf;\n+  p2 = rs->buf.data ();\n   *p2++ = 'q';\n   *p2++ = query_type;\n \n@@ -11068,8 +11068,8 @@ remote_target::xfer_partial (enum target_object object,\n   if (i < 0)\n     return TARGET_XFER_E_IO;\n \n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  strcpy ((char *) readbuf, rs->buf);\n+  getpkt (&rs->buf, 0);\n+  strcpy ((char *) readbuf, rs->buf.data ());\n \n   *xfered_len = strlen ((char *) readbuf);\n   return (*xfered_len != 0) ? TARGET_XFER_OK : TARGET_XFER_EOF;\n@@ -11129,23 +11129,24 @@ remote_target::search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,\n   set_general_process ();\n \n   /* Insert header.  */\n-  i = snprintf (rs->buf, max_size, \n+  i = snprintf (rs->buf.data (), max_size, \n \t\t\"qSearch:memory:%s;%s;\",\n \t\tphex_nz (start_addr, addr_size),\n \t\tphex_nz (search_space_len, sizeof (search_space_len)));\n   max_size -= (i + 1);\n \n   /* Escape as much data as fits into rs->buf.  */\n   escaped_pattern_len =\n-    remote_escape_output (pattern, pattern_len, 1, (gdb_byte *) rs->buf + i,\n+    remote_escape_output (pattern, pattern_len, 1,\n+\t\t\t  (gdb_byte *) rs->buf.data () + i,\n \t\t\t  &used_pattern_len, max_size);\n \n   /* Bail if the pattern is too large.  */\n   if (used_pattern_len != pattern_len)\n     error (_(\"Pattern is too large to transmit to remote target.\"));\n \n-  if (putpkt_binary (rs->buf, i + escaped_pattern_len) < 0\n-      || getpkt_sane (&rs->buf, &rs->buf_size, 0) < 0\n+  if (putpkt_binary (rs->buf.data (), i + escaped_pattern_len) < 0\n+      || getpkt_sane (&rs->buf, 0) < 0\n       || packet_ok (rs->buf, packet) != PACKET_OK)\n     {\n       /* The request may not have worked because the command is not\n@@ -11164,12 +11165,12 @@ remote_target::search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,\n     {\n       found = 1;\n       if (rs->buf[1] != ',')\n-\terror (_(\"Unknown qSearch:memory reply: %s\"), rs->buf);\n-      unpack_varlen_hex (rs->buf + 2, &found_addr);\n+\terror (_(\"Unknown qSearch:memory reply: %s\"), rs->buf.data ());\n+      unpack_varlen_hex (&rs->buf[2], &found_addr);\n       *found_addrp = found_addr;\n     }\n   else\n-    error (_(\"Unknown qSearch:memory reply: %s\"), rs->buf);\n+    error (_(\"Unknown qSearch:memory reply: %s\"), rs->buf.data ());\n \n   return found;\n }\n@@ -11178,7 +11179,7 @@ void\n remote_target::rcmd (const char *command, struct ui_file *outbuf)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n \n   if (!rs->remote_desc)\n     error (_(\"remote rcmd is only available after target open\"));\n@@ -11188,10 +11189,10 @@ remote_target::rcmd (const char *command, struct ui_file *outbuf)\n     command = \"\";\n \n   /* The query prefix.  */\n-  strcpy (rs->buf, \"qRcmd,\");\n-  p = strchr (rs->buf, '\\0');\n+  strcpy (rs->buf.data (), \"qRcmd,\");\n+  p = strchr (rs->buf.data (), '\\0');\n \n-  if ((strlen (rs->buf) + strlen (command) * 2 + 8/*misc*/)\n+  if ((strlen (rs->buf.data ()) + strlen (command) * 2 + 8/*misc*/)\n       > get_remote_packet_size ())\n     error (_(\"\\\"monitor\\\" command ``%s'' is too long.\"), command);\n \n@@ -11209,7 +11210,7 @@ remote_target::rcmd (const char *command, struct ui_file *outbuf)\n       /* XXX - see also remote_get_noisy_reply().  */\n       QUIT;\t\t\t/* Allow user to bail out with ^C.  */\n       rs->buf[0] = '\\0';\n-      if (getpkt_sane (&rs->buf, &rs->buf_size, 0) == -1)\n+      if (getpkt_sane (&rs->buf, 0) == -1)\n         { \n           /* Timeout.  Continue to (try to) read responses.\n              This is better than stopping with an error, assuming the stub\n@@ -11218,7 +11219,7 @@ remote_target::rcmd (const char *command, struct ui_file *outbuf)\n              an effect similar to stop on timeout.  */\n           continue;\n         }\n-      buf = rs->buf;\n+      buf = rs->buf.data ();\n       if (buf[0] == '\\0')\n \terror (_(\"Target does not support this command.\"));\n       if (buf[0] == 'O' && buf[1] != 'K')\n@@ -11280,9 +11281,9 @@ remote_target::packet_command (const char *args, int from_tty)\n \n   remote_state *rs = get_remote_state ();\n \n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n   puts_filtered (\"received: \");\n-  print_packet (rs->buf);\n+  print_packet (rs->buf.data ());\n   puts_filtered (\"\\n\");\n }\n \n@@ -11493,8 +11494,8 @@ remote_target::get_thread_local_address (ptid_t ptid, CORE_ADDR lm,\n   if (packet_support (PACKET_qGetTLSAddr) != PACKET_DISABLE)\n     {\n       struct remote_state *rs = get_remote_state ();\n-      char *p = rs->buf;\n-      char *endp = rs->buf + get_remote_packet_size ();\n+      char *p = rs->buf.data ();\n+      char *endp = p + get_remote_packet_size ();\n       enum packet_result result;\n \n       strcpy (p, \"qGetTLSAddr:\");\n@@ -11507,14 +11508,14 @@ remote_target::get_thread_local_address (ptid_t ptid, CORE_ADDR lm,\n       *p++ = '\\0';\n \n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n       result = packet_ok (rs->buf,\n \t\t\t  &remote_protocol_packets[PACKET_qGetTLSAddr]);\n       if (result == PACKET_OK)\n \t{\n \t  ULONGEST addr;\n \n-\t  unpack_varlen_hex (rs->buf, &addr);\n+\t  unpack_varlen_hex (rs->buf.data (), &addr);\n \t  return addr;\n \t}\n       else if (result == PACKET_UNKNOWN)\n@@ -11540,8 +11541,8 @@ remote_target::get_tib_address (ptid_t ptid, CORE_ADDR *addr)\n   if (packet_support (PACKET_qGetTIBAddr) != PACKET_DISABLE)\n     {\n       struct remote_state *rs = get_remote_state ();\n-      char *p = rs->buf;\n-      char *endp = rs->buf + get_remote_packet_size ();\n+      char *p = rs->buf.data ();\n+      char *endp = p + get_remote_packet_size ();\n       enum packet_result result;\n \n       strcpy (p, \"qGetTIBAddr:\");\n@@ -11550,13 +11551,13 @@ remote_target::get_tib_address (ptid_t ptid, CORE_ADDR *addr)\n       *p++ = '\\0';\n \n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n       result = packet_ok (rs->buf,\n \t\t\t  &remote_protocol_packets[PACKET_qGetTIBAddr]);\n       if (result == PACKET_OK)\n \t{\n \t  ULONGEST val;\n-\t  unpack_varlen_hex (rs->buf, &val);\n+\t  unpack_varlen_hex (rs->buf.data (), &val);\n \t  if (addr)\n \t    *addr = (CORE_ADDR) val;\n \t  return true;\n@@ -11811,8 +11812,8 @@ remote_target::remote_hostio_send_command (int command_bytes, int which_packet,\n       return -1;\n     }\n \n-  putpkt_binary (rs->buf, command_bytes);\n-  bytes_read = getpkt_sane (&rs->buf, &rs->buf_size, 0);\n+  putpkt_binary (rs->buf.data (), command_bytes);\n+  bytes_read = getpkt_sane (&rs->buf, 0);\n \n   /* If it timed out, something is wrong.  Don't try to parse the\n      buffer.  */\n@@ -11834,7 +11835,7 @@ remote_target::remote_hostio_send_command (int command_bytes, int which_packet,\n       break;\n     }\n \n-  if (remote_hostio_parse_result (rs->buf, &ret, remote_errno,\n+  if (remote_hostio_parse_result (rs->buf.data (), &ret, remote_errno,\n \t\t\t\t  &attachment_tmp))\n     {\n       *remote_errno = FILEIO_EINVAL;\n@@ -11854,7 +11855,7 @@ remote_target::remote_hostio_send_command (int command_bytes, int which_packet,\n   if (attachment_tmp != NULL)\n     {\n       *attachment = attachment_tmp;\n-      *attachment_len = bytes_read - (*attachment - rs->buf);\n+      *attachment_len = bytes_read - (*attachment - rs->buf.data ());\n     }\n \n   return ret;\n@@ -11887,7 +11888,7 @@ remote_target::remote_hostio_set_filesystem (struct inferior *inf,\n {\n   struct remote_state *rs = get_remote_state ();\n   int required_pid = (inf == NULL || inf->fake_pid_p) ? 0 : inf->pid;\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   int left = get_remote_packet_size () - 1;\n   char arg[9];\n   int ret;\n@@ -11903,7 +11904,7 @@ remote_target::remote_hostio_set_filesystem (struct inferior *inf,\n   xsnprintf (arg, sizeof (arg), \"%x\", required_pid);\n   remote_buffer_add_string (&p, &left, arg);\n \n-  ret = remote_hostio_send_command (p - rs->buf, PACKET_vFile_setfs,\n+  ret = remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_setfs,\n \t\t\t\t    remote_errno, NULL, NULL);\n \n   if (packet_support (PACKET_vFile_setfs) == PACKET_DISABLE)\n@@ -11923,7 +11924,7 @@ remote_target::remote_hostio_open (inferior *inf, const char *filename,\n \t\t\t\t   int *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   int left = get_remote_packet_size () - 1;\n \n   if (warn_if_slow)\n@@ -11956,7 +11957,7 @@ remote_target::remote_hostio_open (inferior *inf, const char *filename,\n \n   remote_buffer_add_int (&p, &left, mode);\n \n-  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_open,\n+  return remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_open,\n \t\t\t\t     remote_errno, NULL, NULL);\n }\n \n@@ -11976,7 +11977,7 @@ remote_target::remote_hostio_pwrite (int fd, const gdb_byte *write_buf, int len,\n \t\t\t\t     ULONGEST offset, int *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   int left = get_remote_packet_size ();\n   int out_len;\n \n@@ -11991,9 +11992,10 @@ remote_target::remote_hostio_pwrite (int fd, const gdb_byte *write_buf, int len,\n   remote_buffer_add_string (&p, &left, \",\");\n \n   p += remote_escape_output (write_buf, len, 1, (gdb_byte *) p, &out_len,\n-\t\t\t     get_remote_packet_size () - (p - rs->buf));\n+\t\t\t     (get_remote_packet_size ()\n+\t\t\t      - (p - rs->buf.data ())));\n \n-  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_pwrite,\n+  return remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_pwrite,\n \t\t\t\t     remote_errno, NULL, NULL);\n }\n \n@@ -12012,7 +12014,7 @@ remote_target::remote_hostio_pread_vFile (int fd, gdb_byte *read_buf, int len,\n \t\t\t\t\t  ULONGEST offset, int *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   char *attachment;\n   int left = get_remote_packet_size ();\n   int ret, attachment_len;\n@@ -12028,7 +12030,7 @@ remote_target::remote_hostio_pread_vFile (int fd, gdb_byte *read_buf, int len,\n \n   remote_buffer_add_int (&p, &left, offset);\n \n-  ret = remote_hostio_send_command (p - rs->buf, PACKET_vFile_pread,\n+  ret = remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_pread,\n \t\t\t\t    remote_errno, &attachment,\n \t\t\t\t    &attachment_len);\n \n@@ -12121,7 +12123,7 @@ int\n remote_target::remote_hostio_close (int fd, int *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   int left = get_remote_packet_size () - 1;\n \n   rs->readahead_cache.invalidate_fd (fd);\n@@ -12130,7 +12132,7 @@ remote_target::remote_hostio_close (int fd, int *remote_errno)\n \n   remote_buffer_add_int (&p, &left, fd);\n \n-  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_close,\n+  return remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_close,\n \t\t\t\t     remote_errno, NULL, NULL);\n }\n \n@@ -12147,7 +12149,7 @@ remote_target::remote_hostio_unlink (inferior *inf, const char *filename,\n \t\t\t\t     int *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   int left = get_remote_packet_size () - 1;\n \n   if (remote_hostio_set_filesystem (inf, remote_errno) != 0)\n@@ -12158,7 +12160,7 @@ remote_target::remote_hostio_unlink (inferior *inf, const char *filename,\n   remote_buffer_add_bytes (&p, &left, (const gdb_byte *) filename,\n \t\t\t   strlen (filename));\n \n-  return remote_hostio_send_command (p - rs->buf, PACKET_vFile_unlink,\n+  return remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_unlink,\n \t\t\t\t     remote_errno, NULL, NULL);\n }\n \n@@ -12176,7 +12178,7 @@ remote_target::fileio_readlink (struct inferior *inf, const char *filename,\n \t\t\t\tint *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   char *attachment;\n   int left = get_remote_packet_size ();\n   int len, attachment_len;\n@@ -12190,7 +12192,7 @@ remote_target::fileio_readlink (struct inferior *inf, const char *filename,\n   remote_buffer_add_bytes (&p, &left, (const gdb_byte *) filename,\n \t\t\t   strlen (filename));\n \n-  len = remote_hostio_send_command (p - rs->buf, PACKET_vFile_readlink,\n+  len = remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_readlink,\n \t\t\t\t    remote_errno, &attachment,\n \t\t\t\t    &attachment_len);\n \n@@ -12213,7 +12215,7 @@ int\n remote_target::fileio_fstat (int fd, struct stat *st, int *remote_errno)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *p = rs->buf;\n+  char *p = rs->buf.data ();\n   int left = get_remote_packet_size ();\n   int attachment_len, ret;\n   char *attachment;\n@@ -12224,7 +12226,7 @@ remote_target::fileio_fstat (int fd, struct stat *st, int *remote_errno)\n \n   remote_buffer_add_int (&p, &left, fd);\n \n-  ret = remote_hostio_send_command (p - rs->buf, PACKET_vFile_fstat,\n+  ret = remote_hostio_send_command (p - rs->buf.data (), PACKET_vFile_fstat,\n \t\t\t\t    remote_errno, &attachment,\n \t\t\t\t    &attachment_len);\n   if (ret < 0)\n@@ -12737,7 +12739,7 @@ remote_target::trace_init ()\n \n   putpkt (\"QTinit\");\n   remote_get_noisy_reply ();\n-  if (strcmp (rs->buf, \"OK\") != 0)\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n     error (_(\"Target does not support this command.\"));\n }\n \n@@ -12754,13 +12756,13 @@ remote_target::remote_download_command_source (int num, ULONGEST addr,\n   for (cmd = cmds; cmd; cmd = cmd->next)\n     {\n       QUIT;\t/* Allow user to bail out with ^C.  */\n-      strcpy (rs->buf, \"QTDPsrc:\");\n+      strcpy (rs->buf.data (), \"QTDPsrc:\");\n       encode_source_string (num, addr, \"cmd\", cmd->line,\n-\t\t\t    rs->buf + strlen (rs->buf),\n-\t\t\t    rs->buf_size - strlen (rs->buf));\n+\t\t\t    rs->buf.data () + strlen (rs->buf.data ()),\n+\t\t\t    rs->buf.size () - strlen (rs->buf.data ()));\n       putpkt (rs->buf);\n       remote_get_noisy_reply ();\n-      if (strcmp (rs->buf, \"OK\"))\n+      if (strcmp (rs->buf.data (), \"OK\"))\n \twarning (_(\"Target does not support source download.\"));\n \n       if (cmd->control_type == while_control\n@@ -12769,13 +12771,13 @@ remote_target::remote_download_command_source (int num, ULONGEST addr,\n \t  remote_download_command_source (num, addr, cmd->body_list_0.get ());\n \n \t  QUIT;\t/* Allow user to bail out with ^C.  */\n-\t  strcpy (rs->buf, \"QTDPsrc:\");\n+\t  strcpy (rs->buf.data (), \"QTDPsrc:\");\n \t  encode_source_string (num, addr, \"cmd\", \"end\",\n-\t\t\t\trs->buf + strlen (rs->buf),\n-\t\t\t\trs->buf_size - strlen (rs->buf));\n+\t\t\t\trs->buf.data () + strlen (rs->buf.data ()),\n+\t\t\t\trs->buf.size () - strlen (rs->buf.data ()));\n \t  putpkt (rs->buf);\n \t  remote_get_noisy_reply ();\n-\t  if (strcmp (rs->buf, \"OK\"))\n+\t  if (strcmp (rs->buf.data (), \"OK\"))\n \t    warning (_(\"Target does not support source download.\"));\n \t}\n     }\n@@ -12923,7 +12925,7 @@ remote_target::download_tracepoint (struct bp_location *loc)\n \n   putpkt (buf.data ());\n   remote_get_noisy_reply ();\n-  if (strcmp (rs->buf, \"OK\"))\n+  if (strcmp (rs->buf.data (), \"OK\"))\n     error (_(\"Target does not support tracepoints.\"));\n \n   /* do_single_steps (t); */\n@@ -12945,7 +12947,7 @@ remote_target::download_tracepoint (struct bp_location *loc)\n \n       putpkt (buf.data ());\n       remote_get_noisy_reply ();\n-      if (strcmp (rs->buf, \"OK\"))\n+      if (strcmp (rs->buf.data (), \"OK\"))\n \terror (_(\"Error on target while setting tracepoints.\"));\n     }\n \n@@ -12968,7 +12970,7 @@ remote_target::download_tracepoint (struct bp_location *loc)\n \n       putpkt (buf.data ());\n       remote_get_noisy_reply ();\n-      if (strcmp (rs->buf, \"OK\"))\n+      if (strcmp (rs->buf.data (), \"OK\"))\n \terror (_(\"Error on target while setting tracepoints.\"));\n     }\n \n@@ -12987,7 +12989,7 @@ remote_target::download_tracepoint (struct bp_location *loc)\n \t\t\t\tbuf.size () - strlen (buf.data ()));\n \t  putpkt (buf.data ());\n \t  remote_get_noisy_reply ();\n-\t  if (strcmp (rs->buf, \"OK\"))\n+\t  if (strcmp (rs->buf.data (), \"OK\"))\n \t    warning (_(\"Target does not support source download.\"));\n \t}\n       if (b->cond_string)\n@@ -13003,7 +13005,7 @@ remote_target::download_tracepoint (struct bp_location *loc)\n \t\t\t\tbuf.size () - strlen (buf.data ()));\n \t  putpkt (buf.data ());\n \t  remote_get_noisy_reply ();\n-\t  if (strcmp (rs->buf, \"OK\"))\n+\t  if (strcmp (rs->buf.data (), \"OK\"))\n \t    warning (_(\"Target does not support source download.\"));\n \t}\n       remote_download_command_source (b->number, loc->address,\n@@ -13045,19 +13047,20 @@ remote_target::download_trace_state_variable (const trace_state_variable &tsv)\n   struct remote_state *rs = get_remote_state ();\n   char *p;\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"QTDV:%x:%s:%x:\",\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"QTDV:%x:%s:%x:\",\n \t     tsv.number, phex ((ULONGEST) tsv.initial_value, 8),\n \t     tsv.builtin);\n-  p = rs->buf + strlen (rs->buf);\n-  if ((p - rs->buf) + tsv.name.length () * 2 >= get_remote_packet_size ())\n+  p = rs->buf.data () + strlen (rs->buf.data ());\n+  if ((p - rs->buf.data ()) + tsv.name.length () * 2\n+      >= get_remote_packet_size ())\n     error (_(\"Trace state variable name too long for tsv definition packet\"));\n   p += 2 * bin2hex ((gdb_byte *) (tsv.name.data ()), p, tsv.name.length ());\n   *p++ = '\\0';\n   putpkt (rs->buf);\n   remote_get_noisy_reply ();\n-  if (*rs->buf == '\\0')\n+  if (rs->buf[0] == '\\0')\n     error (_(\"Target does not support this command.\"));\n-  if (strcmp (rs->buf, \"OK\") != 0)\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n     error (_(\"Error on target while downloading trace state variable.\"));\n }\n \n@@ -13068,13 +13071,13 @@ remote_target::enable_tracepoint (struct bp_location *location)\n   char addr_buf[40];\n \n   sprintf_vma (addr_buf, location->address);\n-  xsnprintf (rs->buf, get_remote_packet_size (), \"QTEnable:%x:%s\",\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"QTEnable:%x:%s\",\n \t     location->owner->number, addr_buf);\n   putpkt (rs->buf);\n   remote_get_noisy_reply ();\n-  if (*rs->buf == '\\0')\n+  if (rs->buf[0] == '\\0')\n     error (_(\"Target does not support enabling tracepoints while a trace run is ongoing.\"));\n-  if (strcmp (rs->buf, \"OK\") != 0)\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n     error (_(\"Error on target while enabling tracepoint.\"));\n }\n \n@@ -13085,13 +13088,13 @@ remote_target::disable_tracepoint (struct bp_location *location)\n   char addr_buf[40];\n \n   sprintf_vma (addr_buf, location->address);\n-  xsnprintf (rs->buf, get_remote_packet_size (), \"QTDisable:%x:%s\",\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"QTDisable:%x:%s\",\n \t     location->owner->number, addr_buf);\n   putpkt (rs->buf);\n   remote_get_noisy_reply ();\n-  if (*rs->buf == '\\0')\n+  if (rs->buf[0] == '\\0')\n     error (_(\"Target does not support disabling tracepoints while a trace run is ongoing.\"));\n-  if (strcmp (rs->buf, \"OK\") != 0)\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n     error (_(\"Error on target while disabling tracepoint.\"));\n }\n \n@@ -13110,8 +13113,8 @@ remote_target::trace_set_readonly_regions ()\n \n   struct remote_state *rs = get_remote_state ();\n \n-  strcpy (rs->buf, \"QTro\");\n-  offset = strlen (rs->buf);\n+  strcpy (rs->buf.data (), \"QTro\");\n+  offset = strlen (rs->buf.data ());\n   for (s = exec_bfd->sections; s; s = s->next)\n     {\n       char tmp1[40], tmp2[40];\n@@ -13128,21 +13131,21 @@ remote_target::trace_set_readonly_regions ()\n       sprintf_vma (tmp1, vma);\n       sprintf_vma (tmp2, vma + size);\n       sec_length = 1 + strlen (tmp1) + 1 + strlen (tmp2);\n-      if (offset + sec_length + 1 > rs->buf_size)\n+      if (offset + sec_length + 1 > rs->buf.size ())\n \t{\n \t  if (packet_support (PACKET_qXfer_traceframe_info) != PACKET_ENABLE)\n \t    warning (_(\"\\\n Too many sections for read-only sections definition packet.\"));\n \t  break;\n \t}\n-      xsnprintf (rs->buf + offset, rs->buf_size - offset, \":%s,%s\",\n+      xsnprintf (rs->buf.data () + offset, rs->buf.size () - offset, \":%s,%s\",\n \t\t tmp1, tmp2);\n       offset += sec_length;\n     }\n   if (anysecs)\n     {\n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n     }\n }\n \n@@ -13153,10 +13156,10 @@ remote_target::trace_start ()\n \n   putpkt (\"QTStart\");\n   remote_get_noisy_reply ();\n-  if (*rs->buf == '\\0')\n+  if (rs->buf[0] == '\\0')\n     error (_(\"Target does not support this command.\"));\n-  if (strcmp (rs->buf, \"OK\") != 0)\n-    error (_(\"Bogus reply from target: %s\"), rs->buf);\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n+    error (_(\"Bogus reply from target: %s\"), rs->buf.data ());\n }\n \n int\n@@ -13202,7 +13205,7 @@ remote_target::get_trace_status (struct trace_status *ts)\n   ts->filename = NULL;\n \n   if (*p++ != 'T')\n-    error (_(\"Bogus trace status reply from target: %s\"), rs->buf);\n+    error (_(\"Bogus trace status reply from target: %s\"), rs->buf.data ());\n \n   /* Function 'parse_trace_status' sets default value of each field of\n      'ts' at first, so we don't have to do it here.  */\n@@ -13231,7 +13234,7 @@ remote_target::get_tracepoint_status (struct breakpoint *bp,\n \t     any status.  */\n \t  if (tp->number_on_target == 0)\n \t    continue;\n-\t  xsnprintf (rs->buf, size, \"qTP:%x:%s\", tp->number_on_target,\n+\t  xsnprintf (rs->buf.data (), size, \"qTP:%x:%s\", tp->number_on_target,\n \t\t     phex_nz (loc->address, 0));\n \t  putpkt (rs->buf);\n \t  reply = remote_get_noisy_reply ();\n@@ -13246,7 +13249,7 @@ remote_target::get_tracepoint_status (struct breakpoint *bp,\n     {\n       utp->hit_count = 0;\n       utp->traceframe_usage = 0;\n-      xsnprintf (rs->buf, size, \"qTP:%x:%s\", utp->number,\n+      xsnprintf (rs->buf.data (), size, \"qTP:%x:%s\", utp->number,\n \t\t phex_nz (utp->addr, 0));\n       putpkt (rs->buf);\n       reply = remote_get_noisy_reply ();\n@@ -13265,10 +13268,10 @@ remote_target::trace_stop ()\n \n   putpkt (\"QTStop\");\n   remote_get_noisy_reply ();\n-  if (*rs->buf == '\\0')\n+  if (rs->buf[0] == '\\0')\n     error (_(\"Target does not support this command.\"));\n-  if (strcmp (rs->buf, \"OK\") != 0)\n-    error (_(\"Bogus reply from target: %s\"), rs->buf);\n+  if (strcmp (rs->buf.data (), \"OK\") != 0)\n+    error (_(\"Bogus reply from target: %s\"), rs->buf.data ());\n }\n \n int\n@@ -13277,7 +13280,7 @@ remote_target::trace_find (enum trace_find_type type, int num,\n \t\t\t   int *tpp)\n {\n   struct remote_state *rs = get_remote_state ();\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *endbuf = rs->buf.data () + get_remote_packet_size ();\n   char *p, *reply;\n   int target_frameno = -1, target_tracept = -1;\n \n@@ -13287,7 +13290,7 @@ remote_target::trace_find (enum trace_find_type type, int num,\n   if (type != tfind_number)\n     set_remote_traceframe ();\n \n-  p = rs->buf;\n+  p = rs->buf.data ();\n   strcpy (p, \"QTFrame:\");\n   p = strchr (p, '\\0');\n   switch (type)\n@@ -13362,7 +13365,7 @@ remote_target::get_trace_state_variable_value (int tsvnum, LONGEST *val)\n \n   set_remote_traceframe ();\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"qTV:%x\", tsvnum);\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"qTV:%x\", tsvnum);\n   putpkt (rs->buf);\n   reply = remote_get_noisy_reply ();\n   if (reply && *reply)\n@@ -13383,10 +13386,11 @@ remote_target::save_trace_data (const char *filename)\n   struct remote_state *rs = get_remote_state ();\n   char *p, *reply;\n \n-  p = rs->buf;\n+  p = rs->buf.data ();\n   strcpy (p, \"QTSave:\");\n   p += strlen (p);\n-  if ((p - rs->buf) + strlen (filename) * 2 >= get_remote_packet_size ())\n+  if ((p - rs->buf.data ()) + strlen (filename) * 2\n+      >= get_remote_packet_size ())\n     error (_(\"Remote file name too long for trace save packet\"));\n   p += 2 * bin2hex ((gdb_byte *) filename, p, strlen (filename));\n   *p++ = '\\0';\n@@ -13412,7 +13416,7 @@ remote_target::get_raw_trace_data (gdb_byte *buf, ULONGEST offset, LONGEST len)\n   char *p;\n   int rslt;\n \n-  p = rs->buf;\n+  p = rs->buf.data ();\n   strcpy (p, \"qTBuffer:\");\n   p += strlen (p);\n   p += hexnumstr (p, offset);\n@@ -13451,7 +13455,8 @@ remote_target::set_disconnected_tracing (int val)\n     {\n       char *reply;\n \n-      xsnprintf (rs->buf, get_remote_packet_size (), \"QTDisconnected:%x\", val);\n+      xsnprintf (rs->buf.data (), get_remote_packet_size (),\n+\t\t \"QTDisconnected:%x\", val);\n       putpkt (rs->buf);\n       reply = remote_get_noisy_reply ();\n       if (*reply == '\\0')\n@@ -13480,7 +13485,8 @@ remote_target::set_circular_trace_buffer (int val)\n   struct remote_state *rs = get_remote_state ();\n   char *reply;\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"QTBuffer:circular:%x\", val);\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (),\n+\t     \"QTBuffer:circular:%x\", val);\n   putpkt (rs->buf);\n   reply = remote_get_noisy_reply ();\n   if (*reply == '\\0')\n@@ -13520,7 +13526,7 @@ remote_target::get_min_fast_tracepoint_insn_len ()\n   /* Make sure the remote is pointing at the right process.  */\n   set_general_process ();\n \n-  xsnprintf (rs->buf, get_remote_packet_size (), \"qTMinFTPILen\");\n+  xsnprintf (rs->buf.data (), get_remote_packet_size (), \"qTMinFTPILen\");\n   putpkt (rs->buf);\n   reply = remote_get_noisy_reply ();\n   if (*reply == '\\0')\n@@ -13541,8 +13547,8 @@ remote_target::set_trace_buffer_size (LONGEST val)\n   if (packet_support (PACKET_QTBuffer_size) != PACKET_DISABLE)\n     {\n       struct remote_state *rs = get_remote_state ();\n-      char *buf = rs->buf;\n-      char *endbuf = rs->buf + get_remote_packet_size ();\n+      char *buf = rs->buf.data ();\n+      char *endbuf = buf + get_remote_packet_size ();\n       enum packet_result result;\n \n       gdb_assert (val >= 0 || val == -1);\n@@ -13562,7 +13568,7 @@ remote_target::set_trace_buffer_size (LONGEST val)\n \t\t  &remote_protocol_packets[PACKET_QTBuffer_size]);\n \n       if (result != PACKET_OK)\n-\twarning (_(\"Bogus reply from target: %s\"), rs->buf);\n+\twarning (_(\"Bogus reply from target: %s\"), rs->buf.data ());\n     }\n }\n \n@@ -13572,8 +13578,8 @@ remote_target::set_trace_notes (const char *user, const char *notes,\n {\n   struct remote_state *rs = get_remote_state ();\n   char *reply;\n-  char *buf = rs->buf;\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *buf = rs->buf.data ();\n+  char *endbuf = buf + get_remote_packet_size ();\n   int nbytes;\n \n   buf += xsnprintf (buf, endbuf - buf, \"QTNotes:\");\n@@ -13620,11 +13626,11 @@ remote_target::use_agent (bool use)\n       struct remote_state *rs = get_remote_state ();\n \n       /* If the stub supports QAgent.  */\n-      xsnprintf (rs->buf, get_remote_packet_size (), \"QAgent:%d\", use);\n+      xsnprintf (rs->buf.data (), get_remote_packet_size (), \"QAgent:%d\", use);\n       putpkt (rs->buf);\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n-      if (strcmp (rs->buf, \"OK\") == 0)\n+      if (strcmp (rs->buf.data (), \"OK\") == 0)\n \t{\n \t  ::use_agent = use;\n \t  return true;\n@@ -13667,7 +13673,7 @@ remote_target::btrace_sync_conf (const btrace_config *conf)\n   char *buf, *pos, *endbuf;\n \n   rs = get_remote_state ();\n-  buf = rs->buf;\n+  buf = rs->buf.data ();\n   endbuf = buf + get_remote_packet_size ();\n \n   packet = &remote_protocol_packets[PACKET_Qbtrace_conf_bts_size];\n@@ -13679,7 +13685,7 @@ remote_target::btrace_sync_conf (const btrace_config *conf)\n                         conf->bts.size);\n \n       putpkt (buf);\n-      getpkt (&buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n       if (packet_ok (buf, packet) == PACKET_ERROR)\n \t{\n@@ -13701,7 +13707,7 @@ remote_target::btrace_sync_conf (const btrace_config *conf)\n                         conf->pt.size);\n \n       putpkt (buf);\n-      getpkt (&buf, &rs->buf_size, 0);\n+      getpkt (&rs->buf, 0);\n \n       if (packet_ok (buf, packet) == PACKET_ERROR)\n \t{\n@@ -13789,8 +13795,8 @@ remote_target::enable_btrace (ptid_t ptid, const struct btrace_config *conf)\n   struct btrace_target_info *tinfo = NULL;\n   struct packet_config *packet = NULL;\n   struct remote_state *rs = get_remote_state ();\n-  char *buf = rs->buf;\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *buf = rs->buf.data ();\n+  char *endbuf = buf + get_remote_packet_size ();\n \n   switch (conf->format)\n     {\n@@ -13812,13 +13818,13 @@ remote_target::enable_btrace (ptid_t ptid, const struct btrace_config *conf)\n \n   buf += xsnprintf (buf, endbuf - buf, \"%s\", packet->name);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   if (packet_ok (rs->buf, packet) == PACKET_ERROR)\n     {\n       if (rs->buf[0] == 'E' && rs->buf[1] == '.')\n \terror (_(\"Could not enable branch tracing for %s: %s\"),\n-\t       target_pid_to_str (ptid), rs->buf + 2);\n+\t       target_pid_to_str (ptid), &rs->buf[2]);\n       else\n \terror (_(\"Could not enable branch tracing for %s.\"),\n \t       target_pid_to_str (ptid));\n@@ -13850,8 +13856,8 @@ remote_target::disable_btrace (struct btrace_target_info *tinfo)\n {\n   struct packet_config *packet = &remote_protocol_packets[PACKET_Qbtrace_off];\n   struct remote_state *rs = get_remote_state ();\n-  char *buf = rs->buf;\n-  char *endbuf = rs->buf + get_remote_packet_size ();\n+  char *buf = rs->buf.data ();\n+  char *endbuf = buf + get_remote_packet_size ();\n \n   if (packet_config_support (packet) != PACKET_ENABLE)\n     error (_(\"Target does not support branch tracing.\"));\n@@ -13860,13 +13866,13 @@ remote_target::disable_btrace (struct btrace_target_info *tinfo)\n \n   buf += xsnprintf (buf, endbuf - buf, \"%s\", packet->name);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   if (packet_ok (rs->buf, packet) == PACKET_ERROR)\n     {\n       if (rs->buf[0] == 'E' && rs->buf[1] == '.')\n \terror (_(\"Could not disable branch tracing for %s: %s\"),\n-\t       target_pid_to_str (tinfo->ptid), rs->buf + 2);\n+\t       target_pid_to_str (tinfo->ptid), &rs->buf[2]);\n       else\n \terror (_(\"Could not disable branch tracing for %s.\"),\n \t       target_pid_to_str (tinfo->ptid));\n@@ -14133,19 +14139,19 @@ remote_target::thread_events (int enable)\n   if (packet_support (PACKET_QThreadEvents) == PACKET_DISABLE)\n     return;\n \n-  xsnprintf (rs->buf, size, \"QThreadEvents:%x\", enable ? 1 : 0);\n+  xsnprintf (rs->buf.data (), size, \"QThreadEvents:%x\", enable ? 1 : 0);\n   putpkt (rs->buf);\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n+  getpkt (&rs->buf, 0);\n \n   switch (packet_ok (rs->buf,\n \t\t     &remote_protocol_packets[PACKET_QThreadEvents]))\n     {\n     case PACKET_OK:\n-      if (strcmp (rs->buf, \"OK\") != 0)\n-\terror (_(\"Remote refused setting thread events: %s\"), rs->buf);\n+      if (strcmp (rs->buf.data (), \"OK\") != 0)\n+\terror (_(\"Remote refused setting thread events: %s\"), rs->buf.data ());\n       break;\n     case PACKET_ERROR:\n-      warning (_(\"Remote failure reply: %s\"), rs->buf);\n+      warning (_(\"Remote failure reply: %s\"), rs->buf.data ());\n       break;\n     case PACKET_UNKNOWN:\n       break;\n@@ -14211,15 +14217,15 @@ remote_target::upload_tracepoints (struct uploaded_tp **utpp)\n \n   /* Ask for a first packet of tracepoint definition.  */\n   putpkt (\"qTfP\");\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  p = rs->buf;\n+  getpkt (&rs->buf, 0);\n+  p = rs->buf.data ();\n   while (*p && *p != 'l')\n     {\n       parse_tracepoint_definition (p, utpp);\n       /* Ask for another packet of tracepoint definition.  */\n       putpkt (\"qTsP\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      p = rs->buf;\n+      getpkt (&rs->buf, 0);\n+      p = rs->buf.data ();\n     }\n   return 0;\n }\n@@ -14232,15 +14238,15 @@ remote_target::upload_trace_state_variables (struct uploaded_tsv **utsvp)\n \n   /* Ask for a first packet of variable definition.  */\n   putpkt (\"qTfV\");\n-  getpkt (&rs->buf, &rs->buf_size, 0);\n-  p = rs->buf;\n+  getpkt (&rs->buf, 0);\n+  p = rs->buf.data ();\n   while (*p && *p != 'l')\n     {\n       parse_tsv_definition (p, utsvp);\n       /* Ask for another packet of variable definition.  */\n       putpkt (\"qTsV\");\n-      getpkt (&rs->buf, &rs->buf_size, 0);\n-      p = rs->buf;\n+      getpkt (&rs->buf, 0);\n+      p = rs->buf.data ();\n     }\n   return 0;\n }"
    }
  ]
}