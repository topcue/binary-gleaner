{
  "sha": "f68f85b52b2897ba54e0b119322be1abb2d53afe",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjY4Zjg1YjUyYjI4OTdiYTU0ZTBiMTE5MzIyYmUxYWJiMmQ1M2FmZQ==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-05-30T13:20:10Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-05-30T13:20:10Z"
    },
    "message": "replace_typedefs: handle templates in namespaces\n\nGDB currently crashes with infinite recursion, if you set a breakpoint\non a function inside a namespace that includes a template on its fully\nqualified name, and, the template's name is also used as typedef in\nthe global scope that expands to a name that includes the template\nname in its qualified name.  For example, from the testcase added by\nthis commit:\n\n namespace NS1 { namespace NS2 {\n\n template<typename T> struct Templ1\n {\n   T x;\n\n   Templ1 (object_p) {}\n }} // namespace NS1::NS2\n\n using Templ1 = NS1::NS2::Templ1<unsigned>;\n\nSetting a breakpoint like so:\n\n(gdb) break NS1::NS2::Templ1<int>::Templ1(NS1::NS2::object*)\n\nResults in infinite recursion, with this cycle (started by\ncp_canonicalize_string_full) repeating until the stack is exhausted:\n\n ...\n #1709 0x000000000055533c in inspect_type (info=0x38ff720, ret_comp=0xd83be10, finder=0x0, data=0x0) at /home/pedro/gdb/mygit/src/gdb/cp-support.c:267\n #1710 0x0000000000555a6f in replace_typedefs (info=0x38ff720, ret_comp=0xd83be10, finder=0x0, data=0x0) at /home/pedro/gdb/mygit/src/gdb/cp-support.c:475\n #1711 0x0000000000555a36 in replace_typedefs (info=0x38ff720, ret_comp=0xd83be70, finder=0x0, data=0x0) at /home/pedro/gdb/mygit/src/gdb/cp-support.c:470\n #1712 0x0000000000555800 in replace_typedefs_qualified_name (info=0x38ff720, ret_comp=0xd839470, finder=0x0, data=0x0) at /home/pedro/gdb/mygit/src/gdb/cp-support.c:389\n #1713 0x0000000000555a8c in replace_typedefs (info=0x38ff720, ret_comp=0xd839470, finder=0x0, data=0x0) at /home/pedro/gdb/mygit/src/gdb/cp-support.c:479\n ...\n\nThe demangle component tree for that symbol name looks like this:\n\nd_dump tree for NS1::NS2::Templ1<int>::Templ1(NS1::NS2::object*):\ntyped name\n  qualified name\n    name 'NS1'\n    qualified name\n      name 'NS2'\n      qualified name\n        template                  <<<<<<<<<<\n          name 'Templ1'\n          template argument list\n            builtin type int\n        name 'Templ1'\n  function type\n    argument list\n      pointer\n        qualified name\n          name 'NS1'\n          qualified name\n            name 'NS2'\n            name 'object'\n\nThe recursion starts at replace_typedefs_qualified_name, which doesn't\nhandle the \"template\" node, and thus doesn't realize that the template\nname actually has the fully qualified name NS1::NS2::Templ1.\nreplace_typedefs_qualified_name calls into replace_typedefs on the\ntemplate node, and that ends up in inspect_type looking up for a\nsymbol named \"Templ1\", which finds the global namespace typedef, which\nitself expands to NS1::NS2::Templ1.  GDB then tries replacing typedefs\nin that newly expanded name, which ends up again in\nreplace_typedefs_qualified_name, trying to expand a fully qualified\nname with \"NS::NS2::Templ1<unsigned>\" in its name, which results in\nrecursion whenever the template node is reached.\n\nFix this by teaching replace_typedefs_qualified_name how to handle\ntemplate nodes.  It needs handling in two places: the first spot\nhandles the symbol above; the second spot handles a symbol like this,\nfrom the new test:\n\n(gdb) b NS1::NS2::grab_it(NS1::NS2::Templ1<int>*)\nd_dump tree for NS1::NS2::grab_it(NS1::NS2::Templ1<int>*):\ntyped name\n  qualified name\n    name 'NS1'\n    qualified name\n      name 'NS2'\n      name 'grab_it'\n  function type\n    argument list\n      pointer\n        qualified name\n          name 'NS1'\n          qualified name\n            name 'NS2'\n            template             <<<<<<<<\n              name 'Templ1'\n              template argument list\n                builtin type int\n\nWhat's different in this case is that the template node appears on the\nright child node of a qualified name, instead of on the left child.\n\nThe testcase includes a test that checks whether template aliases are\ncorrectly replaced by GDB too.  That fails with GCC due to GCC PR\n95437, which makes GDB not know about a typedef for\n\"NS1::NS2::AliasTempl<int>\".  GCC emits a typedef named\n\"NS1::NS2::AliasTempl\" instead, with no template parameter info.  The\ntest passes with Clang (5.0.2 at least).  See more details here:\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=95437\n\ngdb/ChangeLog:\n2020-05-30  Pedro Alves  <palves@redhat.com>\n\n\t* cp-support.c (replace_typedefs_template): New.\n\t(replace_typedefs_qualified_name): Handle\n\tDEMANGLE_COMPONENT_TEMPLATE.\n\ngdb/testsuite/ChangeLog:\n2020-05-30  Pedro Alves  <palves@redhat.com>\n\n\t* gdb.linespec/cp-replace-typedefs-ns-template.cc: New.\n\t* gdb.linespec/cp-replace-typedefs-ns-template.exp: New.",
    "tree": {
      "sha": "63467c56e90cce13fe3c99cc00503bc8b0b2327d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/63467c56e90cce13fe3c99cc00503bc8b0b2327d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f68f85b52b2897ba54e0b119322be1abb2d53afe",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f68f85b52b2897ba54e0b119322be1abb2d53afe",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f68f85b52b2897ba54e0b119322be1abb2d53afe",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f68f85b52b2897ba54e0b119322be1abb2d53afe/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bb6e246742f8795aacfbea2401e505e97c079ffa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb6e246742f8795aacfbea2401e505e97c079ffa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb6e246742f8795aacfbea2401e505e97c079ffa"
    }
  ],
  "stats": {
    "total": 309,
    "additions": 305,
    "deletions": 4
  },
  "files": [
    {
      "sha": "2ea60bb476d9d5f74b761c46007ec7aac61c6d0c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f68f85b52b2897ba54e0b119322be1abb2d53afe",
      "patch": "@@ -1,3 +1,9 @@\n+2020-05-30  Pedro Alves  <palves@redhat.com>\n+\n+\t* cp-support.c (replace_typedefs_template): New.\n+\t(replace_typedefs_qualified_name): Handle\n+\tDEMANGLE_COMPONENT_TEMPLATE.\n+\n 2020-05-29  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* dwarf2/comp-unit.c, dwarf2/comp-unit.h, dwarf2/index-cache.c,"
    },
    {
      "sha": "11e54c272c57a2d55265d3213ef9dce54be3216f",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 72,
      "deletions": 4,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=f68f85b52b2897ba54e0b119322be1abb2d53afe",
      "patch": "@@ -294,6 +294,42 @@ inspect_type (struct demangle_parse_info *info,\n   return 0;\n }\n \n+/* Helper for replace_typedefs_qualified_name to handle\n+   DEMANGLE_COMPONENT_TEMPLATE.  TMPL is the template node.  BUF is\n+   the buffer that holds the qualified name being built by\n+   replace_typedefs_qualified_name.  REPL is the node that will be\n+   rewritten as a DEMANGLE_COMPONENT_NAME node holding the 'template\n+   plus template arguments' name with typedefs replaced.  */\n+\n+static bool\n+replace_typedefs_template (struct demangle_parse_info *info,\n+\t\t\t   string_file &buf,\n+\t\t\t   struct demangle_component *tmpl,\n+\t\t\t   struct demangle_component *repl,\n+\t\t\t   canonicalization_ftype *finder,\n+\t\t\t   void *data)\n+{\n+  demangle_component *tmpl_arglist = d_right (tmpl);\n+\n+  /* Replace typedefs in the template argument list.  */\n+  replace_typedefs (info, tmpl_arglist, finder, data);\n+\n+  /* Convert 'template + replaced template argument list' to a string\n+     and replace the REPL node.  */\n+  gdb::unique_xmalloc_ptr<char> tmpl_str = cp_comp_to_string (tmpl, 100);\n+  if (tmpl_str == nullptr)\n+    {\n+      /* If something went astray, abort typedef substitutions.  */\n+      return false;\n+    }\n+  buf.puts (tmpl_str.get ());\n+\n+  repl->type = DEMANGLE_COMPONENT_NAME;\n+  repl->u.s_name.s = obstack_strdup (&info->obstack, buf.string ());\n+  repl->u.s_name.len = buf.size ();\n+  return true;\n+}\n+\n /* Replace any typedefs appearing in the qualified name\n    (DEMANGLE_COMPONENT_QUAL_NAME) represented in RET_COMP for the name parse\n    given in INFO.  */\n@@ -314,6 +350,29 @@ replace_typedefs_qualified_name (struct demangle_parse_info *info,\n      substituted name.  */\n   while (comp->type == DEMANGLE_COMPONENT_QUAL_NAME)\n     {\n+      if (d_left (comp)->type == DEMANGLE_COMPONENT_TEMPLATE)\n+\t{\n+\t  /* Convert 'template + replaced template argument list' to a\n+\t     string and replace the top DEMANGLE_COMPONENT_QUAL_NAME\n+\t     node.  */\n+\t  if (!replace_typedefs_template (info, buf,\n+\t\t\t\t\t  d_left (comp), d_left (ret_comp),\n+\t\t\t\t\t  finder, data))\n+\t    return;\n+\n+\t  buf.clear ();\n+\t  d_right (ret_comp) = d_right (comp);\n+\t  comp = ret_comp;\n+\n+\t  /* Fallback to DEMANGLE_COMPONENT_NAME processing.  We want\n+\t     to call inspect_type for this template, in case we have a\n+\t     template alias, like:\n+\t       template<typename T> using alias = base<int, t>;\n+\t     in which case we want inspect_type to do a replacement like:\n+\t       alias<int> -> base<int, int>\n+\t  */\n+\t}\n+\n       if (d_left (comp)->type == DEMANGLE_COMPONENT_NAME)\n \t{\n \t  struct demangle_component newobj;\n@@ -370,11 +429,20 @@ replace_typedefs_qualified_name (struct demangle_parse_info *info,\n       comp = d_right (comp);\n     }\n \n-  /* If the next component is DEMANGLE_COMPONENT_NAME, save the qualified\n-     name assembled above and append the name given by COMP.  Then use this\n-     reassembled name to check for a typedef.  */\n+  /* If the next component is DEMANGLE_COMPONENT_TEMPLATE or\n+     DEMANGLE_COMPONENT_NAME, save the qualified name assembled above\n+     and append the name given by COMP.  Then use this reassembled\n+     name to check for a typedef.  */\n \n-  if (comp->type == DEMANGLE_COMPONENT_NAME)\n+  if (comp->type == DEMANGLE_COMPONENT_TEMPLATE)\n+    {\n+      /* Replace the top (DEMANGLE_COMPONENT_QUAL_NAME) node with a\n+\t DEMANGLE_COMPONENT_NAME node containing the whole name.  */\n+      if (!replace_typedefs_template (info, buf, comp, ret_comp, finder, data))\n+\treturn;\n+      inspect_type (info, ret_comp, finder, data);\n+    }\n+  else if (comp->type == DEMANGLE_COMPONENT_NAME)\n     {\n       buf.write (comp->u.s_name.s, comp->u.s_name.len);\n "
    },
    {
      "sha": "8c5553ee14daa6b2a44e820f21134c4cb8d87821",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=f68f85b52b2897ba54e0b119322be1abb2d53afe",
      "patch": "@@ -1,3 +1,8 @@\n+2020-05-30  Pedro Alves  <palves@redhat.com>\n+\n+\t* gdb.linespec/cp-replace-typedefs-ns-template.cc: New.\n+\t* gdb.linespec/cp-replace-typedefs-ns-template.exp: New.\n+\n 2020-05-29  Gary Benson <gbenson@redhat.com>\n \n \t* gdb.compile/compile-cplus.exp (additional_flags): Also"
    },
    {
      "sha": "fb30685f2a50b89a6a8970684a92733e923a4bba",
      "filename": "gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.cc",
      "status": "added",
      "additions": 101,
      "deletions": 0,
      "changes": 101,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.cc?ref=f68f85b52b2897ba54e0b119322be1abb2d53afe",
      "patch": "@@ -0,0 +1,101 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2019-2020 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+namespace NS1 {\n+\n+namespace NS2 {\n+\n+struct object\n+{\n+  object ()\n+  {\n+  }\n+};\n+\n+typedef object *object_p;\n+\n+template<typename T>\n+struct Templ1\n+{\n+  explicit Templ1 (object_p)\n+  {\n+  }\n+\n+  template<typename I>\n+  static void\n+  static_method (object_p)\n+  {\n+  }\n+};\n+\n+template<typename T, typename U>\n+struct Templ2\n+{\n+  explicit Templ2 (object_p)\n+  {\n+  }\n+\n+  template<typename I>\n+  static void\n+  static_method (object_p)\n+  {\n+  }\n+};\n+\n+template<typename T> using AliasTempl = Templ2<int, T>;\n+\n+typedef Templ1<int> int_Templ1_t;\n+\n+void\n+object_p_func (object_p)\n+{\n+}\n+\n+void\n+int_Templ1_t_func (int_Templ1_t *)\n+{\n+}\n+\n+} // namespace NS2\n+\n+} // namespace NS1\n+\n+/* These typedefs have the same name as some of the components within\n+   NS1 that they alias to, on purpose, to try to confuse GDB and cause\n+   recursion.  */\n+using NS2 = int;\n+using object = NS1::NS2::object;\n+using Templ1 = NS1::NS2::Templ1<unsigned>;\n+using Templ2 = NS1::NS2::Templ2<long, long>;\n+using AliasTempl = NS1::NS2::AliasTempl<int>;\n+\n+NS2 ns2_int = 0;\n+object obj;\n+Templ1 templ1 (0);\n+NS1::NS2::int_Templ1_t int_templ1 (0);\n+AliasTempl alias (0);\n+\n+int\n+main ()\n+{\n+  NS1::NS2::Templ1<int>::static_method<int> (0);\n+  NS1::NS2::AliasTempl<int>::static_method<int> (0);\n+  NS1::NS2::object_p_func (0);\n+  NS1::NS2::int_Templ1_t_func (0);\n+\n+  return 0;\n+}"
    },
    {
      "sha": "590b06d34fcad93ce3b0e7446669135f516aca7a",
      "filename": "gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.exp",
      "status": "added",
      "additions": 121,
      "deletions": 0,
      "changes": 121,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f68f85b52b2897ba54e0b119322be1abb2d53afe/gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.linespec/cp-replace-typedefs-ns-template.exp?ref=f68f85b52b2897ba54e0b119322be1abb2d53afe",
      "patch": "@@ -0,0 +1,121 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file tests GDB's ability to replace typedefs in C++ symbols\n+# when setting breakpoints, particularly around templates in\n+# namespaces.\n+\n+load_lib completion-support.exp\n+\n+standard_testfile .cc\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile \\\n+\t {debug c++ additional_flags=-std=c++11}]} {\n+    return -1\n+}\n+\n+# Disable the completion limit for the whole testcase.\n+gdb_test_no_output \"set max-completions unlimited\"\n+\n+# Confirm that the important global namespace typedefs were indeed\n+# emited in the debug info.\n+gdb_test \"ptype NS2\" \"type = int\"\n+gdb_test \"ptype object\" \"type = struct NS1::NS2::object {.*\"\n+gdb_test \"ptype Templ1\" \"type = struct NS1::NS2::Templ1<unsigned int> .*\"\n+gdb_test \"ptype AliasTempl\" \"type = struct NS1::NS2::Templ2<int, int> .*\"\n+\n+# Wrapper around check_bp_locations_match_list that expect a single\n+# location in the set breakpoint, instead of a list of locations.  If\n+# the set location isn't specified, then it is assumed to be the exact\n+# same as the input location.\n+proc check_bp {location_in {location_out \"\"}} {\n+    if {$location_out == \"\"} {\n+\tset location_out $location_in\n+    }\n+    check_bp_locations_match_list \"b $location_in\" [list $location_out]\n+}\n+\n+# These used to crash GDB with infinite recursion because GDB would\n+# confuse the \"Templ1\" typedef in the global namespace with the \"Templ1\"\n+# template in within NS1::NS2.\n+test_gdb_complete_unique \\\n+    \"break NS1::NS2::Templ1<int>::Tem\" \\\n+    \"break NS1::NS2::Templ1<int>::Templ1(NS1::NS2::object*)\"\n+check_bp \"NS1::NS2::Templ1<int>::Templ1(NS1::NS2::object*)\"\n+\n+# Similar test, but without a template.  This would not crash.\n+test_gdb_complete_unique \\\n+    \"break NS1::NS2::object::obj\" \\\n+    \"break NS1::NS2::object::object()\"\n+check_bp \"NS1::NS2::object::object()\"\n+\n+# Test some non-template typedef replacing within a namespace.\n+test_gdb_complete_unique \\\n+    \"break NS1::NS2::object_p_f\" \\\n+    \"break NS1::NS2::object_p_func(NS1::NS2::object*)\"\n+check_bp \\\n+    \"NS1::NS2::object_p_func(NS1::NS2::object_p)\" \\\n+    \"NS1::NS2::object_p_func(NS1::NS2::object*)\"\n+\n+# Make sure the \"NS2\" in the template argument list is resolved as\n+# being a global typedef for int.\n+foreach loc {\n+    \"NS1::NS2::Templ1<int>::static_method<int>(NS1::NS2::object*)\"\n+    \"NS1::NS2::Templ1<int>::static_method<NS2>(NS1::NS2::object*)\"\n+    \"NS1::NS2::Templ1<NS2>::static_method<int>(NS1::NS2::object*)\"\n+    \"NS1::NS2::Templ1<NS2>::static_method<NS2>(NS1::NS2::object*)\"\n+} {\n+    check_bp $loc \"NS1::NS2::Templ1<int>::static_method<int>(NS1::NS2::object*)\"\n+}\n+\n+foreach loc {\n+    \"NS1::NS2::Templ2<int, int>::static_method<int>(NS1::NS2::object*)\"\n+    \"NS1::NS2::Templ2<int, int>::static_method<int>(NS1::NS2::object_p)\"\n+} {\n+    check_bp $loc \"NS1::NS2::Templ2<int, int>::static_method<int>(NS1::NS2::object*)\"\n+}\n+\n+# Check that GDB expands the \"NS1::NS2::AliasTempl<int>\" as\n+# \"NS1::NS2::Templ2<int, int>\".\n+foreach loc {\n+    \"NS1::NS2::AliasTempl<int>::static_method<int>(NS1::NS2::object*)\"\n+    \"NS1::NS2::AliasTempl<int>::static_method<int>(NS1::NS2::object_p)\"\n+} {\n+    if [test_compiler_info gcc*] {\n+\t# While Clang emits \"AliasTempl<int>\" (etc.) typedefs, GCC\n+\t# emits \"AliasTempl\" typedefs with no template parameter info.\n+\tsetup_xfail gcc/95437 *-*-*\n+    }\n+    check_bp $loc \"NS1::NS2::Templ2<int, int>::static_method<int>(NS1::NS2::object*)\"\n+\n+    # Check that setting the breakpoint with GCC really failed,\n+    # instead of succeeding with e.g., \"AliasTempl<int>\" preserved in\n+    # the location text.  If that ever happens, we'll need to update\n+    # these tests.\n+    if [test_compiler_info gcc*] {\n+\tcheck_setting_bp_fails \"b $loc\"\n+    }\n+}\n+\n+# Check typedef substitution in a template in a qualified name in a\n+# function parameter list.  These used to crash GDB with recursion\n+# around \"Templ1\", because there's a \"Templ1\" typedef in the global\n+# namespace.\n+foreach loc {\n+    \"NS1::NS2::int_Templ1_t_func(NS1::NS2::int_Templ1_t*)\"\n+    \"NS1::NS2::int_Templ1_t_func(NS1::NS2::Templ1<int>*)\"\n+} {\n+    check_bp $loc \"NS1::NS2::int_Templ1_t_func(NS1::NS2::Templ1<int>*)\"\n+}"
    }
  ]
}